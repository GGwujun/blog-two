<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>30 | 实战（五）：怎么设计一个“画图”程序？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/许式伟的架构课/03.桌面开发篇/11" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a aria-current="page" class="active" href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a aria-current="page" class="active" href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/许式伟的架构课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-two/许式伟的架构课/01.开篇词/01"><span>开篇词 | 怎样成长为优秀的软件架构师？</span></a></li></ul></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇">02.基础平台篇</a><ul><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/01"><span>01 | 架构设计的宏观视角</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/02"><span>02 | 大厦基石：无生有，有生万物</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/03"><span>03 | 汇编：编程语言的诞生</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/04"><span>04 | 编程语言的进化</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/05"><span>05 | 思考题解读：如何实现可自我迭代的计算机？</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/06"><span>06 | 操作系统进场</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/07"><span>07 | 软件运行机制及内存管理</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/08"><span>08 | 操作系统内核与编程接口</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/09"><span>09 | 外存管理与文件系统</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/10"><span>10 | 输入和输出设备：交互的演进</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/11"><span>11 | 多任务：进程、线程与协程</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/12"><span>12 | 进程内协同：同步、互斥与通讯</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/13"><span>13 | 进程间的同步互斥、资源共享与通讯</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/14"><span>14 | IP 网络：连接世界的桥梁</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/15"><span>15 | 可编程的互联网世界</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/16"><span>16 | 安全管理：数字世界的守护</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/17"><span>17 | 架构：需求分析 (上)</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/18"><span>18 | 架构：需求分析 (下) · 实战案例</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/19"><span>19 | 基础平台篇：回顾与总结</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/许式伟的架构课/03.桌面开发篇">03.桌面开发篇</a><ul><li><a href="/blog-two/许式伟的架构课/03.桌面开发篇/01"><span>20 | 桌面开发的宏观视角</span></a></li><li><a href="/blog-two/许式伟的架构课/03.桌面开发篇/02"><span>21 | 图形界面程序的框架</span></a></li><li><a href="/blog-two/许式伟的架构课/03.桌面开发篇/03"><span>22 | 桌面程序的架构建议</span></a></li><li><a href="/blog-two/许式伟的架构课/03.桌面开发篇/04"><span>23 | Web开发：浏览器、小程序与PWA</span></a></li><li><a href="/blog-two/许式伟的架构课/03.桌面开发篇/05"><span>24 | 跨平台与 Web 开发的建议</span></a></li><li><a href="/blog-two/许式伟的架构课/03.桌面开发篇/06"><span>25 | 桌面开发的未来</span></a></li><li><a href="/blog-two/许式伟的架构课/03.桌面开发篇/07"><span>26 | 实战（一）：怎么设计一个“画图”程序？</span></a></li><li><a href="/blog-two/许式伟的架构课/03.桌面开发篇/08"><span>27 | 实战（二）：怎么设计一个“画图”程序？</span></a></li><li><a href="/blog-two/许式伟的架构课/03.桌面开发篇/09"><span>28 | 实战（三）：怎么设计一个“画图”程序？</span></a></li><li><a href="/blog-two/许式伟的架构课/03.桌面开发篇/10"><span>29 | 实战（四）：怎么设计一个“画图”程序？</span></a></li><li><a aria-current="page" class="active" href="/blog-two/许式伟的架构课/03.桌面开发篇/11"><span>30  | 实战（五）：怎么设计一个“画图”程序？</span></a></li><li><a href="/blog-two/许式伟的架构课/03.桌面开发篇/12"><span>31 | 辅助界面元素的架构设计</span></a></li><li><a href="/blog-two/许式伟的架构课/03.桌面开发篇/13"><span>32 | 架构：系统的概要设计</span></a></li><li><a href="/blog-two/许式伟的架构课/03.桌面开发篇/14"><span>33 | 桌面开发篇：回顾与总结</span></a></li></ul></li><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇">04.服务端开发篇</a><ul><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇/01"><span>34 | 服务端开发的宏观视角</span></a></li><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇/02"><span>35 | 流量调度与负载均衡</span></a></li><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇/03"><span>36 | 业务状态与存储中间件</span></a></li><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇/04"><span>37 | 键值存储与数据库</span></a></li><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇/05"><span>38  | 文件系统与对象存储</span></a></li><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇/06"><span>39  | 存储与缓存</span></a></li><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇/07"><span>40 | 服务端的业务架构建议</span></a></li><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇/08"><span>41 | 实战（一）：“画图”程序后端实战</span></a></li><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇/09"><span>42 | 实战（二）：“画图”程序后端实战</span></a></li><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇/10"><span>43 | 实战（三）：“画图”程序后端实战</span></a></li><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇/11"><span>44 | 实战（四）：“画图”程序后端实战</span></a></li><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇/12"><span>45 | 架构：怎么做详细设计？</span></a></li><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇/13"><span>46 | 服务端开发篇：回顾与总结</span></a></li><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇/14"><span>加餐 | 如何做HTTP服务的测试？</span></a></li></ul></li><li><a href="/blog-two/许式伟的架构课/05.服务治理篇">05.服务治理篇</a><ul><li><a href="/blog-two/许式伟的架构课/05.服务治理篇/01"><span>47 | 服务治理的宏观视角</span></a></li><li><a href="/blog-two/许式伟的架构课/05.服务治理篇/02"><span>48 | 事务与工程：什么是工程师思维？</span></a></li><li><a href="/blog-two/许式伟的架构课/05.服务治理篇/03"><span>49 | 发布、升级与版本管理</span></a></li><li><a href="/blog-two/许式伟的架构课/05.服务治理篇/04"><span>50 | 日志、监控与报警</span></a></li><li><a href="/blog-two/许式伟的架构课/05.服务治理篇/05"><span>加餐 | 怎么保障发布的效率与质量？</span></a></li><li><a href="/blog-two/许式伟的架构课/05.服务治理篇/06"><span>51 | 故障域与故障预案</span></a></li><li><a href="/blog-two/许式伟的架构课/05.服务治理篇/07"><span>52 | 故障排查与根因分析</span></a></li><li><a href="/blog-two/许式伟的架构课/05.服务治理篇/08"><span>53 | 过载保护与容量规划</span></a></li><li><a href="/blog-two/许式伟的架构课/05.服务治理篇/09"><span>54 | 业务的可支持性与持续运营</span></a></li><li><a href="/blog-two/许式伟的架构课/05.服务治理篇/10"><span>55 | 云计算、容器革命与服务端的未来</span></a></li><li><a href="/blog-two/许式伟的架构课/05.服务治理篇/11"><span>56 | 服务治理篇：回顾与总结</span></a></li></ul></li><li><a href="/blog-two/许式伟的架构课/06.架构思维篇">06.架构思维篇</a><ul><li><a href="/blog-two/许式伟的架构课/06.架构思维篇/01"><span>57 | 心性：架构师的修炼之道</span></a></li><li><a href="/blog-two/许式伟的架构课/06.架构思维篇/02"><span>58 | 如何判断架构设计的优劣？</span></a></li><li><a href="/blog-two/许式伟的架构课/06.架构思维篇/03"><span>59 | 少谈点框架，多谈点业务</span></a></li><li><a href="/blog-two/许式伟的架构课/06.架构思维篇/04"><span>60 | 架构分解：边界，不断重新审视边界</span></a></li><li><a href="/blog-two/许式伟的架构课/06.架构思维篇/05"><span>加餐 | 实战：“画图程序” 的整体架构</span></a></li><li><a href="/blog-two/许式伟的架构课/06.架构思维篇/06"><span>61 | 全局性功能的架构设计</span></a></li><li><a href="/blog-two/许式伟的架构课/06.架构思维篇/07"><span>62 | 重新认识开闭原则 (OCP)</span></a></li><li><a href="/blog-two/许式伟的架构课/06.架构思维篇/08"><span>63 | 接口设计的准则</span></a></li><li><a href="/blog-two/许式伟的架构课/06.架构思维篇/09"><span>64 | 不断完善的架构范式</span></a></li><li><a href="/blog-two/许式伟的架构课/06.架构思维篇/10"><span>65 | 架构范式：文本处理</span></a></li><li><a href="/blog-two/许式伟的架构课/06.架构思维篇/11"><span>66 | 架构老化与重构</span></a></li><li><a href="/blog-two/许式伟的架构课/06.架构思维篇/12"><span>67 | 架构思维篇：回顾与总结</span></a></li></ul></li><li><a href="/blog-two/许式伟的架构课/07.软件工程篇">07.软件工程篇</a><ul><li><a href="/blog-two/许式伟的架构课/07.软件工程篇/01"><span>68 | 软件工程的宏观视角</span></a></li><li><a href="/blog-two/许式伟的架构课/07.软件工程篇/02"><span>69 | 团队的共识管理</span></a></li><li><a href="/blog-two/许式伟的架构课/07.软件工程篇/03"><span>70 | 怎么写设计文档？</span></a></li><li><a href="/blog-two/许式伟的架构课/07.软件工程篇/04"><span>71 | 如何阅读别人的代码？</span></a></li><li><a href="/blog-two/许式伟的架构课/07.软件工程篇/05"><span>72 | 发布单元与版本管理</span></a></li><li><a href="/blog-two/许式伟的架构课/07.软件工程篇/06"><span>73 | 软件质量管理：单元测试、持续构建与发布</span></a></li><li><a href="/blog-two/许式伟的架构课/07.软件工程篇/07"><span>74 | 开源、云服务与外包管理</span></a></li><li><a href="/blog-two/许式伟的架构课/07.软件工程篇/08"><span>75 | 软件版本迭代的规划</span></a></li><li><a href="/blog-two/许式伟的架构课/07.软件工程篇/09"><span>76 | 软件工程的未来</span></a></li><li><a href="/blog-two/许式伟的架构课/07.软件工程篇/10"><span>77 | 软件工程篇：回顾与总结</span></a></li></ul></li><li><a href="/blog-two/许式伟的架构课/08.结束语">08.结束语</a><ul><li><a href="/blog-two/许式伟的架构课/08.结束语/01"><span>结束语 | 放下技术人的身段，用极限思维提升架构能力</span></a></li><li><a href="/blog-two/许式伟的架构课/08.结束语/02"><span>结课问卷获奖用户名单</span></a></li><li><a href="/blog-two/许式伟的架构课/08.结束语/03"><span>课程迭代 | 84讲音频重新交付</span></a></li></ul></li><li><a href="/blog-two/许式伟的架构课/09.延展阅读">09.延展阅读</a><ul><li><a href="/blog-two/许式伟的架构课/09.延展阅读/01"><span>热点观察 | 我看Facebook发币（上）：区块链、比特币与Libra币</span></a></li><li><a href="/blog-two/许式伟的架构课/09.延展阅读/02"><span>热点观察 | 我看Facebook发币（下）：深入浅出理解 Libra 币</span></a></li><li><a href="/blog-two/许式伟的架构课/09.延展阅读/03"><span>课外阅读 | 从《孙子兵法》看底层的自然法则</span></a></li><li><a href="/blog-two/许式伟的架构课/09.延展阅读/04"><span>答疑解惑 | 想当架构师，我需要成为“全才”吗？</span></a></li><li><a href="/blog-two/许式伟的架构课/09.延展阅读/05"><span>用户故事 | 站在更高的视角看架构</span></a></li></ul></li><li><a href="/blog-two/许式伟的架构课/summary">许式伟的架构课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="宏观的系统架构" data-depth="2"><a href="/blog-two/许式伟的架构课/03.桌面开发篇/11#宏观的系统架构"><span>宏观的系统架构</span></a></li><li title="计算变更" data-depth="2"><a href="/blog-two/许式伟的架构课/03.桌面开发篇/11#计算变更"><span>计算变更</span></a></li><li title="同步变更" data-depth="2"><a href="/blog-two/许式伟的架构课/03.桌面开发篇/11#同步变更"><span>同步变更</span></a></li><li title="加载文档" data-depth="2"><a href="/blog-two/许式伟的架构课/03.桌面开发篇/11#加载文档"><span>加载文档</span></a></li><li title="Model 层的厚度" data-depth="2"><a href="/blog-two/许式伟的架构课/03.桌面开发篇/11#model-层的厚度"><span>Model 层的厚度</span></a></li><li title="结语" data-depth="2"><a href="/blog-two/许式伟的架构课/03.桌面开发篇/11#结语"><span>结语</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="30---实战五怎么设计一个画图程序"><a aria-hidden="true" tabindex="-1" href="/blog-two/许式伟的架构课/03.桌面开发篇/11#30---实战五怎么设计一个画图程序"><span class="icon icon-link"></span></a>30  | 实战（五）：怎么设计一个“画图”程序？</h1><p>你好，我是七牛云许式伟。</p><p>我们继续聊我们的话题。这是画图程序的最后一讲了。当然我们后续还会结合这个实战程序展开讨论有关于架构的方方面面。</p><h2 id="宏观的系统架构"><a aria-hidden="true" tabindex="-1" href="/blog-two/许式伟的架构课/03.桌面开发篇/11#宏观的系统架构"><span class="icon icon-link"></span></a>宏观的系统架构</h2><p>上一讲开始，我们的画图程序有了跨团队协作：因为我们开始有了 paintdom 和 paintweb 两大软件。paintdom 监听的地址是 localhost:9999，而 paintweb 监听的地址是 localhost:8888。</p><p>应当注意，在实际业务中它们是不同的软件，事实上我们 paintweb 程序也完全是以进程间协作的方式，通过反向代理机制来调用 paintdom 的功能。但是在我们这个画图 DEMO 程序中，它们同属一个进程，paintdom 作为 paintweb 的一个 goroutine 在跑。这纯粹是因为我们想让这两个程序 “同生共死”，方便调试的时候起停进程。</p><p>paintdom 和 paintweb 之间相互协作的基础，是它们之间所采用的网络协议。</p><p>当我们说起网络协议，它其实通常包含两个层面的意思：其一是我们网络协议的载体，也就是协议栈（我们这里采纳的是 HTTP 协议，而 HTTP 协议又基于 TCP/IP 协议）；其二是我们网络协议承载的业务逻辑。</p><p>当我们谈架构的时候，也会同时聊这两个层面，只是它们在不同的维度。我们会关心网络协议的协议栈选择什么，是基于 HTTP 还是基于自定义的二进制协议，这个是属于基础架构的维度。我们也会关心网络协议的业务逻辑，判断它是否自然体现业务需求，这是属于应用架构的维度。</p><p>明确了网络协议后，我们实现了 Mock 版本的服务端程序 paintdom。在实际项目中，Mock 程序往往会大幅提速团队的开发效率。这是因为它能够达到如下两个大的核心目标：</p><ul><li>让团队的研发迭代并行，彼此可以独立演进。</li><li>及早验证网络协议的合理性，在实战中达到用最短时间稳定协议的目的。</li></ul><p>上一讲我们的 paintdom 和 paintweb 之间虽然定义了网络协议，并且实现了第一版，但是并没有去做两者的对接。</p><p>今天我们就来对接它们。</p><p>虽然 paintweb 没有对接服务端，但从文档编辑的角度来说，它的功能是非常完整的。我们对接 paintdom 和 paintweb 的目的不是加编辑功能，而是让文档可以存储到服务端，以便于人们在世界任何可以联网的角落都可以打开它。</p><p>当然严谨来说，说 paintweb 没有服务端是不正确的，paintweb 本身是一个 B/S 结构，它有它自己的服务端。如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var wwwServer = http.FileServer(http.Dir(&quot;www&quot;))</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func handleDefault(w http.ResponseWriter, req *http.Request) {</span></div><div class="token-line"><span class="token plain">      if req.URL.Path == &quot;/&quot; {</span></div><div class="token-line"><span class="token plain">        http.ServeFile(w, req, &quot;www/index.htm&quot;)</span></div><div class="token-line"><span class="token plain">    	return</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      req.URL.RawQuery = &quot;&quot; // skip &quot;?params&quot;</span></div><div class="token-line"><span class="token plain">      wwwServer.ServeHTTP(w, req)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">      http.HandleFunc(&quot;/&quot;, handleDefault)</span></div><div class="token-line"><span class="token plain">      http.ListenAndServe(&quot;:8888&quot;, nil)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看出，paintweb 自己的服务端基本上没干什么事情，就是一个非常普通的静态文件下载服务器，提供给浏览器端下载 HTML + CSS + JavaScript 等内容。</p><p>所以 paintweb 的服务端完全是“平庸”的，与业务无关。具体的业务，都是通过 www 目录里面的文件来做到的。这些文件都是前端的浏览器端所依赖的，只不过被 “托管” 到 paintweb 服务端而已。</p><p>那么 paintweb 怎么对接 paintdom 呢？</p><p>物理上的对接比较简单，只是个反向代理服务器而已，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func newReverseProxy(baseURL string) *httputil.ReverseProxy {</span></div><div class="token-line"><span class="token plain">      rpURL, _ := url.Parse(baseURL)</span></div><div class="token-line"><span class="token plain">      return httputil.NewSingleHostReverseProxy(rpURL)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    var apiReverseProxy = newReverseProxy(&quot;http://localhost:9999&quot;)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">      http.Handle(&quot;/api/&quot;, http.StripPrefix(&quot;/api/&quot;, apiReverseProxy))</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看出，paintweb 的服务端干的事情仍然是 “平庸” 的，只是把发往 <a target="_blank" rel="noopener noreferrer" href="http://localhost:8888/api/xxx">http://localhost:8888/api/xxx<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的请求，原封不动地发往 <a target="_blank" rel="noopener noreferrer" href="http://localhost:9999/xxx">http://localhost:9999/xxx<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 而已。</p><p>在现实中，paintweb 的服务端干的事情稍微复杂一些。它背后不只是有业务服务器 paintdom，还有必不可少的帐号服务器（Account Service），用来支持用户登录/登出。</p><p>帐号服务器是一个基础架构类的服务，与业务无关。公司很可能不只有 QPaint 这样一个业务，还会有别的，但这些业务可以共享相同的帐号服务。更准确地说，是必须共享相同的帐号服务，否则一个公司弄出好多套独立的帐号体系来，用户也会有所诟病。</p><p>在需要对接帐号服务器的情况下，实际上 paintweb 的服务端并不是原封不动地转发业务请求，而是会对协议进行转义。</p><p>在 “<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/107128">24 | 跨平台与 Web 开发的建议<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”这一讲中我们提到过：</p><blockquote><p>到了 Web 开发，我们同样需要二次开发接口，只不过这个二次开发接口不再是在 Client 端完成的，而是在 Server 端完成。Server 端支持直接的 API 调用，以支持自动化（Automation）方面的需求。</p><blockquote></blockquote><p>所以，对 Server 端来说，最底层的是一个多租户的 Model 层（Multi-User Model），它实现了自动化（Automation）所需的 API。</p><blockquote></blockquote><p>在 Multi-User Model 层之上，有一个 Web 层。Web 层和 Model 层的假设不同，Web 层是基于会话的（Session-based），因为它负责用户的接入，每个用户登录后，会形成一个个会话（Session）。</p><blockquote></blockquote><p>如果我们对Web 层细究的话，又分为 Model 层和 ViewModel 层。为了区分，Web 这边的 Model 层我们叫它 Session-based Model。相应地，ViewModel 层我们叫它 Session-based ViewModel。</p><blockquote></blockquote><p>在服务端，Session-based Model 和 Session-based ViewModel 并不发生直接关联，它们通过自己网络遥控浏览器这一侧的 Model 和 ViewModel，从而响应用户的交互。</p><blockquote></blockquote><p>Session-based Model 是什么样的呢？它其实是 Multi-User Model 层的转译。把多租户的 API 转译成单租户的场景。所以这一层并不需要太多的代码，甚至理论上自动实现也是有可能的。</p><blockquote></blockquote><p>Session-based ViewModel 是一些 HTML+JavaScript+CSS 文件。它是真正的 Web 业务入口。它通过互联网把自己的数据返回给浏览器，浏览器基于 ViewModel 渲染出View，这样整个系统就运转起来了。</p></blockquote><p>这段话说的比较抽象，但结合 QPaint 这个实际的例子，就非常明朗了：</p><ul><li>paintdom 就是这里说的 Multi-User Model 层，负责多租户的业务服务器。</li><li>paintweb 服务端实现 Session-based Model 层，负责 Session-based 到 Multi-User 的转译。由于我们当前这个例子还不支持多租户，转译就变成了简单的转发。后面我们在 “服务端开发” 一节中会给大家看实际的转译层是怎么做的。</li></ul><p>所以你可以看到，其实 paintweb 自身的服务端是业务无关的。它做这样一些事情：</p><ul><li>Web 前端文件的托管（作为静态文件下载服务器）；</li><li>支持帐号服务，实现 Web 的用户登录；</li><li>做业务协议的转译，将 Session-based 的 API 请求转为 Multi-User 的 API 请求。</li></ul><p>当然，我们这里假设 Web 自身的业务逻辑都是通过 JavaScript 来实现的。这意味着我们是基于 “胖前端” 模式的。</p><p>但这并不一定符合事实，有些公司会基于 “胖后端” 模式。这意味着大部分的前端用户行为，都是由后端支持的，比如我们用 PHP 来实现 Web 后端的业务代码。</p><p>胖后端模式的好处是 Web 代码比较安全。这里的 “安全” 是指 IT 资产保全方面的安全，不是指业务存在安全问题，因为别人看不到完整的 Web 业务逻辑代码。</p><p>但是胖后端模式的缺点是没办法支持离线。大部分的用户交互都需要 Web 后端来响应，一旦断了网就什么都干不了了。</p><p>在 “胖后端” 模式下，我个人会倾向于基于类似 PHP 这种胶水语言来实现 Web 后端的业务代码。而一旦我们这么做，paintweb 的业务逻辑就被剥离了，paintweb 自身的后端仍然是业务无关的，只是多了一个职责：支持 PHP 脚本语言。</p><p>真正 Web 后端业务逻辑，还是放在了 www 目录中，以 PHP 文件存在，这些文件就不是简单的静态资源，而是 “胖后端” 的业务代码。</p><p>既然 paintweb 后端是 “平庸” 的，与业务无关，那么整个业务逻辑的串联，靠的就是 www 里面的 js 文件，和 paintdom 提供的 API 接口。</p><p>上面我们说过，在连接 paintdom 之前，paintweb 程序独立看是完整的，它支持离线创建、编辑以及存储文档到浏览器本地的 localStorage 上。</p><p>对接 paintdom 与 paintweb 后我们并不会放弃离线编辑的能力，而是要能够做到：</p><ul><li>在断网情况下，表现为上一讲我们达到的效果，可以继续离线编辑和保存；</li><li>一旦联网，所有离线编辑的内容可以自动保存到 paintdom 服务器。</li></ul><h2 id="计算变更"><a aria-hidden="true" tabindex="-1" href="/blog-two/许式伟的架构课/03.桌面开发篇/11#计算变更"><span class="icon icon-link"></span></a>计算变更</h2><p>听起来挺简单一件事情？</p><p>其实很复杂。第一件要做的事情是：怎么知道断网后离线编辑过的内容有哪些？</p><p>思路一是不管三七二十一，每次都完整保存整篇文档。这很浪费，因为不单单刚恢复联网的时候我们需要保存文档，平常每一次编辑操作我们也都会自动保存修改的内容。</p><p>思路二是记录完整的编辑操作历史，每做一个编辑操作都将其记录到 localStorage。这个思路看似会更节约，但是实际上在很多情况下会更浪费。原因在于：</p><ul><li>一个对象编辑多次，会有很多条编辑操作的指令要保存；</li><li>断网久了，编辑操作累计下来，其存储空间甚至可能超过文档大小。</li></ul><p>所以这种方案缺乏很好的鲁棒性，在 badcase 情况下让人难以接受。</p><p>思路三是给对象增加版本号。通过对比整个文档的基版本（baseVer，即上一次同步完成时的版本），与某个对象的版本 ver。如果 ver &gt; baseVer，说明上一次同步完成后，该对象发生了变更。完整的变更信息的计算逻辑如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">prepareSync(baseVer) {</span></div><div class="token-line"><span class="token plain">      let shapeIDs = []</span></div><div class="token-line"><span class="token plain">      let changes = []</span></div><div class="token-line"><span class="token plain">      let shapes = this._shapes</span></div><div class="token-line"><span class="token plain">      for (let i in shapes) {</span></div><div class="token-line"><span class="token plain">        let shape = shapes[i]</span></div><div class="token-line"><span class="token plain">        if (shape.ver &gt; baseVer) {</span></div><div class="token-line"><span class="token plain">          changes.push(shape)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        shapeIDs.push(shape.id)</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      let result = {</span></div><div class="token-line"><span class="token plain">        shapes: shapeIDs,</span></div><div class="token-line"><span class="token plain">        changes: changes,</span></div><div class="token-line"><span class="token plain">        ver: this.ver</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      this.ver++</span></div><div class="token-line"><span class="token plain">      return result</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h2 id="同步变更"><a aria-hidden="true" tabindex="-1" href="/blog-two/许式伟的架构课/03.桌面开发篇/11#同步变更"><span class="icon icon-link"></span></a>同步变更</h2><p>有了变更的信息，怎么同步给服务端？</p><p>一个可能的思路是把变更还原为一条条编辑操作发给服务端。但是，这样做问题会很复杂，因为这些编辑操作一部分发送成功，一部分发送失败怎么办？</p><p>这种部分成功的中间态是最挑战我们程序员的编程水平的，很烧脑。</p><p>我个人一贯坚持的架构准则是不要烧脑。尤其对大部分非性能敏感的业务代码，简单易于实施为第一原则。</p><p>所以我们选择了修改网络协议。增加了同步接口：</p><p><img src="https://static001.geekbang.org/resource/image/15/13/15b65c55fae904ca16ec6192ed81b613.png?wh=559*334" alt=""/></p><p>这很有趣。在我们讨论相互配合的接口时，我们非常尊重业务逻辑，按照我们对业务的理解，定义了一系列的编辑操作。但是，到最后我们却发现，它们统统不管用，我们要的是一个同步协议。</p><p>是最初我们错了吗？</p><p>也不能这么说。最初我们定义协议的逻辑并没有错，只是没有考虑到支持离线编辑这样的需求而已。</p><p>复盘这件事情，我们可以这么说：</p><ul><li>需求的预见性非常重要。如果我们没有充分预见到需求，大部分情况下就会因为我们缺乏市场洞察而买单；</li><li>进一步说明，及早推出 Mock，让前端可以快速迭代，进而及早去发现原先定义网络协议的不足是很有必要的。越晚做出协议调整，事情就越难，也越低效。</li></ul><p>有了同步协议，我们就可以把变更信息同步给服务端了。这个事情我们交给了 QSynchronizer 类来完成（详细请看 <a target="_blank" rel="noopener noreferrer" href="https://github.com/qiniu/qpaint/blob/v30/paintweb/www/dom.js#L204">dom.js#L204<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）。</p><h2 id="加载文档"><a aria-hidden="true" tabindex="-1" href="/blog-two/许式伟的架构课/03.桌面开发篇/11#加载文档"><span class="icon icon-link"></span></a>加载文档</h2><p>把变更详细推送给服务端后，理论上我们就可以在世界各地看到这篇文档。</p><p>怎么做到？</p><p>我们接下来就谈谈怎么来加载文档。这个过程的难点在于怎么根据服务端返回的 json 数据重建整个文档。</p><p>上一讲我们已经说过，我们图形（Shape）的网络协议中的数据格式，和 localStorage 中是不同的。这意味着我们需要做两套图形数据的加载工作。</p><p>这挺没有必要。</p><p>而且，从预测变更的角度，我们很容易预期的一个变化，就是画图程序支持的图形（Shape）的种类会越来越多。</p><p>这两个事情我们一起看。为此我们做了一次重构。重构目标是：</p><ul><li>统一 localStorage 和网络协议中的图形表示；</li><li>增加新的图形种类要很容易，代码非常内聚，不必到处修改代码。</li></ul><p>为此我们增加 qshapes: QSerializer 全局变量，允许各种图形类型注册自己的创建方法（creator）进去。示意代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">qshapes.register(&quot;rect&quot;, function(json) {</span></div><div class="token-line"><span class="token plain">      return new QRect(json)</span></div><div class="token-line"><span class="token plain">    })</span></div></pre></div><p>为了支持 QSerializer 类（代码参见 <a target="_blank" rel="noopener noreferrer" href="https://github.com/qiniu/qpaint/blob/v30/paintweb/www/dom.js#L89">dom.js#L89<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），每个图形需要增加两个方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">interface Shape {</span></div><div class="token-line"><span class="token plain">      constructor(json: Object)</span></div><div class="token-line"><span class="token plain">      toJSON(): Object</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这样我们就可以调用 qshapes.create(json) 来创建一个图形实例。</p><p>有了这个能力，我们加载文档就水到渠成了，具体代码请参考 QPaintDoc 类的 _loadRemote(displayID) 方法（参见 <a target="_blank" rel="noopener noreferrer" href="https://github.com/qiniu/qpaint/blob/v30/paintweb/www/dom.js#L690">dom.js#L690<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）。</p><p>完整来说，加载文档的场景分为这样三类：</p><ul><li>_loadBlank，即加载新文档。在联网情况下，会在服务端创建一个新 drawing。在非联网情况下，会本地创建一个临时文档（displayID 以 t 开头）。</li><li>_loadTempDoc，即加载一个临时文档。即该文档从创建之初到目前，一直都处于离线编辑的状态。同样它也分两个情况，如果当前处于联网状态下，会在服务端创建一个新 drawing，并把当前的离线编辑的数据同步过去。如果在非联网的情况下，会加载离线编辑的数据，并可继续离线编辑。</li><li>_loadRemote，即加载一个远程文档。该文档在本地有可能编辑过，那么会先加载本地缓存的离线编辑的数据。如果当前处于联网状态，会异步加载远程文档，成功后本地离线编辑的内容会被放弃。</li></ul><p>另外，加载文档结束后，QPaintDoc 会发出 onload 消息。这个消息当前会被 QPaintView 响应，用来刷新界面，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class QPaintView {</span></div><div class="token-line"><span class="token plain">      constructor() {</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">        let view = this</span></div><div class="token-line"><span class="token plain">        this.doc.onload = function() {</span></div><div class="token-line"><span class="token plain">          view.invalidateRect(null)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>之所以会有 onload 消息，是因为向服务器的 ajax 请求，什么时候完成是比较难预期的，我们加载文档是在异步 ajax 完成之后。这样来看，完成文档加载后发出 onload 事件，就可以避免 Model 层需要去理解 View 层的业务逻辑。</p><h2 id="model-层的厚度"><a aria-hidden="true" tabindex="-1" href="/blog-two/许式伟的架构课/03.桌面开发篇/11#model-层的厚度"><span class="icon icon-link"></span></a>Model 层的厚度</h2><p>介绍到这里，我们基本上把本次迭代的主体内容介绍清楚了。其他有些小细节的变动，我们不再赘述。详细的代码变更请参阅：</p><ul><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/qiniu/qpaint/compare/v29...v30">https://github.com/qiniu/qpaint/compare/v29...v30<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><p>下面我想聊的话题是关于 Model 层的厚度问题。我们在 “<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/105356">22 | 桌面程序的架构建议<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>” 中提到：</p><blockquote><p>从界面编程角度看，Model 层越厚越好。为什么这么说？因为这是和操作系统的界面程序框架最为无关的部分，是最容易测试的部分，也同时是跨平台最容易的部分。我们把逻辑更多向 Model 层倾斜，那么 Controller 层就简洁很多，这对跨平台开发将极其有利。</p></blockquote><p>我们秉承的理念是 Model 层越厚越好。事实上在这次 “画图” 程序实战中，我们在一直坚持这一点。让我们来观测两组数据。</p><p>其一，不同版本（v26..v30）的 Model 层（dom.js）对比：</p><ul><li>MVP 版本（v26 版）的 <a target="_blank" rel="noopener noreferrer" href="https://github.com/qiniu/qpaint/blob/v26/paintweb/www/dom.js">dom.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ，约 120 行。</li><li>最新版本（v30 版）的 <a target="_blank" rel="noopener noreferrer" href="https://github.com/qiniu/qpaint/blob/v30/paintweb/www/dom.js">dom.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ，约 860 行。</li></ul><p>Model 层的代码行翻了多少倍？7.x 倍。</p><p>其二，不同版本（v26..v30）的变更历史：</p><p>v27：<a target="_blank" rel="noopener noreferrer" href="https://github.com/qiniu/qpaint/compare/v26...v27">https://github.com/qiniu/qpaint/compare/v26...v27<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p><img src="https://static001.geekbang.org/resource/image/23/6f/23a102e16f26d278ef10a4938066fd6f.png?wh=1010*327" alt=""/></p><p>v28：<a target="_blank" rel="noopener noreferrer" href="https://github.com/qiniu/qpaint/compare/v27...v28">https://github.com/qiniu/qpaint/compare/v27...v28<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p><img src="https://static001.geekbang.org/resource/image/1a/4d/1ab61e11c153a2b3b38bc90bf1006c4d.png?wh=1007*210" alt=""/></p><p>v29：<a target="_blank" rel="noopener noreferrer" href="https://github.com/qiniu/qpaint/compare/v28...v29">https://github.com/qiniu/qpaint/compare/v28...v29<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p><img src="https://static001.geekbang.org/resource/image/74/ab/74032dc7ab390189f3be591c13dad2ab.png?wh=1003*316" alt=""/></p><p>v30：<a target="_blank" rel="noopener noreferrer" href="https://github.com/qiniu/qpaint/compare/v29...v30">https://github.com/qiniu/qpaint/compare/v29...v30<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p><img src="https://static001.geekbang.org/resource/image/f4/b7/f4715e1055c75bbdf1b9d21bb89496b7.png?wh=998*279" alt=""/></p><p>不知道你看出什么来了吗？</p><p>一个有趣的事实是，多个版本的迭代，基本上都是以变更 Model 层为多。v29 版本的变更看似比较例外，没有修改 dom.js。但是实际上 v29 整个变更都是 Model 层的变更，因为是增加了服务端的 Model（我们前面把它叫做 Multi-User Model）。</p><p>我们深刻思考这个问题的话，我们会有这样一个推论：</p><ul><li>如果我们不是让 Model 层代码以内聚的方式放在一起，而是让它自由的散落于各处，那么我们的代码变更质量会非常不受控。</li></ul><p>为什么？Model 层总体来说是最容易测试的，因为它的环境依赖最小。如果这些代码被分散到 View、Controller 层中，代码的阅读难度、维护难度、测试的难度都会大幅增加。</p><p>通过几轮的功能迭代，我们对 Model 层的认知在不断的加深。我们总结一下它的职责，如下：</p><ul><li>业务逻辑，对外暴露业务接口。它也是 Model 的最本职的工作。</li><li>实现 View 层委托的 onpaint 事件，完成绘制功能。</li><li>实现 Controller 层的 hitTest 接口，用来实现 selection 支持。</li><li>实现与服务端 Multi-User Model 层的通讯，View、Controllers 组件都不需要感知服务端。</li><li>实现离线编辑 localStorage 的存取。</li></ul><p>除了少量 View（onpaint）、Controllers（hitTest）的需求，大部分都是 Model 层的正常业务范畴。</p><p>这些职责已经很多，所以 Model 层自然会胖。</p><h2 id="结语"><a aria-hidden="true" tabindex="-1" href="/blog-two/许式伟的架构课/03.桌面开发篇/11#结语"><span class="icon icon-link"></span></a>结语</h2><p>今天我们完成了画图程序前后端 paintdom、paintweb 的对接。由于考虑支持离线编辑，对接工作有较大的复杂性，你如果不能理解，建议仔细对代码进行研读。当然后面我们还会掰开来细谈这个案例。</p><p>这是最新版本的源代码：</p><ul><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/qiniu/qpaint/tree/v30">https://github.com/qiniu/qpaint/tree/v30<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><p>到这里我们的实战过程就先告一段落了。</p><p>如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。到现在为止，我们探讨的都是一个完整的桌面应用程序（可能是单机的，也可能是 B/S 结构的）的业务架构。</p><p>下一讲我们会谈谈辅助界面元素（自定义控件）的架构设计，它和应用程序的业务架构考虑的问题颇有不同。</p><p>话外：按照大纲，当前进度还只有 1/3 的内容。看起来我们最终会比原计划的 58 讲超出不少，可能要往 90 讲去了。关于这一点，我总体还是以说清楚事情为目标，在聊的过程会根据反馈作出适当的调整。</p><p>如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/许式伟的架构课/03.桌面开发篇/11.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:03</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
