<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>65 |&nbsp;架构范式：文本处理</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/许式伟的架构课/06.架构思维篇/10" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a aria-current="page" class="active" href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a aria-current="page" class="active" href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/许式伟的架构课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-two/许式伟的架构课/01.开篇词/01"><span>开篇词 | 怎样成长为优秀的软件架构师？</span></a></li></ul></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇">02.基础平台篇</a><ul><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/01"><span>01 | 架构设计的宏观视角</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/02"><span>02 | 大厦基石：无生有，有生万物</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/03"><span>03 | 汇编：编程语言的诞生</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/04"><span>04 | 编程语言的进化</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/05"><span>05 | 思考题解读：如何实现可自我迭代的计算机？</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/06"><span>06 | 操作系统进场</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/07"><span>07 | 软件运行机制及内存管理</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/08"><span>08 | 操作系统内核与编程接口</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/09"><span>09 | 外存管理与文件系统</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/10"><span>10 | 输入和输出设备：交互的演进</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/11"><span>11 | 多任务：进程、线程与协程</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/12"><span>12 | 进程内协同：同步、互斥与通讯</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/13"><span>13 | 进程间的同步互斥、资源共享与通讯</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/14"><span>14 | IP 网络：连接世界的桥梁</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/15"><span>15 | 可编程的互联网世界</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/16"><span>16 | 安全管理：数字世界的守护</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/17"><span>17 | 架构：需求分析 (上)</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/18"><span>18 | 架构：需求分析 (下) · 实战案例</span></a></li><li><a href="/blog-two/许式伟的架构课/02.基础平台篇/19"><span>19 | 基础平台篇：回顾与总结</span></a></li></ul></li><li><a href="/blog-two/许式伟的架构课/03.桌面开发篇">03.桌面开发篇</a><ul><li><a href="/blog-two/许式伟的架构课/03.桌面开发篇/01"><span>20 | 桌面开发的宏观视角</span></a></li><li><a href="/blog-two/许式伟的架构课/03.桌面开发篇/02"><span>21 | 图形界面程序的框架</span></a></li><li><a href="/blog-two/许式伟的架构课/03.桌面开发篇/03"><span>22 | 桌面程序的架构建议</span></a></li><li><a href="/blog-two/许式伟的架构课/03.桌面开发篇/04"><span>23 | Web开发：浏览器、小程序与PWA</span></a></li><li><a href="/blog-two/许式伟的架构课/03.桌面开发篇/05"><span>24 | 跨平台与 Web 开发的建议</span></a></li><li><a href="/blog-two/许式伟的架构课/03.桌面开发篇/06"><span>25 | 桌面开发的未来</span></a></li><li><a href="/blog-two/许式伟的架构课/03.桌面开发篇/07"><span>26 | 实战（一）：怎么设计一个“画图”程序？</span></a></li><li><a href="/blog-two/许式伟的架构课/03.桌面开发篇/08"><span>27 | 实战（二）：怎么设计一个“画图”程序？</span></a></li><li><a href="/blog-two/许式伟的架构课/03.桌面开发篇/09"><span>28 | 实战（三）：怎么设计一个“画图”程序？</span></a></li><li><a href="/blog-two/许式伟的架构课/03.桌面开发篇/10"><span>29 | 实战（四）：怎么设计一个“画图”程序？</span></a></li><li><a href="/blog-two/许式伟的架构课/03.桌面开发篇/11"><span>30  | 实战（五）：怎么设计一个“画图”程序？</span></a></li><li><a href="/blog-two/许式伟的架构课/03.桌面开发篇/12"><span>31 | 辅助界面元素的架构设计</span></a></li><li><a href="/blog-two/许式伟的架构课/03.桌面开发篇/13"><span>32 | 架构：系统的概要设计</span></a></li><li><a href="/blog-two/许式伟的架构课/03.桌面开发篇/14"><span>33 | 桌面开发篇：回顾与总结</span></a></li></ul></li><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇">04.服务端开发篇</a><ul><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇/01"><span>34 | 服务端开发的宏观视角</span></a></li><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇/02"><span>35 | 流量调度与负载均衡</span></a></li><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇/03"><span>36 | 业务状态与存储中间件</span></a></li><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇/04"><span>37 | 键值存储与数据库</span></a></li><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇/05"><span>38  | 文件系统与对象存储</span></a></li><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇/06"><span>39  | 存储与缓存</span></a></li><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇/07"><span>40 | 服务端的业务架构建议</span></a></li><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇/08"><span>41 | 实战（一）：“画图”程序后端实战</span></a></li><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇/09"><span>42 | 实战（二）：“画图”程序后端实战</span></a></li><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇/10"><span>43 | 实战（三）：“画图”程序后端实战</span></a></li><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇/11"><span>44 | 实战（四）：“画图”程序后端实战</span></a></li><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇/12"><span>45 | 架构：怎么做详细设计？</span></a></li><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇/13"><span>46 | 服务端开发篇：回顾与总结</span></a></li><li><a href="/blog-two/许式伟的架构课/04.服务端开发篇/14"><span>加餐 | 如何做HTTP服务的测试？</span></a></li></ul></li><li><a href="/blog-two/许式伟的架构课/05.服务治理篇">05.服务治理篇</a><ul><li><a href="/blog-two/许式伟的架构课/05.服务治理篇/01"><span>47 | 服务治理的宏观视角</span></a></li><li><a href="/blog-two/许式伟的架构课/05.服务治理篇/02"><span>48 | 事务与工程：什么是工程师思维？</span></a></li><li><a href="/blog-two/许式伟的架构课/05.服务治理篇/03"><span>49 | 发布、升级与版本管理</span></a></li><li><a href="/blog-two/许式伟的架构课/05.服务治理篇/04"><span>50 | 日志、监控与报警</span></a></li><li><a href="/blog-two/许式伟的架构课/05.服务治理篇/05"><span>加餐 | 怎么保障发布的效率与质量？</span></a></li><li><a href="/blog-two/许式伟的架构课/05.服务治理篇/06"><span>51 | 故障域与故障预案</span></a></li><li><a href="/blog-two/许式伟的架构课/05.服务治理篇/07"><span>52 | 故障排查与根因分析</span></a></li><li><a href="/blog-two/许式伟的架构课/05.服务治理篇/08"><span>53 | 过载保护与容量规划</span></a></li><li><a href="/blog-two/许式伟的架构课/05.服务治理篇/09"><span>54 | 业务的可支持性与持续运营</span></a></li><li><a href="/blog-two/许式伟的架构课/05.服务治理篇/10"><span>55 | 云计算、容器革命与服务端的未来</span></a></li><li><a href="/blog-two/许式伟的架构课/05.服务治理篇/11"><span>56 | 服务治理篇：回顾与总结</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/许式伟的架构课/06.架构思维篇">06.架构思维篇</a><ul><li><a href="/blog-two/许式伟的架构课/06.架构思维篇/01"><span>57 | 心性：架构师的修炼之道</span></a></li><li><a href="/blog-two/许式伟的架构课/06.架构思维篇/02"><span>58 | 如何判断架构设计的优劣？</span></a></li><li><a href="/blog-two/许式伟的架构课/06.架构思维篇/03"><span>59 | 少谈点框架，多谈点业务</span></a></li><li><a href="/blog-two/许式伟的架构课/06.架构思维篇/04"><span>60 | 架构分解：边界，不断重新审视边界</span></a></li><li><a href="/blog-two/许式伟的架构课/06.架构思维篇/05"><span>加餐 | 实战：“画图程序” 的整体架构</span></a></li><li><a href="/blog-two/许式伟的架构课/06.架构思维篇/06"><span>61 | 全局性功能的架构设计</span></a></li><li><a href="/blog-two/许式伟的架构课/06.架构思维篇/07"><span>62 | 重新认识开闭原则 (OCP)</span></a></li><li><a href="/blog-two/许式伟的架构课/06.架构思维篇/08"><span>63 | 接口设计的准则</span></a></li><li><a href="/blog-two/许式伟的架构课/06.架构思维篇/09"><span>64 | 不断完善的架构范式</span></a></li><li><a aria-current="page" class="active" href="/blog-two/许式伟的架构课/06.架构思维篇/10"><span>65 | 架构范式：文本处理</span></a></li><li><a href="/blog-two/许式伟的架构课/06.架构思维篇/11"><span>66 | 架构老化与重构</span></a></li><li><a href="/blog-two/许式伟的架构课/06.架构思维篇/12"><span>67 | 架构思维篇：回顾与总结</span></a></li></ul></li><li><a href="/blog-two/许式伟的架构课/07.软件工程篇">07.软件工程篇</a><ul><li><a href="/blog-two/许式伟的架构课/07.软件工程篇/01"><span>68 | 软件工程的宏观视角</span></a></li><li><a href="/blog-two/许式伟的架构课/07.软件工程篇/02"><span>69 | 团队的共识管理</span></a></li><li><a href="/blog-two/许式伟的架构课/07.软件工程篇/03"><span>70 | 怎么写设计文档？</span></a></li><li><a href="/blog-two/许式伟的架构课/07.软件工程篇/04"><span>71 | 如何阅读别人的代码？</span></a></li><li><a href="/blog-two/许式伟的架构课/07.软件工程篇/05"><span>72 | 发布单元与版本管理</span></a></li><li><a href="/blog-two/许式伟的架构课/07.软件工程篇/06"><span>73 | 软件质量管理：单元测试、持续构建与发布</span></a></li><li><a href="/blog-two/许式伟的架构课/07.软件工程篇/07"><span>74 | 开源、云服务与外包管理</span></a></li><li><a href="/blog-two/许式伟的架构课/07.软件工程篇/08"><span>75 | 软件版本迭代的规划</span></a></li><li><a href="/blog-two/许式伟的架构课/07.软件工程篇/09"><span>76 | 软件工程的未来</span></a></li><li><a href="/blog-two/许式伟的架构课/07.软件工程篇/10"><span>77 | 软件工程篇：回顾与总结</span></a></li></ul></li><li><a href="/blog-two/许式伟的架构课/08.结束语">08.结束语</a><ul><li><a href="/blog-two/许式伟的架构课/08.结束语/01"><span>结束语 | 放下技术人的身段，用极限思维提升架构能力</span></a></li><li><a href="/blog-two/许式伟的架构课/08.结束语/02"><span>结课问卷获奖用户名单</span></a></li><li><a href="/blog-two/许式伟的架构课/08.结束语/03"><span>课程迭代 | 84讲音频重新交付</span></a></li></ul></li><li><a href="/blog-two/许式伟的架构课/09.延展阅读">09.延展阅读</a><ul><li><a href="/blog-two/许式伟的架构课/09.延展阅读/01"><span>热点观察 | 我看Facebook发币（上）：区块链、比特币与Libra币</span></a></li><li><a href="/blog-two/许式伟的架构课/09.延展阅读/02"><span>热点观察 | 我看Facebook发币（下）：深入浅出理解 Libra 币</span></a></li><li><a href="/blog-two/许式伟的架构课/09.延展阅读/03"><span>课外阅读 | 从《孙子兵法》看底层的自然法则</span></a></li><li><a href="/blog-two/许式伟的架构课/09.延展阅读/04"><span>答疑解惑 | 想当架构师，我需要成为“全才”吗？</span></a></li><li><a href="/blog-two/许式伟的架构课/09.延展阅读/05"><span>用户故事 | 站在更高的视角看架构</span></a></li></ul></li><li><a href="/blog-two/许式伟的架构课/summary">许式伟的架构课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="我的文本处理技术栈演进" data-depth="2"><a href="/blog-two/许式伟的架构课/06.架构思维篇/10#我的文本处理技术栈演进"><span>我的文本处理技术栈演进</span></a></li><li title="文本内容的处理范式" data-depth="2"><a href="/blog-two/许式伟的架构课/06.架构思维篇/10#文本内容的处理范式"><span>文本内容的处理范式</span></a></li><li title="二进制内容的处理范式" data-depth="2"><a href="/blog-two/许式伟的架构课/06.架构思维篇/10#二进制内容的处理范式"><span>二进制内容的处理范式</span></a></li><li title="结语" data-depth="2"><a href="/blog-two/许式伟的架构课/06.架构思维篇/10#结语"><span>结语</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="65-架构范式文本处理"><a aria-hidden="true" tabindex="-1" href="/blog-two/许式伟的架构课/06.架构思维篇/10#65-架构范式文本处理"><span class="icon icon-link"></span></a>65 | 架构范式：文本处理</h1><p>你好，我是七牛云许式伟。</p><p>上一讲 “<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/177746?utm_source=time_pcchaping&amp;utm_term=pc_interstitial_11">64 | 不断完善的架构范式<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>” 我们提到架构师的武器库是不断完善的架构范式。今天我们围绕一个具体的问题域，看看我们日常能够积累什么样的经验和成果，来完善作为一个架构师的知识体系。</p><p>我们选择的问题是 “文本处理”。</p><p>计算机之所以叫计算机，是因为计算机的能力基本上就是“计算+I/O”两部分。I/O 只是为了让计算机与物理世界打交道，它也是为计算服务的。所以数据是软件的灵魂，数据处理是软件的能力。</p><p>今天我们聊的文本处理，不是通用的数据处理能力，而是收敛在数据的 I/O 上。这里说的文本，是指写入到磁盘的非结构化数据。它可能真的是文本内容，比如 HTML 文档、CSS 文档；也可能是二进制内容，比如 Word 文档、Excel 文档。文本处理则是指对这类非结构化数据的处理过程，常见文本处理的需求场景有：</p><ul><li>数据验证（Data Validation）。比如判断用户输入的文本是否合法，值的范围是否符合期望。</li><li>数据抽取（Data Extraction）。比如从某 HTML 页面中抽取出结构化的机票信息（什么时间，从哪里出发，到哪里去，价格几何等等）。</li><li>编译器（Compiler）。特殊地，在文本格式是某种语言的代码时，我们可以将文本编译成可执行的机器码，或虚拟机解释执行的字节码。当然我们也可以边解释文本的语义边执行。</li><li>……</li></ul><p>从用户需求的角度来说，文本处理的需求场景是不可穷尽的。网络爬虫与搜索引擎需要文本处理，Office 软件需要文本处理，编程语言的编译器需要文本处理，网络协议解析需要文本处理，等等。</p><p>那么，怎么才能从这些多变的需求场景中，抽出正交分解后可复用的架构范式？</p><p>我们今天聊聊文本处理的通用思路。</p><h2 id="我的文本处理技术栈演进"><a aria-hidden="true" tabindex="-1" href="/blog-two/许式伟的架构课/06.架构思维篇/10#我的文本处理技术栈演进"><span class="icon icon-link"></span></a>我的文本处理技术栈演进</h2><p>文本处理，很多人都会遇到，只不过大家各自遇到的场景不同。我这里先回顾下我个人遇到的文本处理场景。我总结了一个图，如下：</p><p><img src="https://static001.geekbang.org/resource/image/bc/0e/bc10a74957ac5bf36ec46a1b98dbbd0e.png" alt=""/></p><p>在 2000 年初，我作为实习生拿到的第一个任务，是金山电子表格自身的文件格式设计和 Excel 文件的读写。此后，我参与了多个版本的 Word 文件读写工作。为了便于分析 Excel 和 Word 文件的格式，我实现了 ExcelViewer 和 DocViewer 这两个文件格式查看器。</p><p>实际上这两个 Viewer 非常重要，因为它第一次让文件格式的理解过程用程序固化了下来。这非常利于知识传承。大家可以设想一下，假如没有 Viewer，那么后面接手的人基本上只能靠阅读 ExcelReader 和 DocReader 模块的代码来理解文件格式。</p><p>但是这有两个问题。其一，Reader 模块有大量的业务逻辑，对我们理解 Excel 和 Word 文件格式本身会造成干扰。其二，Reader 模块增加功能会比较慢，对于那些我们本身不支持的功能，或者我们还暂时来不及兼容的功能，是没有对应的解析代码的。</p><p>但是 Viewer 就不一样。我们会尽可能地把我们对 Excel 和 Word 的理解记录下来，成为稳定可传承的知识，而无需关心是否已经支持该功能。另外，从时间的维度来说，应该先有 Viewer，在理解了文件格式之后，再设计出 Reader 才比较合理。</p><p>这个时期的 ExcelViewer 和 DocViewer，它主要抽象出来的是界面呈现部分。具体 ExcelViewer 和 DocViewer 的代码不需要有一行涉及到界面。这有诸多好处。实际上可视化界面只是 ExcelViewer 和 DocViewer 的一种输出终端，它们同时也生成了一个纯文本结果到磁盘文件中。这有助于我们用常规的 diff 工具来对比两个文件的差异，从而加速我们对未知数据格式的了解。</p><p>但，此时的 ExcelViewer 和 DocViewer 并没有将文件格式的处理过程抽象出通用的模块。也可以说，还没有抽象出文本处理范式。</p><p>这个时期同期还有一个探索性的 WPS for Linux 项目。为了支持跨平台编译，我实现了一个简单的 mk 程序。这个程序区别于 Linux 标准化的 make 程序，没有那么复杂的逻辑需要理解。它的输入是一个类 Windows 平台的 ini 文件，里面只需要指定选择的编译器、相关的编译选项、源代码文件列表等，就可以进行编译。甚至源代码列表可以直接指定为从 Visual C++ 的项目配置 dsp 文件中抽取，极易使用。</p><p>这个 mk 程序除了要解析一个类 ini 的配置文件外，也会解析 C/C++ 源代码文件形成源代码文件的依赖表，以更好地支持增量编译。不只是源代码文件本身的修改会触发重新编译，任何依赖文件的修改也会触发重新编译。</p><p>同样地，这个时期的 mk 程序同样没有引入任何通用的文本处理范式。</p><p>此后大约在 2004 年，我开始在金山办公软件内部推 KSDN。KSDN 这个名字承自 MSDN，我们希望打造一个全局的文档系统，它自动从项目的源代码中提取并生成。每天日构建完毕后得到最新版本的 KSDN。</p><p>KSDN 处理的输入主要是 C++ 和 Delphi 源代码文件（当时的界面是 Delphi 写的），是纯文本的。这和 ExcelViewer、DocViewer 不同，他们的输入是二进制文件。</p><p>KSDN 第一次引入了一个通用的脚本，来表达我们想从源代码中抽取什么内容。整个 KSDN 处理单个源代码文件的工作原理可以描述为：</p><ul><li>通过文件后缀选择源代码文件的解析脚本，通过该脚本解析 C++ 或 Dephi 的源代码，并输出 XML 格式的文件；</li><li>通过 XSLT 脚本，将 XML 文件渲染为一个或多个 HTML 文件。XSLT 全称是 Extensible Stylesheet Language Transformations（可扩展样式表转换），是 XML 生态中的一项技术。</li></ul><p>在 2006 年的时候，我决定实现 KSDN 2.0 版本。这个版本主要想解决第一个版本的脚本语法表达能力比较局限的问题。</p><p>于是 C++ 版本的 TPL（Text Processing Language）诞生了。它非常类似于 Boost Spirit，但功能要强大很多。它的项目主页为：</p><ul><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/xushiwei/tpl">https://github.com/xushiwei/tpl<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><p>它依赖基础库 stdext，项目主页为：</p><ul><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/xushiwei/stdext">https://github.com/xushiwei/stdext<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><p>C++ 版本的 TPL 支持的表达能力，已经完全不弱于 UNIX 经典的 LEX + YACC 组合，使用上却轻量很多。KSDN 2.0 的工作原理变成了：</p><ul><li>基于 TPL 将 C++ 或 Delphi 文件转为 json 格式；</li><li>与 XSLT 类似地，我们引入了 JSPT，即以 json 为输入，PHP 为 formatter，将内容转为一个或多个 HTML 文件。</li></ul><p>这个过程非常通用，可以用于实现任意文件格式之间的变换。包括我们前面的 mk 程序，它本质上也是类 ini 文件格式变换到 Makefile 的过程，我们基于 TPL 很轻松就改造了一个 mk 2.0 版本。</p><p>2009 年的时候，我们基于 C++ 实现一个名为 CERL 的网络库，它和 Go 语言的 goroutine 类似，也是基于协程来实现高并发。在这个网络库中，我们定义了一个名为 SDL（Server Description Language）的语言来描述服务器的网络协议。很自然地，我们基于 TPL + JSPT 来实现了 SDL 文件的解析过程。</p><p>2011 年，七牛云成立，我们选择了 Go 语言作为技术栈的核心。在转 Go 语言后，除了 TPL，我个人沉淀的大部分 C++ 基础库都不再需要，因为它们往往已经被 Go 语言的标准库解决得很好。</p><p>在 2015 年的时候，出于某种原因我实现了一个网络爬虫，这个爬虫会在收到网页内容后，抽取网页中的结构化信息并存储起来。这个抽取信息的过程，最终导致 Go 语言版本 TPL 的诞生。它的项目主页为：</p><ul><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/qiniu/text">https://github.com/qiniu/text<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><p>为了验证 Go 语言版本 TPL 的有效性，我在实现了经典的 “计算器（Calculator）” 之余，顺手实现了一门语言，这就是 qlang。它的项目主页为：</p><ul><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/qiniu/qlang">https://github.com/qiniu/qlang<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><p>由于 Go 语言中实现泛型数据结构的需要，我给 qlang 实现了一个 embedded 版本，简称 eql。它是类似 erubis/erb 的东西。结合 go generate，它可以很方便地让 Go 支持模板（不是 html template，是指泛型）。</p><p>在 2017 年，出于 rtmp 网络协议理解的需要，我创建了 BPL（Binary Processing Language），它的项目主页为：</p><ul><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/qiniu/bpl">https://github.com/qiniu/bpl<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><p>区别于 TPL 的是，BPL 主要用于处理二进制文档。前面我们谈到 ExcelViewer 和 DocViewer 时说过，我们并没有建立任何通用的架构范式。这一直是我引以为憾的事情，所以 2006 年 C++ 版本的 TPL 诞生后就有过 BPL 相关的尝试。这里是尝试残留的痕迹：</p><ul><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/xushiwei/tpl/tree/master/include/tpl/binary">tpl/binary/*<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><p>但是二进制文档的确很难，它的格式描述中通常有一定的条件判断逻辑，所以 BPL 背后需要依赖一门语言。在 qlang 诞生后，这个条件就得到了满足，这是最终 BPL 得以能够诞生的原因。</p><p>BPL 非常强大，它可以处理任意的二进制文件，也可以用于处理任意的 TCP 网络协议数据流。有了 BPL，我们最初的 ExcelViewer 和 DocViewer 可以轻松得以实现。关于 BPL 更详细的介绍，请参阅 <a target="_blank" rel="noopener noreferrer" href="https://github.com/qiniu/bpl">https://github.com/qiniu/bpl<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中的文档说明。</p><h2 id="文本内容的处理范式"><a aria-hidden="true" tabindex="-1" href="/blog-two/许式伟的架构课/06.架构思维篇/10#文本内容的处理范式"><span class="icon icon-link"></span></a>文本内容的处理范式</h2><p>介绍了我个人文本处理的技术栈演进过程后，我们把话题重新回到架构范式。</p><p>首先，让我们把焦点放在文本内容的处理上。</p><p>文本内容的处理，有非常标准的方式。它通常分词法分析（Lex）和语法分析（Parser）两个阶段。UNIX 系的操作系统还提供了 lex 和 yacc 两个经典的程序来协助我们做文本文件的分析处理。</p><p>词法分析（Lex）通常由一个 Scanner 来完成，它负责将文本内容从字节流（Byte Stream）转为 Token 流（Token Stream）。我们以解析 Go 源代码的 Scanner 为例（参见 <a target="_blank" rel="noopener noreferrer" href="https://godoc.org/go/scanner">https://godoc.org/go/scanner<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），其 Scan 函数的原型如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type Scanner struct {</span></div><div class="token-line"><span class="token plain">      Scan() (pos token.Pos, tok token.Token, lit string)</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>其使用范式如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import (</span></div><div class="token-line"><span class="token plain">      &quot;go/scanner&quot;</span></div><div class="token-line"><span class="token plain">      &quot;go/token&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func doScan(s *scanner.Scanner) {</span></div><div class="token-line"><span class="token plain">      for {</span></div><div class="token-line"><span class="token plain">        pos, tok, lit := s.Scan()</span></div><div class="token-line"><span class="token plain">        if tok == token.EOF {</span></div><div class="token-line"><span class="token plain">          break</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">        // pos 是这个 token 的位置</span></div><div class="token-line"><span class="token plain">        // tok 是这个 token 的类型，见 https://godoc.org/go/token</span></div><div class="token-line"><span class="token plain">        // lit 是这个 token 的文本内容</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>Scanner 有时候也叫 Tokenizer。例如 Go 语言中 HTML 的 Tokenizer 类（参阅 <a target="_blank" rel="noopener noreferrer" href="https://godoc.org/golang.org/x/net/html">https://godoc.org/golang.org/x/net/html<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）的原型如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type Token struct {</span></div><div class="token-line"><span class="token plain">      Type     TokenType</span></div><div class="token-line"><span class="token plain">      DataAtom atom.Atom</span></div><div class="token-line"><span class="token plain">      Data     string</span></div><div class="token-line"><span class="token plain">      Attr     []Attribute</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    type Tokenizer struct {</span></div><div class="token-line"><span class="token plain">      Next() TokenType</span></div><div class="token-line"><span class="token plain">      Err() error</span></div><div class="token-line"><span class="token plain">      Token() Token</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>其使用范式如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import (</span></div><div class="token-line"><span class="token plain">      &quot;golang.org/x/net/html&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func doScan(z *html.Tokenizer) error {</span></div><div class="token-line"><span class="token plain">      for {</span></div><div class="token-line"><span class="token plain">      	if z.Next() == html.ErrorToken {</span></div><div class="token-line"><span class="token plain">      	  // Returning io.EOF indicates success.</span></div><div class="token-line"><span class="token plain">      	  return z.Err()</span></div><div class="token-line"><span class="token plain">      	}</span></div><div class="token-line"><span class="token plain">      	token := z.Token()</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>词法分析（Lex）过程非常基础，大部分情况下我们不会直接和它打交道。我们打交道的基本都是语法分析器，通常叫 Parser。而从Parser 的使用方式来说，分为 SAX 和 DOM 两种模型。SAX 模型基于事件机制，DOM 模型则基于结构化的数据访问接口。</p><p>前面我们已经多次分析过 SAX 与 DOM 的优劣，这里不再展开。通常来说，我们会倾向于采用 DOM 模型。这里我们还是以 Go 文法和 HTML 文法的解析为例。</p><p>先看 Go 文法的 Parser（参阅 <a target="_blank" rel="noopener noreferrer" href="https://godoc.org/go/parser">https://godoc.org/go/parser<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），它的原型如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func ParseExpr(x string) (ast.Expr, error)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func ParseFile(</span></div><div class="token-line"><span class="token plain">      fset *token.FileSet,</span></div><div class="token-line"><span class="token plain">      filename string, src interface{},</span></div><div class="token-line"><span class="token plain">      mode Mode) (f *ast.File, err error)</span></div></pre></div><p>这里看起来有点复杂的是 ParseFile，它输入的字节流（Byte Stream）可以是：</p><ul><li>scr != nil，且为 io.Reader 类型；</li><li>src != nil，且为 string 或 []byte 类型；</li><li>src == nil，filename 非空，字节流从 filename 对应的文件中读取。</li></ul><p>而 Parser 的输出则统一是一个抽象语法树（Abstract Syntax Tree，AST）。显然，它基于的是 DOM 模型。</p><p>我们再看 HTML 文法的 Parser（参阅 <a target="_blank" rel="noopener noreferrer" href="https://godoc.org/golang.org/x/net/html">https://godoc.org/golang.org/x/net/html<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），它的原型如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func Parse(r io.Reader) (*Node, error)</span></div></pre></div><p>超级简单的基于 DOM 模型的使用接口，任何解释都是多余的。</p><p>那么，我前面提的 TPL（Text Processing Language）是做什么的呢？它实现了一套通用的 Scanner + Parser 的机制。首先是词法分析，也就是 Scanner，它负责将文本流转换为 Token 序列。简单来说，就是一个从 text []byte 到 tokens []Token 的过程。</p><p>尽管世上语言多样，但是词法非常接近，所以在词法分析这块 ，TPL 抽象了一个 Tokenizer 接口，方便用户自定义。TPL 也内置了一个与 Go 语言词法类似的 Scanner，只是做了非常细微的调整，增加了 <code>?</code>、<code>~</code>、<code>@</code> 等操作符。</p><p>TPL 的 Parser 通过类 EBNF 文法表达。比如一个浮点运算的计算器（Calculator），支持加减乘除、函数调用、常量（如 pi 等）的类 EBNF 文法如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">term = factor *(&#x27;*&#x27; factor/mul | &#x27;/&#x27; factor/quo | &#x27;%&#x27; factor/mod)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    doc = term *(&#x27;+&#x27; term/add | &#x27;-&#x27; term/sub)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    factor =</span></div><div class="token-line"><span class="token plain">      FLOAT/push |</span></div><div class="token-line"><span class="token plain">      &#x27;-&#x27; factor/neg |</span></div><div class="token-line"><span class="token plain">      &#x27;(&#x27; doc &#x27;)&#x27; |</span></div><div class="token-line"><span class="token plain">      (IDENT &#x27;(&#x27; doc %= &#x27;,&#x27;/ARITY &#x27;)&#x27;)/call |</span></div><div class="token-line"><span class="token plain">      IDENT/ident |</span></div><div class="token-line"><span class="token plain">      &#x27;+&#x27; factor</span></div></pre></div><p>关于这个类 EBNF 文法，有以下补充说明：</p><ul><li>我们用 *G 和 +G 来表示重复，而不是用 <!-- -->{<!-- -->G<!-- -->}<!-- -->。要记住这条规则其实比较简单。在编译原理的图书中，我们看到往往是 G* 和 G+。但语言文法中除了 ++ 和 -- 运算符，很少是后缀形式，所以我们选择改为前缀。</li><li>我们用 ?G 来表示可选，而不是用 [G]。同上，只要能够回忆起编译原理中我们用 G? 表示可选，我们就很容易理解这里为什么可选是用 ?G 表示。</li><li>我们直接用 G1 G2 来表示串接，而不是 G1, G2。</li><li>我们用 G1 % G2 和 G1 %= G2 表示 G1 G2 G1 G2 ... G1 这样的列表。其中 G1 % G2 和 G1 %= G2 的区别是前者不能为空列表，后者可以。在上面的例子中，我们用 doc %= <code>,</code> 表示函数的参数列表。</li><li>我们用 G/action 表示在 G 匹配成功后执行 action 这个动作。action 最终是调用到 Go 语言中的回调函数。在上面这个计算器中大量使用了 G/action 文法。</li></ul><p>与 UNIX 实用程序 yacc 不同的是，TPL 中文法描述的脚本，与执行代码尽可能分离，以加业务语义的可读性。</p><p>从模型的归属来说，TPL 属于 SAX 模型。但 G/action 不一定真的是动作。在 extractor 模式下，G/action 被视为 G/marker，TPL 变成 DOM 模型。也就是说，此时 action 只是一个标记，用于形成输出的 DOM 树。</p><p>关于 TPL 更详细的介绍需要很长的篇幅，你可以参考 <a target="_blank" rel="noopener noreferrer" href="https://github.com/qiniu/text/tree/master/tpl">TPL Doc<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>在文本内容处理的技术栈中，还有一个分支是正则表达式（Regular Expression）。在简单场景下，正则表达式是比较方便的，但是它的缺点也比较明显，可伸缩性和可读性都不强。</p><h2 id="二进制内容的处理范式"><a aria-hidden="true" tabindex="-1" href="/blog-two/许式伟的架构课/06.架构思维篇/10#二进制内容的处理范式"><span class="icon icon-link"></span></a>二进制内容的处理范式</h2><p>接下来我们讨论二进制内容的通用处理范式。</p><p>二进制内容的处理过程整体来说，似乎比较 “容易”。如果要说出一点问题的话，那就是 “有点繁琐”。</p><p>还记得序列化机制吧？它基本上算得上二进制内容的 I/O 框架了。它看起来是这样的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type Foo struct {</span></div><div class="token-line"><span class="token plain">      A uint32</span></div><div class="token-line"><span class="token plain">      B string</span></div><div class="token-line"><span class="token plain">      C float64</span></div><div class="token-line"><span class="token plain">      D Bar</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func readFoo(foo *Foo, ar *Archive) {</span></div><div class="token-line"><span class="token plain">      readUint32(&amp;foo.A, ar)</span></div><div class="token-line"><span class="token plain">      readString(&amp;foo.B, ar)</span></div><div class="token-line"><span class="token plain">      readFloat64(&amp;foo.C, ar)</span></div><div class="token-line"><span class="token plain">      readBar(&amp;foo.D, ar)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在 C++ 的操作符重载的支持下，这段代码看起来会更简洁一些：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Archive&amp; operator&gt;&gt;(Archive&amp; ar, Foo&amp; foo) {</span></div><div class="token-line"><span class="token plain">      ar &gt;&gt; foo.A &gt;&gt; foo.B &gt;&gt; foo.C &gt;&gt; foo.D;</span></div><div class="token-line"><span class="token plain">      return ar;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>当然，上面只是最基础的情形，所以看起来还比较简洁。但在考虑可选、重复、数组等场景，实际上并不会那么简单。比如对于数组，理想情况下代码是下面这样的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type Foo struct {</span></div><div class="token-line"><span class="token plain">      N uint16</span></div><div class="token-line"><span class="token plain">      Bars []Bar // [N]Bar</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func readFoo(foo *Foo, ar *Archive) {</span></div><div class="token-line"><span class="token plain">      readUint16(&amp;foo.N, ar)</span></div><div class="token-line"><span class="token plain">      readArray(&amp;foo.Bars, int(foo.N), ar)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>对于 Go 语言来说，这里我们想要的 readArray 并不存在。而在 C++ 则可以通过泛型来做到，我们示意如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">template &lt;class T&gt;</span></div><div class="token-line"><span class="token plain">    void readArray(T[]&amp; v, int n, Archive&amp; ar) {</span></div><div class="token-line"><span class="token plain">      v = new T[n];</span></div><div class="token-line"><span class="token plain">      for (int i = 0; i &lt; n; i++) {</span></div><div class="token-line"><span class="token plain">        ar &gt;&gt; T[i];</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>呼唤一下 Go 语言的泛型吧。不过泛型大概率需要破坏 Go 的一些基础假设，比如不支持重载。所以 Go 的泛型之路不会那么容易。</p><p>回到序列化机制。常规意义的序列化，通常还提供了 Object 动态序列化与反序列化的能力。但是实际上这个机制属于过度设计。</p><p>为什么这么说？</p><p>因为 Object 动态序列化的确带来了一定的便捷性，但是这个便捷性的背后是让使用者放弃了对磁盘文件格式设计的思考。这是非常不正确的指导思想。</p><p>数据是软件的灵魂，文件是软件最重要的资产。</p><blockquote><p>文件 I/O 的序列化机制，最重要的是定义严谨的数据格式，而非提供任何出于便捷性考虑的智能。</p></blockquote><p>所以我们只需要保留序列化的形式就好了，任何额外的 “智能” 都是多余的。</p><p>基于这样的基本原则，稍作探究你就会发现，在数据结构清晰的情况下，其实整个序列化的代码是非常平庸的。假如我们参考 TPL 的类 EBNF 文法，定义以下这样一条规则：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Foo = {</span></div><div class="token-line"><span class="token plain">      N uint16</span></div><div class="token-line"><span class="token plain">      Bars [N]Bar</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这样，我们就可以自动帮这里的 Foo 类型实现它的序列化代码了。</p><p>而这正是 BPL 诞生的灵感来源。</p><p>BPL 设计的核心思想是，不破坏 TPL 的 EBNF 文法的任何语义，把自己作为 TPL 的扩展。这就好比，如果我们把 TPL 看作 C 的话，BPL 就是 C++。所有 TPL 的功能，BPL 都应该具备而且行为一致。</p><p>我们以 MongoDB 的网络协议为例，看看 BPL 文法是什么样的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">document = bson</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    MsgHeader = {/C</span></div><div class="token-line"><span class="token plain">      int32   messageLength; // total message size, including this</span></div><div class="token-line"><span class="token plain">      int32   requestID;     // identifier for this message</span></div><div class="token-line"><span class="token plain">      int32   responseTo;    // requestID from the original request (used in responses from db)</span></div><div class="token-line"><span class="token plain">      int32   opCode;        // request type - see table below</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    OP_UPDATE = {/C</span></div><div class="token-line"><span class="token plain">      int32     ZERO;               // 0 - reserved for future use</span></div><div class="token-line"><span class="token plain">      cstring   fullCollectionName; // &quot;dbname.collectionname&quot;</span></div><div class="token-line"><span class="token plain">      int32     flags;              // bit vector. see below</span></div><div class="token-line"><span class="token plain">      document  selector;           // the query to select the document</span></div><div class="token-line"><span class="token plain">      document  update;             // specification of the update to perform</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    OP_INSERT = {/C</span></div><div class="token-line"><span class="token plain">      int32      flags;              // bit vector - see below</span></div><div class="token-line"><span class="token plain">      cstring    fullCollectionName; // &quot;dbname.collectionname&quot;</span></div><div class="token-line"><span class="token plain">      document*  documents;          // one or more documents to insert into the collection</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    OP_QUERY = {/C</span></div><div class="token-line"><span class="token plain">      int32     flags;                  // bit vector of query options.  See below for details.</span></div><div class="token-line"><span class="token plain">      cstring   fullCollectionName;     // &quot;dbname.collectionname&quot;</span></div><div class="token-line"><span class="token plain">      int32     numberToSkip;           // number of documents to skip</span></div><div class="token-line"><span class="token plain">      int32     numberToReturn;         // number of documents to return</span></div><div class="token-line"><span class="token plain">      	                                //  in the first OP_REPLY batch</span></div><div class="token-line"><span class="token plain">      document  query;                  // query object.  See below for details.</span></div><div class="token-line"><span class="token plain">      document? returnFieldsSelector;   // Optional. Selector indicating the fields</span></div><div class="token-line"><span class="token plain">      	                                //  to return.  See below for details.</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    OP_GET_MORE = {/C</span></div><div class="token-line"><span class="token plain">      int32     ZERO;               // 0 - reserved for future use</span></div><div class="token-line"><span class="token plain">      cstring   fullCollectionName; // &quot;dbname.collectionname&quot;</span></div><div class="token-line"><span class="token plain">      int32     numberToReturn;     // number of documents to return</span></div><div class="token-line"><span class="token plain">      int64     cursorID;           // cursorID from the OP_REPLY</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    OP_DELETE = {/C</span></div><div class="token-line"><span class="token plain">      int32     ZERO;               // 0 - reserved for future use</span></div><div class="token-line"><span class="token plain">      cstring   fullCollectionName; // &quot;dbname.collectionname&quot;</span></div><div class="token-line"><span class="token plain">      int32     flags;              // bit vector - see below for details.</span></div><div class="token-line"><span class="token plain">      document  selector;           // query object.  See below for details.</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    OP_KILL_CURSORS = {/C</span></div><div class="token-line"><span class="token plain">      int32     ZERO;              // 0 - reserved for future use</span></div><div class="token-line"><span class="token plain">      int32     numberOfCursorIDs; // number of cursorIDs in message</span></div><div class="token-line"><span class="token plain">      int64*    cursorIDs;         // sequence of cursorIDs to close</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    OP_MSG = {/C</span></div><div class="token-line"><span class="token plain">      cstring   message; // message for the database</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    OP_REPLY = {/C</span></div><div class="token-line"><span class="token plain">      int32     responseFlags;  // bit vector - see details below</span></div><div class="token-line"><span class="token plain">      int64     cursorID;       // cursor id if client needs to do get more&#x27;s</span></div><div class="token-line"><span class="token plain">      int32     startingFrom;   // where in the cursor this reply is starting</span></div><div class="token-line"><span class="token plain">      int32     numberReturned; // number of documents in the reply</span></div><div class="token-line"><span class="token plain">      document* documents;      // documents</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    OP_REQ = {/C</span></div><div class="token-line"><span class="token plain">      cstring  dbName;</span></div><div class="token-line"><span class="token plain">      cstring  cmd;</span></div><div class="token-line"><span class="token plain">      document param;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    OP_RET = {/C</span></div><div class="token-line"><span class="token plain">      document ret;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Message = {</span></div><div class="token-line"><span class="token plain">      header MsgHeader   // standard message header</span></div><div class="token-line"><span class="token plain">      let bodyLen = header.messageLength - sizeof(MsgHeader)</span></div><div class="token-line"><span class="token plain">      read bodyLen do case header.opCode {</span></div><div class="token-line"><span class="token plain">      	1:    OP_REPLY    // Reply to a client request. responseTo is set.</span></div><div class="token-line"><span class="token plain">      	1000: OP_MSG      // Generic msg command followed by a string.</span></div><div class="token-line"><span class="token plain">      	2001: OP_UPDATE</span></div><div class="token-line"><span class="token plain">      	2002: OP_INSERT</span></div><div class="token-line"><span class="token plain">      	2004: OP_QUERY</span></div><div class="token-line"><span class="token plain">      	2005: OP_GET_MORE // Get more data from a query. See Cursors.</span></div><div class="token-line"><span class="token plain">      	2006: OP_DELETE</span></div><div class="token-line"><span class="token plain">      	2007: OP_KILL_CURSORS // Notify database that the client has finished with the cursor.</span></div><div class="token-line"><span class="token plain">      	2010: OP_REQ</span></div><div class="token-line"><span class="token plain">      	2011: OP_RET</span></div><div class="token-line"><span class="token plain">      	default: {</span></div><div class="token-line"><span class="token plain">          body [bodyLen]byte</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    doc = *Message</span></div></pre></div><p>我们对比 MongoDB 官方的协议文档（参考 <a target="_blank" rel="noopener noreferrer" href="https://docs.mongodb.com/manual/reference/mongodb-wire-protocol/">https://docs.mongodb.com/manual/reference/mongodb-wire-protocol/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），你会发现很有趣的一点是，我们 BPL 文法几乎和 MongoDB 官方采用的伪代码完全一致，除了一个小细节：在 BPL 中，我们用 <!-- -->{<!-- -->...<!-- -->}<!-- --> 表示采用 Go 语言结构体的文法，而 <!-- -->{<!-- -->/C ... <!-- -->}<!-- --> 表示采用 C 语言结构体的文法。</p><p>当前 BPL 还只支持解释执行，但这只是暂时的。就像在 TPL 中我们除了动态解释执行外，也已经提供 tpl generator 来生成 Go 代码以静态编译执行。</p><p>要进一步了解 BPL 的功能，请参阅 <a target="_blank" rel="noopener noreferrer" href="https://github.com/qiniu/bpl">https://github.com/qiniu/bpl<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。我们也还提供了不少具体 BPL 的样例，详细可参考：</p><ul><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/qiniu/bpl/tree/master/formats">https://github.com/qiniu/bpl/tree/master/formats<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><h2 id="结语"><a aria-hidden="true" tabindex="-1" href="/blog-two/许式伟的架构课/06.架构思维篇/10#结语"><span class="icon icon-link"></span></a>结语</h2><p>文本处理是一个非常庞大的课题，本文详细解剖了我个人在这个领域下的经验总结。相信这些经验对你面对相关场景时会有帮助。</p><p>但是更重要的一点是，我们平常需要有意识去分析我们工作中遇到的业务场景，从中提炼通用的需求场景形成架构范式的积累。</p><p>如此，架构的正交分解思想方能得到贯彻。而我们的业务迭代，也就越来越容易。</p><p>如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。下一讲我们的话题是 “架构老化与重构”。</p><p>如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/许式伟的架构课/06.架构思维篇/10.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:04</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
