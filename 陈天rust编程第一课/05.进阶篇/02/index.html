<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>24｜类型系统：如何在实战中使用trait object？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/陈天rust编程第一课/05.进阶篇/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/陈天rust编程第一课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-two/陈天rust编程第一课/01.开篇词/01"><span>开篇词｜让Rust成为你的下一门主力语言</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/02.前置篇">02.前置篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/02.前置篇/01"><span>01｜内存：值放堆上还是放栈上，这是一个问题</span></a></li><li><a href="/blog-two/陈天rust编程第一课/02.前置篇/02"><span>02｜串讲：编程开发中，那些你需要掌握的基本概念</span></a></li><li><a href="/blog-two/陈天rust编程第一课/02.前置篇/03"><span>加餐｜这个专栏你可以怎么学，以及Rust是否值得学？</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇">03.基础篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/01"><span>03｜初窥门径：从你的第一个Rust程序开始！</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/02"><span>04｜get hands dirty：来写个实用的CLI小工具</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/03"><span>05｜get hands dirty：做一个图片服务器有多难？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/04"><span>06｜get hands dirty：SQL查询工具怎么一鱼多吃？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/05"><span>07｜所有权：值的生杀大权到底在谁手上？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/06"><span>08｜所有权：值的借用是如何工作的？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/07"><span>09｜所有权：一个值可以有多个所有者么？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/08"><span>10｜生命周期：你创建的值究竟能活多久？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/09"><span>11｜内存管理：从创建到消亡，值都经历了什么？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/10"><span>加餐｜愚昧之巅：你的Rust学习常见问题汇总</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/11"><span>12｜类型系统：Rust的类型系统有什么特点？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/12"><span>13｜类型系统：如何使用trait来定义接口？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/13"><span>14｜类型系统：有哪些必须掌握的trait？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/14"><span>15｜数据结构：这些浓眉大眼的结构竟然都是智能指针？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/15"><span>16｜数据结构：Vec、&amp;[T]、Box&lt;[T]&gt; ，你真的了解集合容器么？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/16"><span>17｜数据结构：软件系统核心部件哈希表，内存如何布局？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/17"><span>18｜错误处理：为什么Rust的错误处理与众不同？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/18"><span>19｜闭包：FnOnce、FnMut和Fn，为什么有这么多类型？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/19"><span>20｜4 Steps ：如何更好地阅读Rust源码？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/20"><span>21｜阶段实操（1）：构建一个简单的KV server-基本流程</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/21"><span>22｜阶段实操（2）：构建一个简单的KV server-基本流程</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/04.期中周">04.期中周</a><ul><li><a href="/blog-two/陈天rust编程第一课/04.期中周/01"><span>加餐｜期中测试：来写一个简单的grep命令行</span></a></li><li><a href="/blog-two/陈天rust编程第一课/04.期中周/02"><span>加餐｜期中测试：参考实现讲解</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课/05.进阶篇">05.进阶篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/01"><span>23｜类型系统：如何在实战中使用泛型编程？</span></a></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课/05.进阶篇/02"><span>24｜类型系统：如何在实战中使用trait object？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/03"><span>25｜类型系统：如何围绕trait来设计和架构系统？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/04"><span>加餐｜Rust2021版次问世了！</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/05"><span>26｜阶段实操（3）：构建一个简单的KV server-高级trait技巧</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/06"><span>27｜生态系统：有哪些常有的Rust库可以为我所用？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/07"><span>28｜网络开发（上）：如何使用Rust处理网络请求？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/08"><span>29｜网络开发（下）：如何使用Rust处理网络请求？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/09"><span>30｜Unsafe Rust：如何用C++的方式打开Rust？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/10"><span>31｜FFI：Rust如何和你的语言架起沟通桥梁？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/11"><span>32｜实操项目：使用PyO3开发Python3模块</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇">06.并发篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/01"><span>33｜并发处理（上）：从atomics到Channel，Rust都提供了什么工具？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/02"><span>34｜并发处理（下）：从atomics到Channel，Rust都提供了什么工具？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/03"><span>35｜实操项目：如何实现一个基本的MPSC channel？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/04"><span>用户故事｜绝望之谷：改变从学习开始</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/05"><span>36｜阶段实操（4）：构建一个简单的KV server-网络处理</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/06"><span>37｜阶段实操（5）：构建一个简单的KV server-网络安全</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/07"><span>38｜异步处理：Future是什么？它和async/await是什么关系？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/08"><span>39｜异步处理：async/await内部是怎么实现的？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/09"><span>40｜异步处理：如何处理异步IO？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/10"><span>41｜阶段实操（6）：构建一个简单的KV server-异步处理</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/11"><span>42｜阶段实操（7）：构建一个简单的KV server-如何做大的重构？</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇">07.实战篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/01"><span>43｜生产环境：真实世界下的一个Rust项目包含哪些要素？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/02"><span>44｜数据处理：应用程序和数据如何打交道？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/03"><span>45｜阶段实操（8）：构建一个简单的KV server-配置/测试/监控/CI/CD</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/04"><span>46｜软件架构：如何用Rust架构复杂系统？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/05"><span>大咖助场｜开悟之坡（上）：Rust的现状、机遇与挑战</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/06"><span>大咖助场｜开悟之坡（下）：Rust的现状、机遇与挑战</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/07"><span>用户故事｜语言不仅是工具，还是思维方式</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/08.高级篇">08.高级篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/08.高级篇/01"><span>加餐｜代码即数据：为什么我们需要宏编程能力？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/08.高级篇/02"><span>加餐｜宏编程（上）：用最“笨”的方式撰写宏</span></a></li><li><a href="/blog-two/陈天rust编程第一课/08.高级篇/03"><span>加餐｜宏编程（下）：用 syn/quote 优雅地构建宏</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/09.结束语">09.结束语</a><ul><li><a href="/blog-two/陈天rust编程第一课/09.结束语/01"><span>结束语｜永续之原：Rust学习，如何持续精进？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/09.结束语/02"><span>期末测试｜来赴一场满分之约！</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊">10.学习锦囊</a><ul><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊/01"><span>特别策划｜学习锦囊（一）：听听课代表们怎么说</span></a></li><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊/02"><span>特别策划｜学习锦囊（二）：听听课代表们怎么说</span></a></li><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊/03"><span>特别策划｜学习锦囊（三）：听听课代表们怎么说</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/summary">陈天rust编程第一课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="在函数中使用 trait object" data-depth="2"><a href="/blog-two/陈天rust编程第一课/05.进阶篇/02#在函数中使用-trait-object"><span>在函数中使用 trait object</span></a></li><li title="在函数返回值中使用" data-depth="3"><a href="/blog-two/陈天rust编程第一课/05.进阶篇/02#在函数返回值中使用"><span>在函数返回值中使用</span></a></li><li title="在数据结构中使用 trait object" data-depth="2"><a href="/blog-two/陈天rust编程第一课/05.进阶篇/02#在数据结构中使用-trait-object"><span>在数据结构中使用 trait object</span></a></li><li title="用 trait object 处理 KV server 的 Service 结构" data-depth="2"><a href="/blog-two/陈天rust编程第一课/05.进阶篇/02#用-trait-object-处理-kv-server-的-service-结构"><span>用 trait object 处理 KV server 的 Service 结构</span></a></li><li title="小结" data-depth="2"><a href="/blog-two/陈天rust编程第一课/05.进阶篇/02#小结"><span>小结</span></a></li><li title="思考题" data-depth="3"><a href="/blog-two/陈天rust编程第一课/05.进阶篇/02#思考题"><span>思考题</span></a></li><li title="延伸阅读" data-depth="2"><a href="/blog-two/陈天rust编程第一课/05.进阶篇/02#延伸阅读"><span>延伸阅读</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="24类型系统如何在实战中使用trait-object"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/05.进阶篇/02#24类型系统如何在实战中使用trait-object"><span class="icon icon-link"></span></a>24｜类型系统：如何在实战中使用trait object？</h1><p>你好，我是陈天。</p><p>今天我们来看看 trait object 是如何在实战中使用的。</p><p>照例先来回顾一下 trait object。当我们在运行时想让某个具体类型，只表现出某个 trait 的行为，可以通过将其赋值给一个 dyn T，无论是 &amp;dyn T，还是 Box&lt;dyn T&gt;，还是 Arc&lt;dyn T&gt;，都可以，这里，T 是当前数据类型实现的某个 trait。此时，原有的类型被抹去，Rust 会创建一个 trait object，并为其分配满足该 trait 的 vtable。</p><p>你可以再阅读一下<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/420028">第 13 讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的这个图，来回顾 trait object 是怎么回事：<br/><img src="https://static001.geekbang.org/resource/image/49/1d/4900097edab0yye11233e14ef857be1d.jpg?wh=2248x1370" alt=""/></p><p>在编译 dyn T 时，Rust 会为使用了 trait object 类型的 trait 实现，生成相应的 vtable，放在可执行文件中（一般在 TEXT 或 RODATA 段）：<br/><img src="https://static001.geekbang.org/resource/image/9d/5e/9ddeafee9740e891f6bf9c1584e6905e.jpg?wh=2389x1738" alt=""/></p><p>这样，当 trait object 调用 trait 的方法时，它会先从 vptr 中找到对应的 vtable，进而找到对应的方法来执行。</p><p>使用 trait object 的好处是，<strong>当在某个上下文中需要满足某个 trait 的类型，且这样的类型可能有很多，当前上下文无法确定会得到哪一个类型时，我们可以用 trait object 来统一处理行为</strong>。和泛型参数一样，trait object 也是一种延迟绑定，它让决策可以延迟到运行时，从而得到最大的灵活性。</p><p>当然，有得必有失。trait object 把决策延迟到运行时，带来的后果是执行效率的打折。在 Rust 里，函数或者方法的执行就是一次跳转指令，而 trait object 方法的执行还多一步，它涉及额外的内存访问，才能得到要跳转的位置再进行跳转，执行的效率要低一些。</p><p>此外，如果要把 trait object 作为返回值返回，或者要在线程间传递 trait object，都免不了使用 Box&lt;dyn T&gt; 或者 Arc&lt;dyn T&gt;，会带来额外的堆分配的开销。</p><p>好，对 trait object 的回顾就到这里，如果你对它还一知半解，请复习 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/420028">13 讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，并且阅读 Rust book 里的：<a target="_blank" rel="noopener noreferrer" href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html">Using Trait Objects that allow for values of different types<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。接下来我们讲讲实战中 trait object 的主要使用场景。</p><h2 id="在函数中使用-trait-object"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/05.进阶篇/02#在函数中使用-trait-object"><span class="icon icon-link"></span></a>在函数中使用 trait object</h2><p>我们可以在函数的参数或者返回值中使用 trait object。</p><p>先来看在参数中使用 trait object。下面的代码构建了一个 Executor trait，并对比做静态分发的 impl Executor、做动态分发的 &amp;dyn Executor 和 Box&lt;dyn Executor&gt; 这几种不同的参数的使用：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use std::{error::Error, process::Command};</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    pub type BoxedError = Box&lt;dyn Error + Send + Sync&gt;;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    pub trait Executor {</span></div><div class="token-line"><span class="token plain">        fn run(&amp;self) -&gt; Result&lt;Option&lt;i32&gt;, BoxedError&gt;;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    pub struct Shell&lt;&#x27;a, &#x27;b&gt; {</span></div><div class="token-line"><span class="token plain">        cmd: &amp;&#x27;a str,</span></div><div class="token-line"><span class="token plain">        args: &amp;&#x27;b [&amp;&#x27;a str],</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl&lt;&#x27;a, &#x27;b&gt; Shell&lt;&#x27;a, &#x27;b&gt; {</span></div><div class="token-line"><span class="token plain">        pub fn new(cmd: &amp;&#x27;a str, args: &amp;&#x27;b [&amp;&#x27;a str]) -&gt; Self {</span></div><div class="token-line"><span class="token plain">            Self { cmd, args }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl&lt;&#x27;a, &#x27;b&gt; Executor for Shell&lt;&#x27;a, &#x27;b&gt; {</span></div><div class="token-line"><span class="token plain">        fn run(&amp;self) -&gt; Result&lt;Option&lt;i32&gt;, BoxedError&gt; {</span></div><div class="token-line"><span class="token plain">            let output = Command::new(self.cmd).args(self.args).output()?;</span></div><div class="token-line"><span class="token plain">            Ok(output.status.code())</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// 使用泛型参数</span></div><div class="token-line"><span class="token plain">    pub fn execute_generics(cmd: &amp;impl Executor) -&gt; Result&lt;Option&lt;i32&gt;, BoxedError&gt; {</span></div><div class="token-line"><span class="token plain">        cmd.run()</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// 使用 trait object: &amp;dyn T</span></div><div class="token-line"><span class="token plain">    pub fn execute_trait_object(cmd: &amp;dyn Executor) -&gt; Result&lt;Option&lt;i32&gt;, BoxedError&gt; {</span></div><div class="token-line"><span class="token plain">        cmd.run()</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// 使用 trait object: Box&lt;dyn T&gt;</span></div><div class="token-line"><span class="token plain">    pub fn execute_boxed_trait_object(cmd: Box&lt;dyn Executor&gt;) -&gt; Result&lt;Option&lt;i32&gt;, BoxedError&gt; {</span></div><div class="token-line"><span class="token plain">        cmd.run()</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #[cfg(test)]</span></div><div class="token-line"><span class="token plain">    mod tests {</span></div><div class="token-line"><span class="token plain">        use super::*;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        #[test]</span></div><div class="token-line"><span class="token plain">        fn shell_shall_work() {</span></div><div class="token-line"><span class="token plain">            let cmd = Shell::new(&quot;ls&quot;, &amp;[]);</span></div><div class="token-line"><span class="token plain">            let result = cmd.run().unwrap();</span></div><div class="token-line"><span class="token plain">            assert_eq!(result, Some(0));</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        #[test]</span></div><div class="token-line"><span class="token plain">        fn execute_shall_work() {</span></div><div class="token-line"><span class="token plain">            let cmd = Shell::new(&quot;ls&quot;, &amp;[]);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            let result = execute_generics(&amp;cmd).unwrap();</span></div><div class="token-line"><span class="token plain">            assert_eq!(result, Some(0));</span></div><div class="token-line"><span class="token plain">            let result = execute_trait_object(&amp;cmd).unwrap();</span></div><div class="token-line"><span class="token plain">            assert_eq!(result, Some(0));</span></div><div class="token-line"><span class="token plain">            let boxed = Box::new(cmd);</span></div><div class="token-line"><span class="token plain">            let result = execute_boxed_trait_object(boxed).unwrap();</span></div><div class="token-line"><span class="token plain">            assert_eq!(result, Some(0));</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>其中，impl Executor 使用的是泛型参数的简化版本，而 &amp;dyn Executor 和 Box&lt;dyn Executor&gt; 是 trait object，前者在栈上，后者分配在堆上。值得注意的是，分配在堆上的 trait object 也可以作为返回值返回，比如示例中的 Result&lt;Option&lt;i32&gt;, BoxedError&gt; 里使用了 trait object。</p><p>这里为了简化代码，我使用了 type 关键字创建了一个<strong>BoxedError 类型，是 Box&lt;dyn Error + Send + Sync + &#x27;static&gt; 的别名，它是 Error trait 的 trait object</strong>，除了要求类型实现了 Error trait 外，它还有额外的约束：类型必须满足 Send / Sync 这两个 trait。</p><p>在参数中使用 trait object 比较简单，再来看一个实战中的<a target="_blank" rel="noopener noreferrer" href="https://docs.rs/reqwest/0.11.5/reqwest/cookie/trait.CookieStore.html">例子<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>巩固一下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pub trait CookieStore: Send + Sync {</span></div><div class="token-line"><span class="token plain">        fn set_cookies(</span></div><div class="token-line"><span class="token plain">            &amp;self, </span></div><div class="token-line"><span class="token plain">            cookie_headers: &amp;mut dyn Iterator&lt;Item = &amp;HeaderValue&gt;, </span></div><div class="token-line"><span class="token plain">            url: &amp;Url</span></div><div class="token-line"><span class="token plain">        );</span></div><div class="token-line"><span class="token plain">        fn cookies(&amp;self, url: &amp;Url) -&gt; Option&lt;HeaderValue&gt;;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这是我们之前使用过的 reqwest 库中的一个处理 CookieStore 的 trait。在 set_cookies 方法中使用了 &amp;mut dyn Iterator 这样一个 trait object。</p><h3 id="在函数返回值中使用"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/05.进阶篇/02#在函数返回值中使用"><span class="icon icon-link"></span></a>在函数返回值中使用</h3><p>好，相信你对在参数中如何使用 trait object 已经没有什么问题了，我们再看返回值中使用 trait object，这是 trait object 使用频率比较高的场景。</p><p>之前已经出现过很多次了。比如上一讲已经详细介绍的，为何 KV server 里的 Storage trait 不能使用泛型参数来处理返回的 iterator，只能用 Box&lt;dyn Iterator&gt;：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pub trait Storage: Send + Sync + &#x27;static {</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">        /// 遍历 HashTable，返回 kv pair 的 Iterator</span></div><div class="token-line"><span class="token plain">        fn get_iter(&amp;self, table: &amp;str) -&gt; Result&lt;Box&lt;dyn Iterator&lt;Item = Kvpair&gt;&gt;, KvError&gt;;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>再来看一些实战中会遇到的例子。</p><p>首先是 <a target="_blank" rel="noopener noreferrer" href="https://docs.rs/async-trait">async_trait<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。它是一种特殊的 trait，方法中包含 async fn。目前 <a target="_blank" rel="noopener noreferrer" href="https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/">Rust 并不支持 trait 中使用 async fn<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，一个变通的方法是使用 async_trait 宏。</p><p>在 get hands dirty 系列中，我们就使用过 async trait。下面是<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/414478">第 6 讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>SQL查询工具数据源的获取中定义的 Fetch trait：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Rust 的 async trait 还没有稳定，可以用 async_trait 宏</span></div><div class="token-line"><span class="token plain">    #[async_trait]</span></div><div class="token-line"><span class="token plain">    pub trait Fetch {</span></div><div class="token-line"><span class="token plain">        type Error;</span></div><div class="token-line"><span class="token plain">        async fn fetch(&amp;self) -&gt; Result&lt;String, Self::Error&gt;;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里宏展开后，类似于：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pub trait Fetch {</span></div><div class="token-line"><span class="token plain">        type Error;</span></div><div class="token-line"><span class="token plain">        fn fetch&lt;&#x27;a&gt;(&amp;&#x27;a self) -&gt; </span></div><div class="token-line"><span class="token plain">            Result&lt;Pin&lt;Box&lt;dyn Future&lt;Output = String&gt; + Send + &#x27;a&gt;&gt;, Self::Error&gt;;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>它使用了 trait object 作为返回值。这样，不管 fetch() 的实现，返回什么样的 Future 类型，都可以被 trait object 统一起来，调用者只需要按照正常 Future 的接口使用即可。</p><p>我们再看一个 <a target="_blank" rel="noopener noreferrer" href="https://github.com/mcginty/snow">snow<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 下的 <a target="_blank" rel="noopener noreferrer" href="https://docs.rs/snow/0.8.0/snow/resolvers/trait.CryptoResolver.html">CryptoResolver<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/// An object that resolves the providers of Noise crypto choices</span></div><div class="token-line"><span class="token plain">    pub trait CryptoResolver {</span></div><div class="token-line"><span class="token plain">        /// Provide an implementation of the Random trait or None if none available.</span></div><div class="token-line"><span class="token plain">        fn resolve_rng(&amp;self) -&gt; Option&lt;Box&lt;dyn Random&gt;&gt;;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        /// Provide an implementation of the Dh trait for the given DHChoice or None if unavailable.</span></div><div class="token-line"><span class="token plain">        fn resolve_dh(&amp;self, choice: &amp;DHChoice) -&gt; Option&lt;Box&lt;dyn Dh&gt;&gt;;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        /// Provide an implementation of the Hash trait for the given HashChoice or None if unavailable.</span></div><div class="token-line"><span class="token plain">        fn resolve_hash(&amp;self, choice: &amp;HashChoice) -&gt; Option&lt;Box&lt;dyn Hash&gt;&gt;;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        /// Provide an implementation of the Cipher trait for the given CipherChoice or None if unavailable.</span></div><div class="token-line"><span class="token plain">        fn resolve_cipher(&amp;self, choice: &amp;CipherChoice) -&gt; Option&lt;Box&lt;dyn Cipher&gt;&gt;;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        /// Provide an implementation of the Kem trait for the given KemChoice or None if unavailable</span></div><div class="token-line"><span class="token plain">        #[cfg(feature = &quot;hfs&quot;)]</span></div><div class="token-line"><span class="token plain">        fn resolve_kem(&amp;self, _choice: &amp;KemChoice) -&gt; Option&lt;Box&lt;dyn Kem&gt;&gt; {</span></div><div class="token-line"><span class="token plain">            None</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这是一个处理 <a target="_blank" rel="noopener noreferrer" href="https://zhuanlan.zhihu.com/p/96944134">Noise Protocol<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 使用何种加密算法的一个 trait。这个 trait 的每个方法，都返回一个 trait object，每个 trait object 都提供加密算法中所需要的不同的能力，比如随机数生成算法（Random）、DH 算法（Dh）、哈希算法（Hash）、对称加密算法（Cipher）和密钥封装算法（Kem）。</p><p>所有这些，都有一系列的具体的算法实现，通过 CryptoResolver trait，可以得到当前使用的某个具体算法的 trait object，<strong>这样，在处理业务逻辑时，我们不用关心当前究竟使用了什么算法，就能根据这些 trait object 构筑相应的实现</strong>，比如下面的 generate_keypair：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pub fn generate_keypair(&amp;self) -&gt; Result&lt;Keypair, Error&gt; {</span></div><div class="token-line"><span class="token plain">        // 拿到当前的随机数生成算法</span></div><div class="token-line"><span class="token plain">        let mut rng = self.resolver.resolve_rng().ok_or(InitStage::GetRngImpl)?;</span></div><div class="token-line"><span class="token plain">    		// 拿到当前的 DH 算法</span></div><div class="token-line"><span class="token plain">        let mut dh = self.resolver.resolve_dh(&amp;self.params.dh).ok_or(InitStage::GetDhImpl)?;</span></div><div class="token-line"><span class="token plain">        let mut private = vec![0u8; dh.priv_len()];</span></div><div class="token-line"><span class="token plain">        let mut public = vec![0u8; dh.pub_len()];</span></div><div class="token-line"><span class="token plain">        // 使用随机数生成器 和 DH 生成密钥对</span></div><div class="token-line"><span class="token plain">        dh.generate(&amp;mut *rng);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        private.copy_from_slice(dh.privkey());</span></div><div class="token-line"><span class="token plain">        public.copy_from_slice(dh.pubkey());</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        Ok(Keypair { private, public })</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>说句题外话，如果你想更好地学习 trait 和 trait object 的使用，snow 是一个很好的学习资料。你可以顺着 CryptoResolver 梳理它用到的这几个主要的加密算法相关的 trait，看看别人是怎么定义 trait、如何把各个 trait 关联起来，以及最终如何把 trait 和核心数据结构联系起来的（小提示：<a target="_blank" rel="noopener noreferrer" href="https://docs.rs/snow/0.8.0/snow/struct.Builder.html">Builder<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 以及 <a target="_blank" rel="noopener noreferrer" href="https://docs.rs/snow/0.8.0/snow/struct.HandshakeState.html">HandshakeState<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）。</p><h2 id="在数据结构中使用-trait-object"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/05.进阶篇/02#在数据结构中使用-trait-object"><span class="icon icon-link"></span></a>在数据结构中使用 trait object</h2><p>了解了在函数中是如何使用 trait object 的，接下来我们再看看在数据结构中，如何使用 trait object。</p><p>继续以 snow 的代码为例，看 HandshakeState这个用于处理 Noise Protocol 握手协议的数据结构，用到了哪些 trait object（<a target="_blank" rel="noopener noreferrer" href="https://docs.rs/snow/0.8.0/src/snow/handshakestate.rs.html#29-48">代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pub struct HandshakeState {</span></div><div class="token-line"><span class="token plain">        pub(crate) rng:              Box&lt;dyn Random&gt;,</span></div><div class="token-line"><span class="token plain">        pub(crate) symmetricstate:   SymmetricState,</span></div><div class="token-line"><span class="token plain">        pub(crate) cipherstates:     CipherStates,</span></div><div class="token-line"><span class="token plain">        pub(crate) s:                Toggle&lt;Box&lt;dyn Dh&gt;&gt;,</span></div><div class="token-line"><span class="token plain">        pub(crate) e:                Toggle&lt;Box&lt;dyn Dh&gt;&gt;,</span></div><div class="token-line"><span class="token plain">        pub(crate) fixed_ephemeral:  bool,</span></div><div class="token-line"><span class="token plain">        pub(crate) rs:               Toggle&lt;[u8; MAXDHLEN]&gt;,</span></div><div class="token-line"><span class="token plain">        pub(crate) re:               Toggle&lt;[u8; MAXDHLEN]&gt;,</span></div><div class="token-line"><span class="token plain">        pub(crate) initiator:        bool,</span></div><div class="token-line"><span class="token plain">        pub(crate) params:           NoiseParams,</span></div><div class="token-line"><span class="token plain">        pub(crate) psks:             [Option&lt;[u8; PSKLEN]&gt;; 10],</span></div><div class="token-line"><span class="token plain">        #[cfg(feature = &quot;hfs&quot;)]</span></div><div class="token-line"><span class="token plain">        pub(crate) kem:              Option&lt;Box&lt;dyn Kem&gt;&gt;,</span></div><div class="token-line"><span class="token plain">        #[cfg(feature = &quot;hfs&quot;)]</span></div><div class="token-line"><span class="token plain">        pub(crate) kem_re:           Option&lt;[u8; MAXKEMPUBLEN]&gt;,</span></div><div class="token-line"><span class="token plain">        pub(crate) my_turn:          bool,</span></div><div class="token-line"><span class="token plain">        pub(crate) message_patterns: MessagePatterns,</span></div><div class="token-line"><span class="token plain">        pub(crate) pattern_position: usize,</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>你不需要了解 Noise protocol，也能够大概可以明白这里 Random、Dh 以及 Kem 三个 trait object 的作用：它们为握手期间使用的加密协议提供最大的灵活性。</p><p>想想看，如果这里不用 trait object，这个数据结构该怎么处理？</p><p>可以用泛型参数，也就是说：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pub struct HandshakeState&lt;R, D, K&gt;</span></div><div class="token-line"><span class="token plain">    where</span></div><div class="token-line"><span class="token plain">        R: Random,</span></div><div class="token-line"><span class="token plain">        D: Dh,</span></div><div class="token-line"><span class="token plain">        K: Kem</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这是我们大部分时候处理这样的数据结构的选择。但是，过多的泛型参数会带来两个问题：首先，代码实现过程中，所有涉及的接口都变得非常臃肿，你在使用 HandshakeState&lt;R, D, K&gt; 的任何地方，都必须带着这几个泛型参数以及它们的约束。其次，这些参数所有被使用到的情况，组合起来，会生成大量的代码。</p><p>而使用 trait object，我们在牺牲一点性能的前提下，消除了这些泛型参数，实现的代码更干净清爽，且代码只会有一份实现。</p><p>在数据结构中使用 trait object 还有一种很典型的场景是，<strong>闭包</strong>。</p><p>因为在 Rust 中，闭包都是以匿名类型的方式出现，我们无法直接在数据结构中使用其类型，只能用泛型参数。而对闭包使用泛型参数后，如果捕获的数据太大，可能造成数据结构本身太大；但有时，我们并不在意一点点性能损失，更愿意让代码处理起来更方便。</p><p>比如用于做 RBAC 的库 <a target="_blank" rel="noopener noreferrer" href="https://github.com/osohq/oso">oso<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 里的 AttributeGetter，它包含了一个 Fn：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#[derive(Clone)]</span></div><div class="token-line"><span class="token plain">    pub struct AttributeGetter(</span></div><div class="token-line"><span class="token plain">        Arc&lt;dyn Fn(&amp;Instance, &amp;mut Host) -&gt; crate::Result&lt;PolarValue&gt; + Send + Sync&gt;,</span></div><div class="token-line"><span class="token plain">    );</span></div></pre></div><p>如果你对在 Rust 中如何实现 Python 的 getattr 感兴趣，可以看看 <a target="_blank" rel="noopener noreferrer" href="https://github.com/osohq/oso">oso<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的代码。</p><p>再比如做交互式 CLI 的 <a target="_blank" rel="noopener noreferrer" href="https://github.com/mitsuhiko/dialoguer">dialoguer<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的 <a target="_blank" rel="noopener noreferrer" href="https://docs.rs/dialoguer/0.8.0/dialoguer/struct.Input.html">Input<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，它的 validator 就是一个 FnMut：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pub struct Input&lt;&#x27;a, T&gt; {</span></div><div class="token-line"><span class="token plain">        prompt: String,</span></div><div class="token-line"><span class="token plain">        default: Option&lt;T&gt;,</span></div><div class="token-line"><span class="token plain">        show_default: bool,</span></div><div class="token-line"><span class="token plain">        initial_text: Option&lt;String&gt;,</span></div><div class="token-line"><span class="token plain">        theme: &amp;&#x27;a dyn Theme,</span></div><div class="token-line"><span class="token plain">        permit_empty: bool,</span></div><div class="token-line"><span class="token plain">        validator: Option&lt;Box&lt;dyn FnMut(&amp;T) -&gt; Option&lt;String&gt; + &#x27;a&gt;&gt;,</span></div><div class="token-line"><span class="token plain">        #[cfg(feature = &quot;history&quot;)]</span></div><div class="token-line"><span class="token plain">        history: Option&lt;&amp;&#x27;a mut dyn History&lt;T&gt;&gt;,</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h2 id="用-trait-object-处理-kv-server-的-service-结构"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/05.进阶篇/02#用-trait-object-处理-kv-server-的-service-结构"><span class="icon icon-link"></span></a>用 trait object 处理 KV server 的 Service 结构</h2><p>好，到这里用 trait object 做动态分发的几个场景我们就介绍完啦，来写段代码练习一下。</p><p>就用之前写的 KV server 的 Service 结构来趁热打铁，我们尝试对它做个处理，使其内部使用 trait object。</p><p>其实对于 KV server 而言，使用泛型是更好的选择，因为此处泛型并不会造成太多的复杂性，我们也不希望丢掉哪怕一点点性能。然而，出于学习的目的，我们可以看看如果 store 使用 trait object，代码会变成什么样子。你自己可以先尝试一下，再来看下面的示例（<a target="_blank" rel="noopener noreferrer" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=bf13294ace57216e529ac1f93efd9291">代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use std::{error::Error, sync::Arc};</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 定义类型，让 KV server 里的 trait 可以被编译通过</span></div><div class="token-line"><span class="token plain">    pub type KvError = Box&lt;dyn Error + Send + Sync&gt;;</span></div><div class="token-line"><span class="token plain">    pub struct Value(i32);</span></div><div class="token-line"><span class="token plain">    pub struct Kvpair(i32, i32);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// 对存储的抽象，我们不关心数据存在哪儿，但需要定义外界如何和存储打交道</span></div><div class="token-line"><span class="token plain">    pub trait Storage: Send + Sync + &#x27;static {</span></div><div class="token-line"><span class="token plain">        fn get(&amp;self, table: &amp;str, key: &amp;str) -&gt; Result&lt;Option&lt;Value&gt;, KvError&gt;;</span></div><div class="token-line"><span class="token plain">        fn set(&amp;self, table: &amp;str, key: String, value: Value) -&gt; Result&lt;Option&lt;Value&gt;, KvError&gt;;</span></div><div class="token-line"><span class="token plain">        fn contains(&amp;self, table: &amp;str, key: &amp;str) -&gt; Result&lt;bool, KvError&gt;;</span></div><div class="token-line"><span class="token plain">        fn del(&amp;self, table: &amp;str, key: &amp;str) -&gt; Result&lt;Option&lt;Value&gt;, KvError&gt;;</span></div><div class="token-line"><span class="token plain">        fn get_all(&amp;self, table: &amp;str) -&gt; Result&lt;Vec&lt;Kvpair&gt;, KvError&gt;;</span></div><div class="token-line"><span class="token plain">        fn get_iter(&amp;self, table: &amp;str) -&gt; Result&lt;Box&lt;dyn Iterator&lt;Item = Kvpair&gt;&gt;, KvError&gt;;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 使用 trait object，不需要泛型参数，也不需要 ServiceInner 了</span></div><div class="token-line"><span class="token plain">    pub struct Service {</span></div><div class="token-line"><span class="token plain">        pub store: Arc&lt;dyn Storage&gt;,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // impl 的代码略微简单一些</span></div><div class="token-line"><span class="token plain">    impl Service {</span></div><div class="token-line"><span class="token plain">        pub fn new&lt;S: Storage&gt;(store: S) -&gt; Self {</span></div><div class="token-line"><span class="token plain">            Self {</span></div><div class="token-line"><span class="token plain">                store: Arc::new(store),</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 实现 trait 时也不需要带着泛型参数</span></div><div class="token-line"><span class="token plain">    impl Clone for Service {</span></div><div class="token-line"><span class="token plain">        fn clone(&amp;self) -&gt; Self {</span></div><div class="token-line"><span class="token plain">            Self {</span></div><div class="token-line"><span class="token plain">                store: Arc::clone(&amp;self.store),</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>从这段代码中可以看到，通过牺牲一点性能，我们让代码整体撰写和使用起来方便了不少。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/05.进阶篇/02#小结"><span class="icon icon-link"></span></a>小结</h2><p>无论是上一讲的泛型参数，还是今天的 trait object，都是 Rust 处理多态的手段。当系统需要使用多态来解决复杂多变的需求，让同一个接口可以展现不同的行为时，我们要决定究竟是编译时的静态分发更好，还是运行时的动态分发更好。</p><p>一般情况下，作为 Rust 开发者，我们不介意泛型参数带来的稍微复杂的代码结构，愿意用开发时的额外付出，换取运行时的高效；但<strong>有时候，当泛型参数过多，导致代码出现了可读性问题，或者运行效率并不是主要矛盾的时候，我们可以通过使用 trait object 做动态分发，来降低代码的复杂度</strong>。</p><p>具体看，在有些情况，我们不太容易使用泛型参数，比如希望函数返回某个 trait 的实现，或者数据结构中某些参数在运行时的组合过于复杂，比如上文提到的 HandshakeState，此时，使用 trait object 是更好的选择。</p><h3 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/05.进阶篇/02#思考题"><span class="icon icon-link"></span></a>思考题</h3><p>期中测试中我给出的 <a target="_blank" rel="noopener noreferrer" href="https://github.com/tyrchen/geektime-rust">rgrep 的代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，如果把 StrategyFn 的接口改成使用 trait object：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/// 定义类型，这样，在使用时可以简化复杂类型的书写</span></div><div class="token-line"><span class="token plain">    pub type StrategyFn = fn(&amp;Path, &amp;mut dyn BufRead, &amp;Regex, &amp;mut dyn Write) -&gt; Result&lt;(), GrepError&gt;;</span></div></pre></div><p>你能把实现部分修改，使测试通过么？对比修改前后的代码，你觉得对 rgrep，哪种实现更好？为什么？</p><p>今天你完成了Rust学习的第24次打卡。如果你觉得有收获，也欢迎分享给你身边的朋友，邀他一起讨论。我们下节课见。</p><h2 id="延伸阅读"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/05.进阶篇/02#延伸阅读"><span class="icon icon-link"></span></a>延伸阅读</h2><p>我们总说 trait object 性能会差一些，因为需要从 vtable 中额外加载对应的方法的地址，才能跳转执行。那么这个性能差异究竟有多大呢？网上有人说调用 trait object 的方法，性能会比直接调用类型的方法差一个数量级，真的么？</p><p>我用 criterion 做了一个简单的测试，测试的 trait 使用的就是我们这一讲使用的 Executor trait。测试代码如下（你可以访问 <a target="_blank" rel="noopener noreferrer" href="https://github.com/tyrchen/geektime-rust">GitHub repo<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中这一讲的代码）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use advanced_trait_objects::{</span></div><div class="token-line"><span class="token plain">        execute_boxed_trait_object, execute_generics, execute_trait_object, Shell,</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    use criterion::{black_box, criterion_group, criterion_main, Criterion};</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    pub fn generics_benchmark(c: &amp;mut Criterion) {</span></div><div class="token-line"><span class="token plain">        c.bench_function(&quot;generics&quot;, |b| {</span></div><div class="token-line"><span class="token plain">            b.iter(|| {</span></div><div class="token-line"><span class="token plain">                let cmd = Shell::new(&quot;ls&quot;, &amp;[]);</span></div><div class="token-line"><span class="token plain">                execute_generics(black_box(&amp;cmd)).unwrap();</span></div><div class="token-line"><span class="token plain">            })</span></div><div class="token-line"><span class="token plain">        });</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    pub fn trait_object_benchmark(c: &amp;mut Criterion) {</span></div><div class="token-line"><span class="token plain">        c.bench_function(&quot;trait object&quot;, |b| {</span></div><div class="token-line"><span class="token plain">            b.iter(|| {</span></div><div class="token-line"><span class="token plain">                let cmd = Shell::new(&quot;ls&quot;, &amp;[]);</span></div><div class="token-line"><span class="token plain">                execute_trait_object(black_box(&amp;cmd)).unwrap();</span></div><div class="token-line"><span class="token plain">            })</span></div><div class="token-line"><span class="token plain">        });</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    pub fn boxed_object_benchmark(c: &amp;mut Criterion) {</span></div><div class="token-line"><span class="token plain">        c.bench_function(&quot;boxed object&quot;, |b| {</span></div><div class="token-line"><span class="token plain">            b.iter(|| {</span></div><div class="token-line"><span class="token plain">                let cmd = Box::new(Shell::new(&quot;ls&quot;, &amp;[]));</span></div><div class="token-line"><span class="token plain">                execute_boxed_trait_object(black_box(cmd)).unwrap();</span></div><div class="token-line"><span class="token plain">            })</span></div><div class="token-line"><span class="token plain">        });</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    criterion_group!(</span></div><div class="token-line"><span class="token plain">        benches,</span></div><div class="token-line"><span class="token plain">        generics_benchmark,</span></div><div class="token-line"><span class="token plain">        trait_object_benchmark,</span></div><div class="token-line"><span class="token plain">        boxed_object_benchmark</span></div><div class="token-line"><span class="token plain">    );</span></div><div class="token-line"><span class="token plain">    criterion_main!(benches);</span></div></pre></div><p>为了不让实现本身干扰接口调用的速度，我们在 trait 的方法中什么也不做，直接返回：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">impl&lt;&#x27;a, &#x27;b&gt; Executor for Shell&lt;&#x27;a, &#x27;b&gt; {</span></div><div class="token-line"><span class="token plain">        fn run(&amp;self) -&gt; Result&lt;Option&lt;i32&gt;, BoxedError&gt; {</span></div><div class="token-line"><span class="token plain">            // let output = Command::new(self.cmd).args(self.args).output()?;</span></div><div class="token-line"><span class="token plain">            // Ok(output.status.code())</span></div><div class="token-line"><span class="token plain">            Ok(Some(0))</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>测试结果如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">generics                time:   [3.0995 ns 3.1549 ns 3.2172 ns]                      </span></div><div class="token-line"><span class="token plain">                            change: [-96.890% -96.810% -96.732%] (p = 0.00 &lt; 0.05)</span></div><div class="token-line"><span class="token plain">                            Performance has improved.</span></div><div class="token-line"><span class="token plain">    Found 5 outliers among 100 measurements (5.00%)</span></div><div class="token-line"><span class="token plain">      4 (4.00%) high mild</span></div><div class="token-line"><span class="token plain">      1 (1.00%) high severe</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    trait object            time:   [4.0348 ns 4.0934 ns 4.1552 ns]                          </span></div><div class="token-line"><span class="token plain">                            change: [-96.024% -95.893% -95.753%] (p = 0.00 &lt; 0.05)</span></div><div class="token-line"><span class="token plain">                            Performance has improved.</span></div><div class="token-line"><span class="token plain">    Found 8 outliers among 100 measurements (8.00%)</span></div><div class="token-line"><span class="token plain">      3 (3.00%) high mild</span></div><div class="token-line"><span class="token plain">      5 (5.00%) high severe</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    boxed object            time:   [65.240 ns 66.473 ns 67.777 ns]                         </span></div><div class="token-line"><span class="token plain">                            change: [-67.403% -66.462% -65.530%] (p = 0.00 &lt; 0.05)</span></div><div class="token-line"><span class="token plain">                            Performance has improved.</span></div><div class="token-line"><span class="token plain">    Found 2 outliers among 100 measurements (2.00%)</span></div></pre></div><p>可以看到，使用泛型做静态分发最快，平均 3.15ns；使用 &amp;dyn Executor 平均速度 4.09ns，要慢 30%；而使用 Box&lt;dyn Executor&gt; 平均速度 66.47ns，慢了足足 20 倍。可见，额外的内存访问并不是 trait object 的效率杀手，有些场景下为了使用 trait object 不得不做的额外的堆内存分配，才是主要的效率杀手。</p><p>那么，这个性能差异重要么？</p><p>在回答这个问题之前，我们把 run() 方法改回来：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">impl&lt;&#x27;a, &#x27;b&gt; Executor for Shell&lt;&#x27;a, &#x27;b&gt; {</span></div><div class="token-line"><span class="token plain">        fn run(&amp;self) -&gt; Result&lt;Option&lt;i32&gt;, BoxedError&gt; {</span></div><div class="token-line"><span class="token plain">            let output = Command::new(self.cmd).args(self.args).output()?;</span></div><div class="token-line"><span class="token plain">            Ok(output.status.code())</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们知道 Command 的执行速度比较慢，但是想再看看，对于执行效率低的方法，这个性能差异是否重要。</p><p>新的测试结果不出所料：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">generics                time:   [4.6901 ms 4.7267 ms 4.7678 ms]                      </span></div><div class="token-line"><span class="token plain">                            change: [+145694872% +148496855% +151187366%] (p = 0.00 &lt; 0.05)</span></div><div class="token-line"><span class="token plain">                            Performance has regressed.</span></div><div class="token-line"><span class="token plain">    Found 7 outliers among 100 measurements (7.00%)</span></div><div class="token-line"><span class="token plain">      3 (3.00%) high mild</span></div><div class="token-line"><span class="token plain">      4 (4.00%) high severe</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    trait object            time:   [4.7452 ms 4.7912 ms 4.8438 ms]                          </span></div><div class="token-line"><span class="token plain">                            change: [+109643581% +113478268% +116908330%] (p = 0.00 &lt; 0.05)</span></div><div class="token-line"><span class="token plain">                            Performance has regressed.</span></div><div class="token-line"><span class="token plain">    Found 7 outliers among 100 measurements (7.00%)</span></div><div class="token-line"><span class="token plain">      4 (4.00%) high mild</span></div><div class="token-line"><span class="token plain">      3 (3.00%) high severe</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    boxed object            time:   [4.7867 ms 4.8336 ms 4.8874 ms]                          </span></div><div class="token-line"><span class="token plain">                            change: [+6935303% +7085465% +7238819%] (p = 0.00 &lt; 0.05)</span></div><div class="token-line"><span class="token plain">                            Performance has regressed.</span></div><div class="token-line"><span class="token plain">    Found 8 outliers among 100 measurements (8.00%)</span></div><div class="token-line"><span class="token plain">      4 (4.00%) high mild</span></div><div class="token-line"><span class="token plain">      4 (4.00%) high severe</span></div></pre></div><p>因为执行一个 Shell 命令的效率实在太低，到毫秒的量级，虽然 generics 依然最快，但使用 &amp;dyn Executor 和 Box&lt;dyn executor&gt; 也不过只比它慢了 1% 和 2%。</p><p>所以，如果是那种执行效率在数百纳秒以内的函数，是否使用 trait object，尤其是 boxed trait object，性能差别会比较明显；但当函数本身的执行需要数微秒到数百微秒时，性能差别就很小了；到了毫秒的量级，性能的差别几乎无关紧要。</p><p>总的来说，大部分情况，我们在撰写代码的时候，不必太在意 trait object 的性能问题。如果你实在在意关键路径上 trait object 的性能，那么先尝试看能不能不要做额外的堆内存分配。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/陈天rust编程第一课/05.进阶篇/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:25</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
