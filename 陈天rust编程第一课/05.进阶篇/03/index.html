<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>25｜类型系统：如何围绕trait来设计和架构系统？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/陈天rust编程第一课/05.进阶篇/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/陈天rust编程第一课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-two/陈天rust编程第一课/01.开篇词/01"><span>开篇词｜让Rust成为你的下一门主力语言</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/02.前置篇">02.前置篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/02.前置篇/01"><span>01｜内存：值放堆上还是放栈上，这是一个问题</span></a></li><li><a href="/blog-two/陈天rust编程第一课/02.前置篇/02"><span>02｜串讲：编程开发中，那些你需要掌握的基本概念</span></a></li><li><a href="/blog-two/陈天rust编程第一课/02.前置篇/03"><span>加餐｜这个专栏你可以怎么学，以及Rust是否值得学？</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇">03.基础篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/01"><span>03｜初窥门径：从你的第一个Rust程序开始！</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/02"><span>04｜get hands dirty：来写个实用的CLI小工具</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/03"><span>05｜get hands dirty：做一个图片服务器有多难？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/04"><span>06｜get hands dirty：SQL查询工具怎么一鱼多吃？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/05"><span>07｜所有权：值的生杀大权到底在谁手上？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/06"><span>08｜所有权：值的借用是如何工作的？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/07"><span>09｜所有权：一个值可以有多个所有者么？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/08"><span>10｜生命周期：你创建的值究竟能活多久？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/09"><span>11｜内存管理：从创建到消亡，值都经历了什么？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/10"><span>加餐｜愚昧之巅：你的Rust学习常见问题汇总</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/11"><span>12｜类型系统：Rust的类型系统有什么特点？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/12"><span>13｜类型系统：如何使用trait来定义接口？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/13"><span>14｜类型系统：有哪些必须掌握的trait？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/14"><span>15｜数据结构：这些浓眉大眼的结构竟然都是智能指针？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/15"><span>16｜数据结构：Vec、&amp;[T]、Box&lt;[T]&gt; ，你真的了解集合容器么？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/16"><span>17｜数据结构：软件系统核心部件哈希表，内存如何布局？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/17"><span>18｜错误处理：为什么Rust的错误处理与众不同？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/18"><span>19｜闭包：FnOnce、FnMut和Fn，为什么有这么多类型？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/19"><span>20｜4 Steps ：如何更好地阅读Rust源码？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/20"><span>21｜阶段实操（1）：构建一个简单的KV server-基本流程</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/21"><span>22｜阶段实操（2）：构建一个简单的KV server-基本流程</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/04.期中周">04.期中周</a><ul><li><a href="/blog-two/陈天rust编程第一课/04.期中周/01"><span>加餐｜期中测试：来写一个简单的grep命令行</span></a></li><li><a href="/blog-two/陈天rust编程第一课/04.期中周/02"><span>加餐｜期中测试：参考实现讲解</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课/05.进阶篇">05.进阶篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/01"><span>23｜类型系统：如何在实战中使用泛型编程？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/02"><span>24｜类型系统：如何在实战中使用trait object？</span></a></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课/05.进阶篇/03"><span>25｜类型系统：如何围绕trait来设计和架构系统？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/04"><span>加餐｜Rust2021版次问世了！</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/05"><span>26｜阶段实操（3）：构建一个简单的KV server-高级trait技巧</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/06"><span>27｜生态系统：有哪些常有的Rust库可以为我所用？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/07"><span>28｜网络开发（上）：如何使用Rust处理网络请求？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/08"><span>29｜网络开发（下）：如何使用Rust处理网络请求？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/09"><span>30｜Unsafe Rust：如何用C++的方式打开Rust？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/10"><span>31｜FFI：Rust如何和你的语言架起沟通桥梁？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/11"><span>32｜实操项目：使用PyO3开发Python3模块</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇">06.并发篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/01"><span>33｜并发处理（上）：从atomics到Channel，Rust都提供了什么工具？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/02"><span>34｜并发处理（下）：从atomics到Channel，Rust都提供了什么工具？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/03"><span>35｜实操项目：如何实现一个基本的MPSC channel？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/04"><span>用户故事｜绝望之谷：改变从学习开始</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/05"><span>36｜阶段实操（4）：构建一个简单的KV server-网络处理</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/06"><span>37｜阶段实操（5）：构建一个简单的KV server-网络安全</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/07"><span>38｜异步处理：Future是什么？它和async/await是什么关系？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/08"><span>39｜异步处理：async/await内部是怎么实现的？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/09"><span>40｜异步处理：如何处理异步IO？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/10"><span>41｜阶段实操（6）：构建一个简单的KV server-异步处理</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/11"><span>42｜阶段实操（7）：构建一个简单的KV server-如何做大的重构？</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇">07.实战篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/01"><span>43｜生产环境：真实世界下的一个Rust项目包含哪些要素？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/02"><span>44｜数据处理：应用程序和数据如何打交道？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/03"><span>45｜阶段实操（8）：构建一个简单的KV server-配置/测试/监控/CI/CD</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/04"><span>46｜软件架构：如何用Rust架构复杂系统？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/05"><span>大咖助场｜开悟之坡（上）：Rust的现状、机遇与挑战</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/06"><span>大咖助场｜开悟之坡（下）：Rust的现状、机遇与挑战</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/07"><span>用户故事｜语言不仅是工具，还是思维方式</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/08.高级篇">08.高级篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/08.高级篇/01"><span>加餐｜代码即数据：为什么我们需要宏编程能力？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/08.高级篇/02"><span>加餐｜宏编程（上）：用最“笨”的方式撰写宏</span></a></li><li><a href="/blog-two/陈天rust编程第一课/08.高级篇/03"><span>加餐｜宏编程（下）：用 syn/quote 优雅地构建宏</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/09.结束语">09.结束语</a><ul><li><a href="/blog-two/陈天rust编程第一课/09.结束语/01"><span>结束语｜永续之原：Rust学习，如何持续精进？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/09.结束语/02"><span>期末测试｜来赴一场满分之约！</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊">10.学习锦囊</a><ul><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊/01"><span>特别策划｜学习锦囊（一）：听听课代表们怎么说</span></a></li><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊/02"><span>特别策划｜学习锦囊（二）：听听课代表们怎么说</span></a></li><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊/03"><span>特别策划｜学习锦囊（三）：听听课代表们怎么说</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/summary">陈天rust编程第一课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="用 trait 让代码自然舒服好用" data-depth="2"><a href="/blog-two/陈天rust编程第一课/05.进阶篇/03#用-trait-让代码自然舒服好用"><span>用 trait 让代码自然舒服好用</span></a></li><li title="用 trait 做桥接" data-depth="2"><a href="/blog-two/陈天rust编程第一课/05.进阶篇/03#用-trait-做桥接"><span>用 trait 做桥接</span></a></li><li title="使用 trait 提供控制反转" data-depth="2"><a href="/blog-two/陈天rust编程第一课/05.进阶篇/03#使用-trait-提供控制反转"><span>使用 trait 提供控制反转</span></a></li><li title="用 trait 实现 SOLID 原则" data-depth="2"><a href="/blog-two/陈天rust编程第一课/05.进阶篇/03#用-trait-实现-solid-原则"><span>用 trait 实现 SOLID 原则</span></a></li><li title="小结" data-depth="2"><a href="/blog-two/陈天rust编程第一课/05.进阶篇/03#小结"><span>小结</span></a></li><li title="思考题" data-depth="3"><a href="/blog-two/陈天rust编程第一课/05.进阶篇/03#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="25类型系统如何围绕trait来设计和架构系统"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/05.进阶篇/03#25类型系统如何围绕trait来设计和架构系统"><span class="icon icon-link"></span></a>25｜类型系统：如何围绕trait来设计和架构系统？</h1><p>你好，我是陈天。</p><p>Trait，trait，trait，怎么又是 trait？how old are you?</p><p>希望你还没有厌倦我们没完没了地聊关于 trait 的话题。因为 trait 在 Rust 开发中的地位，怎么吹都不为过。</p><p>其实不光是 Rust 中的 trait，任何一门语言，和接口处理相关的概念，都是那门语言在使用过程中最重要的概念。<strong>软件开发的整个行为，基本上可以说是不断创建和迭代接口，然后在这些接口上进行实现的过程</strong>。</p><p>在这个过程中，有些接口是标准化的，雷打不动，就像钢筋、砖瓦、螺丝、钉子、插座等这些材料一样，无论要构筑的房子是什么样子的，这些标准组件的接口在确定下来后，都不会改变，它们就像 Rust 语言标准库中的标准 trait 一样。</p><p>而有些接口是跟构造的房子息息相关的，比如门窗、电器、家具等，它们就像你要设计的系统中的 trait 一样，可以把系统的各个部分联结起来，最终呈现给用户一个完整的使用体验。</p><p>之前讲了trait 的基础知识，也介绍了如何在实战中使用 trait 和 trait object。今天，我们再花一讲的时间，来看看如何围绕着 trait 来设计和架构系统。</p><p>由于在讲架构和设计时，不免要引入需求，然后我需要解释这需求的来龙去脉，再提供设计思路，再介绍 trait 在其中的作用，但这样下来，一堂课的内容能讲好一个系统设计就不错了。所以我们换个方式，把之前设计过的系统捋一下，重温它们的 trait 设计，看看其中的思路以及取舍。</p><h2 id="用-trait-让代码自然舒服好用"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/05.进阶篇/03#用-trait-让代码自然舒服好用"><span class="icon icon-link"></span></a>用 trait 让代码自然舒服好用</h2><p>在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/413634">第 5 讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，thumbor 的项目里，我设计了一个 SpecTransform trait，通过它可以统一处理任意类型的、描述我们希望如何处理图片的 spec：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 一个 spec 可以包含上述的处理方式之一（这是 protobuf 定义）</span></div><div class="token-line"><span class="token plain">    message Spec {</span></div><div class="token-line"><span class="token plain">      oneof data {</span></div><div class="token-line"><span class="token plain">        Resize resize = 1;</span></div><div class="token-line"><span class="token plain">        Crop crop = 2;</span></div><div class="token-line"><span class="token plain">        Flipv flipv = 3;</span></div><div class="token-line"><span class="token plain">        Fliph fliph = 4;</span></div><div class="token-line"><span class="token plain">        Contrast contrast = 5;</span></div><div class="token-line"><span class="token plain">        Filter filter = 6;</span></div><div class="token-line"><span class="token plain">        Watermark watermark = 7;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>SpecTransform trait 的定义如下（<a target="_blank" rel="noopener noreferrer" href="https://github.com/tyrchen/geektime-rust/blob/master/05_thumbor/src/engine/mod.rs#L16">代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// SpecTransform：未来如果添加更多的 spec，只需要实现它即可</span></div><div class="token-line"><span class="token plain">    pub trait SpecTransform&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        // 对图片使用 op 做 transform</span></div><div class="token-line"><span class="token plain">        fn transform(&amp;mut self, op: T);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>它可以用来对图片使用某个 spec 进行处理。</p><p>但如果你阅读 GitHub 上的源码，你可能会发现一个没用到的文件 <a target="_blank" rel="noopener noreferrer" href="http://imageproc.rs/">imageproc.rs<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中类似的 trait（<a target="_blank" rel="noopener noreferrer" href="https://github.com/tyrchen/geektime-rust/blob/master/05_thumbor/src/imageproc.rs#L41">代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pub trait ImageTransform {</span></div><div class="token-line"><span class="token plain">        fn transform(&amp;self, image: &amp;mut PhotonImage);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个 trait 是第一版的 trait。我依旧保留着它，就是想在此展示一下 trait 设计上的取舍。</p><p>当你审视这段代码的时候会不会觉得，这个 trait 的设计有些草率？因为如果传入的 image 来自不同的图片处理引擎，而某个图片引擎提供的 image 类型不是 PhotonImage，那这个接口不就无法使用了么？</p><p>hmm，这是个设计上的大问题啊。想想看，以目前所学的知识，怎么解决这个问题呢？什么可以帮助我们延迟 image 是否必须是 PhotonImage 的决策呢？</p><p>对，泛型。我们可以使用泛型 trait 修改一下刚才那段代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 使用 trait 可以统一处理的接口，以后无论增加多少功能，只需要加新的 Spec，然后实现 ImageTransform 接口</span></div><div class="token-line"><span class="token plain">    pub trait ImageTransform&lt;Image&gt; {</span></div><div class="token-line"><span class="token plain">        fn transform(&amp;self, image: &amp;mut Image);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>把传入的 image 类型抽象成泛型类型之后，延迟了图片类型判断和支持的决策，可用性更高。</p><p>但如果你继续对比现在的 ImageTransform和之前写的 SpecTransform，会发现，它们实现 trait 的数据结构和用在 trait 上的泛型参数，正好掉了个个。</p><p>你看，PhotonImage 下对于 Contrast 的 ImageTransform 的实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">impl ImageTransform&lt;PhotonImage&gt; for Contrast {</span></div><div class="token-line"><span class="token plain">        fn transform(&amp;self, image: &amp;mut Image) {</span></div><div class="token-line"><span class="token plain">            effects::adjust_contrast(image, self.contrast);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>而同样的，PhotonImage 下对 Contract 的 SpecTransform 的实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">impl SpecTransform&lt;&amp;Contrast&gt; for Photon {</span></div><div class="token-line"><span class="token plain">        fn transform(&amp;mut self, op: &amp;Contrast) {</span></div><div class="token-line"><span class="token plain">            effects::adjust_contrast(&amp;mut self.0, op.contrast);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这两种方式基本上等价，但一个围绕着 Spec 展开，一个围绕着 Image 展开：<br/><img src="https://static001.geekbang.org/resource/image/05/93/05052aff8a2204ddba4fd4aee81ce193.jpg?wh=2364x1740" alt=""/></p><p>那么，哪种设计更好呢？</p><p>其实二者并没有功能上或者性能上的优劣。</p><p>那为什么我选择了 SpecTransform 的设计呢？在第一版的设计我还没有考虑 Engine的时候，是以 Spec 为中心的；但在把 Engine 考虑进去后，我以 Engine 为中心重新做了设计，这样做的好处是，开发新的 Engine 的时候，SpecTransform trait 用起来更顺手，更自然一些。</p><p>嗯，顺手，自然。接口的设计一定要关注使用者的体验，一个使用起来感觉自然顺手舒服的接口，就是更好的接口。<strong>因为这意味着使用的时候，代码可以自然而然写出来，而无需看文档</strong>。</p><p>比如同样是 Python 代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">df[df[&quot;age&quot;] &gt; 10]</span></div></pre></div><p>就要比：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">df.filter(df.col(&quot;age&quot;).gt(10))</span></div></pre></div><p>要更加自然舒服。前面的代码，你看一眼别人怎么用，自己就很快能写出来，而后者，你需要先搞清楚 filter 函数是怎么回事，以及col()、gt() 这两个方法如何使用。</p><p>我们再来看来两段 Rust 代码。这行使用了 From/Into trait 的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let url = generate_url_with_spec(image_spec.into());</span></div></pre></div><p>就要比：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let data = image_spec.encode_to_vec();</span></div><div class="token-line"><span class="token plain">    let s = encode_config(data, URL_SAFE_NO_PAD);</span></div><div class="token-line"><span class="token plain">    let url = generate_url_with_spec(s);</span></div></pre></div><p>要简洁、自然得多。它把实现细节都屏蔽了起来，只让用户关心他们需要关心的逻辑。<br/>所以，我们在设计 trait 的时候，除了关注功能，还要注意是否好用、易用。这也是为什么我们在介绍 KV server 的时候，不断强调，trait 在设计结束之后，不要先着急撰写实现 trait 的代码，而是最好先写一些对于 trait 使用的测试代码。</p><p>你在写这些测试代码的使用体验，就是别人在使用你的 trait 构建系统时的真实体验，如果它用起来别扭、啰嗦，不看文档就不容易用对，那这个 trait 本身还有待进一步迭代。</p><h2 id="用-trait-做桥接"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/05.进阶篇/03#用-trait-做桥接"><span class="icon icon-link"></span></a>用 trait 做桥接</h2><p>在软件开发的绝大多数时候，我们都不会从零到一完完全全设计和构建系统的所有部分。就像盖房子，不可能从一抔土、一块瓦片开始打造。我们需要依赖生态系统中已有的组件。</p><p>作为架构师，你的职责是在生态系统中找到合适的组件，连同你自己打造的部分，一起粘合起来，形成一个产品。所以，你会遇到那些接口与你预期不符的组件，可是自己又无法改变那些组件来让接口满足你的预期，怎么办？</p><p>此刻，我们需要桥接。</p><p>就像要用的电器是二相插口，而附近墙上的插座只有三相插口，我们总不能修改电器或者墙上的插座，使其满足对方吧？正确的做法是购置一个多项插座来桥接二者。</p><p>在 Rust 里，桥接的工作可以通过函数来完成，但最好通过 trait 来桥接。继续看<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/413634">第 5 讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> thumbor 里的另一个 trait Engine（<a target="_blank" rel="noopener noreferrer" href="https://github.com/tyrchen/geektime-rust/blob/master/05_thumbor/src/engine/mod.rs#L8">代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Engine trait：未来可以添加更多的 engine，主流程只需要替换 engine</span></div><div class="token-line"><span class="token plain">    pub trait Engine {</span></div><div class="token-line"><span class="token plain">        // 对 engine 按照 specs 进行一系列有序的处理</span></div><div class="token-line"><span class="token plain">        fn apply(&amp;mut self, specs: &amp;[Spec]);</span></div><div class="token-line"><span class="token plain">        // 从 engine 中生成目标图片，注意这里用的是 self，而非 self 的引用</span></div><div class="token-line"><span class="token plain">        fn generate(self, format: ImageOutputFormat) -&gt; Vec&lt;u8&gt;;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>通过 Engine 这个 trait，我们把第三方的库 photon和自己设计的 Image Spec 连接起来，使得我们不用关心 Engine 背后究竟是什么，只需要调用 apply 和 generate 方法即可：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 使用 image engine 处理</span></div><div class="token-line"><span class="token plain">    let mut engine: Photon = data</span></div><div class="token-line"><span class="token plain">        .try_into()</span></div><div class="token-line"><span class="token plain">        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;</span></div><div class="token-line"><span class="token plain">    engine.apply(&amp;spec.specs);</span></div><div class="token-line"><span class="token plain">    let image = engine.generate(ImageOutputFormat::Jpeg(85));</span></div></pre></div><p>这段代码中，由于之前为 Photon 实现了 TryFrom&lt;Bytes&gt;，所以可以直接调用 try_into() 来得到一个 photon engine：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 从 Bytes 转换成 Photon 结构</span></div><div class="token-line"><span class="token plain">    impl TryFrom&lt;Bytes&gt; for Photon {</span></div><div class="token-line"><span class="token plain">        type Error = anyhow::Error;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        fn try_from(data: Bytes) -&gt; Result&lt;Self, Self::Error&gt; {</span></div><div class="token-line"><span class="token plain">            Ok(Self(open_image_from_bytes(&amp;data)?))</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>就桥接 thumbor 代码和 photon crate 而言，Engine 表现良好，它让我们不但很容易使用 photon crate，还可以很方便在未来需要的时候替换掉 photon crate。</p><p>不过，Engine 在构造时，所做的桥接还是不够直观和自然，如果不仔细看代码或者文档，使用者可能并不清楚，第3行代码，如何通过 TryFrom/TryInto 得到一个实现了 Engine 的结构。从这个使用体验来看，我们会希望通过使用 Engine trait，任何一个图片引擎都可以统一地创建 Engine结构。怎么办？</p><p>可以为这个 trait 添加一个缺省的 create 方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Engine trait：未来可以添加更多的 engine，主流程只需要替换 engine</span></div><div class="token-line"><span class="token plain">    pub trait Engine {</span></div><div class="token-line"><span class="token plain">        // 生成一个新的 engine</span></div><div class="token-line"><span class="token plain">        fn create&lt;T&gt;(data: T) -&gt; Result&lt;Self&gt;</span></div><div class="token-line"><span class="token plain">        where</span></div><div class="token-line"><span class="token plain">            Self: Sized,</span></div><div class="token-line"><span class="token plain">            T: TryInto&lt;Self&gt;,</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            data.try_into()</span></div><div class="token-line"><span class="token plain">                .map_err(|_| anyhow!(&quot;failed to create engine&quot;))</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        // 对 engine 按照 specs 进行一系列有序的处理</span></div><div class="token-line"><span class="token plain">        fn apply(&amp;mut self, specs: &amp;[Spec]);</span></div><div class="token-line"><span class="token plain">        // 从 engine 中生成目标图片，注意这里用的是 self，而非 self 的引用</span></div><div class="token-line"><span class="token plain">        fn generate(self, format: ImageOutputFormat) -&gt; Vec&lt;u8&gt;;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>注意看新 create 方法的约束：任何 T，只要实现了相应的 TryFrom/TryInto，就可以用这个缺省的 create() 方法来构造 Engine。</p><p>有了这个接口后，上面使用 engine 的代码可以更加直观，省掉了第3行的try_into()处理：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 使用 image engine 处理</span></div><div class="token-line"><span class="token plain">    let mut engine = Photon::create(data)</span></div><div class="token-line"><span class="token plain">        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;</span></div><div class="token-line"><span class="token plain">    engine.apply(&amp;spec.specs);</span></div><div class="token-line"><span class="token plain">    let image = engine.generate(ImageOutputFormat::Jpeg(85));</span></div></pre></div><p>桥接是架构中一个非常重要的思想，我们一定要掌握这个思想的精髓。</p><p>再举个例子。比如现在想要系统可以通过访问某个 REST API，得到用户自己发布的、按时间顺序倒排的朋友圈。怎么写这段代码呢？最简单粗暴的方式是：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let secret_api = api_with_user_token(&amp;user, params);</span></div><div class="token-line"><span class="token plain">    let data: Vec&lt;Status&gt; = reqwest::get(secret_api)?.json()?;</span></div></pre></div><p>更好的方式是使用 trait 桥接来屏蔽实现细节：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pub trait FriendCircle {</span></div><div class="token-line"><span class="token plain">    	  fn get_published(&amp;self, user: &amp;User) -&gt; Result&lt;Vec&lt;Status&gt;, FriendCircleError&gt;;</span></div><div class="token-line"><span class="token plain">        ... </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这样，我们的业务逻辑代码可以围绕着这个接口展开，而无需关心它具体的实现是来自 REST API，还是其它什么地方；也不用关心实现做没做 cache、有没有重传机制、具体都会返回什么样的错误（FriendCircleError 就已经提供了所有的出错可能）等等。</p><h2 id="使用-trait-提供控制反转"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/05.进阶篇/03#使用-trait-提供控制反转"><span class="icon icon-link"></span></a>使用 trait 提供控制反转</h2><p>继续看刚才的Engine 代码，在 Engine 和 T 之间通过 TryInto trait 进行了解耦，使得调用者可以灵活处理他们的 T：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pub trait Engine {</span></div><div class="token-line"><span class="token plain">        // 生成一个新的 engine</span></div><div class="token-line"><span class="token plain">        fn create&lt;T&gt;(data: T) -&gt; Result&lt;Self&gt;</span></div><div class="token-line"><span class="token plain">        where</span></div><div class="token-line"><span class="token plain">            Self: Sized,</span></div><div class="token-line"><span class="token plain">            T: TryInto&lt;Self&gt;,</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            data.try_into()</span></div><div class="token-line"><span class="token plain">                .map_err(|_| anyhow!(&quot;failed to create engine&quot;))</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里还体现了trait 在设计中，另一个很重要的作用，控制反转。</p><p>通过使用 trait，我们可以在设计底层库的时候告诉上层：<strong>我需要某个满足 trait X 的数据，因为我依赖这个数据实现的 trait X 方法来完成某些功能，但这个数据具体怎么实现，我不知道，也不关心</strong>。</p><p>刚才为 Engine 新构建的 create 方法。T 是实现 Engine 所需要的依赖，我们不知道属于类型 T 的 data 是如何在上下文中产生的，也不关心 T 具体是什么，只要 T 实现了 TryInto&lt;Self&gt; 即可。这就是典型的控制反转。</p><p>使用 trait 做控制反转另一个例子是<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/414478">第 6 讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中的 <a target="_blank" rel="noopener noreferrer" href="https://docs.rs/sqlparser/0.12.0/sqlparser/dialect/trait.Dialect.html">Dialect trait<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（<a target="_blank" rel="noopener noreferrer" href="https://docs.rs/sqlparser/0.12.0/src/sqlparser/dialect/mod.rs.html#43-56">代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pub trait Dialect: Debug + Any {</span></div><div class="token-line"><span class="token plain">        /// Determine if a character starts a quoted identifier. The default</span></div><div class="token-line"><span class="token plain">        /// implementation, accepting &quot;double quoted&quot; ids is both ANSI-compliant</span></div><div class="token-line"><span class="token plain">        /// and appropriate for most dialects (with the notable exception of</span></div><div class="token-line"><span class="token plain">        /// MySQL, MS SQL, and sqlite). You can accept one of characters listed</span></div><div class="token-line"><span class="token plain">        /// in `Word::matching_end_quote` here</span></div><div class="token-line"><span class="token plain">        fn is_delimited_identifier_start(&amp;self, ch: char) -&gt; bool {</span></div><div class="token-line"><span class="token plain">            ch == &#x27;&quot;&#x27;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        /// Determine if a character is a valid start character for an unquoted identifier</span></div><div class="token-line"><span class="token plain">        fn is_identifier_start(&amp;self, ch: char) -&gt; bool;</span></div><div class="token-line"><span class="token plain">        /// Determine if a character is a valid unquoted identifier character</span></div><div class="token-line"><span class="token plain">        fn is_identifier_part(&amp;self, ch: char) -&gt; bool;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们只需要为自己的 SQL 方言实现 Dialect trait：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 创建自己的 sql 方言。TyrDialect 支持 identifier 可以是简单的 url</span></div><div class="token-line"><span class="token plain">    impl Dialect for TyrDialect {</span></div><div class="token-line"><span class="token plain">        fn is_identifier_start(&amp;self, ch: char) -&gt; bool {</span></div><div class="token-line"><span class="token plain">            (&#x27;a&#x27;..=&#x27;z&#x27;).contains(&amp;ch) || (&#x27;A&#x27;..=&#x27;Z&#x27;).contains(&amp;ch) || ch == &#x27;_&#x27;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // identifier 可以有 &#x27;:&#x27;, &#x27;/&#x27;, &#x27;?&#x27;, &#x27;&amp;&#x27;, &#x27;=&#x27;</span></div><div class="token-line"><span class="token plain">        fn is_identifier_part(&amp;self, ch: char) -&gt; bool {</span></div><div class="token-line"><span class="token plain">            (&#x27;a&#x27;..=&#x27;z&#x27;).contains(&amp;ch)</span></div><div class="token-line"><span class="token plain">                || (&#x27;A&#x27;..=&#x27;Z&#x27;).contains(&amp;ch)</span></div><div class="token-line"><span class="token plain">                || (&#x27;0&#x27;..=&#x27;9&#x27;).contains(&amp;ch)</span></div><div class="token-line"><span class="token plain">                || [&#x27;:&#x27;, &#x27;/&#x27;, &#x27;?&#x27;, &#x27;&amp;&#x27;, &#x27;=&#x27;, &#x27;-&#x27;, &#x27;_&#x27;, &#x27;.&#x27;].contains(&amp;ch)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>就可以让 sql parser 解析我们的 SQL 方言：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let ast = Parser::parse_sql(&amp;TyrDialect::default(), sql.as_ref())?;</span></div></pre></div><p>这就是 Dialect 这个看似简单的 trait 的强大用途。</p><p>对于我们这些使用者来说，通过Dialect trait，可以很方便地注入自己的解析函数，来提供我们的 SQL 方言的额外信息；对于 sqlparser 这个库的作者来说，通过 Dialect trait，他不必关心未来会有多少方言、每个方言长什么样子，只需要方言的作者告诉他如何 tokenize 一个标识符即可。</p><p>控制反转是架构中经常使用到的功能，它能够<strong>让调用者和被调用者之间的关系在某个时刻调转过来，被调用者反过来调用调用者提供的能力，二者协同完成一些事情</strong>。</p><p>比如 MapReduce 的架构：用于 map 的方法和用于 reduce 的方法是啥，MapReduce 的架构设计者并不清楚，但调用者可以把这些方法提供给 MapReduce 架构，由 MapReduce 架构在合适的时候进行调用。</p><p>当然，控制反转并非只能由 trait 来完成，但使用 trait 做控制反转会非常灵活，调用者和被调用者只需要关心它们之间的接口，而非具体的数据结构。</p><h2 id="用-trait-实现-solid-原则"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/05.进阶篇/03#用-trait-实现-solid-原则"><span class="icon icon-link"></span></a>用 trait 实现 SOLID 原则</h2><p>其实刚才介绍的用 trait 做控制反转，核心体现的就是面向对象设计时SOLID原则中的，依赖反转原则DIP，这是一个很重要的构建灵活系统的思想。</p><p>在做面向对象设计时，我们经常会探讨 <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/SOLID">SOLID 原则<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：</p><ul><li>SRP：单一职责原则，是指每个模块应该只负责单一的功能，不应该让多个功能耦合在一起，而是应该将其组合在一起。</li><li>OCP：开闭原则，是指软件系统应该对修改关闭，而对扩展开放。</li><li>LSP：里氏替换原则，是指如果组件可替换，那么这些可替换的组件应该遵守相同的约束，或者说接口。</li><li>ISP：接口隔离原则，是指使用者只需要知道他们感兴趣的方法，而不该被迫了解和使用对他们来说无用的方法或者功能。</li><li>DIP：依赖反转原则，是指某些场合下底层代码应该依赖高层代码，而非高层代码去依赖底层代码。</li></ul><p>虽然 Rust 不是一门面向对象语言，但这些思想都是通用的。</p><p>在过去的课程中，我一直强调 SRP 和 OCP。你看<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/414478">第 6 讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的 Fetch / Load trait，它们都只负责一个很简单的动作：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#[async_trait]</span></div><div class="token-line"><span class="token plain">    pub trait Fetch {</span></div><div class="token-line"><span class="token plain">        type Error;</span></div><div class="token-line"><span class="token plain">        async fn fetch(&amp;self) -&gt; Result&lt;String, Self::Error&gt;;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    pub trait Load {</span></div><div class="token-line"><span class="token plain">        type Error;</span></div><div class="token-line"><span class="token plain">        fn load(self) -&gt; Result&lt;DataSet, Self::Error&gt;;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>以 Fetch 为例，我们先实现了 UrlFetcher，后来又根据需要，实现了 FileFetcher。</p><p>FileFetcher 的实现并不会对 UrlFetcher 的实现代码有任何影响，也就是说，在实现 FileFetcher 的时候，已有的所有实现了 Fetch 接口的代码都是稳定的，它们对修改是关闭的；同时，在实现 FileFetcher 的时候，我们扩展了系统的能力，使系统可以根据不同的前缀（<code>from file://</code> 或者 <code>from &lt;http://</code>&gt;）进行不同的处理，这是对扩展开放。</p><p>前面提到的 SpecTransform / Engine trait，包括 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/425001">21 讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中 KV server 里涉及的 CommandService trait：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/// 对 Command 的处理的抽象</span></div><div class="token-line"><span class="token plain">    pub trait CommandService {</span></div><div class="token-line"><span class="token plain">        /// 处理 Command，返回 Response</span></div><div class="token-line"><span class="token plain">        fn execute(self, store: &amp;impl Storage) -&gt; CommandResponse;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>也是 SRP 和 OCP 原则的践行者。</p><p>LSP 里氏替换原则自不必说，我们本文中所有的内容都在践行通过使用接口，来使组件可替换。比如上文提到的 Engine trait，在 KV server 中我们使用的 Storage trait，都允许我们在不改变代码核心逻辑的前提下，替换其中的主要组件。</p><p>至于 ISP 接口隔离原则，我们目前撰写的 trait 都很简单，天然满足接口隔离原则。其实，大部分时候，当你的 trait 满足 SRP 单一职责原则时，它也满足接口隔离原则。</p><p>但在 Rust 中，有些 trait 的接口可能会比较庞杂，<strong>此时，如果我们想减轻调用者的负担，让它们能够在需要的时候才引入某些接口，可以使用 trait 的继承</strong>。比如 AsyncRead / AsyncWrite / Stream 和它们对应的 AsyncReadExt / AsyncWriteExt / StreamExt 等。这样，复杂的接口被不同的 trait 分担了并隔离开。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/05.进阶篇/03#小结"><span class="icon icon-link"></span></a>小结</h2><p>接口设计是架构设计中最核心的环节。<strong>好的接口容易使用，很难误用，会让使用接口的人产生共鸣</strong>。当我们说一段代码读起来/写起来感觉很舒服，或者很不舒服、很冗长、很难看，这种感觉往往就来自于接口给人的感觉，我们可以妥善使用 trait 来降低甚至消除这种不舒服的感觉。</p><p>当我们的代码和其他人的代码共存时，接口在不同的组件之间就起到了桥接的作用。通过桥接，甚至可以把原本设计不好的代码，先用接口封装成我们希望的样子，然后实现这个简单的包装，之后再慢慢改动原先不好的设计。</p><p>这样，由于系统的其它部分使用新的接口处理，未来改动的影响被控制在很小的范围。在第 5 讲设计 thumbor 的时候我也提到，photon 库并不是一个设计良好的库，然而，通过 Engine trait 的桥接，未来即使我们 fork 一下 photon 库，对其大改，并不会影响 thumbor 的代码。</p><p>最后，在软件设计时，我们还要注意 SOLID 原则。基本上，<strong>好的 trait，设计一定是符合 SOLID 原则的</strong>，从 Rust 标准库的设计，以及之前讲到的 trait，结合今天的解读，想必你对此有了一定的认识。未来在使用 trait 构建你自己的接口时，你也可以将 SOLID 原则作为一个备忘清单，随时检查。</p><h3 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/05.进阶篇/03#思考题"><span class="icon icon-link"></span></a>思考题</h3><p>Rust 下有一个处理 Web 前端的库叫 <a target="_blank" rel="noopener noreferrer" href="https://github.com/yewstack/yew">yew<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。请 clone 到你本地，然后使用 ag 或者 rgrep（eat our own dogfood）查找一下所有的 trait 定义，看看这些 trait 被设计的目的和意义，并且着重阅读一下它最核心的 Component trait，思考几个问题：</p><ol><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Component trait 可以做 trait object 么？</span></div></pre></div></li><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">关联类型 Message 和 Properties 的作用是什么？</span></div></pre></div></li><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">作为使用者，该如何用 Component trait？它的 lifecycle 是什么样子的？</span></div></pre></div></li><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">如果你之前有前端开发的经验，比较一下 React / Vue / Elm component 和 yew component 的区别？</span></div></pre></div></li></ol><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">yew on  master via 🦀 v1.55.0</span></div><div class="token-line"><span class="token plain">    ❯ rgrep &quot;pub trait&quot; &quot;**/*.rs&quot;</span></div><div class="token-line"><span class="token plain">    examples/router/src/generator.rs</span></div><div class="token-line"><span class="token plain">       155:1   pub trait Generated: Sized {</span></div><div class="token-line"><span class="token plain">    packages/yew/src/html/component/mod.rs</span></div><div class="token-line"><span class="token plain">        42:1   pub trait Component: Sized + &#x27;static {</span></div><div class="token-line"><span class="token plain">    packages/yew/src/html/component/properties.rs</span></div><div class="token-line"><span class="token plain">         6:1   pub trait Properties: PartialEq {</span></div><div class="token-line"><span class="token plain">    examples/boids/src/math.rs</span></div><div class="token-line"><span class="token plain">       128:1   pub trait WeightedMean&lt;T = Self&gt;: Sized {</span></div><div class="token-line"><span class="token plain">       152:1   pub trait Mean&lt;T = Self&gt;: Sized {</span></div><div class="token-line"><span class="token plain">    packages/yew/src/functional/mod.rs</span></div><div class="token-line"><span class="token plain">        69:1   pub trait FunctionProvider {</span></div><div class="token-line"><span class="token plain">    packages/yew/src/html/conversion.rs</span></div><div class="token-line"><span class="token plain">         5:1   pub trait ImplicitClone: Clone {}</span></div><div class="token-line"><span class="token plain">        18:1   pub trait IntoPropValue&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">    packages/yew/src/html/listener/mod.rs</span></div><div class="token-line"><span class="token plain">        27:1   pub trait TargetCast</span></div><div class="token-line"><span class="token plain">       136:1   pub trait IntoEventCallback&lt;EVENT&gt; {</span></div><div class="token-line"><span class="token plain">    packages/yew/src/scheduler.rs</span></div><div class="token-line"><span class="token plain">        11:1   pub trait Runnable {</span></div><div class="token-line"><span class="token plain">    packages/yew-router/src/routable.rs</span></div><div class="token-line"><span class="token plain">        16:1   pub trait Routable: Sized + Clone {</span></div><div class="token-line"><span class="token plain">    packages/yew-agent/src/pool.rs</span></div><div class="token-line"><span class="token plain">        60:1   pub trait Dispatched: Agent + Sized + &#x27;static {</span></div><div class="token-line"><span class="token plain">        78:1   pub trait Dispatchable {}</span></div><div class="token-line"><span class="token plain">    packages/yew/src/html/component/scope.rs</span></div><div class="token-line"><span class="token plain">       508:1   pub trait SendAsMessage&lt;COMP: Component&gt; {</span></div><div class="token-line"><span class="token plain">    packages/yew-macro/src/stringify.rs</span></div><div class="token-line"><span class="token plain">        16:1   pub trait Stringify {</span></div><div class="token-line"><span class="token plain">    packages/yew-agent/src/lib.rs</span></div><div class="token-line"><span class="token plain">        22:1   pub trait Agent: Sized + &#x27;static {</span></div><div class="token-line"><span class="token plain">        82:1   pub trait Discoverer {</span></div><div class="token-line"><span class="token plain">        92:1   pub trait Bridge&lt;AGN: Agent&gt; {</span></div><div class="token-line"><span class="token plain">        98:1   pub trait Bridged: Agent + Sized + &#x27;static {</span></div><div class="token-line"><span class="token plain">    packages/yew-agent/src/utils/store.rs</span></div><div class="token-line"><span class="token plain">        20:1   pub trait Store: Sized + &#x27;static {</span></div><div class="token-line"><span class="token plain">       138:1   pub trait Bridgeable: Sized + &#x27;static {</span></div><div class="token-line"><span class="token plain">    packages/yew-macro/src/html_tree/mod.rs</span></div><div class="token-line"><span class="token plain">       178:1   pub trait ToNodeIterator {</span></div><div class="token-line"><span class="token plain">    packages/yew/src/virtual_dom/listeners.rs</span></div><div class="token-line"><span class="token plain">        42:1   pub trait Listener {</span></div><div class="token-line"><span class="token plain">    packages/yew-agent/src/worker/mod.rs</span></div><div class="token-line"><span class="token plain">        17:1   pub trait Threaded {</span></div><div class="token-line"><span class="token plain">        24:1   pub trait Packed {</span></div></pre></div><p>感谢你的阅读，如果你觉得有收获，也欢迎你分享给身边的朋友，邀他一起讨论。今天你已经完成Rust学习的第25次打卡啦，我们下节课见！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/陈天rust编程第一课/05.进阶篇/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:25</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
