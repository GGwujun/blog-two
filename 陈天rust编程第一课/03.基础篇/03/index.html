<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>05｜get hands dirty：做一个图片服务器有多难？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/陈天rust编程第一课/03.基础篇/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/陈天rust编程第一课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-two/陈天rust编程第一课/01.开篇词/01"><span>开篇词｜让Rust成为你的下一门主力语言</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/02.前置篇">02.前置篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/02.前置篇/01"><span>01｜内存：值放堆上还是放栈上，这是一个问题</span></a></li><li><a href="/blog-two/陈天rust编程第一课/02.前置篇/02"><span>02｜串讲：编程开发中，那些你需要掌握的基本概念</span></a></li><li><a href="/blog-two/陈天rust编程第一课/02.前置篇/03"><span>加餐｜这个专栏你可以怎么学，以及Rust是否值得学？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课/03.基础篇">03.基础篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/01"><span>03｜初窥门径：从你的第一个Rust程序开始！</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/02"><span>04｜get hands dirty：来写个实用的CLI小工具</span></a></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课/03.基础篇/03"><span>05｜get hands dirty：做一个图片服务器有多难？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/04"><span>06｜get hands dirty：SQL查询工具怎么一鱼多吃？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/05"><span>07｜所有权：值的生杀大权到底在谁手上？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/06"><span>08｜所有权：值的借用是如何工作的？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/07"><span>09｜所有权：一个值可以有多个所有者么？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/08"><span>10｜生命周期：你创建的值究竟能活多久？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/09"><span>11｜内存管理：从创建到消亡，值都经历了什么？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/10"><span>加餐｜愚昧之巅：你的Rust学习常见问题汇总</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/11"><span>12｜类型系统：Rust的类型系统有什么特点？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/12"><span>13｜类型系统：如何使用trait来定义接口？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/13"><span>14｜类型系统：有哪些必须掌握的trait？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/14"><span>15｜数据结构：这些浓眉大眼的结构竟然都是智能指针？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/15"><span>16｜数据结构：Vec、&amp;[T]、Box&lt;[T]&gt; ，你真的了解集合容器么？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/16"><span>17｜数据结构：软件系统核心部件哈希表，内存如何布局？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/17"><span>18｜错误处理：为什么Rust的错误处理与众不同？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/18"><span>19｜闭包：FnOnce、FnMut和Fn，为什么有这么多类型？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/19"><span>20｜4 Steps ：如何更好地阅读Rust源码？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/20"><span>21｜阶段实操（1）：构建一个简单的KV server-基本流程</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/21"><span>22｜阶段实操（2）：构建一个简单的KV server-基本流程</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/04.期中周">04.期中周</a><ul><li><a href="/blog-two/陈天rust编程第一课/04.期中周/01"><span>加餐｜期中测试：来写一个简单的grep命令行</span></a></li><li><a href="/blog-two/陈天rust编程第一课/04.期中周/02"><span>加餐｜期中测试：参考实现讲解</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇">05.进阶篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/01"><span>23｜类型系统：如何在实战中使用泛型编程？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/02"><span>24｜类型系统：如何在实战中使用trait object？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/03"><span>25｜类型系统：如何围绕trait来设计和架构系统？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/04"><span>加餐｜Rust2021版次问世了！</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/05"><span>26｜阶段实操（3）：构建一个简单的KV server-高级trait技巧</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/06"><span>27｜生态系统：有哪些常有的Rust库可以为我所用？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/07"><span>28｜网络开发（上）：如何使用Rust处理网络请求？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/08"><span>29｜网络开发（下）：如何使用Rust处理网络请求？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/09"><span>30｜Unsafe Rust：如何用C++的方式打开Rust？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/10"><span>31｜FFI：Rust如何和你的语言架起沟通桥梁？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/11"><span>32｜实操项目：使用PyO3开发Python3模块</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇">06.并发篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/01"><span>33｜并发处理（上）：从atomics到Channel，Rust都提供了什么工具？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/02"><span>34｜并发处理（下）：从atomics到Channel，Rust都提供了什么工具？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/03"><span>35｜实操项目：如何实现一个基本的MPSC channel？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/04"><span>用户故事｜绝望之谷：改变从学习开始</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/05"><span>36｜阶段实操（4）：构建一个简单的KV server-网络处理</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/06"><span>37｜阶段实操（5）：构建一个简单的KV server-网络安全</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/07"><span>38｜异步处理：Future是什么？它和async/await是什么关系？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/08"><span>39｜异步处理：async/await内部是怎么实现的？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/09"><span>40｜异步处理：如何处理异步IO？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/10"><span>41｜阶段实操（6）：构建一个简单的KV server-异步处理</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/11"><span>42｜阶段实操（7）：构建一个简单的KV server-如何做大的重构？</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇">07.实战篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/01"><span>43｜生产环境：真实世界下的一个Rust项目包含哪些要素？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/02"><span>44｜数据处理：应用程序和数据如何打交道？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/03"><span>45｜阶段实操（8）：构建一个简单的KV server-配置/测试/监控/CI/CD</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/04"><span>46｜软件架构：如何用Rust架构复杂系统？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/05"><span>大咖助场｜开悟之坡（上）：Rust的现状、机遇与挑战</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/06"><span>大咖助场｜开悟之坡（下）：Rust的现状、机遇与挑战</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/07"><span>用户故事｜语言不仅是工具，还是思维方式</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/08.高级篇">08.高级篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/08.高级篇/01"><span>加餐｜代码即数据：为什么我们需要宏编程能力？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/08.高级篇/02"><span>加餐｜宏编程（上）：用最“笨”的方式撰写宏</span></a></li><li><a href="/blog-two/陈天rust编程第一课/08.高级篇/03"><span>加餐｜宏编程（下）：用 syn/quote 优雅地构建宏</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/09.结束语">09.结束语</a><ul><li><a href="/blog-two/陈天rust编程第一课/09.结束语/01"><span>结束语｜永续之原：Rust学习，如何持续精进？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/09.结束语/02"><span>期末测试｜来赴一场满分之约！</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊">10.学习锦囊</a><ul><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊/01"><span>特别策划｜学习锦囊（一）：听听课代表们怎么说</span></a></li><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊/02"><span>特别策划｜学习锦囊（二）：听听课代表们怎么说</span></a></li><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊/03"><span>特别策划｜学习锦囊（三）：听听课代表们怎么说</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/summary">陈天rust编程第一课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="Thumbor" data-depth="2"><a href="/blog-two/陈天rust编程第一课/03.基础篇/03#thumbor"><span>Thumbor</span></a></li><li title="设计分析" data-depth="3"><a href="/blog-two/陈天rust编程第一课/03.基础篇/03#设计分析"><span>设计分析</span></a></li><li title="protobuf 的定义和编译" data-depth="3"><a href="/blog-two/陈天rust编程第一课/03.基础篇/03#protobuf-的定义和编译"><span>protobuf 的定义和编译</span></a></li><li title="引入 HTTP 服务器" data-depth="3"><a href="/blog-two/陈天rust编程第一课/03.基础篇/03#引入-http-服务器"><span>引入 HTTP 服务器</span></a></li><li title="获取源图并缓存" data-depth="3"><a href="/blog-two/陈天rust编程第一课/03.基础篇/03#获取源图并缓存"><span>获取源图并缓存</span></a></li><li title="图片处理" data-depth="3"><a href="/blog-two/陈天rust编程第一课/03.基础篇/03#图片处理"><span>图片处理</span></a></li><li title="小结" data-depth="2"><a href="/blog-two/陈天rust编程第一课/03.基础篇/03#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-two/陈天rust编程第一课/03.基础篇/03#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="05get-hands-dirty做一个图片服务器有多难"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/03#05get-hands-dirty做一个图片服务器有多难"><span class="icon icon-link"></span></a>05｜get hands dirty：做一个图片服务器有多难？</h1><p>你好，我是陈天。</p><p>上一讲我们只用了百来行代码就写出了 HTTPie 这个小工具，你是不是有点意犹未尽，今天我们就来再写一个实用的小例子，看看Rust还能怎么玩。</p><p>再说明一下，代码看不太懂完全没有关系，先不要强求理解，跟着我的节奏一行行写就好，<strong>先让自己的代码跑起来，感受 Rust 和自己常用语言的区别，看看代码风格是什么样的，就可以了</strong>。</p><p>今天的例子是我们在工作中都会遇到的需求：构建一个 Web Server，对外提供某种服务。类似上一讲的 HTTPie ，我们继续找一个已有的开源工具用 Rust 来重写，但是今天来挑战一个稍大一点的项目：构建一个类似 <a target="_blank" rel="noopener noreferrer" href="https://github.com/thumbor/thumbor">Thumbor<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的图片服务器。</p><h2 id="thumbor"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/03#thumbor"><span class="icon icon-link"></span></a>Thumbor</h2><p>Thumbor 是 Python 下的一个非常著名的图片服务器，被广泛应用在各种需要动态调整图片尺寸的场合里。</p><p>它可以通过一个很简单的 HTTP 接口，实现图片的动态剪切和大小调整，另外还支持文件存储、替换处理引擎等其他辅助功能。我在之前的创业项目中还用过它，非常实用，性能也还不错。</p><p>我们看它的例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">http://&lt;thumbor-server&gt;/300x200/smart/thumbor.readthedocs.io/en/latest/_images/logo-thumbor.png</span></div></pre></div><p>在这个例子里，Thumbor 可以对这个图片最后的 URL 使用 smart crop 剪切，并调整大小为 300x200 的尺寸输出，用户访问这个 URL 会得到一个 300x200 大小的缩略图。</p><p><strong>我们今天就来实现它最核心的功能，对图片进行动态转换</strong>。你可以想一想，如果用你最熟悉的语言，要实现这个服务，怎么设计，需要用到些什么库，大概用多少行代码？如果用 Rust 的话，又大概会多少行代码？</p><p>带着你自己的一些想法，开始用 Rust 构建这个工具吧！目标依旧是，用大约 200 行代码实现我们的需求。</p><h3 id="设计分析"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/03#设计分析"><span class="icon icon-link"></span></a>设计分析</h3><p>既然是图片转换，最基本的肯定是要支持各种各样的转换功能，比如调整大小、剪切、加水印，甚至包括图片的滤镜但是，<strong>图片转换服务的难点其实在接口设计上</strong>，如何设计一套易用、简洁的接口，让图片服务器未来可以很轻松地扩展。</p><p>为什么这么说，你想如果有一天，产品经理来找你，突然想让原本只用来做缩略图的图片服务，支持老照片的滤镜效果，你准备怎么办？</p><p>Thumbor 给出的答案是，把要使用的处理方法的接口，按照一定的格式、一定的顺序放在 URL 路径中，不使用的图片处理方法就不放：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/hmac/trim/AxB:CxD/(adaptative-)(full-)fit-in/-Ex-F/HALIGN/VALIGN/smart/filters:FILTERNAME(ARGUMENT):FILTERNAME(ARGUMENT)/*IMAGE-URI*</span></div></pre></div><p>但这样不容易扩展，解析起来不方便，也很难满足对图片做多个有序操作的要求，比如对某个图片我想先加滤镜再加水印，对另一个图片我想先加水印再加滤镜。</p><p>另外，如果未来要加更多的参数，一个不小心，还很可能和已有的参数冲突，或者造成 API 的破坏性更新（breaking change）。作为开发者，我们永远不要低估产品经理那颗什么奇葩想法都有的躁动的心。</p><p>所以，在构思这个项目的时候，<strong>我们需要找一种更简洁且可扩展的方式，来描述对图片进行的一系列有序操作</strong>，比如说：先做 resize，之后对 resize 的结果添加一个水印，最后统一使用一个滤镜。</p><p>这样的有序操作，对应到代码中，可以用列表来表述，列表中每个操作可以是一个 enum，像这样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 解析出来的图片处理的参数</span></div><div class="token-line"><span class="token plain">    struct ImageSpec {</span></div><div class="token-line"><span class="token plain">        specs: Vec&lt;Spec&gt;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 每个参数的是我们支持的某种处理方式</span></div><div class="token-line"><span class="token plain">    enum Spec {</span></div><div class="token-line"><span class="token plain">        Resize(Resize),</span></div><div class="token-line"><span class="token plain">        Crop(Crop),</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 处理图片的 resize</span></div><div class="token-line"><span class="token plain">    struct Resize {</span></div><div class="token-line"><span class="token plain">        width: u32,</span></div><div class="token-line"><span class="token plain">        height: u32</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>现在需要的数据结构有了，刚才分析了 thumbor 使用的方式拓展性不好，<strong>那我们如何设计一个任何客户端可以使用的、体现在 URL 上的接口，使其能够解析成我们设计的数据结构呢</strong>？</p><p>使用 querystring 么？虽然可行，但它在图片处理步骤比较复杂的时候，容易无序增长，比如我们要对某个图片做七八次转换，这个 querystring 就会非常长。</p><p>我这里的思路是使用 protobuf。protobuf 可以描述数据结构，几乎所有语言都有对 protobuf 的支持。当用 protobuf 生成一个 image spec 后，我们可以将其序列化成字节流。但字节流无法放在 URL 中，怎么办？我们可以用 base64 转码！</p><p>顺着这个思路，来试着写一下描述 image spec 的 protobuf 消息的定义：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">message ImageSpec { repeated Spec specs = 1; }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    message Spec {</span></div><div class="token-line"><span class="token plain">      oneof data {</span></div><div class="token-line"><span class="token plain">        Resize resize = 1;</span></div><div class="token-line"><span class="token plain">        Crop crop = 2;</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ...</span></div></pre></div><p>这样我们就可以在 URL 中，嵌入通过 protobuf 生成的 base64 字符串，来提供可扩展的图片处理参数。处理过的 URL 长这个样子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">http://localhost:3000/image/CgoKCAjYBBCgBiADCgY6BAgUEBQKBDICCAM/&lt;encoded origin url&gt;</span></div></pre></div><p><code>CgoKCAjYBBCgBiADCgY6BAgUEBQKBDICCAM</code> 描述了我们上面说的图片的处理流程：先做 resize，之后对 resize 的结果添加一个水印，最后统一使用一个滤镜。它可以用下面的代码实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fn print_test_url(url: &amp;str) {</span></div><div class="token-line"><span class="token plain">        use std::borrow::Borrow;</span></div><div class="token-line"><span class="token plain">        let spec1 = Spec::new_resize(600, 800, resize::SampleFilter::CatmullRom);</span></div><div class="token-line"><span class="token plain">        let spec2 = Spec::new_watermark(20, 20);</span></div><div class="token-line"><span class="token plain">        let spec3 = Spec::new_filter(filter::Filter::Marine);</span></div><div class="token-line"><span class="token plain">        let image_spec = ImageSpec::new(vec![spec1, spec2, spec3]);</span></div><div class="token-line"><span class="token plain">        let s: String = image_spec.borrow().into();</span></div><div class="token-line"><span class="token plain">        let test_image = percent_encode(url.as_bytes(), NON_ALPHANUMERIC).to_string();</span></div><div class="token-line"><span class="token plain">        println!(&quot;test url: http://localhost:3000/image/{}/{}&quot;, s, test_image);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>使用 protobuf 的好处是，序列化后的结果比较小巧，而且任何支持 protobuf 的语言都可以生成或者解析这个接口。</p><p>好，接口我们敲定好，接下来就是做一个 HTTP 服务器提供这个接口。在 HTTP 服务器对 /image 路由的处理流程里，我们需要从 URL 中获取原始的图片，然后按照 image spec 依次处理，最后把处理完的字节流返回给用户。</p><p>在这个流程中，显而易见能够想到的优化是，<strong>为原始图片的获取过程，提供一个 LRU（Least Recently Used）缓存</strong>，因为访问外部网络是整个路径中最缓慢也最不可控的环节。</p><p><img src="https://static001.geekbang.org/resource/image/70/9c/705642e227462ca4a100f73c343af89c.jpg?wh=1920x1140" alt="图片"/></p><p>分析完后，是不是感觉 thumbor 也没有什么复杂的？不过你一定会有疑问：200 行代码真的可以完成这么多工作么？我们先写着，完成之后再来统计一下。</p><h3 id="protobuf-的定义和编译"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/03#protobuf-的定义和编译"><span class="icon icon-link"></span></a>protobuf 的定义和编译</h3><p>这个项目我们需要很多依赖，就不一一介绍了，未来在你的学习、工作中，大部分依赖你都会渐渐遇到和使用到。</p><p>我们照样先 “cargo new thumbor” 生成项目，然后在项目的 Cargo.toml 中添加这些依赖：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[dependencies]</span></div><div class="token-line"><span class="token plain">    axum = &quot;0.2&quot; # web 服务器</span></div><div class="token-line"><span class="token plain">    anyhow = &quot;1&quot; # 错误处理</span></div><div class="token-line"><span class="token plain">    base64 = &quot;0.13&quot; # base64 编码/解码</span></div><div class="token-line"><span class="token plain">    bytes = &quot;1&quot; # 处理字节流</span></div><div class="token-line"><span class="token plain">    image = &quot;0.23&quot; # 处理图片</span></div><div class="token-line"><span class="token plain">    lazy_static = &quot;1&quot; # 通过宏更方便地初始化静态变量</span></div><div class="token-line"><span class="token plain">    lru = &quot;0.6&quot; # LRU 缓存</span></div><div class="token-line"><span class="token plain">    percent-encoding = &quot;2&quot; # url 编码/解码</span></div><div class="token-line"><span class="token plain">    photon-rs = &quot;0.3&quot; # 图片效果</span></div><div class="token-line"><span class="token plain">    prost = &quot;0.8&quot; # protobuf 处理</span></div><div class="token-line"><span class="token plain">    reqwest = &quot;0.11&quot; # HTTP cliebnt</span></div><div class="token-line"><span class="token plain">    serde = { version = &quot;1&quot;, features = [&quot;derive&quot;] } # 序列化/反序列化数据</span></div><div class="token-line"><span class="token plain">    tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] } # 异步处理</span></div><div class="token-line"><span class="token plain">    tower = { version = &quot;0.4&quot;, features = [&quot;util&quot;, &quot;timeout&quot;, &quot;load-shed&quot;, &quot;limit&quot;] } # 服务处理及中间件</span></div><div class="token-line"><span class="token plain">    tower-http = { version = &quot;0.1&quot;, features = [&quot;add-extension&quot;, &quot;compression-full&quot;, &quot;trace&quot; ] } # http 中间件</span></div><div class="token-line"><span class="token plain">    tracing = &quot;0.1&quot; # 日志和追踪</span></div><div class="token-line"><span class="token plain">    tracing-subscriber = &quot;0.2&quot; # 日志和追踪</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    [build-dependencies]</span></div><div class="token-line"><span class="token plain">    prost-build = &quot;0.8&quot; # 编译 protobuf</span></div></pre></div><p>在项目根目录下，生成一个 abi.proto 文件，写入我们支持的图片处理服务用到的数据结构：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">syntax = &quot;proto3&quot;;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    package abi; // 这个名字会被用作编译结果，prost 会产生：abi.rs</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 一个 ImageSpec 是一个有序的数组，服务器按照 spec 的顺序处理</span></div><div class="token-line"><span class="token plain">    message ImageSpec { repeated Spec specs = 1; }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 处理图片改变大小</span></div><div class="token-line"><span class="token plain">    message Resize {</span></div><div class="token-line"><span class="token plain">      uint32 width = 1;</span></div><div class="token-line"><span class="token plain">      uint32 height = 2;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      enum ResizeType {</span></div><div class="token-line"><span class="token plain">        NORMAL = 0;</span></div><div class="token-line"><span class="token plain">        SEAM_CARVE = 1;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      ResizeType rtype = 3;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      enum SampleFilter {</span></div><div class="token-line"><span class="token plain">        UNDEFINED = 0;</span></div><div class="token-line"><span class="token plain">        NEAREST = 1;</span></div><div class="token-line"><span class="token plain">        TRIANGLE = 2;</span></div><div class="token-line"><span class="token plain">        CATMULL_ROM = 3;</span></div><div class="token-line"><span class="token plain">        GAUSSIAN = 4;</span></div><div class="token-line"><span class="token plain">        LANCZOS3 = 5;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      SampleFilter filter = 4;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 处理图片截取</span></div><div class="token-line"><span class="token plain">    message Crop {</span></div><div class="token-line"><span class="token plain">      uint32 x1 = 1;</span></div><div class="token-line"><span class="token plain">      uint32 y1 = 2;</span></div><div class="token-line"><span class="token plain">      uint32 x2 = 3;</span></div><div class="token-line"><span class="token plain">      uint32 y2 = 4;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 处理水平翻转</span></div><div class="token-line"><span class="token plain">    message Fliph {}</span></div><div class="token-line"><span class="token plain">    // 处理垂直翻转</span></div><div class="token-line"><span class="token plain">    message Flipv {}</span></div><div class="token-line"><span class="token plain">    // 处理对比度</span></div><div class="token-line"><span class="token plain">    message Contrast { float contrast = 1; }</span></div><div class="token-line"><span class="token plain">    // 处理滤镜</span></div><div class="token-line"><span class="token plain">    message Filter {</span></div><div class="token-line"><span class="token plain">      enum Filter {</span></div><div class="token-line"><span class="token plain">        UNSPECIFIED = 0;</span></div><div class="token-line"><span class="token plain">        OCEANIC = 1;</span></div><div class="token-line"><span class="token plain">        ISLANDS = 2;</span></div><div class="token-line"><span class="token plain">        MARINE = 3;</span></div><div class="token-line"><span class="token plain">        // more: https://docs.rs/photon-rs/0.3.1/photon_rs/filters/fn.filter.html</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      Filter filter = 1;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 处理水印</span></div><div class="token-line"><span class="token plain">    message Watermark {</span></div><div class="token-line"><span class="token plain">      uint32 x = 1;</span></div><div class="token-line"><span class="token plain">      uint32 y = 2;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 一个 spec 可以包含上述的处理方式之一</span></div><div class="token-line"><span class="token plain">    message Spec {</span></div><div class="token-line"><span class="token plain">      oneof data {</span></div><div class="token-line"><span class="token plain">        Resize resize = 1;</span></div><div class="token-line"><span class="token plain">        Crop crop = 2;</span></div><div class="token-line"><span class="token plain">        Flipv flipv = 3;</span></div><div class="token-line"><span class="token plain">        Fliph fliph = 4;</span></div><div class="token-line"><span class="token plain">        Contrast contrast = 5;</span></div><div class="token-line"><span class="token plain">        Filter filter = 6;</span></div><div class="token-line"><span class="token plain">        Watermark watermark = 7;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这包含了我们支持的图片处理服务，以后可以轻松扩展它来支持更多的操作。</p><p>protobuf 是一个向下兼容的工具，所以在服务器不断支持更多功能时，还可以和旧版本的客户端兼容。在 Rust 下，我们可以用 <a target="_blank" rel="noopener noreferrer" href="https://github.com/tokio-rs/prost">prost<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 来使用和编译 protobuf。同样，在项目根目录下，创建一个 build.rs，写入以下代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fn main() {</span></div><div class="token-line"><span class="token plain">        prost_build::Config::new()</span></div><div class="token-line"><span class="token plain">            .out_dir(&quot;src/pb&quot;)</span></div><div class="token-line"><span class="token plain">            .compile_protos(&amp;[&quot;abi.proto&quot;], &amp;[&quot;.&quot;])</span></div><div class="token-line"><span class="token plain">            .unwrap();</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>build.rs 可以在编译 cargo 项目时，做额外的编译处理。这里我们使用 prost_build 把 abi.proto 编译到 src/pb 目录下。</p><p>这个目录现在还不存在，你需要 <code>mkdir src/pb</code> 创建它。运行 <code>cargo build</code>，你会发现在 src/pb 下，有一个 abi.rs 文件被生成出来，这个文件包含了从 protobuf 消息转换出来的 Rust 数据结构。我们先不用管 prost 额外添加的各种标记宏，就把它们当成普通的数据结构使用即可。</p><p>接下来，我们创建 src/pb/mod.rs，第三讲说过，<strong>一个目录下的所有代码，可以通过 mod.rs 声明</strong>。在这个文件中，我们引入 abi.rs，并且撰写一些辅助函数。这些辅助函数主要是为了，让 ImageSpec 可以被方便地转换成字符串，或者从字符串中恢复。</p><p>另外，我们还写了一个测试确保功能的正确性，你可以 <code>cargo test</code> 测试一下。记得在 main.rs 里添加 <code>mod pb;</code> 引入这个模块。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use base64::{decode_config, encode_config, URL_SAFE_NO_PAD};</span></div><div class="token-line"><span class="token plain">    use photon_rs::transform ::SamplingFilter;</span></div><div class="token-line"><span class="token plain">    use prost::Message;</span></div><div class="token-line"><span class="token plain">    use std::convert::TryFrom;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    mod abi; // 声明 abi.rs</span></div><div class="token-line"><span class="token plain">    pub use abi::*;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl ImageSpec {</span></div><div class="token-line"><span class="token plain">        pub fn new(specs: Vec&lt;Spec&gt;) -&gt; Self {</span></div><div class="token-line"><span class="token plain">            Self { specs }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 让 ImageSpec 可以生成一个字符串</span></div><div class="token-line"><span class="token plain">    impl From&lt;&amp;ImageSpec&gt; for String {</span></div><div class="token-line"><span class="token plain">        fn from(image_spec: &amp;ImageSpec) -&gt; Self {</span></div><div class="token-line"><span class="token plain">            let data = image_spec.encode_to_vec();</span></div><div class="token-line"><span class="token plain">            encode_config(data, URL_SAFE_NO_PAD)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 让 ImageSpec 可以通过一个字符串创建。比如 s.parse().unwrap()</span></div><div class="token-line"><span class="token plain">    impl TryFrom&lt;&amp;str&gt; for ImageSpec {</span></div><div class="token-line"><span class="token plain">        type Error = anyhow::Error;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        fn try_from(value: &amp;str) -&gt; Result&lt;Self, Self::Error&gt; {</span></div><div class="token-line"><span class="token plain">            let data = decode_config(value, URL_SAFE_NO_PAD)?;</span></div><div class="token-line"><span class="token plain">            Ok(ImageSpec::decode(&amp;data[..])?)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 辅助函数，photon_rs 相应的方法里需要字符串</span></div><div class="token-line"><span class="token plain">    impl filter::Filter {</span></div><div class="token-line"><span class="token plain">        pub fn to_str(&amp;self) -&gt; Option&lt;&amp;&#x27;static str&gt; {</span></div><div class="token-line"><span class="token plain">            match self {</span></div><div class="token-line"><span class="token plain">                filter::Filter::Unspecified =&gt; None,</span></div><div class="token-line"><span class="token plain">                filter::Filter::Oceanic =&gt; Some(&quot;oceanic&quot;),</span></div><div class="token-line"><span class="token plain">                filter::Filter::Islands =&gt; Some(&quot;islands&quot;),</span></div><div class="token-line"><span class="token plain">                filter::Filter::Marine =&gt; Some(&quot;marine&quot;),</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 在我们定义的 SampleFilter 和 photon_rs 的 SamplingFilter 间转换</span></div><div class="token-line"><span class="token plain">    impl From&lt;resize::SampleFilter&gt; for SamplingFilter {</span></div><div class="token-line"><span class="token plain">        fn from(v: resize::SampleFilter) -&gt; Self {</span></div><div class="token-line"><span class="token plain">            match v {</span></div><div class="token-line"><span class="token plain">                resize::SampleFilter::Undefined =&gt; SamplingFilter::Nearest,</span></div><div class="token-line"><span class="token plain">                resize::SampleFilter::Nearest =&gt; SamplingFilter::Nearest,</span></div><div class="token-line"><span class="token plain">                resize::SampleFilter::Triangle =&gt; SamplingFilter::Triangle,</span></div><div class="token-line"><span class="token plain">                resize::SampleFilter::CatmullRom =&gt; SamplingFilter::CatmullRom,</span></div><div class="token-line"><span class="token plain">                resize::SampleFilter::Gaussian =&gt; SamplingFilter::Gaussian,</span></div><div class="token-line"><span class="token plain">                resize::SampleFilter::Lanczos3 =&gt; SamplingFilter::Lanczos3,</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 提供一些辅助函数，让创建一个 spec 的过程简单一些</span></div><div class="token-line"><span class="token plain">    impl Spec {</span></div><div class="token-line"><span class="token plain">        pub fn new_resize_seam_carve(width: u32, height: u32) -&gt; Self {</span></div><div class="token-line"><span class="token plain">            Self {</span></div><div class="token-line"><span class="token plain">                data: Some(spec::Data::Resize(Resize {</span></div><div class="token-line"><span class="token plain">                    width,</span></div><div class="token-line"><span class="token plain">                    height,</span></div><div class="token-line"><span class="token plain">                    rtype: resize::ResizeType::SeamCarve as i32,</span></div><div class="token-line"><span class="token plain">                    filter: resize::SampleFilter::Undefined as i32,</span></div><div class="token-line"><span class="token plain">                })),</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        pub fn new_resize(width: u32, height: u32, filter: resize::SampleFilter) -&gt; Self {</span></div><div class="token-line"><span class="token plain">            Self {</span></div><div class="token-line"><span class="token plain">                data: Some(spec::Data::Resize(Resize {</span></div><div class="token-line"><span class="token plain">                    width,</span></div><div class="token-line"><span class="token plain">                    height,</span></div><div class="token-line"><span class="token plain">                    rtype: resize::ResizeType::Normal as i32,</span></div><div class="token-line"><span class="token plain">                    filter: filter as i32,</span></div><div class="token-line"><span class="token plain">                })),</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        pub fn new_filter(filter: filter::Filter) -&gt; Self {</span></div><div class="token-line"><span class="token plain">            Self {</span></div><div class="token-line"><span class="token plain">                data: Some(spec::Data::Filter(Filter {</span></div><div class="token-line"><span class="token plain">                    filter: filter as i32,</span></div><div class="token-line"><span class="token plain">                })),</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        pub fn new_watermark(x: u32, y: u32) -&gt; Self {</span></div><div class="token-line"><span class="token plain">            Self {</span></div><div class="token-line"><span class="token plain">                data: Some(spec::Data::Watermark(Watermark { x, y })),</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #[cfg(test)]</span></div><div class="token-line"><span class="token plain">    mod tests {</span></div><div class="token-line"><span class="token plain">        use super::*;</span></div><div class="token-line"><span class="token plain">        use std::borrow::Borrow;</span></div><div class="token-line"><span class="token plain">        use std::convert::TryInto;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        #[test]</span></div><div class="token-line"><span class="token plain">        fn encoded_spec_could_be_decoded() {</span></div><div class="token-line"><span class="token plain">            let spec1 = Spec::new_resize(600, 600, resize::SampleFilter::CatmullRom);</span></div><div class="token-line"><span class="token plain">            let spec2 = Spec::new_filter(filter::Filter::Marine);</span></div><div class="token-line"><span class="token plain">            let image_spec = ImageSpec::new(vec![spec1, spec2]);</span></div><div class="token-line"><span class="token plain">            let s: String = image_spec.borrow().into();</span></div><div class="token-line"><span class="token plain">            assert_eq!(image_spec, s.as_str().try_into().unwrap());</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="引入-http-服务器"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/03#引入-http-服务器"><span class="icon icon-link"></span></a>引入 HTTP 服务器</h3><p>处理完和 protobuf 相关的内容，我们来处理 HTTP 服务的流程。Rust 社区有很多高性能的 Web 服务器，比如<a target="_blank" rel="noopener noreferrer" href="https://github.com/actix/actix-web">actix-web<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 、<a target="_blank" rel="noopener noreferrer" href="https://github.com/SergioBenitez/Rocket">rocket<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 、<a target="_blank" rel="noopener noreferrer" href="https://github.com/seanmonstar/warp">warp<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ，以及最近新出的 <a target="_blank" rel="noopener noreferrer" href="https://github.com/tokio-rs/axum">axum<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。我们就来用新鲜出炉的 axum 做这个服务器。</p><p>根据 axum 的文档，我们可以构建出下面的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use axum::{extract::Path, handler::get, http::StatusCode, Router};</span></div><div class="token-line"><span class="token plain">    use percent_encoding::percent_decode_str;</span></div><div class="token-line"><span class="token plain">    use serde::Deserialize;</span></div><div class="token-line"><span class="token plain">    use std::convert::TryInto;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 引入 protobuf 生成的代码，我们暂且不用太关心他们</span></div><div class="token-line"><span class="token plain">    mod pb;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    use pb::*;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 参数使用 serde 做 Deserialize，axum 会自动识别并解析</span></div><div class="token-line"><span class="token plain">    #[derive(Deserialize)]</span></div><div class="token-line"><span class="token plain">    struct Params {</span></div><div class="token-line"><span class="token plain">        spec: String,</span></div><div class="token-line"><span class="token plain">        url: String,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #[tokio::main]</span></div><div class="token-line"><span class="token plain">    async fn main() {</span></div><div class="token-line"><span class="token plain">        // 初始化 tracing</span></div><div class="token-line"><span class="token plain">        tracing_subscriber::fmt::init();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 构建路由</span></div><div class="token-line"><span class="token plain">        let app = Router::new()</span></div><div class="token-line"><span class="token plain">            // `GET /image` 会执行 generate 函数，并把 spec 和 url 传递过去</span></div><div class="token-line"><span class="token plain">            .route(&quot;/image/:spec/:url&quot;, get(generate));</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 运行 web 服务器</span></div><div class="token-line"><span class="token plain">        let addr = &quot;127.0.0.1:3000&quot;.parse().unwrap();</span></div><div class="token-line"><span class="token plain">        tracing::debug!(&quot;listening on {}&quot;, addr);</span></div><div class="token-line"><span class="token plain">        axum::Server::bind(&amp;addr)</span></div><div class="token-line"><span class="token plain">            .serve(app.into_make_service())</span></div><div class="token-line"><span class="token plain">            .await</span></div><div class="token-line"><span class="token plain">            .unwrap();</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 目前我们就只把参数解析出来</span></div><div class="token-line"><span class="token plain">    async fn generate(Path(Params { spec, url }): Path&lt;Params&gt;) -&gt; Result&lt;String, StatusCode&gt; {</span></div><div class="token-line"><span class="token plain">        let url = percent_decode_str(&amp;url).decode_utf8_lossy();</span></div><div class="token-line"><span class="token plain">        let spec: ImageSpec = spec</span></div><div class="token-line"><span class="token plain">            .as_str()</span></div><div class="token-line"><span class="token plain">            .try_into()</span></div><div class="token-line"><span class="token plain">            .map_err(|_| StatusCode::BAD_REQUEST)?;</span></div><div class="token-line"><span class="token plain">    		Ok(format!(&quot;url: {}\n spec: {:#?}&quot;, url, spec))</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>把它们添加到 main.rs 后，使用 <code>cargo run</code> 运行服务器。然后我们就可以用上一讲做的 HTTPie 测试（eat your own dog food）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">httpie get &quot;http://localhost:3000/image/CgoKCAjYBBCgBiADCgY6BAgUEBQKBDICCAM/https%3A%2F%2Fimages%2Epexels%2Ecom%2Fphotos%2F2470905%2Fpexels%2Dphoto%2D2470905%2Ejpeg%3Fauto%3Dcompress%26cs%3Dtinysrgb%26dpr%3D2%26h%3D750%26w%3D1260&quot;</span></div><div class="token-line"><span class="token plain">    HTTP/1.1 200 OK</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    content-type: &quot;text/plain&quot;</span></div><div class="token-line"><span class="token plain">    content-length: &quot;901&quot;</span></div><div class="token-line"><span class="token plain">    date: &quot;Wed, 25 Aug 2021 18:03:50 GMT&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    url: https://images.pexels.com/photos/2470905/pexels-photo-2470905.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;h=750&amp;w=1260</span></div><div class="token-line"><span class="token plain">     spec: ImageSpec {</span></div><div class="token-line"><span class="token plain">        specs: [</span></div><div class="token-line"><span class="token plain">            Spec {</span></div><div class="token-line"><span class="token plain">                data: Some(</span></div><div class="token-line"><span class="token plain">                    Resize(</span></div><div class="token-line"><span class="token plain">                        Resize {</span></div><div class="token-line"><span class="token plain">                            width: 600,</span></div><div class="token-line"><span class="token plain">                            height: 800,</span></div><div class="token-line"><span class="token plain">                            rtype: Normal,</span></div><div class="token-line"><span class="token plain">                            filter: CatmullRom,</span></div><div class="token-line"><span class="token plain">                        },</span></div><div class="token-line"><span class="token plain">                    ),</span></div><div class="token-line"><span class="token plain">                ),</span></div><div class="token-line"><span class="token plain">            },</span></div><div class="token-line"><span class="token plain">            Spec {</span></div><div class="token-line"><span class="token plain">                data: Some(</span></div><div class="token-line"><span class="token plain">                    Watermark(</span></div><div class="token-line"><span class="token plain">                        Watermark {</span></div><div class="token-line"><span class="token plain">                            x: 20,</span></div><div class="token-line"><span class="token plain">                            y: 20,</span></div><div class="token-line"><span class="token plain">                        },</span></div><div class="token-line"><span class="token plain">                    ),</span></div><div class="token-line"><span class="token plain">                ),</span></div><div class="token-line"><span class="token plain">            },</span></div><div class="token-line"><span class="token plain">            Spec {</span></div><div class="token-line"><span class="token plain">                data: Some(</span></div><div class="token-line"><span class="token plain">                    Filter(</span></div><div class="token-line"><span class="token plain">                        Filter {</span></div><div class="token-line"><span class="token plain">                            filter: Marine,</span></div><div class="token-line"><span class="token plain">                        },</span></div><div class="token-line"><span class="token plain">                    ),</span></div><div class="token-line"><span class="token plain">                ),</span></div><div class="token-line"><span class="token plain">            },</span></div><div class="token-line"><span class="token plain">        ],</span></div></pre></div><p>Wow，Web 服务器的接口部分我们已经能够正确处理了。</p><p>写到这里，如果出现的语法让你觉得迷茫，不要担心。因为我们还没有讲所有权、类型系统、泛型等内容，所以很多细节你会看不懂。今天这个例子，你只要跟我的思路走，了解整个处理流程就可以了。</p><h3 id="获取源图并缓存"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/03#获取源图并缓存"><span class="icon icon-link"></span></a>获取源图并缓存</h3><p>好，当接口已经可以工作之后，我们再来处理获取源图的逻辑。</p><p>根据之前的设计，需要<strong>引入 LRU cache 来缓存源图</strong>。一般 Web 框架都会有中间件来处理全局的状态，axum 也不例外，可以使用 AddExtensionLayer 添加一个全局的状态，这个状态目前就是 LRU cache，在内存中缓存网络请求获得的源图。</p><p>我们把 main.rs 的代码，改成下面的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use anyhow::Result;</span></div><div class="token-line"><span class="token plain">    use axum::{</span></div><div class="token-line"><span class="token plain">        extract::{Extension, Path},</span></div><div class="token-line"><span class="token plain">        handler::get,</span></div><div class="token-line"><span class="token plain">        http::{HeaderMap, HeaderValue, StatusCode},</span></div><div class="token-line"><span class="token plain">        AddExtensionLayer, Router,</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    use bytes::Bytes;</span></div><div class="token-line"><span class="token plain">    use lru::LruCache;</span></div><div class="token-line"><span class="token plain">    use percent_encoding::{percent_decode_str, percent_encode, NON_ALPHANUMERIC};</span></div><div class="token-line"><span class="token plain">    use serde::Deserialize;</span></div><div class="token-line"><span class="token plain">    use std::{</span></div><div class="token-line"><span class="token plain">        collections::hash_map::DefaultHasher,</span></div><div class="token-line"><span class="token plain">        convert::TryInto,</span></div><div class="token-line"><span class="token plain">        hash::{Hash, Hasher},</span></div><div class="token-line"><span class="token plain">        sync::Arc,</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    use tokio::sync::Mutex;</span></div><div class="token-line"><span class="token plain">    use tower::ServiceBuilder;</span></div><div class="token-line"><span class="token plain">    use tracing::{info, instrument};</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    mod pb;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    use pb::*;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #[derive(Deserialize)]</span></div><div class="token-line"><span class="token plain">    struct Params {</span></div><div class="token-line"><span class="token plain">        spec: String,</span></div><div class="token-line"><span class="token plain">        url: String,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    type Cache = Arc&lt;Mutex&lt;LruCache&lt;u64, Bytes&gt;&gt;&gt;;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #[tokio::main]</span></div><div class="token-line"><span class="token plain">    async fn main() {</span></div><div class="token-line"><span class="token plain">        // 初始化 tracing</span></div><div class="token-line"><span class="token plain">        tracing_subscriber::fmt::init();</span></div><div class="token-line"><span class="token plain">        let cache: Cache = Arc::new(Mutex::new(LruCache::new(1024)));</span></div><div class="token-line"><span class="token plain">        // 构建路由</span></div><div class="token-line"><span class="token plain">        let app = Router::new()</span></div><div class="token-line"><span class="token plain">            // `GET /` 会执行</span></div><div class="token-line"><span class="token plain">            .route(&quot;/image/:spec/:url&quot;, get(generate))</span></div><div class="token-line"><span class="token plain">            .layer(</span></div><div class="token-line"><span class="token plain">                ServiceBuilder::new()</span></div><div class="token-line"><span class="token plain">                    .layer(AddExtensionLayer::new(cache))</span></div><div class="token-line"><span class="token plain">                    .into_inner(),</span></div><div class="token-line"><span class="token plain">            );</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 运行 web 服务器</span></div><div class="token-line"><span class="token plain">        let addr = &quot;127.0.0.1:3000&quot;.parse().unwrap();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        print_test_url(&quot;https://images.pexels.com/photos/1562477/pexels-photo-1562477.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=3&amp;h=750&amp;w=1260&quot;);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        info!(&quot;Listening on {}&quot;, addr);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        axum::Server::bind(&amp;addr)</span></div><div class="token-line"><span class="token plain">            .serve(app.into_make_service())</span></div><div class="token-line"><span class="token plain">            .await</span></div><div class="token-line"><span class="token plain">            .unwrap();</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    async fn generate(</span></div><div class="token-line"><span class="token plain">        Path(Params { spec, url }): Path&lt;Params&gt;,</span></div><div class="token-line"><span class="token plain">        Extension(cache): Extension&lt;Cache&gt;,</span></div><div class="token-line"><span class="token plain">    ) -&gt; Result&lt;(HeaderMap, Vec&lt;u8&gt;), StatusCode&gt; {</span></div><div class="token-line"><span class="token plain">        let spec: ImageSpec = spec</span></div><div class="token-line"><span class="token plain">            .as_str()</span></div><div class="token-line"><span class="token plain">            .try_into()</span></div><div class="token-line"><span class="token plain">            .map_err(|_| StatusCode::BAD_REQUEST)?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        let url: &amp;str = &amp;percent_decode_str(&amp;url).decode_utf8_lossy();</span></div><div class="token-line"><span class="token plain">        let data = retrieve_image(&amp;url, cache)</span></div><div class="token-line"><span class="token plain">            .await</span></div><div class="token-line"><span class="token plain">            .map_err(|_| StatusCode::BAD_REQUEST)?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // TODO: 处理图片</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        let mut headers = HeaderMap::new();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        headers.insert(&quot;content-type&quot;, HeaderValue::from_static(&quot;image/jpeg&quot;));</span></div><div class="token-line"><span class="token plain">        Ok((headers, data.to_vec()))</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #[instrument(level = &quot;info&quot;, skip(cache))]</span></div><div class="token-line"><span class="token plain">    async fn retrieve_image(url: &amp;str, cache: Cache) -&gt; Result&lt;Bytes&gt; {</span></div><div class="token-line"><span class="token plain">        let mut hasher = DefaultHasher::new();</span></div><div class="token-line"><span class="token plain">        url.hash(&amp;mut hasher);</span></div><div class="token-line"><span class="token plain">        let key = hasher.finish();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        let g = &amp;mut cache.lock().await;</span></div><div class="token-line"><span class="token plain">        let data = match g.get(&amp;key) {</span></div><div class="token-line"><span class="token plain">            Some(v) =&gt; {</span></div><div class="token-line"><span class="token plain">                info!(&quot;Match cache {}&quot;, key);</span></div><div class="token-line"><span class="token plain">                v.to_owned()</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            None =&gt; {</span></div><div class="token-line"><span class="token plain">                info!(&quot;Retrieve url&quot;);</span></div><div class="token-line"><span class="token plain">                let resp = reqwest::get(url).await?;</span></div><div class="token-line"><span class="token plain">                let data = resp.bytes().await?;</span></div><div class="token-line"><span class="token plain">                g.put(key, data.clone());</span></div><div class="token-line"><span class="token plain">                data</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        Ok(data)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 调试辅助函数</span></div><div class="token-line"><span class="token plain">    fn print_test_url(url: &amp;str) {</span></div><div class="token-line"><span class="token plain">        use std::borrow::Borrow;</span></div><div class="token-line"><span class="token plain">        let spec1 = Spec::new_resize(500, 800, resize::SampleFilter::CatmullRom);</span></div><div class="token-line"><span class="token plain">        let spec2 = Spec::new_watermark(20, 20);</span></div><div class="token-line"><span class="token plain">        let spec3 = Spec::new_filter(filter::Filter::Marine);</span></div><div class="token-line"><span class="token plain">        let image_spec = ImageSpec::new(vec![spec1, spec2, spec3]);</span></div><div class="token-line"><span class="token plain">        let s: String = image_spec.borrow().into();</span></div><div class="token-line"><span class="token plain">        let test_image = percent_encode(url.as_bytes(), NON_ALPHANUMERIC).to_string();</span></div><div class="token-line"><span class="token plain">        println!(&quot;test url: http://localhost:3000/image/{}/{}&quot;, s, test_image);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这段代码看起来多，其实主要就是添加了 retrieve_image 这个函数。对于图片的网络请求，我们先把 URL 做个哈希，在 LRU 缓存中查找，找不到才用 reqwest 发送请求。<br/>你可以 <code>cargo run</code> 运行一下现在的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">❯ RUST_LOG=info cargo run --quiet</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    test url: http://localhost:3000/image/CgoKCAj0AxCgBiADCgY6BAgUEBQKBDICCAM/https%3A%2F%2Fimages%2Epexels%2Ecom%2Fphotos%2F1562477%2Fpexels%2Dphoto%2D1562477%2Ejpeg%3Fauto%3Dcompress%26cs%3Dtinysrgb%26dpr%3D3%26h%3D750%26w%3D1260</span></div><div class="token-line"><span class="token plain">    Aug 26 16:43:45.747  INFO server2: Listening on 127.0.0.1:3000</span></div></pre></div><p>为了测试方便，我放了个辅助函数可以生成一个测试 URL，在浏览器中打开后会得到一个和源图一模一样的图片。这就说明，网络处理的部分，我们就搞定了。</p><h3 id="图片处理"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/03#图片处理"><span class="icon icon-link"></span></a>图片处理</h3><p>接下来，我们就可以处理图片了。Rust 下有一个不错的、偏底层的 <a target="_blank" rel="noopener noreferrer" href="https://github.com/image-rs/image">image<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 库，围绕它有很多上层的库，包括我们今天要使用 <a target="_blank" rel="noopener noreferrer" href="https://github.com/silvia-odwyer/photon">photon_rs<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>我扫了一下它的源代码，感觉它不算一个特别优秀的库，内部有太多无谓的内存拷贝，所以性能还有不少提升空间。就算如此，从 photon_rs 自己的 <a target="_blank" rel="noopener noreferrer" href="https://silvia-odwyer.github.io/photon/">benchmark<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 看，也比 PIL / ImageMagick 性能好太多，这也算是 Rust 性能强大的一个小小佐证吧。</p><p><img src="https://static001.geekbang.org/resource/image/a2/e0/a236c61c10516437d529a00cff66a4e0.png?wh=1496x752" alt="图片"/></p><p>因为 photo_rs 使用简单，这里我们也不太关心更高的性能，就暂且用它。然而，作为一个有追求的开发者，我们知道，有朝一日可能要用不同的 image 引擎替换它，所以我们设计一个 Engine trait：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Engine trait：未来可以添加更多的 engine，主流程只需要替换 engine</span></div><div class="token-line"><span class="token plain">    pub trait Engine {</span></div><div class="token-line"><span class="token plain">        // 对 engine 按照 specs 进行一系列有序的处理</span></div><div class="token-line"><span class="token plain">        fn apply(&amp;mut self, specs: &amp;[Spec]);</span></div><div class="token-line"><span class="token plain">        // 从 engine 中生成目标图片，注意这里用的是 self，而非 self 的引用</span></div><div class="token-line"><span class="token plain">        fn generate(self, format: ImageOutputFormat) -&gt; Vec&lt;u8&gt;;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>它提供两个方法，<strong>apply 方法对 engine 按照 specs 进行一系列有序的处理，generate 方法从 engine 中生成目标图片</strong>。</p><p>那么 apply 方法怎么实现呢？我们可以再设计一个 trait，这样可以为每个 Spec 生成对应处理：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// SpecTransform：未来如果添加更多的 spec，只需要实现它即可</span></div><div class="token-line"><span class="token plain">    pub trait SpecTransform&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        // 对图片使用 op 做 transform</span></div><div class="token-line"><span class="token plain">        fn transform(&amp;mut self, op: T);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>好，有了这个思路，我们创建 src/engine 目录，并添加 src/engine/mod.rs，在这个文件里添加对 trait 的定义：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use crate::pb::Spec;</span></div><div class="token-line"><span class="token plain">    use image::ImageOutputFormat;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    mod photon;</span></div><div class="token-line"><span class="token plain">    pub use photon::Photon;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // Engine trait：未来可以添加更多的 engine，主流程只需要替换 engine</span></div><div class="token-line"><span class="token plain">    pub trait Engine {</span></div><div class="token-line"><span class="token plain">        // 对 engine 按照 specs 进行一系列有序的处理</span></div><div class="token-line"><span class="token plain">        fn apply(&amp;mut self, specs: &amp;[Spec]);</span></div><div class="token-line"><span class="token plain">        // 从 engine 中生成目标图片，注意这里用的是 self，而非 self 的引用</span></div><div class="token-line"><span class="token plain">        fn generate(self, format: ImageOutputFormat) -&gt; Vec&lt;u8&gt;;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // SpecTransform：未来如果添加更多的 spec，只需要实现它即可</span></div><div class="token-line"><span class="token plain">    pub trait SpecTransform&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        // 对图片使用 op 做 transform</span></div><div class="token-line"><span class="token plain">        fn transform(&amp;mut self, op: T);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>接下来我们再生成一个文件 src/engine/photon.rs，对 photon 实现 Engine trait，这个文件主要是一些功能的实现细节，就不详述了，你可以看注释。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use super::{Engine, SpecTransform};</span></div><div class="token-line"><span class="token plain">    use crate::pb::*;</span></div><div class="token-line"><span class="token plain">    use anyhow::Result;</span></div><div class="token-line"><span class="token plain">    use bytes::Bytes;</span></div><div class="token-line"><span class="token plain">    use image::{DynamicImage, ImageBuffer, ImageOutputFormat};</span></div><div class="token-line"><span class="token plain">    use lazy_static::lazy_static;</span></div><div class="token-line"><span class="token plain">    use photon_rs::{</span></div><div class="token-line"><span class="token plain">        effects, filters, multiple, native::open_image_from_bytes, transform, PhotonImage,</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    use std::convert::TryFrom;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    lazy_static! {</span></div><div class="token-line"><span class="token plain">        // 预先把水印文件加载为静态变量</span></div><div class="token-line"><span class="token plain">        static ref WATERMARK: PhotonImage = {</span></div><div class="token-line"><span class="token plain">            // 这里你需要把我 github 项目下的对应图片拷贝到你的根目录</span></div><div class="token-line"><span class="token plain">            // 在编译的时候 include_bytes! 宏会直接把文件读入编译后的二进制</span></div><div class="token-line"><span class="token plain">            let data = include_bytes!(&quot;../../rust-logo.png&quot;);</span></div><div class="token-line"><span class="token plain">            let watermark = open_image_from_bytes(data).unwrap();</span></div><div class="token-line"><span class="token plain">            transform::resize(&amp;watermark, 64, 64, transform::SamplingFilter::Nearest)</span></div><div class="token-line"><span class="token plain">        };</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 我们目前支持 Photon engine</span></div><div class="token-line"><span class="token plain">    pub struct Photon(PhotonImage);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 从 Bytes 转换成 Photon 结构</span></div><div class="token-line"><span class="token plain">    impl TryFrom&lt;Bytes&gt; for Photon {</span></div><div class="token-line"><span class="token plain">        type Error = anyhow::Error;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        fn try_from(data: Bytes) -&gt; Result&lt;Self, Self::Error&gt; {</span></div><div class="token-line"><span class="token plain">            Ok(Self(open_image_from_bytes(&amp;data)?))</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl Engine for Photon {</span></div><div class="token-line"><span class="token plain">        fn apply(&amp;mut self, specs: &amp;[Spec]) {</span></div><div class="token-line"><span class="token plain">            for spec in specs.iter() {</span></div><div class="token-line"><span class="token plain">                match spec.data {</span></div><div class="token-line"><span class="token plain">                    Some(spec::Data::Crop(ref v)) =&gt; self.transform(v),</span></div><div class="token-line"><span class="token plain">                    Some(spec::Data::Contrast(ref v)) =&gt; self.transform(v),</span></div><div class="token-line"><span class="token plain">                    Some(spec::Data::Filter(ref v)) =&gt; self.transform(v),</span></div><div class="token-line"><span class="token plain">                    Some(spec::Data::Fliph(ref v)) =&gt; self.transform(v),</span></div><div class="token-line"><span class="token plain">                    Some(spec::Data::Flipv(ref v)) =&gt; self.transform(v),</span></div><div class="token-line"><span class="token plain">                    Some(spec::Data::Resize(ref v)) =&gt; self.transform(v),</span></div><div class="token-line"><span class="token plain">                    Some(spec::Data::Watermark(ref v)) =&gt; self.transform(v),</span></div><div class="token-line"><span class="token plain">                    // 对于目前不认识的 spec，不做任何处理</span></div><div class="token-line"><span class="token plain">                    _ =&gt; {}</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        fn generate(self, format: ImageOutputFormat) -&gt; Vec&lt;u8&gt; {</span></div><div class="token-line"><span class="token plain">            image_to_buf(self.0, format)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl SpecTransform&lt;&amp;Crop&gt; for Photon {</span></div><div class="token-line"><span class="token plain">        fn transform(&amp;mut self, op: &amp;Crop) {</span></div><div class="token-line"><span class="token plain">            let img = transform::crop(&amp;mut self.0, op.x1, op.y1, op.x2, op.y2);</span></div><div class="token-line"><span class="token plain">            self.0 = img;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl SpecTransform&lt;&amp;Contrast&gt; for Photon {</span></div><div class="token-line"><span class="token plain">        fn transform(&amp;mut self, op: &amp;Contrast) {</span></div><div class="token-line"><span class="token plain">            effects::adjust_contrast(&amp;mut self.0, op.contrast);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl SpecTransform&lt;&amp;Flipv&gt; for Photon {</span></div><div class="token-line"><span class="token plain">        fn transform(&amp;mut self, _op: &amp;Flipv) {</span></div><div class="token-line"><span class="token plain">            transform::flipv(&amp;mut self.0)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl SpecTransform&lt;&amp;Fliph&gt; for Photon {</span></div><div class="token-line"><span class="token plain">        fn transform(&amp;mut self, _op: &amp;Fliph) {</span></div><div class="token-line"><span class="token plain">            transform::fliph(&amp;mut self.0)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl SpecTransform&lt;&amp;Filter&gt; for Photon {</span></div><div class="token-line"><span class="token plain">        fn transform(&amp;mut self, op: &amp;Filter) {</span></div><div class="token-line"><span class="token plain">            match filter::Filter::from_i32(op.filter) {</span></div><div class="token-line"><span class="token plain">                Some(filter::Filter::Unspecified) =&gt; {}</span></div><div class="token-line"><span class="token plain">                Some(f) =&gt; filters::filter(&amp;mut self.0, f.to_str().unwrap()),</span></div><div class="token-line"><span class="token plain">                _ =&gt; {}</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl SpecTransform&lt;&amp;Resize&gt; for Photon {</span></div><div class="token-line"><span class="token plain">        fn transform(&amp;mut self, op: &amp;Resize) {</span></div><div class="token-line"><span class="token plain">            let img = match resize::ResizeType::from_i32(op.rtype).unwrap() {</span></div><div class="token-line"><span class="token plain">                resize::ResizeType::Normal =&gt; transform::resize(</span></div><div class="token-line"><span class="token plain">                    &amp;mut self.0,</span></div><div class="token-line"><span class="token plain">                    op.width,</span></div><div class="token-line"><span class="token plain">                    op.height,</span></div><div class="token-line"><span class="token plain">                    resize::SampleFilter::from_i32(op.filter).unwrap().into(),</span></div><div class="token-line"><span class="token plain">                ),</span></div><div class="token-line"><span class="token plain">                resize::ResizeType::SeamCarve =&gt; {</span></div><div class="token-line"><span class="token plain">                    transform::seam_carve(&amp;mut self.0, op.width, op.height)</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            };</span></div><div class="token-line"><span class="token plain">            self.0 = img;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl SpecTransform&lt;&amp;Watermark&gt; for Photon {</span></div><div class="token-line"><span class="token plain">        fn transform(&amp;mut self, op: &amp;Watermark) {</span></div><div class="token-line"><span class="token plain">            multiple::watermark(&amp;mut self.0, &amp;WATERMARK, op.x, op.y);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // photon 库竟然没有提供在内存中对图片转换格式的方法，只好手工实现</span></div><div class="token-line"><span class="token plain">    fn image_to_buf(img: PhotonImage, format: ImageOutputFormat) -&gt; Vec&lt;u8&gt; {</span></div><div class="token-line"><span class="token plain">        let raw_pixels = img.get_raw_pixels();</span></div><div class="token-line"><span class="token plain">        let width = img.get_width();</span></div><div class="token-line"><span class="token plain">        let height = img.get_height();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        let img_buffer = ImageBuffer::from_vec(width, height, raw_pixels).unwrap();</span></div><div class="token-line"><span class="token plain">        let dynimage = DynamicImage::ImageRgba8(img_buffer);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        let mut buffer = Vec::with_capacity(32768);</span></div><div class="token-line"><span class="token plain">        dynimage.write_to(&amp;mut buffer, format).unwrap();</span></div><div class="token-line"><span class="token plain">        buffer</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>好，图片处理引擎就搞定了。这里用了一个水印图片，你可以去 <a target="_blank" rel="noopener noreferrer" href="https://github.com/tyrchen/geektime-rust/tree/master/05_thumbor">GitHub repo<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 下载，然后放在项目根目录下。我们同样把 engine 模块加入 main.rs，并引入 Photon：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">mod engine;</span></div><div class="token-line"><span class="token plain">    use engine::{Engine, Photon};</span></div><div class="token-line"><span class="token plain">    use image::ImageOutputFormat;</span></div></pre></div><p>还记得 src/main.rs 的代码中，我们留了一个 TODO 么？</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// TODO: 处理图片</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    let mut headers = HeaderMap::new();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    headers.insert(&quot;content-type&quot;, HeaderValue::from_static(&quot;image/jpeg&quot;));</span></div><div class="token-line"><span class="token plain">    Ok((headers, data.to_vec()))</span></div></pre></div><p>我们把这段替换掉，使用刚才写好的 Photon 引擎处理：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 使用 image engine 处理</span></div><div class="token-line"><span class="token plain">    let mut engine: Photon = data</span></div><div class="token-line"><span class="token plain">        .try_into()</span></div><div class="token-line"><span class="token plain">        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;</span></div><div class="token-line"><span class="token plain">    engine.apply(&amp;spec.specs);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    let image = engine.generate(ImageOutputFormat::Jpeg(85));</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    info!(&quot;Finished processing: image size {}&quot;, image.len());</span></div><div class="token-line"><span class="token plain">    let mut headers = HeaderMap::new();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    headers.insert(&quot;content-type&quot;, HeaderValue::from_static(&quot;image/jpeg&quot;));</span></div><div class="token-line"><span class="token plain">    Ok((headers, image))</span></div></pre></div><p>这样整个服务器的全部流程就完成了，完整的代码可以在 <a target="_blank" rel="noopener noreferrer" href="https://github.com/tyrchen/geektime-rust/tree/master/05_thumbor">GitHub repo<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 访问。</p><p>我在网上随手找了一张图片来测试下效果。用 <code>cargo build \--release</code> 编译 thumbor 项目，然后打开日志运行：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">RUST_LOG=info target/release/thumbor</span></div></pre></div><p>打开测试链接，在浏览器中可以看到左下角的处理后图片。（原图片来自 <a target="_blank" rel="noopener noreferrer" href="https://www.pexels.com/photo/woman-behind-banana-leaves-1562477/">pexels<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，发布者 <a target="_blank" rel="noopener noreferrer" href="https://www.pexels.com/@minan1398">Min An<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）</p><p><img src="https://static001.geekbang.org/resource/image/7f/f2/7f69bebe4f911f7587455966bdf3eaf2.jpg?wh=1533x2250" alt="" title="方便看对比效果，把两张图拼到一起了"/></p><p>成功了！这就是我们的 Thumbor 服务根据用户的请求缩小到 500x800、加了水印和 Marine 滤镜后的效果。</p><p>从日志看，第一次请求时因为没有缓存，需要请求源图，所以总共花了 400ms；如果你再刷新一下，后续对同一图片的请求，会命中缓存，花了大概 200ms。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Aug 25 15:09:28.035  INFO thumbor: Listening on 127.0.0.1:3000</span></div><div class="token-line"><span class="token plain">    Aug 25 15:09:30.523  INFO retrieve_image{url=&quot;&lt;https://images.pexels.com/photos/1562477/pexels-photo-1562477.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=3&amp;h=750&amp;w=1260&gt;&quot;}: thumbor: Retrieve url</span></div><div class="token-line"><span class="token plain">    Aug 25 15:09:30.950  INFO thumbor: Finished processing: image size 52674</span></div><div class="token-line"><span class="token plain">    Aug 25 15:09:35.037  INFO retrieve_image{url=&quot;&lt;https://images.pexels.com/photos/1562477/pexels-photo-1562477.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=3&amp;h=750&amp;w=1260&gt;&quot;}: thumbor: Match cache 13782279907884137652</span></div><div class="token-line"><span class="token plain">    Aug 25 15:09:35.254  INFO thumbor: Finished processing: image size 52674</span></div></pre></div><p>这个版本目前是一个没有详细优化过的版本，性能已经足够好。而且，像 Thumbor 这样的图片服务，前面还有 CDN（Content Distribution Network）扛压力，只有 CDN 需要回源时，才会访问到，所以也可以不用太优化。</p><p><img src="https://static001.geekbang.org/resource/image/ac/9e/aca9f3e8acdd0e0daf07707c3a73cc9e.jpg?wh=1920x1140" alt="图片"/></p><p>最后来看看目标完成得如何。如果不算 protobuf 生成的代码，Thumbor 这个项目，到目前为止我们写了 324 行代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">❯ tokei src/main.rs src/engine/* src/pb/mod.rs</span></div><div class="token-line"><span class="token plain">    -------------------------------------------------------------------------------</span></div><div class="token-line"><span class="token plain">     Language            Files        Lines         Code     Comments       Blanks</span></div><div class="token-line"><span class="token plain">    -------------------------------------------------------------------------------</span></div><div class="token-line"><span class="token plain">     Rust                    4          394          324           22           48</span></div><div class="token-line"><span class="token plain">    -------------------------------------------------------------------------------</span></div><div class="token-line"><span class="token plain">     Total                   4          394          324           22           48</span></div><div class="token-line"><span class="token plain">    -------------------------------------------------------------------------------</span></div></pre></div><p>三百多行代码就把一个图片服务器的核心部分搞定了，不仅如此，还充分考虑到了架构的可扩展性，用 trait 实现了主要的图片处理流程，并且引入了缓存来避免不必要的网络请求。虽然比我们预期的 200 行代码多了 50% 的代码量，但我相信它进一步佐证了 Rust 强大的表达能力。</p><p>而且，<strong>通过合理使用 protobuf 定义接口和使用 trait 做图片引擎，未来添加新的功能非常简单</strong>，可以像搭积木一样垒上去，不会影响已有的功能，完全符合开闭原则（<a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">Open-Closed Principle<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）。</p><p>作为一门系统级语言，Rust 使用独特的内存管理方案，零成本地帮我们管理内存；作为一门高级语言，Rust 提供了足够强大的类型系统和足够完善的标准库，帮我们很容易写出低耦合、高内聚的代码。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/03#小结"><span class="icon icon-link"></span></a>小结</h2><p>今天讲的 Thumbor 要比上一讲的 HTTPie 难度高一个数量级（完整代码在 <a target="_blank" rel="noopener noreferrer" href="https://github.com/tyrchen/geektime-rust/tree/master/05_thumbor">GitHub repo<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ），所以细节理解不了不打紧，但我相信你会进一步被 Rust 强大的表现力、抽象能力和解决实际问题的能力折服。</p><p>比如说，我们通过 Engine trait 分离了具体的图片处理引擎和主流程，让主流程变得干净清爽；同时在处理 protobuf 生成的数据结构时，大量使用了 From / TryFrom trait 做数据类型的转换，也是一种解耦（关注点分离）的思路。</p><p>听我讲得这么流畅，你是不是觉得我写的时候肯定不会犯错。其实并没有，我在用 axum 写源图获取的流程时，就因为使用 Mutex 的错误而被编译器毒打，花了些时间才解决。</p><p>但这种毒打是非常让人心悦诚服且快乐的，因为我知道，<strong>这样的并发问题一旦泄露到生产环境，解决起来大概率会毫无头绪，只能一点点试错可能有问题的代码</strong>，那个时候代价就远非和编译器搏斗的这十来分钟可比了。</p><p>所以只要你入了门，写 Rust 代码的过程绝对是一种享受，绝大多数错误在编译时就被揪出来了，你的代码只要编译能通过，基本上不需要担心它运行时的正确性。</p><p>也正是因为这样，在前期学习 Rust 的时候编译很难通过，导致我们直观感觉它是一门难学的语言，但其实它又很容易上手。这听起来矛盾，但确实是我自己的感受：它之所以学起来有些费力，有点像讲拉丁语系的人学习中文一样，<strong>要打破很多自己原有的认知，去拥抱新的思想和概念</strong>。但是只要多写多思考，时间长了，理解起来就是水到渠成的事。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/03#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>之前提到通过合理使用 protobuf 定义接口和使用 trait 做图片引擎，未来添加新的功能非常简单。如果你学有余力，可以自己尝试一下。</p><p>我们看如何添加新功能：</p><ul><li>首先添加新的 proto，定义新的 spec</li><li>然后为 spec 实现 SpecTransform trait 和一些辅助函数</li><li>最后在 Engine 中使用 spec</li></ul><p>如果要换图片引擎呢？也很简单：</p><ul><li>添加新的图片引擎，像 Photon 那样，实现 Engine trait 以及为每种 spec 实现 SpecTransform Trait。</li><li>在 main.rs 里使用新的引擎。</li></ul><p>欢迎在留言区分享你的思考，如果你觉得有收获，也欢迎你分享给你身边的朋友，邀他一起挑战。你的 Rust 学习第五次打卡成功，我们下一讲见！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/陈天rust编程第一课/03.基础篇/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:24</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
