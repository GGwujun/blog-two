<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>17｜数据结构：软件系统核心部件哈希表，内存如何布局？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/陈天rust编程第一课/03.基础篇/16" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/陈天rust编程第一课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-two/陈天rust编程第一课/01.开篇词/01"><span>开篇词｜让Rust成为你的下一门主力语言</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/02.前置篇">02.前置篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/02.前置篇/01"><span>01｜内存：值放堆上还是放栈上，这是一个问题</span></a></li><li><a href="/blog-two/陈天rust编程第一课/02.前置篇/02"><span>02｜串讲：编程开发中，那些你需要掌握的基本概念</span></a></li><li><a href="/blog-two/陈天rust编程第一课/02.前置篇/03"><span>加餐｜这个专栏你可以怎么学，以及Rust是否值得学？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课/03.基础篇">03.基础篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/01"><span>03｜初窥门径：从你的第一个Rust程序开始！</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/02"><span>04｜get hands dirty：来写个实用的CLI小工具</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/03"><span>05｜get hands dirty：做一个图片服务器有多难？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/04"><span>06｜get hands dirty：SQL查询工具怎么一鱼多吃？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/05"><span>07｜所有权：值的生杀大权到底在谁手上？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/06"><span>08｜所有权：值的借用是如何工作的？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/07"><span>09｜所有权：一个值可以有多个所有者么？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/08"><span>10｜生命周期：你创建的值究竟能活多久？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/09"><span>11｜内存管理：从创建到消亡，值都经历了什么？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/10"><span>加餐｜愚昧之巅：你的Rust学习常见问题汇总</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/11"><span>12｜类型系统：Rust的类型系统有什么特点？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/12"><span>13｜类型系统：如何使用trait来定义接口？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/13"><span>14｜类型系统：有哪些必须掌握的trait？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/14"><span>15｜数据结构：这些浓眉大眼的结构竟然都是智能指针？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/15"><span>16｜数据结构：Vec、&amp;[T]、Box&lt;[T]&gt; ，你真的了解集合容器么？</span></a></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课/03.基础篇/16"><span>17｜数据结构：软件系统核心部件哈希表，内存如何布局？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/17"><span>18｜错误处理：为什么Rust的错误处理与众不同？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/18"><span>19｜闭包：FnOnce、FnMut和Fn，为什么有这么多类型？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/19"><span>20｜4 Steps ：如何更好地阅读Rust源码？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/20"><span>21｜阶段实操（1）：构建一个简单的KV server-基本流程</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/21"><span>22｜阶段实操（2）：构建一个简单的KV server-基本流程</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/04.期中周">04.期中周</a><ul><li><a href="/blog-two/陈天rust编程第一课/04.期中周/01"><span>加餐｜期中测试：来写一个简单的grep命令行</span></a></li><li><a href="/blog-two/陈天rust编程第一课/04.期中周/02"><span>加餐｜期中测试：参考实现讲解</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇">05.进阶篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/01"><span>23｜类型系统：如何在实战中使用泛型编程？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/02"><span>24｜类型系统：如何在实战中使用trait object？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/03"><span>25｜类型系统：如何围绕trait来设计和架构系统？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/04"><span>加餐｜Rust2021版次问世了！</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/05"><span>26｜阶段实操（3）：构建一个简单的KV server-高级trait技巧</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/06"><span>27｜生态系统：有哪些常有的Rust库可以为我所用？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/07"><span>28｜网络开发（上）：如何使用Rust处理网络请求？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/08"><span>29｜网络开发（下）：如何使用Rust处理网络请求？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/09"><span>30｜Unsafe Rust：如何用C++的方式打开Rust？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/10"><span>31｜FFI：Rust如何和你的语言架起沟通桥梁？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/11"><span>32｜实操项目：使用PyO3开发Python3模块</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇">06.并发篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/01"><span>33｜并发处理（上）：从atomics到Channel，Rust都提供了什么工具？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/02"><span>34｜并发处理（下）：从atomics到Channel，Rust都提供了什么工具？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/03"><span>35｜实操项目：如何实现一个基本的MPSC channel？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/04"><span>用户故事｜绝望之谷：改变从学习开始</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/05"><span>36｜阶段实操（4）：构建一个简单的KV server-网络处理</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/06"><span>37｜阶段实操（5）：构建一个简单的KV server-网络安全</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/07"><span>38｜异步处理：Future是什么？它和async/await是什么关系？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/08"><span>39｜异步处理：async/await内部是怎么实现的？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/09"><span>40｜异步处理：如何处理异步IO？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/10"><span>41｜阶段实操（6）：构建一个简单的KV server-异步处理</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/11"><span>42｜阶段实操（7）：构建一个简单的KV server-如何做大的重构？</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇">07.实战篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/01"><span>43｜生产环境：真实世界下的一个Rust项目包含哪些要素？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/02"><span>44｜数据处理：应用程序和数据如何打交道？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/03"><span>45｜阶段实操（8）：构建一个简单的KV server-配置/测试/监控/CI/CD</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/04"><span>46｜软件架构：如何用Rust架构复杂系统？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/05"><span>大咖助场｜开悟之坡（上）：Rust的现状、机遇与挑战</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/06"><span>大咖助场｜开悟之坡（下）：Rust的现状、机遇与挑战</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/07"><span>用户故事｜语言不仅是工具，还是思维方式</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/08.高级篇">08.高级篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/08.高级篇/01"><span>加餐｜代码即数据：为什么我们需要宏编程能力？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/08.高级篇/02"><span>加餐｜宏编程（上）：用最“笨”的方式撰写宏</span></a></li><li><a href="/blog-two/陈天rust编程第一课/08.高级篇/03"><span>加餐｜宏编程（下）：用 syn/quote 优雅地构建宏</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/09.结束语">09.结束语</a><ul><li><a href="/blog-two/陈天rust编程第一课/09.结束语/01"><span>结束语｜永续之原：Rust学习，如何持续精进？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/09.结束语/02"><span>期末测试｜来赴一场满分之约！</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊">10.学习锦囊</a><ul><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊/01"><span>特别策划｜学习锦囊（一）：听听课代表们怎么说</span></a></li><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊/02"><span>特别策划｜学习锦囊（二）：听听课代表们怎么说</span></a></li><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊/03"><span>特别策划｜学习锦囊（三）：听听课代表们怎么说</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/summary">陈天rust编程第一课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="Rust 的哈希表" data-depth="2"><a href="/blog-two/陈天rust编程第一课/03.基础篇/16#rust-的哈希表"><span>Rust 的哈希表</span></a></li><li title="如何解决冲突？" data-depth="3"><a href="/blog-two/陈天rust编程第一课/03.基础篇/16#如何解决冲突"><span>如何解决冲突？</span></a></li><li title="HashMap 的数据结构" data-depth="3"><a href="/blog-two/陈天rust编程第一课/03.基础篇/16#hashmap-的数据结构"><span>HashMap 的数据结构</span></a></li><li title="HashMap 的基本使用方法" data-depth="3"><a href="/blog-two/陈天rust编程第一课/03.基础篇/16#hashmap-的基本使用方法"><span>HashMap 的基本使用方法</span></a></li><li title="HashMap 的内存布局" data-depth="2"><a href="/blog-two/陈天rust编程第一课/03.基础篇/16#hashmap-的内存布局"><span>HashMap 的内存布局</span></a></li><li title="ctrl 表" data-depth="3"><a href="/blog-two/陈天rust编程第一课/03.基础篇/16#ctrl-表"><span>ctrl 表</span></a></li><li title="哈希表重新分配与增长" data-depth="3"><a href="/blog-two/陈天rust编程第一课/03.基础篇/16#哈希表重新分配与增长"><span>哈希表重新分配与增长</span></a></li><li title="删除一个值" data-depth="3"><a href="/blog-two/陈天rust编程第一课/03.基础篇/16#删除一个值"><span>删除一个值</span></a></li><li title="让自定义的数据结构做 Hash key" data-depth="3"><a href="/blog-two/陈天rust编程第一课/03.基础篇/16#让自定义的数据结构做-hash-key"><span>让自定义的数据结构做 Hash key</span></a></li><li title="HashSet / BTreeMap / BTreeSet" data-depth="2"><a href="/blog-two/陈天rust编程第一课/03.基础篇/16#hashset--btreemap--btreeset"><span>HashSet / BTreeMap / BTreeSet</span></a></li><li title="小结" data-depth="2"><a href="/blog-two/陈天rust编程第一课/03.基础篇/16#小结"><span>小结</span></a></li><li title="思考题" data-depth="3"><a href="/blog-two/陈天rust编程第一课/03.基础篇/16#思考题"><span>思考题</span></a></li><li title="参考资料" data-depth="3"><a href="/blog-two/陈天rust编程第一课/03.基础篇/16#参考资料"><span>参考资料</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="17数据结构软件系统核心部件哈希表内存如何布局"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/16#17数据结构软件系统核心部件哈希表内存如何布局"><span class="icon icon-link"></span></a>17｜数据结构：软件系统核心部件哈希表，内存如何布局？</h1><p>你好，我是陈天。</p><p>上一讲我们深入学习了切片，对比了数组、列表、字符串和它们的切片以及切片引用的关系。今天就继续讲 Rust 里另一个非常重要的集合容器：HashMap，也就是哈希表。</p><p>如果谈论软件开发中最重要、出镜率最高的数据结构，那哈希表一定位列其中。很多编程语言甚至将哈希表作为一种内置的数据结构，做进了语言的核心。比如 PHP 的关联数组（associate array）、Python 的字典（dict）、JavaScript 的对象（object）和 Map。</p><p>Google 的工程师Matt Kulukundis 在 <a target="_blank" rel="noopener noreferrer" href="https://youtu.be/ncHmEUmJZf4?t=210">cppCon 2017<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 做的一个演讲，说：全世界 Google 的服务器上 1% 的 CPU 时间用来做哈希表的计算，超过 4% 的内存用来存储哈希表。足以证明哈希表的重要性。</p><p>我们知道，哈希表和列表类似，都用于处理需要随机访问的数据结构。如果数据结构的输入和输出能一一对应，那么可以使用列表，如果无法一一对应，那么就需要使用哈希表。<br/><img src="https://static001.geekbang.org/resource/image/4e/83/4e0c043a82e29886cd7b8e1dd79a5183.jpg?wh=2364x1304" alt=""/></p><h2 id="rust-的哈希表"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/16#rust-的哈希表"><span class="icon icon-link"></span></a>Rust 的哈希表</h2><p>那 Rust 为我们提供了什么样的哈希表呢？它长什么样？性能如何？我们从官方文档学起。</p><p>如果你打开 <a target="_blank" rel="noopener noreferrer" href="https://doc.rust-lang.org/std/collections/struct.HashMap.html">HashMap<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的文档，会看到这样一句话：</p><blockquote><p>A hash map implemented with <strong>quadratic probing</strong> and <strong>SIMD lookup</strong>.</p></blockquote><p>这一看就有点肾上腺素上升了，出现了两个高端词汇：二次探查（quadratic probing）和 SIMD 查表（SIMD lookup），都是什么意思？它们是Rust哈希表算法的设计核心，我们今天的学习也会围绕着这两个词展开，所以别着急，等学完相信你会理解这句话的。</p><p>先把基础理论扫一遍。哈希表最核心的特点就是：**巨量的可能输入和有限的哈希表容量。**这就会引发哈希冲突，也就是两个或者多个输入的哈希被映射到了同一个位置，所以我们要能够处理哈希冲突。</p><p>要解决冲突，首先可以通过更好的、分布更均匀的哈希函数，以及使用更大的哈希表来缓解冲突，但无法完全解决，所以我们还需要使用冲突解决机制。</p><h3 id="如何解决冲突"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/16#如何解决冲突"><span class="icon icon-link"></span></a>如何解决冲突？</h3><p>理论上，主要的冲突解决机制有链地址法（chaining）和开放寻址法（open addressing）。</p><p>链地址法，我们比较熟悉，就是把落在同一个哈希上的数据用单链表或者双链表连接起来。这样在查找的时候，先找到对应的哈希桶（hash bucket），然后再在冲突链上挨个比较，直到找到匹配的项：<img src="https://static001.geekbang.org/resource/image/a3/5d/a3334e4a3259e0bd231815a486b7c45d.jpg?wh=2364x1610" alt=""/></p><p>冲突链处理哈希冲突非常直观，很容易理解和撰写代码，但缺点是哈希表和冲突链使用了不同的内存，对缓存不友好。</p><p>开放寻址法把整个哈希表看做一个大数组，不引入额外的内存，当冲突产生时，按照一定的规则把数据插入到其它空闲的位置。比如线性探寻（linear probing）在出现哈希冲突时，不断往后探寻，直到找到空闲的位置插入。</p><p>而<strong>二次探查</strong>，理论上是在冲突发生时，不断探寻哈希位置加减 n 的二次方，找到空闲的位置插入，我们看图，更容易理解：<br/><img src="https://static001.geekbang.org/resource/image/42/4e/42a18970ac2eec7510c69c1f8323bc4e.jpg?wh=2364x1304" alt=""/>（图中示意是理论上的处理方法，实际为了性能会有很多不同的处理。）</p><p>开放寻址还有其它方案，比如二次哈希什么的，今天就不详细介绍了。</p><p>好，搞明白哈希表的二次探查的理论知识，我们可以推测，Rust 哈希表不是用冲突链来解决哈希冲突，而是用开放寻址法的二次探查来解决的。当然，后面会讲到 Rust 的二次探查和理论的处理方式有些差别。</p><p>而另一个关键词，使用 SIMD 做单指令多数据的查表，也和一会要讲到 Rust 哈希表巧妙的内存布局息息相关。</p><h3 id="hashmap-的数据结构"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/16#hashmap-的数据结构"><span class="icon icon-link"></span></a>HashMap 的数据结构</h3><p>进入正题，我们来看看 Rust 哈希表的数据结构是什么样子的，打开标准库的 <a target="_blank" rel="noopener noreferrer" href="https://doc.rust-lang.org/src/std/collections/hash/map.rs.html#206-208">源代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use hashbrown::hash_map as base;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #[derive(Clone)]</span></div><div class="token-line"><span class="token plain">    pub struct RandomState {</span></div><div class="token-line"><span class="token plain">        k0: u64,</span></div><div class="token-line"><span class="token plain">        k1: u64,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    pub struct HashMap&lt;K, V, S = RandomState&gt; {</span></div><div class="token-line"><span class="token plain">        base: base::HashMap&lt;K, V, S&gt;,</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，HashMap 有三个泛型参数，K 和 V 代表 key / value 的类型，S 是哈希算法的状态，它默认是 RandomState，占两个 u64。RandomState 使用 SipHash 作为缺省的哈希算法，它是一个加密安全的哈希函数（cryptographically secure hashing）。</p><p>从定义中还能看到，Rust 的 HashMap 复用了 hashbrown 的 HashMap。hashbrown 是 Rust 下对 <a target="_blank" rel="noopener noreferrer" href="https://abseil.io/blog/20180927-swisstables">Google Swiss Table<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的一个改进版实现，我们打开 hashbrown 的代码，看它的<a target="_blank" rel="noopener noreferrer" href="https://docs.rs/hashbrown/0.11.2/src/hashbrown/map.rs.html#192-195">结构<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pub struct HashMap&lt;K, V, S = DefaultHashBuilder, A: Allocator + Clone = Global&gt; {</span></div><div class="token-line"><span class="token plain">        pub(crate) hash_builder: S,</span></div><div class="token-line"><span class="token plain">        pub(crate) table: RawTable&lt;(K, V), A&gt;,</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，HashMap 里有两个域，一个是 hash_builder，类型是刚才我们提到的标准库使用的 RandomState，还有一个是具体的 RawTable：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pub struct RawTable&lt;T, A: Allocator + Clone = Global&gt; {</span></div><div class="token-line"><span class="token plain">        table: RawTableInner&lt;A&gt;,</span></div><div class="token-line"><span class="token plain">        // Tell dropck that we own instances of T.</span></div><div class="token-line"><span class="token plain">        marker: PhantomData&lt;T&gt;,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    struct RawTableInner&lt;A&gt; {</span></div><div class="token-line"><span class="token plain">        // Mask to get an index from a hash value. The value is one less than the</span></div><div class="token-line"><span class="token plain">        // number of buckets in the table.</span></div><div class="token-line"><span class="token plain">        bucket_mask: usize,</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // [Padding], T1, T2, ..., Tlast, C1, C2, ...</span></div><div class="token-line"><span class="token plain">        //                                ^ points here</span></div><div class="token-line"><span class="token plain">        ctrl: NonNull&lt;u8&gt;,</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // Number of elements that can be inserted before we need to grow the table</span></div><div class="token-line"><span class="token plain">        growth_left: usize,</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // Number of elements in the table, only really used by len()</span></div><div class="token-line"><span class="token plain">        items: usize,</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        alloc: A,</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>RawTable 中，实际上有意义的数据结构是 RawTableInner，前四个字段很重要，我们一会讲HashMap的内存布局会再提到：</p><ul><li>usize 的 bucket_mask，是哈希表中哈希桶的数量减一；</li><li>名字叫 ctrl 的指针，它指向哈希表堆内存末端的 ctrl 区；</li><li>usize 的字段 growth_left，指哈希表在下次自动增长前还能存储多少数据；</li><li>usize 的 items，表明哈希表现在有多少数据。</li></ul><p>这里最后的 alloc 字段，和 RawTable 的 marker 一样，只是一个用来占位的类型，我们现在只需知道，它用来分配在堆上的内存。</p><h3 id="hashmap-的基本使用方法"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/16#hashmap-的基本使用方法"><span class="icon icon-link"></span></a>HashMap 的基本使用方法</h3><p>数据结构搞清楚，我们再看具体使用方法。Rust 哈希表的使用很简单，它提供了一系列很方便的方法，使用起来和其它语言非常类似，你只要看看<a target="_blank" rel="noopener noreferrer" href="https://doc.rust-lang.org/std/collections/struct.HashMap.html">文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，就很容易理解。我们来写段代码，尝试一下（<a target="_blank" rel="noopener noreferrer" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=a0543e873c9b6ecb49f56755493dc968">代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use std::collections::HashMap;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fn main() {</span></div><div class="token-line"><span class="token plain">        let mut map = HashMap::new();</span></div><div class="token-line"><span class="token plain">        explain(&quot;empty&quot;, &amp;map);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        map.insert(&#x27;a&#x27;, 1);</span></div><div class="token-line"><span class="token plain">        explain(&quot;added 1&quot;, &amp;map);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        map.insert(&#x27;b&#x27;, 2);</span></div><div class="token-line"><span class="token plain">        map.insert(&#x27;c&#x27;, 3);</span></div><div class="token-line"><span class="token plain">        explain(&quot;added 3&quot;, &amp;map);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        map.insert(&#x27;d&#x27;, 4);</span></div><div class="token-line"><span class="token plain">        explain(&quot;added 4&quot;, &amp;map);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // get 时需要使用引用，并且也返回引用</span></div><div class="token-line"><span class="token plain">        assert_eq!(map.get(&amp;&#x27;a&#x27;), Some(&amp;1));</span></div><div class="token-line"><span class="token plain">        assert_eq!(map.get_key_value(&amp;&#x27;b&#x27;), Some((&amp;&#x27;b&#x27;, &amp;2)));</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        map.remove(&amp;&#x27;a&#x27;);</span></div><div class="token-line"><span class="token plain">        // 删除后就找不到了</span></div><div class="token-line"><span class="token plain">        assert_eq!(map.contains_key(&amp;&#x27;a&#x27;), false);</span></div><div class="token-line"><span class="token plain">        assert_eq!(map.get(&amp;&#x27;a&#x27;), None);</span></div><div class="token-line"><span class="token plain">        explain(&quot;removed&quot;, &amp;map);</span></div><div class="token-line"><span class="token plain">        // shrink 后哈希表变小</span></div><div class="token-line"><span class="token plain">        map.shrink_to_fit();</span></div><div class="token-line"><span class="token plain">        explain(&quot;shrinked&quot;, &amp;map);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fn explain&lt;K, V&gt;(name: &amp;str, map: &amp;HashMap&lt;K, V&gt;) {</span></div><div class="token-line"><span class="token plain">        println!(&quot;{}: len: {}, cap: {}&quot;, name, map.len(), map.capacity());</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>运行这段代码，我们可以看到这样的输出：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">empty: len: 0, cap: 0</span></div><div class="token-line"><span class="token plain">    added 1: len: 1, cap: 3</span></div><div class="token-line"><span class="token plain">    added 3: len: 3, cap: 3</span></div><div class="token-line"><span class="token plain">    added 4: len: 4, cap: 7</span></div><div class="token-line"><span class="token plain">    removed: len: 3, cap: 7</span></div><div class="token-line"><span class="token plain">    shrinked: len: 3, cap: 3</span></div></pre></div><p>可以看到，当 HashMap::new() 时，它并没有分配空间，容量为零，<strong>随着哈希表不断插入数据，它会以 2的幂减一的方式增长</strong>，最小是 3。当删除表中的数据时，原有的表大小不变，只有显式地调用 shrink_to_fit，才会让哈希表变小。</p><h2 id="hashmap-的内存布局"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/16#hashmap-的内存布局"><span class="icon icon-link"></span></a>HashMap 的内存布局</h2><p>但是通过 HashMap 的公开接口，我们无法看到 HashMap 在内存中是如何布局的，还是需要借助之前使用过的 std::mem::transmute 方法，来把数据结构打出来。我们把刚才的代码改一改（<a target="_blank" rel="noopener noreferrer" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=40a71cd4e349369e7255f173578ec9ae">代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use std::collections::HashMap;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fn main() {</span></div><div class="token-line"><span class="token plain">        let map = HashMap::new();</span></div><div class="token-line"><span class="token plain">        let mut map = explain(&quot;empty&quot;, map);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        map.insert(&#x27;a&#x27;, 1);</span></div><div class="token-line"><span class="token plain">        let mut map = explain(&quot;added 1&quot;, map);</span></div><div class="token-line"><span class="token plain">        map.insert(&#x27;b&#x27;, 2);</span></div><div class="token-line"><span class="token plain">        map.insert(&#x27;c&#x27;, 3);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        let mut map = explain(&quot;added 3&quot;, map);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        map.insert(&#x27;d&#x27;, 4);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        let mut map = explain(&quot;added 4&quot;, map);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        map.remove(&amp;&#x27;a&#x27;);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        explain(&quot;final&quot;, map);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // HashMap 结构有两个 u64 的 RandomState，然后是四个 usize，</span></div><div class="token-line"><span class="token plain">    // 分别是 bucket_mask, ctrl, growth_left 和 items</span></div><div class="token-line"><span class="token plain">    // 我们 transmute 打印之后，再 transmute 回去</span></div><div class="token-line"><span class="token plain">    fn explain&lt;K, V&gt;(name: &amp;str, map: HashMap&lt;K, V&gt;) -&gt; HashMap&lt;K, V&gt; {</span></div><div class="token-line"><span class="token plain">        let arr: [usize; 6] = unsafe { std::mem::transmute(map) };</span></div><div class="token-line"><span class="token plain">        println!(</span></div><div class="token-line"><span class="token plain">            &quot;{}: bucket_mask 0x{:x}, ctrl 0x{:x}, growth_left: {}, items: {}&quot;,</span></div><div class="token-line"><span class="token plain">            name, arr[2], arr[3], arr[4], arr[5]</span></div><div class="token-line"><span class="token plain">        );</span></div><div class="token-line"><span class="token plain">        unsafe { std::mem::transmute(arr) }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>运行之后，可以看到：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">empty: bucket_mask 0x0, ctrl 0x1056df820, growth_left: 0, items: 0</span></div><div class="token-line"><span class="token plain">    added 1: bucket_mask 0x3, ctrl 0x7fa0d1405e30, growth_left: 2, items: 1</span></div><div class="token-line"><span class="token plain">    added 3: bucket_mask 0x3, ctrl 0x7fa0d1405e30, growth_left: 0, items: 3</span></div><div class="token-line"><span class="token plain">    added 4: bucket_mask 0x7, ctrl 0x7fa0d1405e90, growth_left: 3, items: 4</span></div><div class="token-line"><span class="token plain">    final: bucket_mask 0x7, ctrl 0x7fa0d1405e90, growth_left: 4, items: 3</span></div></pre></div><p>有意思，我们发现在运行的过程中，ctrl 对应的堆地址发生了改变。</p><p>在我的 OS X 下，一开始哈希表为空，ctrl 地址看上去是一个 TEXT/RODATA 段的地址，应该是指向了一个默认的空表地址；插入第一个数据后，哈希表分配了 4 个 bucket，ctrl 地址发生改变；在插入三个数据后，growth_left 为零，再插入时，哈希表重新分配，ctrl 地址继续改变。</p><p>刚才在探索 HashMap 数据结构时，说过 ctrl 是一个指向哈希表堆地址末端 ctrl 区的地址，所以我们可以通过这个地址，计算出哈希表堆地址的起始地址。</p><p>因为哈希表有 8 个 bucket（0x7 + 1），每个 bucket 大小是 key（char） + value（i32） 的大小，也就是 8 个字节，所以一共是 64 个字节。对于这个例子，<strong>通过 ctrl 地址减去 64，就可以得到哈希表的堆内存起始地址</strong>。然后，我们可以用 rust-gdb / rust-lldb 来打印这个内存（如果你对 rust-gdb / rust-lldb 感兴趣，可以看文末的参考阅读）。</p><p>这里我用 Linux 下的 rust-gdb 设置断点，依次查看哈希表有一个、三个、四个值，以及删除一个值的状态：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">❯ rust-gdb ~/.target/debug/hashmap2</span></div><div class="token-line"><span class="token plain">    GNU gdb (Ubuntu 9.2-0ubuntu2) 9.2</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    (gdb) b hashmap2.rs:32</span></div><div class="token-line"><span class="token plain">    Breakpoint 1 at 0xa43e: file src/hashmap2.rs, line 32.</span></div><div class="token-line"><span class="token plain">    (gdb) r</span></div><div class="token-line"><span class="token plain">    Starting program: /home/tchen/.target/debug/hashmap2</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    # 最初的状态，哈希表为空</span></div><div class="token-line"><span class="token plain">    empty: bucket_mask 0x0, ctrl 0x555555597be0, growth_left: 0, items: 0</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Breakpoint 1, hashmap2::explain (name=..., map=...) at src/hashmap2.rs:32</span></div><div class="token-line"><span class="token plain">    32	    unsafe { std::mem::transmute(arr) }</span></div><div class="token-line"><span class="token plain">    (gdb) c</span></div><div class="token-line"><span class="token plain">    Continuing.</span></div><div class="token-line"><span class="token plain">    # 插入了一个元素后，bucket 有 4 个（0x3+1），堆地址起始位置 0x5555555a7af0 - 4*8(0x20)</span></div><div class="token-line"><span class="token plain">    added 1: bucket_mask 0x3, ctrl 0x5555555a7af0, growth_left: 2, items: 1</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Breakpoint 1, hashmap2::explain (name=..., map=...) at src/hashmap2.rs:32</span></div><div class="token-line"><span class="token plain">    32	    unsafe { std::mem::transmute(arr) }</span></div><div class="token-line"><span class="token plain">    (gdb) x /12x 0x5555555a7ad0</span></div><div class="token-line"><span class="token plain">    0x5555555a7ad0:	0x00000061	0x00000001	0x00000000	0x00000000</span></div><div class="token-line"><span class="token plain">    0x5555555a7ae0:	0x00000000	0x00000000	0x00000000	0x00000000</span></div><div class="token-line"><span class="token plain">    0x5555555a7af0:	0x0affffff	0xffffffff	0xffffffff	0xffffffff</span></div><div class="token-line"><span class="token plain">    (gdb) c</span></div><div class="token-line"><span class="token plain">    Continuing.</span></div><div class="token-line"><span class="token plain">    # 插入了三个元素后，哈希表没有剩余空间，堆地址起始位置不变 0x5555555a7af0 - 4*8(0x20)</span></div><div class="token-line"><span class="token plain">    added 3: bucket_mask 0x3, ctrl 0x5555555a7af0, growth_left: 0, items: 3</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Breakpoint 1, hashmap2::explain (name=..., map=...) at src/hashmap2.rs:32</span></div><div class="token-line"><span class="token plain">    32	    unsafe { std::mem::transmute(arr) }</span></div><div class="token-line"><span class="token plain">    (gdb) x /12x 0x5555555a7ad0</span></div><div class="token-line"><span class="token plain">    0x5555555a7ad0:	0x00000061	0x00000001	0x00000062	0x00000002</span></div><div class="token-line"><span class="token plain">    0x5555555a7ae0:	0x00000000	0x00000000	0x00000063	0x00000003</span></div><div class="token-line"><span class="token plain">    0x5555555a7af0:	0x0a72ff02	0xffffffff	0xffffffff	0xffffffff</span></div><div class="token-line"><span class="token plain">    (gdb) c</span></div><div class="token-line"><span class="token plain">    Continuing.</span></div><div class="token-line"><span class="token plain">    # 插入第四个元素后，哈希表扩容，堆地址起始位置变为 0x5555555a7b50 - 8*8(0x40)</span></div><div class="token-line"><span class="token plain">    added 4: bucket_mask 0x7, ctrl 0x5555555a7b50, growth_left: 3, items: 4</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Breakpoint 1, hashmap2::explain (name=..., map=...) at src/hashmap2.rs:32</span></div><div class="token-line"><span class="token plain">    32	    unsafe { std::mem::transmute(arr) }</span></div><div class="token-line"><span class="token plain">    (gdb) x /20x 0x5555555a7b10</span></div><div class="token-line"><span class="token plain">    0x5555555a7b10:	0x00000061	0x00000001	0x00000000	0x00000000</span></div><div class="token-line"><span class="token plain">    0x5555555a7b20:	0x00000064	0x00000004	0x00000063	0x00000003</span></div><div class="token-line"><span class="token plain">    0x5555555a7b30:	0x00000000	0x00000000	0x00000062	0x00000002</span></div><div class="token-line"><span class="token plain">    0x5555555a7b40:	0x00000000	0x00000000	0x00000000	0x00000000</span></div><div class="token-line"><span class="token plain">    0x5555555a7b50:	0xff72ffff	0x0aff6502	0xffffffff	0xffffffff</span></div><div class="token-line"><span class="token plain">    (gdb) c</span></div><div class="token-line"><span class="token plain">    Continuing.</span></div><div class="token-line"><span class="token plain">    # 删除 a 后，剩余 4 个位置。注意 ctrl bit 的变化，以及 0x61 0x1 并没有被清除</span></div><div class="token-line"><span class="token plain">    final: bucket_mask 0x7, ctrl 0x5555555a7b50, growth_left: 4, items: 3</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Breakpoint 1, hashmap2::explain (name=..., map=...) at src/hashmap2.rs:32</span></div><div class="token-line"><span class="token plain">    32	    unsafe { std::mem::transmute(arr) }</span></div><div class="token-line"><span class="token plain">    (gdb) x /20x 0x5555555a7b10</span></div><div class="token-line"><span class="token plain">    0x5555555a7b10:	0x00000061	0x00000001	0x00000000	0x00000000</span></div><div class="token-line"><span class="token plain">    0x5555555a7b20:	0x00000064	0x00000004	0x00000063	0x00000003</span></div><div class="token-line"><span class="token plain">    0x5555555a7b30:	0x00000000	0x00000000	0x00000062	0x00000002</span></div><div class="token-line"><span class="token plain">    0x5555555a7b40:	0x00000000	0x00000000	0x00000000	0x00000000</span></div><div class="token-line"><span class="token plain">    0x5555555a7b50:	0xff72ffff	0xffff6502	0xffffffff	0xffffffff</span></div></pre></div><p>这段输出蕴藏了很多信息，我们结合示意图来仔细梳理。</p><p>首先，插入第一个元素 ‘a’: 1 后，哈希表的内存布局如下：<img src="https://static001.geekbang.org/resource/image/d1/87/d126ceb74605b168d36bc1e83d4c9e87.jpg?wh=2364x1762" alt=""/></p><p>key ‘a’ 的 hash 和 bucket_mask 0x3 运算后得到第 0 个位置插入。同时，这个 hash 的头 7 位取出来，在 ctrl 表中对应的位置，也就是第 0 个字节，把这个值写入。</p><p>要理解这个步骤，关键就是要搞清楚这个 ctrl 表是什么。</p><h3 id="ctrl-表"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/16#ctrl-表"><span class="icon icon-link"></span></a>ctrl 表</h3><p>ctrl 表的主要目的是快速查找。它的设计非常优雅，值得我们学习。</p><p>一张 ctrl 表里，有若干个 128bit 或者说 16 个字节的分组（group），group 里的每个字节叫 ctrl byte，对应一个 bucket，那么一个 group 对应 16 个 bucket。如果一个 bucket 对应的 ctrl byte 首位不为 1，就表示这个 ctrl byte 被使用；如果所有位都是 1，或者说这个字节是 0xff，那么它是空闲的。</p><p>一组 control byte 的整个 128 bit 的数据，可以通过一条指令被加载进来，然后和某个值进行 mask，找到它所在的位置。这就是一开始提到的<strong>SIMD 查表</strong>。</p><p>我们知道，现代 CPU 都支持单指令多数据集的操作，而Rust 充分利用了 CPU 这种能力，一条指令可以让多个相关的数据载入到缓存中处理，大大加快查表的速度。所以，Rust 的哈希表查询的效率非常高。</p><p>具体怎么操作，我们来看 HashMap 是如何通过 ctrl 表来进行数据查询的。假设这张表里已经添加了一些数据，我们现在要查找 key 为 ‘c’ 的数据：</p><ol><li>首先对 ‘c’ 做哈希，得到一个哈希值 h；</li><li>把 h 跟 bucket_mask 做与，得到一个值，图中是 139；</li><li>拿着这个 139，找到对应的 ctrl group 的起始位置，因为 ctrl group 以 16 为一组，所以这里找到 128；</li><li>用 SIMD 指令加载从 128 对应地址开始的 16 个字节；</li><li>对 hash 取头 7 个 bit，然后和刚刚取出的 16 个字节一起做与，找到对应的匹配，如果找到了，它（们）很大概率是要找的值；</li><li>如果不是，那么以二次探查（以 16 的倍数不断累积）的方式往后查找，直到找到为止。</li></ol><p>你可以结合下图理解这个算法：<img src="https://static001.geekbang.org/resource/image/d2/60/d2a3cc569c9a9b0728a659c030eb6560.jpg?wh=2364x1762" alt=""/></p><p>所以，当 HashMap 插入和删除数据，以及因此导致重新分配的时候，主要工作就是在维护这张 ctrl 表和数据的对应。</p><p>因为 ctrl 表是所有操作最先触及的内存，所以，在 HashMap 的结构中，<strong>堆内存的指针直接指向 ctrl 表</strong>，而不是指向堆内存的起始位置，这样可以减少一次内存的访问。</p><h3 id="哈希表重新分配与增长"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/16#哈希表重新分配与增长"><span class="icon icon-link"></span></a>哈希表重新分配与增长</h3><p>好，回到刚才讲的内存布局继续说。在插入第一条数据后，我们的哈希表只有 4 个 bucket，所以只有头 4 个字节的 ctrl 表有用。随着哈希表的增长，bucket 不够，就会导致重新分配。由于 bucket_mask 永远比 bucket 数量少 1，所以插入三个元素后就会重新分配。</p><p>根据 rust-gdb 中得到的信息，我们看插入三个元素后没有剩余空间的哈希表，在加入 ‘d’: 4 时，是如何增长的。</p><p>首先，<strong>哈希表会按幂扩容</strong>，从 4 个 bucket 扩展到 8 个 bucket。</p><p>这会导致分配新的堆内存，然后原来的 ctrl table 和对应的kv数据会被移动到新的内存中。这个例子里因为 char 和 i32 实现了 Copy trait，所以是拷贝；如果 key 的类型是 String，那么只有 String 的 24 个字节 (ptr|cap|len) 的结构被移动，String 的实际内存不需要变动。</p><p>在移动的过程中，会涉及<strong>哈希的重分配</strong>。从下图可以看到，‘a’ / ‘c’ 的相对位置和它们的 ctrl byte 没有变化，但重新做 hash 后，‘b’ 的 ctrl byte 和位置都发生了变化：<br/><img src="https://static001.geekbang.org/resource/image/ec/e0/ec62494f0c576f932c9716195a1ba6e0.jpg?wh=2364x1762" alt=""/></p><h3 id="删除一个值"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/16#删除一个值"><span class="icon icon-link"></span></a>删除一个值</h3><p>明白了哈希表是如何增长的，我们再来看删除的时候会发生什么。</p><p>当要在哈希表中删除一个值时，整个过程和查找类似，先要找到要被删除的 key 所在的位置。在找到具体位置后，<strong>并不需要实际清除内存，只需要将它的 ctrl byte 设回 0xff</strong>（或者标记成删除状态）。这样，这个 bucket 就可以被再次使用了：<br/><img src="https://static001.geekbang.org/resource/image/82/9e/828f746528039b15b8601ee6f8cdd79e.jpg?wh=2364x1762" alt=""/></p><p>这里有一个问题，当 key/value 有额外的内存时，比如 String，它的内存不会立即回收，只有在下一次对应的 bucket 被使用时，让 HashMap 不再拥有这个 String 的所有权之后，这个 String 的内存才被回收。我们看下面的示意图：<br/><img src="https://static001.geekbang.org/resource/image/0d/4d/0d191c99c4201bb88fb5a11d70a9434d.jpg?wh=2364x1304" alt=""/></p><p>一般来说，这并不会带来什么问题，顶多是内存占用率稍高一些。但某些极端情况下，比如在哈希表中添加大量内容，又删除大量内容后运行，这时你可以通过 shrink_to_fit / shrink_to 释放掉不需要的内存。</p><h3 id="让自定义的数据结构做-hash-key"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/16#让自定义的数据结构做-hash-key"><span class="icon icon-link"></span></a>让自定义的数据结构做 Hash key</h3><p>有时候，我们需要让自定义的数据结构成为 HashMap 的 key。此时，要使用到三个 trait：<a target="_blank" rel="noopener noreferrer" href="https://doc.rust-lang.org/std/hash/trait.Hash.html">Hash<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a target="_blank" rel="noopener noreferrer" href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html">PartialEq<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a target="_blank" rel="noopener noreferrer" href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">Eq<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，不过这三个 trait 都可以通过派生宏自动生成。其中：</p><ul><li>实现了 Hash ，可以让数据结构计算哈希；</li><li>实现了 PartialEq/Eq，可以让数据结构进行相等和不相等的比较。Eq 实现了比较的自反性（a == a）、对称性（a == b 则 b == a）以及传递性（a == b，b == c，则 a == c），PartialEq 没有实现自反性。</li></ul><p>我们可以写个例子，看看自定义数据结构如何支持 HashMap：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use std::{</span></div><div class="token-line"><span class="token plain">        collections::{hash_map::DefaultHasher, HashMap},</span></div><div class="token-line"><span class="token plain">        hash::{Hash, Hasher},</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 如果要支持 Hash，可以用 #[derive(Hash)]，前提是每个字段都实现了 Hash</span></div><div class="token-line"><span class="token plain">    // 如果要能作为 HashMap 的 key，还需要 PartialEq 和 Eq</span></div><div class="token-line"><span class="token plain">    #[derive(Debug, Hash, PartialEq, Eq)]</span></div><div class="token-line"><span class="token plain">    struct Student&lt;&#x27;a&gt; {</span></div><div class="token-line"><span class="token plain">        name: &amp;&#x27;a str,</span></div><div class="token-line"><span class="token plain">        age: u8,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl&lt;&#x27;a&gt; Student&lt;&#x27;a&gt; {</span></div><div class="token-line"><span class="token plain">        pub fn new(name: &amp;&#x27;a str, age: u8) -&gt; Self {</span></div><div class="token-line"><span class="token plain">            Self { name, age }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    fn main() {</span></div><div class="token-line"><span class="token plain">        let mut hasher = DefaultHasher::new();</span></div><div class="token-line"><span class="token plain">        let student = Student::new(&quot;Tyr&quot;, 18);</span></div><div class="token-line"><span class="token plain">        // 实现了 Hash 的数据结构可以直接调用 hash 方法</span></div><div class="token-line"><span class="token plain">        student.hash(&amp;mut hasher);</span></div><div class="token-line"><span class="token plain">        let mut map = HashMap::new();</span></div><div class="token-line"><span class="token plain">        // 实现了 Hash / PartialEq / Eq 的数据结构可以作为 HashMap 的 key</span></div><div class="token-line"><span class="token plain">        map.insert(student, vec![&quot;Math&quot;, &quot;Writing&quot;]);</span></div><div class="token-line"><span class="token plain">        println!(&quot;hash: 0x{:x}, map: {:?}&quot;, hasher.finish(), map);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h2 id="hashset--btreemap--btreeset"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/16#hashset--btreemap--btreeset"><span class="icon icon-link"></span></a>HashSet / BTreeMap / BTreeSet</h2><p>最后我们简单讲讲和 HashMap 相关的其它几个数据结构。</p><p>有时我们只需要简单确认元素是否在集合中，如果用 HashMap 就有些浪费空间了。这时可以用HashSet，它就是简化的 HashMap，可以用来存放无序的集合，定义直接是 HashMap&lt;K, ()&gt;：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use hashbrown::hash_set as base;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    pub struct HashSet&lt;T, S = RandomState&gt; {</span></div><div class="token-line"><span class="token plain">        base: base::HashSet&lt;T, S&gt;,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    pub struct HashSet&lt;T, S = DefaultHashBuilder, A: Allocator + Clone = Global&gt; {</span></div><div class="token-line"><span class="token plain">        pub(crate) map: HashMap&lt;T, (), S, A&gt;,</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>使用 HashSet 查看一个元素是否属于集合的效率非常高。</p><p>另一个和 HashMap 一样常用的数据结构就是BTreeMap了。BTreeMap 是内部使用 <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/B-tree">B-tree<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 来组织哈希表的数据结构。另外 BTreeSet 和 HashSet 类似，是 BTreeMap 的简化版，可以用来存放有序集合。</p><p>我们这里重点看下BTreeMap，它的数据结构如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pub struct BTreeMap&lt;K, V&gt; {</span></div><div class="token-line"><span class="token plain">        root: Option&lt;Root&lt;K, V&gt;&gt;,</span></div><div class="token-line"><span class="token plain">        length: usize,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    pub type Root&lt;K, V&gt; = NodeRef&lt;marker::Owned, K, V, marker::LeafOrInternal&gt;;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    pub struct NodeRef&lt;BorrowType, K, V, Type&gt; {</span></div><div class="token-line"><span class="token plain">        height: usize,</span></div><div class="token-line"><span class="token plain">        node: NonNull&lt;LeafNode&lt;K, V&gt;&gt;,</span></div><div class="token-line"><span class="token plain">        _marker: PhantomData&lt;(BorrowType, Type)&gt;,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    struct LeafNode&lt;K, V&gt; {</span></div><div class="token-line"><span class="token plain">        parent: Option&lt;NonNull&lt;InternalNode&lt;K, V&gt;&gt;&gt;,</span></div><div class="token-line"><span class="token plain">        parent_idx: MaybeUninit&lt;u16&gt;,</span></div><div class="token-line"><span class="token plain">        len: u16,</span></div><div class="token-line"><span class="token plain">        keys: [MaybeUninit&lt;K&gt;; CAPACITY],</span></div><div class="token-line"><span class="token plain">        vals: [MaybeUninit&lt;V&gt;; CAPACITY],</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    struct InternalNode&lt;K, V&gt; {</span></div><div class="token-line"><span class="token plain">        data: LeafNode&lt;K, V&gt;,</span></div><div class="token-line"><span class="token plain">        edges: [MaybeUninit&lt;BoxedNode&lt;K, V&gt;&gt;; 2 * B],</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>和 HashMap 不同的是，BTreeMap 是有序的。我们看个例子（<a target="_blank" rel="noopener noreferrer" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=711b0bd9ac7dbdd882c4b84809212778">代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）:</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use std::collections::BTreeMap;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fn main() {</span></div><div class="token-line"><span class="token plain">        let map = BTreeMap::new();</span></div><div class="token-line"><span class="token plain">        let mut map = explain(&quot;empty&quot;, map);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for i in 0..16usize {</span></div><div class="token-line"><span class="token plain">            map.insert(format!(&quot;Tyr {}&quot;, i), i);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        let mut map = explain(&quot;added&quot;, map);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        map.remove(&quot;Tyr 1&quot;);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        let map = explain(&quot;remove 1&quot;, map);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for item in map.iter() {</span></div><div class="token-line"><span class="token plain">            println!(&quot;{:?}&quot;, item);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // BTreeMap 结构有 height，node 和 length</span></div><div class="token-line"><span class="token plain">    // 我们 transmute 打印之后，再 transmute 回去</span></div><div class="token-line"><span class="token plain">    fn explain&lt;K, V&gt;(name: &amp;str, map: BTreeMap&lt;K, V&gt;) -&gt; BTreeMap&lt;K, V&gt; {</span></div><div class="token-line"><span class="token plain">        let arr: [usize; 3] = unsafe { std::mem::transmute(map) };</span></div><div class="token-line"><span class="token plain">        println!(</span></div><div class="token-line"><span class="token plain">            &quot;{}: height: {}, root node: 0x{:x}, len: 0x{:x}&quot;,</span></div><div class="token-line"><span class="token plain">            name, arr[0], arr[1], arr[2]</span></div><div class="token-line"><span class="token plain">        );</span></div><div class="token-line"><span class="token plain">        unsafe { std::mem::transmute(arr) }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>它的输出如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">empty: height: 0, root node: 0x0, len: 0x0</span></div><div class="token-line"><span class="token plain">    added: height: 1, root node: 0x7f8286406190, len: 0x10</span></div><div class="token-line"><span class="token plain">    remove 1: height: 1, root node: 0x7f8286406190, len: 0xf</span></div><div class="token-line"><span class="token plain">    (&quot;Tyr 0&quot;, 0)</span></div><div class="token-line"><span class="token plain">    (&quot;Tyr 10&quot;, 10)</span></div><div class="token-line"><span class="token plain">    (&quot;Tyr 11&quot;, 11)</span></div><div class="token-line"><span class="token plain">    (&quot;Tyr 12&quot;, 12)</span></div><div class="token-line"><span class="token plain">    (&quot;Tyr 13&quot;, 13)</span></div><div class="token-line"><span class="token plain">    (&quot;Tyr 14&quot;, 14)</span></div><div class="token-line"><span class="token plain">    (&quot;Tyr 15&quot;, 15)</span></div><div class="token-line"><span class="token plain">    (&quot;Tyr 2&quot;, 2)</span></div><div class="token-line"><span class="token plain">    (&quot;Tyr 3&quot;, 3)</span></div><div class="token-line"><span class="token plain">    (&quot;Tyr 4&quot;, 4)</span></div><div class="token-line"><span class="token plain">    (&quot;Tyr 5&quot;, 5)</span></div><div class="token-line"><span class="token plain">    (&quot;Tyr 6&quot;, 6)</span></div><div class="token-line"><span class="token plain">    (&quot;Tyr 7&quot;, 7)</span></div><div class="token-line"><span class="token plain">    (&quot;Tyr 8&quot;, 8)</span></div><div class="token-line"><span class="token plain">    (&quot;Tyr 9&quot;, 9)</span></div></pre></div><p>可以看到，在遍历时，BTreeMap 会按照 key 的顺序把值打印出来。如果你想让自定义的数据结构可以作为 BTreeMap 的 key，那么需要实现 <a target="_blank" rel="noopener noreferrer" href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html">PartialOrd<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 和 <a target="_blank" rel="noopener noreferrer" href="https://doc.rust-lang.org/std/cmp/trait.Ord.html">Ord<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，这两者的关系和 PartialEq / Eq 类似，PartialOrd 也没有实现自反性。同样的，PartialOrd 和 Ord 也可以通过派生宏来实现。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/16#小结"><span class="icon icon-link"></span></a>小结</h2><p>在学习数据结构的时候，常用数据结构的内存布局和基本算法你一定要理解清楚，对它在不同情况下如何增长，也要尽量做到心里有数。</p><p>这一讲我们花大精力详细学习了 HashMap 的数据结构以及算法的基本思路，算是抛砖引玉。这门课无论多深入讲解，也只能触及 Rust 整个生态圈的九牛一毛，不可能面面俱到。</p><p>我的原则是“授人以鱼不如授人以渔”，在你掌握这样的分析方法后，以后遇到标准库或者第三方库的其它的数据结构，也可以用类似的方法深入探索学习。</p><p>此外，我们程序员学东西，<strong>会用是第一层，知道它是如何设计的是第二层，能够自己写出来才是第三层</strong>。Rust借鉴的 Google Swiss table 算法简单精巧，虽然 hashbrown 在实现时，为了最大化性能和利用 SSE 指令集，使用了很多 unsafe 代码，但我们撰写一个性能不那么好的 safe 版本，并不是复杂的事情，非常推荐你实现一下。</p><p>集合类型我们就暂时讲解到这里，未来实战要使用到某些数据结构时，比如 VecDeque，我们再深入探索。其他的集合类型，你也可以在要用的时候自行阅读<a target="_blank" rel="noopener noreferrer" href="https://doc.rust-lang.org/std/collections/index.html">文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>如果你想了解这两讲中集合类型的时间复杂度，可以看下表（<a target="_blank" rel="noopener noreferrer" href="https://doc.rust-lang.org/std/collections/index.html#performance">来源<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）：<img src="https://static001.geekbang.org/resource/image/60/2f/60733157bd6e6171a7fee22981469b2f.jpg?wh=2364x1304" alt=""/></p><h3 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/16#思考题"><span class="icon icon-link"></span></a>思考题</h3><p>1.修改下面代码的错误，使其编译通过（<a target="_blank" rel="noopener noreferrer" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c29bbe5c06183eec0892101298dfc510">代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use std::collections::BTreeMap;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #[derive(Debug)]</span></div><div class="token-line"><span class="token plain">    struct Name {</span></div><div class="token-line"><span class="token plain">        pub name: String,</span></div><div class="token-line"><span class="token plain">        pub flags: u32,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl Name {</span></div><div class="token-line"><span class="token plain">        pub fn new(name: impl AsRef&lt;str&gt;, flags: u32) -&gt; Self {</span></div><div class="token-line"><span class="token plain">            Self {</span></div><div class="token-line"><span class="token plain">                name: name.as_ref().to_string(),</span></div><div class="token-line"><span class="token plain">                flags,</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fn main() {</span></div><div class="token-line"><span class="token plain">        let mut map = BTreeMap::new();</span></div><div class="token-line"><span class="token plain">        map.insert(Name::new(&quot;/etc/password&quot;, 0x1), 12);</span></div><div class="token-line"><span class="token plain">        map.insert(Name::new(&quot;/etc/hosts&quot;, 0x1), 4);</span></div><div class="token-line"><span class="token plain">        map.insert(Name::new(&quot;/home/tchen&quot;, 0x0), 28);</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        for item in map.iter() {</span></div><div class="token-line"><span class="token plain">            println!(&quot;{:?}&quot;, item);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>2.思考一下，如果一个 session 表的 key 是 (Source IP、Source Port、Dst IP、Dst Port、Proto) 这样的长度 15 个字节的五元组，value 是 200 字节的 Session 结构，要容纳 1200000 个 Session，整个哈希表要占多大的堆内存？内存的利用率如何？</p><p>3.使用文中同样的方式，结合 rust-gdb / rust-lldb 探索 BTreeMap。你能画出来在插入以 26 个字母为 key，1～26 为 value 后的 BTreeMap 的内存布局么？</p><p>今天你完成了Rust学习的第17次打卡，我们下节课见。</p><h3 id="参考资料"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/16#参考资料"><span class="icon icon-link"></span></a>参考资料</h3><p>1.为什么 Rust 的 HashMap 要缺省采用加密安全的哈希算法？</p><p>我们知道哈希表在软件系统中的重要地位，但哈希表在最坏情况下，如果绝大多数 key 的 hash 都碰撞在一起，性能会到 O(n)，这会极大拖累系统的效率。</p><p>比如 1M 大小的 session 表，正常情况下查表速度是 O(1)，但极端情况下，需要比较 1M 个数据后才能找到，这样的系统就容易被 DoS 攻击。所以如果不是加密安全的哈希函数，只要黑客知道哈希算法，就可以构造出大量的 key 产生足够多的哈希碰撞，造成目标系统 DoS。</p><p><a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/SipHash">SipHash<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 就是为了回应 DoS 攻击而创建的哈希算法，虽然和 sha2 这样的加密哈希不同（不要将 SipHash 用于加密！），但它可以提供类似等级的安全性。把 SipHash 作为 HashMap 的缺省的哈希算法，Rust 可以避免开发者在不知情的情况下被 DoS，就像曾经在 <a target="_blank" rel="noopener noreferrer" href="https://arstechnica.com/information-technology/2011/12/huge-portions-of-web-vulnerable-to-hashing-denial-of-service-attack/">Web 世界<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>发生的那样。</p><p>当然，这一切的代价是性能损耗，虽然 SipHash 非常快，但它比 hashbrown 缺省使用的 <a target="_blank" rel="noopener noreferrer" href="https://github.com/tkaitchuck/aHash">Ahash<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 慢了不少。如果你确定使用的 HashMap 不需要 DoS 防护（比如一个完全内部使用的 HashMap），那么可以用 Ahash 来替换。你只需要使用 Ahash 提供的 RandomState 即可：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use ahash::{AHasher, RandomState};</span></div><div class="token-line"><span class="token plain">    use std::collections::HashMap;</span></div><div class="token-line"><span class="token plain">    let mut map: HashMap&lt;char, i32, RandomState&gt; = HashMap::default();</span></div><div class="token-line"><span class="token plain">    map.insert(&#x27;a&#x27;, 1);</span></div></pre></div><p>2.如何使用 rust-gdb / rust-lldb？</p><p>之前的愚昧之巅<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/418778">加餐<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>提过 <a target="_blank" rel="noopener noreferrer" href="https://www.gnu.org/software/gdb/">gdb<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> / <a target="_blank" rel="noopener noreferrer" href="https://lldb.llvm.org/">lldb<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ，今天就是使用示例。没有使用过的朋友，可以看看它们的文档了解一下。</p><p>gdb 适合在 Linux 下，lldb 可以在 OS X 下调试 Rust 程序。<a target="_blank" rel="noopener noreferrer" href="https://github.com/rust-lang/rust/blob/master/src/etc/rust-gdb">rust-gdb<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> / <a target="_blank" rel="noopener noreferrer" href="https://github.com/rust-lang/rust/blob/master/src/etc/rust-lldb">rust-lldb<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 提供了一些对 Rust 更友好的 pretty-print 功能，在安装 Rust 时，它们也会被安装。使用过 gdb 的同学，可以看 <a target="_blank" rel="noopener noreferrer" href="https://darkdust.net/files/GDB%20Cheat%20Sheet.pdf">gdb 速查手册<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，也可以看看 <a target="_blank" rel="noopener noreferrer" href="https://lldb.llvm.org/use/map.html">gdb/lldb 命令对应手册<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>我一般不用它们调试程序。<strong>不管任何语言，如果开发时，你发现自己总在设置断点调试程序，说明你撰写代码的方式有问题</strong>。要么，没有把接口和算法设计清楚，想到哪写到哪；要么，是你的函数写得过于复杂，太多状态纠缠，没有遵循 SRP（Single Responsibility Principle）。</p><p><strong>好的代码是写出来的，不是调出来的。与其把时间花在调试上，不如把时间花在设计、日志，以及单元测试上</strong>。所以，gdb/lldb 对我来说，是一个理解数据结构在内存中布局以及探索算法如何运行的工具。你可以仔细阅读文中展示的 gdb session 和与之相关的代码，看看如何构造代码来结合 gdb 探索 HashMap 在不同状态下的行为。</p><p>如果你觉得有收获，也欢迎分享给你身边的朋友，邀TA一起讨论～</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/陈天rust编程第一课/03.基础篇/16.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:24</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
