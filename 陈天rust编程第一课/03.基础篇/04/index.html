<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>06｜get hands dirty：SQL查询工具怎么一鱼多吃？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/陈天rust编程第一课/03.基础篇/04" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/陈天rust编程第一课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-two/陈天rust编程第一课/01.开篇词/01"><span>开篇词｜让Rust成为你的下一门主力语言</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/02.前置篇">02.前置篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/02.前置篇/01"><span>01｜内存：值放堆上还是放栈上，这是一个问题</span></a></li><li><a href="/blog-two/陈天rust编程第一课/02.前置篇/02"><span>02｜串讲：编程开发中，那些你需要掌握的基本概念</span></a></li><li><a href="/blog-two/陈天rust编程第一课/02.前置篇/03"><span>加餐｜这个专栏你可以怎么学，以及Rust是否值得学？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课/03.基础篇">03.基础篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/01"><span>03｜初窥门径：从你的第一个Rust程序开始！</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/02"><span>04｜get hands dirty：来写个实用的CLI小工具</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/03"><span>05｜get hands dirty：做一个图片服务器有多难？</span></a></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课/03.基础篇/04"><span>06｜get hands dirty：SQL查询工具怎么一鱼多吃？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/05"><span>07｜所有权：值的生杀大权到底在谁手上？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/06"><span>08｜所有权：值的借用是如何工作的？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/07"><span>09｜所有权：一个值可以有多个所有者么？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/08"><span>10｜生命周期：你创建的值究竟能活多久？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/09"><span>11｜内存管理：从创建到消亡，值都经历了什么？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/10"><span>加餐｜愚昧之巅：你的Rust学习常见问题汇总</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/11"><span>12｜类型系统：Rust的类型系统有什么特点？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/12"><span>13｜类型系统：如何使用trait来定义接口？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/13"><span>14｜类型系统：有哪些必须掌握的trait？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/14"><span>15｜数据结构：这些浓眉大眼的结构竟然都是智能指针？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/15"><span>16｜数据结构：Vec、&amp;[T]、Box&lt;[T]&gt; ，你真的了解集合容器么？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/16"><span>17｜数据结构：软件系统核心部件哈希表，内存如何布局？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/17"><span>18｜错误处理：为什么Rust的错误处理与众不同？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/18"><span>19｜闭包：FnOnce、FnMut和Fn，为什么有这么多类型？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/19"><span>20｜4 Steps ：如何更好地阅读Rust源码？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/20"><span>21｜阶段实操（1）：构建一个简单的KV server-基本流程</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/21"><span>22｜阶段实操（2）：构建一个简单的KV server-基本流程</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/04.期中周">04.期中周</a><ul><li><a href="/blog-two/陈天rust编程第一课/04.期中周/01"><span>加餐｜期中测试：来写一个简单的grep命令行</span></a></li><li><a href="/blog-two/陈天rust编程第一课/04.期中周/02"><span>加餐｜期中测试：参考实现讲解</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇">05.进阶篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/01"><span>23｜类型系统：如何在实战中使用泛型编程？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/02"><span>24｜类型系统：如何在实战中使用trait object？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/03"><span>25｜类型系统：如何围绕trait来设计和架构系统？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/04"><span>加餐｜Rust2021版次问世了！</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/05"><span>26｜阶段实操（3）：构建一个简单的KV server-高级trait技巧</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/06"><span>27｜生态系统：有哪些常有的Rust库可以为我所用？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/07"><span>28｜网络开发（上）：如何使用Rust处理网络请求？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/08"><span>29｜网络开发（下）：如何使用Rust处理网络请求？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/09"><span>30｜Unsafe Rust：如何用C++的方式打开Rust？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/10"><span>31｜FFI：Rust如何和你的语言架起沟通桥梁？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/11"><span>32｜实操项目：使用PyO3开发Python3模块</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇">06.并发篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/01"><span>33｜并发处理（上）：从atomics到Channel，Rust都提供了什么工具？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/02"><span>34｜并发处理（下）：从atomics到Channel，Rust都提供了什么工具？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/03"><span>35｜实操项目：如何实现一个基本的MPSC channel？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/04"><span>用户故事｜绝望之谷：改变从学习开始</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/05"><span>36｜阶段实操（4）：构建一个简单的KV server-网络处理</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/06"><span>37｜阶段实操（5）：构建一个简单的KV server-网络安全</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/07"><span>38｜异步处理：Future是什么？它和async/await是什么关系？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/08"><span>39｜异步处理：async/await内部是怎么实现的？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/09"><span>40｜异步处理：如何处理异步IO？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/10"><span>41｜阶段实操（6）：构建一个简单的KV server-异步处理</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/11"><span>42｜阶段实操（7）：构建一个简单的KV server-如何做大的重构？</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇">07.实战篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/01"><span>43｜生产环境：真实世界下的一个Rust项目包含哪些要素？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/02"><span>44｜数据处理：应用程序和数据如何打交道？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/03"><span>45｜阶段实操（8）：构建一个简单的KV server-配置/测试/监控/CI/CD</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/04"><span>46｜软件架构：如何用Rust架构复杂系统？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/05"><span>大咖助场｜开悟之坡（上）：Rust的现状、机遇与挑战</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/06"><span>大咖助场｜开悟之坡（下）：Rust的现状、机遇与挑战</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/07"><span>用户故事｜语言不仅是工具，还是思维方式</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/08.高级篇">08.高级篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/08.高级篇/01"><span>加餐｜代码即数据：为什么我们需要宏编程能力？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/08.高级篇/02"><span>加餐｜宏编程（上）：用最“笨”的方式撰写宏</span></a></li><li><a href="/blog-two/陈天rust编程第一课/08.高级篇/03"><span>加餐｜宏编程（下）：用 syn/quote 优雅地构建宏</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/09.结束语">09.结束语</a><ul><li><a href="/blog-two/陈天rust编程第一课/09.结束语/01"><span>结束语｜永续之原：Rust学习，如何持续精进？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/09.结束语/02"><span>期末测试｜来赴一场满分之约！</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊">10.学习锦囊</a><ul><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊/01"><span>特别策划｜学习锦囊（一）：听听课代表们怎么说</span></a></li><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊/02"><span>特别策划｜学习锦囊（二）：听听课代表们怎么说</span></a></li><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊/03"><span>特别策划｜学习锦囊（三）：听听课代表们怎么说</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/summary">陈天rust编程第一课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="SQL" data-depth="2"><a href="/blog-two/陈天rust编程第一课/03.基础篇/04#sql"><span>SQL</span></a></li><li title="设计分析" data-depth="2"><a href="/blog-two/陈天rust编程第一课/03.基础篇/04#设计分析"><span>设计分析</span></a></li><li title="创建一个 SQL 方言" data-depth="2"><a href="/blog-two/陈天rust编程第一课/03.基础篇/04#创建一个-sql-方言"><span>创建一个 SQL 方言</span></a></li><li title="实现 AST 的转换" data-depth="2"><a href="/blog-two/陈天rust编程第一课/03.基础篇/04#实现-ast-的转换"><span>实现 AST 的转换</span></a></li><li title="从源中取数据" data-depth="2"><a href="/blog-two/陈天rust编程第一课/03.基础篇/04#从源中取数据"><span>从源中取数据</span></a></li><li title="主流程" data-depth="2"><a href="/blog-two/陈天rust编程第一课/03.基础篇/04#主流程"><span>主流程</span></a></li><li title="支持其它语言" data-depth="2"><a href="/blog-two/陈天rust编程第一课/03.基础篇/04#支持其它语言"><span>支持其它语言</span></a></li><li title="Python" data-depth="3"><a href="/blog-two/陈天rust编程第一课/03.基础篇/04#python"><span>Python</span></a></li><li title="小结" data-depth="2"><a href="/blog-two/陈天rust编程第一课/03.基础篇/04#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-two/陈天rust编程第一课/03.基础篇/04#思考题"><span>思考题</span></a></li><li title="参考资料" data-depth="2"><a href="/blog-two/陈天rust编程第一课/03.基础篇/04#参考资料"><span>参考资料</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="06get-hands-dirtysql查询工具怎么一鱼多吃"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/04#06get-hands-dirtysql查询工具怎么一鱼多吃"><span class="icon icon-link"></span></a>06｜get hands dirty：SQL查询工具怎么一鱼多吃？</h1><p>你好，我是陈天。</p><p>通过 HTTPie 和 Thumbor 的例子，相信你对 Rust 的能力和代码风格有了比较直观的了解。之前我们说过Rust的应用范围非常广，但是这两个例子体现得还不是太明显。</p><p>有同学想看看，在实际工作中有大量生命周期标注的代码的样子；有同学对 Rust 的宏好奇；有同学对 Rust 和其它语言的互操作感兴趣；还有同学想知道 Rust 做客户端的感觉。所以，我们今天就来<strong>用一个很硬核的例子把这些内容都涵盖进来</strong>。</p><p>话不多说，我们直接开始。</p><h2 id="sql"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/04#sql"><span class="icon icon-link"></span></a>SQL</h2><p>我们工作的时候经常会跟各种数据源打交道，数据源包括数据库、Parquet、CSV、JSON 等，而打交道的过程无非是：数据的获取（fetch）、过滤（filter）、投影（projection）和排序（sort）。</p><p>做大数据的同学可以用类似 Spark SQL 的工具来完成各种异质数据的查询，但是我们平时用 SQL 并没有这么强大。因为虽然用 SQL 对数据库做查询，任何 DBMS 都支持，如果想用 SQL 查询 CSV 或者 JSON，就需要很多额外的处理。</p><p>所以如果能有一个简单的工具，<strong>不需要引入 Spark，就能支持对任何数据源使用 SQL 查询</strong>，是不是很有意义？</p><p>比如，如果你的 shell 支持这样使用是不是爽爆了？<img src="https://static001.geekbang.org/resource/image/3e/7c/3e8e6586d8599e39a6704cf82352cd7c.jpg?wh=1920x703" alt=""/><br/>再比如，我们的客户端会从服务器 API 获取数据的子集，如果这个子集可以在前端通过 SQL 直接做一些额外查询，那将非常灵活，并且用户可以得到即时的响应。</p><p>软件领域有个著名的<a target="_blank" rel="noopener noreferrer" href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E6%9E%97%E6%96%AF%E6%BD%98%E7%AC%AC%E5%8D%81%E5%AE%9A%E5%BE%8B">格林斯潘第十定律<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：</p><blockquote><p>任何 C 或 Fortran 程序复杂到一定程度之后，都会包含一个临时开发的、不合规范的、充满程序错误的、运行速度很慢的、只有一半功能的 Common Lisp 实现。</p></blockquote><p>我们仿照它来一个程序君第四十二定律：</p><blockquote><p>任何 API 接口复杂到一定程度后，都会包含一个临时开发的、不合规范的、充满程序错误的、运行速度很慢的、只有一半功能的 SQL 实现。</p></blockquote><p>所以，我们今天就来设计一个可以对任何数据源使用 SQL 查询，并获得结果的库如何？当然，作为一个 MVP（Mimimu Viable Product），我们就暂且只支持对 CSV 的 SQL 查询。不单如此，我们还希望这个库可以给 Python3 和 Node.js 使用。</p><p>猜一猜这个库要花多少行代码？今天难度比较大，怎么着要 500 行吧？我们暂且以 500 行代码为基准来挑战。</p><h2 id="设计分析"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/04#设计分析"><span class="icon icon-link"></span></a>设计分析</h2><p>我们首先需要一个 SQL 解析器。在 Rust 下，写一个解析器并不困难，可以用 <a target="_blank" rel="noopener noreferrer" href="https://github.com/serde-rs/serde">serde<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、用任何 <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Parser_combinator">parser combinator<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 或者 <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">PEG parser<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 来实现，比如 <a target="_blank" rel="noopener noreferrer" href="https://github.com/Geal/nom">nom<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 或者 <a target="_blank" rel="noopener noreferrer" href="https://github.com/pest-parser/pest">pest<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。不过 SQL 解析，这种足够常见的需求，Rust 社区已经有方案，我们用 <a target="_blank" rel="noopener noreferrer" href="https://github.com/sqlparser-rs/sqlparser-rs">sqlparser-rs<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>接下来就是如何把 CSV 或者其它数据源加载为 DataFrame。</p><p>做过数据处理或者使用过 <a target="_blank" rel="noopener noreferrer" href="https://pandas.pydata.org/pandas-docs/stable/index.html">pandas<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的同学，应该对 DataFrame 并不陌生，它是一个矩阵数据结构，其中每一列可能包含不同的类型，可以在 DataFrame 上做过滤、投影和排序等操作。</p><p>在 Rust 下，我们可以用 <a target="_blank" rel="noopener noreferrer" href="https://github.com/pola-rs/polars">polars<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ，来完成数据从 CSV 到 DataFrame 的加载和各种后续操作。</p><p>确定了这两个库之后，后续的工作就是：如何把 sqlparser 解析出来的抽象语法树 <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">AST<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（Abstract Syntax Tree），映射到 polars 的 DataFrame 的操作上。</p><p>抽象语法树是用来描述复杂语法规则的工具，小到 SQL 或者某个 DSL，大到一门编程语言，其语言结构都可以通过 AST 来描述，如下图所示（来源：<a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">wikipedia<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）：</p><p><img src="https://static001.geekbang.org/resource/image/2f/80/2f60e2d0a908e84ef33634d840ea6380.png?wh=800x903" alt="图片"/></p><p>如何在 SQL 语法和 DataFrame 的操作间进行映射呢？比如我们要从数据中选出三列显示，那这个 “select a, b, c” 就要能映射到 DataFrame 选取 a、b、c 三列输出。</p><p>polars 内部有自己的 AST 可以把各种操作聚合起来，最后一并执行。比如对于 “where a &gt; 10 and b &lt; 5”， Polars 的表达式是：<code>col(&quot;a&quot;).gt(lit(10)).and(col(&quot;b&quot;).lt(lit(5)))</code>。col 代表列，gt/lt 是大于/小于，lit 是字面量的意思。</p><p>有了这个认知，“对 CSV 等源进行 SQL 查询”核心要解决的问题变成了，<strong>如何把一个 AST（ SQL AST ）转换成另一个 AST（ DataFrame AST ）</strong>。</p><p>等等，这不就是宏编程（对于 Rust 来说，是过程宏）做的事情么？因为进一步分析二者的数据结构，我们可以得到这样的对应关系：</p><p><img src="https://static001.geekbang.org/resource/image/dd/72/ddd4995deecc4b7897bf73beb0e2cb72.jpg?wh=1920x1266" alt=""/></p><p>你看，我们要做的主要事情其实就是，在两个数据结构之间进行转换。所以，写完今天的代码，你肯定会对宏有足够的信心。</p><p>宏编程并没有什么大不了的，抛开 quote/unquote，它主要的工作就是把一棵语法树转换成另一颗语法树，而这个转换的过程深入下去，不过就是数据结构到数据结构的转换而已。所以一句话总结：<strong>宏编程的主要流程就是实现若干 From 和 TryFrom</strong>，是不是很简单。</p><p>当然，这个转换的过程非常琐碎，如果语言本身没有很好的模式匹配能力，进行宏编程绝对是对自己非人道的折磨。</p><p>好在 Rust 有很棒的模式匹配支持，它虽然没有 Erlang/Elixir 的模式匹配那么强大，但足以秒杀绝大多数的编程语言。待会你在写的时候，能直观感受到。</p><h2 id="创建一个-sql-方言"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/04#创建一个-sql-方言"><span class="icon icon-link"></span></a>创建一个 SQL 方言</h2><p>好，分析完要做的事情，接下来就是按部就班写代码了。</p><p>我们用 <code>cargo new queryer \--lib</code> 生成一个库。用 VSCode 打开生成的目录，创建和 src 平级的 examples，并在 Cargo.toml 中添加代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[[example]]</span></div><div class="token-line"><span class="token plain">    name = &quot;dialect&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    [dependencies]</span></div><div class="token-line"><span class="token plain">    anyhow = &quot;1&quot; # 错误处理，其实对于库我们应该用 thiserror，但这里简单起见就不节外生枝了</span></div><div class="token-line"><span class="token plain">    async-trait = &quot;0.1&quot; # 允许 trait 里有 async fn</span></div><div class="token-line"><span class="token plain">    sqlparser = &quot;0.10&quot; # SQL 解析器</span></div><div class="token-line"><span class="token plain">    polars = { version = &quot;0.15&quot;, features = [&quot;json&quot;, &quot;lazy&quot;] } # DataFrame 库</span></div><div class="token-line"><span class="token plain">    reqwest = { version = &quot;0.11&quot;, default-features = false, features = [&quot;rustls-tls&quot;] } # 我们的老朋友 HTTP 客户端</span></div><div class="token-line"><span class="token plain">    tokio = { version = &quot;1&quot;, features = [&quot;fs&quot;]} # 我们的老朋友异步库，我们这里需要异步文件处理</span></div><div class="token-line"><span class="token plain">    tracing = &quot;0.1&quot; # 日志处理</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    [dev-dependencies]</span></div><div class="token-line"><span class="token plain">    tracing-subscriber = &quot;0.2&quot; # 日志处理</span></div><div class="token-line"><span class="token plain">    tokio = { version = &quot;1&quot;, features = [&quot;full&quot;]} # 在 example 下我们需要更多的 tokio feature</span></div></pre></div><p>依赖搞定。因为对 sqlparser 的功能不太熟悉，这里写个 example 尝试一下，它会在 examples 目录下寻找 <a target="_blank" rel="noopener noreferrer" href="http://dialect.rs/">dialect.rs<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 文件。</p><p>所以，我们创建 examples/dialect.rs 文件，并写一些测试 sqlparser 的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use sqlparser::{dialect::GenericDialect, parser::Parser};</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fn main() {</span></div><div class="token-line"><span class="token plain">        tracing_subscriber::fmt::init();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        let sql = &quot;SELECT a a1, b, 123, myfunc(b), * \</span></div><div class="token-line"><span class="token plain">        FROM data_source \</span></div><div class="token-line"><span class="token plain">        WHERE a &gt; b AND b &lt; 100 AND c BETWEEN 10 AND 20 \</span></div><div class="token-line"><span class="token plain">        ORDER BY a DESC, b \</span></div><div class="token-line"><span class="token plain">        LIMIT 50 OFFSET 10&quot;;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        let ast = Parser::parse_sql(&amp;GenericDialect::default(), sql);</span></div><div class="token-line"><span class="token plain">        println!(&quot;{:#?}&quot;, ast);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这段代码用一个 SQL 语句来测试<code>Parser::parse_sql</code>会输出什么样的结构。当你写库代码时，如果遇到不明白的第三方库，可以用撰写 example 这种方式先试一下。<br/>我们运行 <code>cargo run \--example dialect</code>查看结果：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Ok([Query(</span></div><div class="token-line"><span class="token plain">        Query {</span></div><div class="token-line"><span class="token plain">            with: None,</span></div><div class="token-line"><span class="token plain">            body: Select(</span></div><div class="token-line"><span class="token plain">                Select {</span></div><div class="token-line"><span class="token plain">                    distinct: false,</span></div><div class="token-line"><span class="token plain">                    top: None,</span></div><div class="token-line"><span class="token plain">                    projection: [ ... ],</span></div><div class="token-line"><span class="token plain">    								from: [ TableWithJoins { ... } ],</span></div><div class="token-line"><span class="token plain">    								selection: Some(BinaryOp { ... }),</span></div><div class="token-line"><span class="token plain">                    ...</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            ),</span></div><div class="token-line"><span class="token plain">            order_by: [ OrderByExpr { ... } ],</span></div><div class="token-line"><span class="token plain">            limit: Some(Value( ... )),</span></div><div class="token-line"><span class="token plain">            offset: Some(Offset { ... })</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    ])</span></div></pre></div><p>我把这个结构简化了一下，你在命令行里看到的，会远比这个复杂。</p><p>写到第9行这里，你有没有突发奇想，<strong>如果 SQL 中的 FROM 子句后面可以接一个 URL 或者文件名该多好</strong>？这样，我们可以从这个 URL 或文件中读取数据。就像开头那个 “select * from ps” 的例子，把 ps 命令作为数据源，从它的输出中很方便地取数据。</p><p>但是普通的 SQL 语句是不支持这种写法的，不过 sqlparser 允许你创建自己的 SQL 方言，那我们就来尝试一下。</p><p>创建 src/dialect.rs 文件，添入下面的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use sqlparser::dialect::Dialect;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #[derive(Debug, Default)]</span></div><div class="token-line"><span class="token plain">    pub struct TyrDialect;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 创建自己的 sql 方言。TyrDialect 支持 identifier 可以是简单的 url</span></div><div class="token-line"><span class="token plain">    impl Dialect for TyrDialect {</span></div><div class="token-line"><span class="token plain">        fn is_identifier_start(&amp;self, ch: char) -&gt; bool {</span></div><div class="token-line"><span class="token plain">            (&#x27;a&#x27;..=&#x27;z&#x27;).contains(&amp;ch) || (&#x27;A&#x27;..=&#x27;Z&#x27;).contains(&amp;ch) || ch == &#x27;_&#x27;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // identifier 可以有 &#x27;:&#x27;, &#x27;/&#x27;, &#x27;?&#x27;, &#x27;&amp;&#x27;, &#x27;=&#x27;</span></div><div class="token-line"><span class="token plain">        fn is_identifier_part(&amp;self, ch: char) -&gt; bool {</span></div><div class="token-line"><span class="token plain">            (&#x27;a&#x27;..=&#x27;z&#x27;).contains(&amp;ch)</span></div><div class="token-line"><span class="token plain">                || (&#x27;A&#x27;..=&#x27;Z&#x27;).contains(&amp;ch)</span></div><div class="token-line"><span class="token plain">                || (&#x27;0&#x27;..=&#x27;9&#x27;).contains(&amp;ch)</span></div><div class="token-line"><span class="token plain">                || [&#x27;:&#x27;, &#x27;/&#x27;, &#x27;?&#x27;, &#x27;&amp;&#x27;, &#x27;=&#x27;, &#x27;-&#x27;, &#x27;_&#x27;, &#x27;.&#x27;].contains(&amp;ch)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// 测试辅助函数</span></div><div class="token-line"><span class="token plain">    pub fn example_sql() -&gt; String {</span></div><div class="token-line"><span class="token plain">        let url = &quot;https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/latest/owid-covid-latest.csv&quot;;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        let sql = format!(</span></div><div class="token-line"><span class="token plain">            &quot;SELECT location name, total_cases, new_cases, total_deaths, new_deaths \</span></div><div class="token-line"><span class="token plain">            FROM {} where new_deaths &gt;= 500 ORDER BY new_cases DESC LIMIT 6 OFFSET 5&quot;,</span></div><div class="token-line"><span class="token plain">            url</span></div><div class="token-line"><span class="token plain">        );</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        sql</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #[cfg(test)]</span></div><div class="token-line"><span class="token plain">    mod tests {</span></div><div class="token-line"><span class="token plain">        use super::*;</span></div><div class="token-line"><span class="token plain">        use sqlparser::parser::Parser;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        #[test]</span></div><div class="token-line"><span class="token plain">        fn it_works() {</span></div><div class="token-line"><span class="token plain">            assert!(Parser::parse_sql(&amp;TyrDialect::default(), &amp;example_sql()).is_ok());</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个代码主要实现了 sqlparser 的 Dialect trait，可以重载 SQL 解析器判断标识符的方法。之后我们需要在 src/lib.rs 中添加</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">mod dialect;</span></div></pre></div><p>引入这个文件，最后也写了一个测试，你可以运行 <code>cargo test</code> 测试一下看看。<br/>测试通过！现在我们可以正常解析出这样的 SQL 了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">SELECT * from https://abc.xyz/covid-cases.csv where new_deaths &gt;= 500</span></div></pre></div><p>Cool！你看，大约用了 10 行代码（第 7 行到第 19 行），通过添加可以让 URL 合法的字符，就实现了一个自己的支持 URL 的 SQL 方言解析。</p><p>为什么这么厉害？因为通过 trait，你可以很方便地做<a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Inversion_of_control">控制反转（Inversion of Control）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，在 Rust 开发中，这是很常见的一件事情。</p><h2 id="实现-ast-的转换"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/04#实现-ast-的转换"><span class="icon icon-link"></span></a>实现 AST 的转换</h2><p>刚刚完成了SQL解析，接着就是用polars做AST转换了。</p><p>由于我们不太了解 polars 库，接下来还是先测试一下怎么用。创建 examples/covid.rs（记得在 Cargo.toml 中添加它哦），手工实现一个 DataFrame 的加载和查询：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use anyhow::Result;</span></div><div class="token-line"><span class="token plain">    use polars::prelude::*;</span></div><div class="token-line"><span class="token plain">    use std::io::Cursor;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #[tokio::main]</span></div><div class="token-line"><span class="token plain">    async fn main() -&gt; Result&lt;()&gt; {</span></div><div class="token-line"><span class="token plain">        tracing_subscriber::fmt::init();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        let url = &quot;https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/latest/owid-covid-latest.csv&quot;;</span></div><div class="token-line"><span class="token plain">        let data = reqwest::get(url).await?.text().await?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 使用 polars 直接请求</span></div><div class="token-line"><span class="token plain">        let df = CsvReader::new(Cursor::new(data))</span></div><div class="token-line"><span class="token plain">            .infer_schema(Some(16))</span></div><div class="token-line"><span class="token plain">            .finish()?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        let filtered = df.filter(&amp;df[&quot;new_deaths&quot;].gt(500))?;</span></div><div class="token-line"><span class="token plain">        println!(</span></div><div class="token-line"><span class="token plain">            &quot;{:?}&quot;,</span></div><div class="token-line"><span class="token plain">            filtered.select((</span></div><div class="token-line"><span class="token plain">                &quot;location&quot;,</span></div><div class="token-line"><span class="token plain">                &quot;total_cases&quot;,</span></div><div class="token-line"><span class="token plain">                &quot;new_cases&quot;,</span></div><div class="token-line"><span class="token plain">                &quot;total_deaths&quot;,</span></div><div class="token-line"><span class="token plain">                &quot;new_deaths&quot;</span></div><div class="token-line"><span class="token plain">            ))</span></div><div class="token-line"><span class="token plain">        );</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        Ok(())</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>如果我们运行这个 example，可以得到一个打印得非常漂亮的表格，它从 GitHub 上的 <a target="_blank" rel="noopener noreferrer" href="https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/latest/owid-covid-latest.csv">owid-covid-latest.csv<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 文件中，读取并查询 new_deaths 大于 500 的国家和区域：<br/><img src="https://static001.geekbang.org/resource/image/31/69/3117645de41cc1d0d6d320c5dd6d2c69.png?wh=1682x1254" alt=""/></p><p>我们最终要实现的就是这个效果，通过解析一条做类似查询的 SQL，来进行相同的数据查询。怎么做呢？</p><p>今天一开始已经分析过了，<strong>主要的工作就是把 sqlparser 解析出来的 AST 转换成 polars 定义的 AST</strong>。再回顾一下 SQL AST 的输出：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Ok([Query(</span></div><div class="token-line"><span class="token plain">        Query {</span></div><div class="token-line"><span class="token plain">            with: None,</span></div><div class="token-line"><span class="token plain">            body: Select(</span></div><div class="token-line"><span class="token plain">                Select {</span></div><div class="token-line"><span class="token plain">                    distinct: false,</span></div><div class="token-line"><span class="token plain">                    top: None,</span></div><div class="token-line"><span class="token plain">                    projection: [ ... ],</span></div><div class="token-line"><span class="token plain">    								from: [ TableWithJoins { ... } ],</span></div><div class="token-line"><span class="token plain">    								selection: Some(BinaryOp { ... }),</span></div><div class="token-line"><span class="token plain">                    ...</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            ),</span></div><div class="token-line"><span class="token plain">            order_by: [ OrderByExpr { ... } ],</span></div><div class="token-line"><span class="token plain">            limit: Some(Value( ... )),</span></div><div class="token-line"><span class="token plain">            offset: Some(Offset { ... })</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    ])</span></div></pre></div><p>这里的 Query 是 Statement enum 其中一个结构。SQL 语句除了查询外，还有插入数据、删除数据、创建表等其他语句，我们今天不关心这些，只关心 Query。</p><p>所以，可以创建一个文件 src/convert.rs，<strong>先定义一个数据结构 Sql 来描述两者的对应关系，然后再实现 Sql 的 TryFrom trait</strong>：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/// 解析出来的 SQL</span></div><div class="token-line"><span class="token plain">    pub struct Sql&lt;&#x27;a&gt; {</span></div><div class="token-line"><span class="token plain">        pub(crate) selection: Vec&lt;Expr&gt;,</span></div><div class="token-line"><span class="token plain">        pub(crate) condition: Option&lt;Expr&gt;,</span></div><div class="token-line"><span class="token plain">        pub(crate) source: &amp;&#x27;a str,</span></div><div class="token-line"><span class="token plain">        pub(crate) order_by: Vec&lt;(String, bool)&gt;,</span></div><div class="token-line"><span class="token plain">        pub(crate) offset: Option&lt;i64&gt;,</span></div><div class="token-line"><span class="token plain">        pub(crate) limit: Option&lt;usize&gt;,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl&lt;&#x27;a&gt; TryFrom&lt;&amp;&#x27;a Statement&gt; for Sql&lt;&#x27;a&gt; {</span></div><div class="token-line"><span class="token plain">        type Error = anyhow::Error;</span></div><div class="token-line"><span class="token plain">    		fn try_from(sql: &amp;&#x27;a Statement) -&gt; Result&lt;Self, Self::Error&gt; {</span></div><div class="token-line"><span class="token plain">            match sql {</span></div><div class="token-line"><span class="token plain">                // 目前我们只关心 query (select ... from ... where ...)</span></div><div class="token-line"><span class="token plain">                Statement::Query(q) =&gt; {</span></div><div class="token-line"><span class="token plain">    							...</span></div><div class="token-line"><span class="token plain">    						}</span></div><div class="token-line"><span class="token plain">    				}</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>框有了，继续写转换。我们看 Query 的结构：它有一个 body，是 Select 类型，其中包含 projection、from、select。在 Rust 里，我们可以用一个赋值语句，同时使用模式匹配加上数据的解构，将它们都取出来：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let Select {</span></div><div class="token-line"><span class="token plain">        from: table_with_joins,</span></div><div class="token-line"><span class="token plain">        selection: where_clause,</span></div><div class="token-line"><span class="token plain">        projection,</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        group_by: _,</span></div><div class="token-line"><span class="token plain">        ..</span></div><div class="token-line"><span class="token plain">    } = match &amp;q.body {</span></div><div class="token-line"><span class="token plain">        SetExpr::Select(statement) =&gt; statement.as_ref(),</span></div><div class="token-line"><span class="token plain">        _ =&gt; return Err(anyhow!(&quot;We only support Select Query at the moment&quot;)),</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>一句话，从匹配到取引用，再到将引用内部几个字段赋值给几个变量，都完成了，真是太舒服了！这样能够极大提高生产力的语言，你怎能不爱它？</p><p>我们再看一个处理 Offset 的例子，需要把 sqlparser 的 Offset 转换成 i64，同样，可以实现一个 TryFrom trait。这次是在 match 的一个分支上，做了数据结构的解构。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use sqlparser::ast::Offset as SqlOffset;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 因为 Rust trait 的孤儿规则，我们如果要想对已有的类型实现已有的 trait，</span></div><div class="token-line"><span class="token plain">    // 需要简单包装一下</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    pub struct Offset&lt;&#x27;a&gt;(pub(crate) &amp;&#x27;a SqlOffset);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// 把 SqlParser 的 offset expr 转换成 i64</span></div><div class="token-line"><span class="token plain">    impl&lt;&#x27;a&gt; From&lt;Offset&lt;&#x27;a&gt;&gt; for i64 {</span></div><div class="token-line"><span class="token plain">        fn from(offset: Offset) -&gt; Self {</span></div><div class="token-line"><span class="token plain">            match offset.0 {</span></div><div class="token-line"><span class="token plain">                SqlOffset {</span></div><div class="token-line"><span class="token plain">                    value: SqlExpr::Value(SqlValue::Number(v, _b)),</span></div><div class="token-line"><span class="token plain">                    ..</span></div><div class="token-line"><span class="token plain">                } =&gt; v.parse().unwrap_or(0),</span></div><div class="token-line"><span class="token plain">                _ =&gt; 0,</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>是的，数据的解构也可以在分支上进行，如果你还记得第三讲中谈到的 if let / while let，也是这个用法。这样对模式匹配的全方位支持，你用得越多，就会越感激 Rust 的作者，尤其在开发过程宏的时候。</p><p>从这段代码中还可以看到，定义的数据结构 Offset 使用了生命周期标注 &lt;&#x27;a&gt;，这是因为内部使用了 SqlOffset 的引用。有关生命周期的知识，我们很快就会讲到，这里你暂且不需要理解为什么要这么做。</p><p>整个 src/convert.rs 主要都是通过模式匹配，进行不同子类型之间的转换，代码比较无趣，而且和上面的代码类似，我就不贴了，你可以在这门课程的 <a target="_blank" rel="noopener noreferrer" href="https://github.com/tyrchen/geektime-rust/blob/master/06_queryer/queryer/src/convert.rs">GitHub repo<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 下的 06_queryer/queryer/src/convert.rs 中获取。</p><p>未来你在 Rust 下写过程宏（procedure macro），干的基本就是这个工作，只不过，最后你需要把转换后的 AST 使用 quote 输出成代码。在这个例子里，我们不需要这么做，polars 的 lazy 接口直接能处理 AST。</p><p>说句题外话，我之所以不厌其烦地讲述数据转换的这个过程，是因为它是我们编程活动中非常重要的部分。你想想，我们写代码，主要都在处理什么？<strong>绝大多数处理逻辑都是把数据从一个接口转换成另一个接口</strong>。</p><p>以我们熟悉的用户注册流程为例：</p><ol><li>用户的输入被前端校验后，转换成 CreateUser 对象，然后再转换成一个 HTTP POST 请求。</li><li>当这个请求到达服务器后，服务器将其读取，再转换成服务器的 CreateUser 对象，这个对象在校验和正规化（normalization）后被转成一个 ORM 对象（如果使用 ORM 的话），然后 ORM 对象再被转换成 SQL，发送给数据库服务器。</li><li>数据库服务器将 SQL 请求包装成一个 <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Write-ahead_logging">WAL<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（Write-Ahead Logging），这个 WAL 再被更新到数据库文件中。</li></ol><p>整个数据转换过程如下图所示：<img src="https://static001.geekbang.org/resource/image/f0/e9/f0c1ab58fbe1e97f8938f01ca97c3ae9.jpg?wh=1920x653" alt=""/></p><p>这样的处理流程，由于它和业务高度绑定，往往容易被写得很耦合，久而久之就变成了难以维护的意大利面条。<strong>好的代码，<strong><strong>应该</strong></strong>是每个主流程都清晰简约，代码恰到好处地出现<strong><strong>在</strong></strong>那里，让人不需要注释也能明白作者在写什么。</strong></p><p>这就意味着，我们要把那些并不重要的细节封装在单独的地方，封装的粒度以一次写完、基本不需要再变动为最佳，或者即使变动，它的影响也非常局部。</p><p>这样的代码，方便阅读、容易测试、维护简单，处理起来更是一种享受。Rust 标准库的 From / TryFrom trait ，就是出于这个目的设计的，非常值得我们好好使用。</p><h2 id="从源中取数据"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/04#从源中取数据"><span class="icon icon-link"></span></a>从源中取数据</h2><p>完成了 AST 的转换，接下来就是从源中获取数据。</p><p>我们通过对 Sql 结构的处理和填充，可以得到 SQL FROM 子句里的数据源，这个源，我们规定它必须是以 http(s):// 或者 file:// 开头的字符串。因为，以 http 开头我们可以通过 URL 获取内容，file 开头我们可以通过文件名，打开本地文件获取内容。</p><p>所以拿到了这个描述了数据源的字符串后，很容易能写出这样的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/// 从文件源或者 http 源中获取数据</span></div><div class="token-line"><span class="token plain">    async fn retrieve_data(source: impl AsRef&lt;str&gt;) -&gt; Result&lt;String&gt; {</span></div><div class="token-line"><span class="token plain">        let name = source.as_ref();</span></div><div class="token-line"><span class="token plain">        match &amp;name[..4] {</span></div><div class="token-line"><span class="token plain">            // 包括 http / https</span></div><div class="token-line"><span class="token plain">            &quot;http&quot; =&gt; Ok(reqwest::get(name).await?.text().await?),</span></div><div class="token-line"><span class="token plain">            // 处理 file://&lt;filename&gt;</span></div><div class="token-line"><span class="token plain">            &quot;file&quot; =&gt; Ok(fs::read_to_string(&amp;name[7..]).await?),</span></div><div class="token-line"><span class="token plain">            _ =&gt; Err(anyhow!(&quot;We only support http/https/file at the moment&quot;)),</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>代码看起来很简单，但未来并不容易维护。因为一旦你的 HTTP 请求获得的结果需要做一些后续的处理，这个函数很快就会变得很复杂。那该怎么办呢？</p><p>如果你回顾前两讲我们写的代码，相信你心里马上有了答案：<strong>可以用 trait 抽取 fetch 的逻辑，定义好接口，然后改变 retrieve_data 的实现</strong>。</p><p>所以下面是 src/fetcher.rs 的完整代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use anyhow::{anyhow, Result};</span></div><div class="token-line"><span class="token plain">    use async_trait::async_trait;</span></div><div class="token-line"><span class="token plain">    use tokio::fs;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // Rust 的 async trait 还没有稳定，可以用 async_trait 宏</span></div><div class="token-line"><span class="token plain">    #[async_trait]</span></div><div class="token-line"><span class="token plain">    pub trait Fetch {</span></div><div class="token-line"><span class="token plain">        type Error;</span></div><div class="token-line"><span class="token plain">        async fn fetch(&amp;self) -&gt; Result&lt;String, Self::Error&gt;;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// 从文件源或者 http 源中获取数据，组成 data frame</span></div><div class="token-line"><span class="token plain">    pub async fn retrieve_data(source: impl AsRef&lt;str&gt;) -&gt; Result&lt;String&gt; {</span></div><div class="token-line"><span class="token plain">        let name = source.as_ref();</span></div><div class="token-line"><span class="token plain">        match &amp;name[..4] {</span></div><div class="token-line"><span class="token plain">            // 包括 http / https</span></div><div class="token-line"><span class="token plain">            &quot;http&quot; =&gt; UrlFetcher(name).fetch().await,</span></div><div class="token-line"><span class="token plain">            // 处理 file://&lt;filename&gt;</span></div><div class="token-line"><span class="token plain">            &quot;file&quot; =&gt; FileFetcher(name).fetch().await,</span></div><div class="token-line"><span class="token plain">            _ =&gt; return Err(anyhow!(&quot;We only support http/https/file at the moment&quot;)),</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    struct UrlFetcher&lt;&#x27;a&gt;(pub(crate) &amp;&#x27;a str);</span></div><div class="token-line"><span class="token plain">    struct FileFetcher&lt;&#x27;a&gt;(pub(crate) &amp;&#x27;a str);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #[async_trait]</span></div><div class="token-line"><span class="token plain">    impl&lt;&#x27;a&gt; Fetch for UrlFetcher&lt;&#x27;a&gt; {</span></div><div class="token-line"><span class="token plain">        type Error = anyhow::Error;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        async fn fetch(&amp;self) -&gt; Result&lt;String, Self::Error&gt; {</span></div><div class="token-line"><span class="token plain">            Ok(reqwest::get(self.0).await?.text().await?)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #[async_trait]</span></div><div class="token-line"><span class="token plain">    impl&lt;&#x27;a&gt; Fetch for FileFetcher&lt;&#x27;a&gt; {</span></div><div class="token-line"><span class="token plain">        type Error = anyhow::Error;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        async fn fetch(&amp;self) -&gt; Result&lt;String, Self::Error&gt; {</span></div><div class="token-line"><span class="token plain">            Ok(fs::read_to_string(&amp;self.0[7..]).await?)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这看上去似乎没有收益，还让代码变得更多。但它把 retrieve_data 和具体每一种类型的处理分离了，还是我们之前讲的思想，通过开闭原则，构建低耦合、高内聚的代码。这样未来我们修改 UrlFetcher 或者 FileFetcher，或者添加新的 Fetcher，对 retrieve_data 的变动都是最小的。</p><p>现在我们完成了SQL的解析、实现了从SQL到DataFrame的AST的转换，以及数据源的获取。挑战已经完成一大半了，就剩主流程逻辑了。</p><h2 id="主流程"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/04#主流程"><span class="icon icon-link"></span></a>主流程</h2><p>一般我们在做一个库的时候，不会把内部使用的数据结构暴露出去，而是会用自己的数据结构包裹它。</p><p>但这样代码有一个问题：<strong>原有数据结构的方法，如果我们想暴露出去，每个接口都需要实现一遍</strong>，虽然里面的代码就是一句简单的 proxy，但还是很麻烦。这是我自己在使用很多语言的一个痛点。</p><p>正好在 queryer 库里也会有这个问题：SQL 查询后的结果，会放在一个 polars 的 DataFrame 中，但我们不想直接暴露这个 DataFrame 出去。因为一旦这么做，未来我们想加额外的 metadata，就无能为力了。</p><p>所以我定义了一个 DataSet，包裹住 DataFrame。可是，我还想暴露 DataSet 的接口，它有好多函数，总不能挨个 proxy 吧？</p><p>不用。Rust 提供了 Deref 和 DerefMut trait 做这个事情，它允许类型在解引用时，可以解引用到其它类型。我们后面在介绍 Rust 常用 trait 时，会详细介绍这两个 trait，现在先来看的 DataSet 怎么处理：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#[derive(Debug)]</span></div><div class="token-line"><span class="token plain">    pub struct DataSet(DataFrame);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// 让 DataSet 用起来和 DataFrame 一致</span></div><div class="token-line"><span class="token plain">    impl Deref for DataSet {</span></div><div class="token-line"><span class="token plain">        type Target = DataFrame;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        fn deref(&amp;self) -&gt; &amp;Self::Target {</span></div><div class="token-line"><span class="token plain">            &amp;self.0</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// 让 DataSet 用起来和 DataFrame 一致</span></div><div class="token-line"><span class="token plain">    impl DerefMut for DataSet {</span></div><div class="token-line"><span class="token plain">        fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {</span></div><div class="token-line"><span class="token plain">            &amp;mut self.0</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // DataSet 自己的方法</span></div><div class="token-line"><span class="token plain">    impl DataSet {</span></div><div class="token-line"><span class="token plain">        /// 从 DataSet 转换成 csv</span></div><div class="token-line"><span class="token plain">        pub fn to_csv(&amp;self) -&gt; Result&lt;String&gt; {</span></div><div class="token-line"><span class="token plain">            ...</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，DataSet 在解引用时，它的 Target 是 DataFrame，这样 DataSet 在用户使用时，就和 DataFrame 一致了；我们还为 DataSet 实现了 to_csv 方法，可以把查询结果生成出 CSV。</p><p>好，定义好 DataSet，核心函数 query 实现起来其实很简单：先解析出我们要的 Sql 结构，然后从 source 中读入一个 DataSet，做 filter / order_by / offset / limit / select 等操作，最后返回 DataSet。</p><p>DataSet 的定义和 query 函数都在 src/lib.rs，它的完整代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use anyhow::{anyhow, Result};</span></div><div class="token-line"><span class="token plain">    use polars::prelude::*;</span></div><div class="token-line"><span class="token plain">    use sqlparser::parser::Parser;</span></div><div class="token-line"><span class="token plain">    use std::convert::TryInto;</span></div><div class="token-line"><span class="token plain">    use std::ops::{Deref, DerefMut};</span></div><div class="token-line"><span class="token plain">    use tracing::info;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    mod convert;</span></div><div class="token-line"><span class="token plain">    mod dialect;</span></div><div class="token-line"><span class="token plain">    mod loader;</span></div><div class="token-line"><span class="token plain">    mod fetcher;</span></div><div class="token-line"><span class="token plain">    use convert::Sql;</span></div><div class="token-line"><span class="token plain">    use loader::detect_content;</span></div><div class="token-line"><span class="token plain">    use fetcher::retrieve_data;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    pub use dialect::example_sql;</span></div><div class="token-line"><span class="token plain">    pub use dialect::TyrDialect;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #[derive(Debug)]</span></div><div class="token-line"><span class="token plain">    pub struct DataSet(DataFrame);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// 让 DataSet 用起来和 DataFrame 一致</span></div><div class="token-line"><span class="token plain">    impl Deref for DataSet {</span></div><div class="token-line"><span class="token plain">        type Target = DataFrame;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        fn deref(&amp;self) -&gt; &amp;Self::Target {</span></div><div class="token-line"><span class="token plain">            &amp;self.0</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// 让 DataSet 用起来和 DataFrame 一致</span></div><div class="token-line"><span class="token plain">    impl DerefMut for DataSet {</span></div><div class="token-line"><span class="token plain">        fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {</span></div><div class="token-line"><span class="token plain">            &amp;mut self.0</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl DataSet {</span></div><div class="token-line"><span class="token plain">        /// 从 DataSet 转换成 csv</span></div><div class="token-line"><span class="token plain">        pub fn to_csv(&amp;self) -&gt; Result&lt;String&gt; {</span></div><div class="token-line"><span class="token plain">            let mut buf = Vec::new();</span></div><div class="token-line"><span class="token plain">            let writer = CsvWriter::new(&amp;mut buf);</span></div><div class="token-line"><span class="token plain">            writer.finish(self)?;</span></div><div class="token-line"><span class="token plain">            Ok(String::from_utf8(buf)?)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// 从 from 中获取数据，从 where 中过滤，最后选取需要返回的列</span></div><div class="token-line"><span class="token plain">    pub async fn query&lt;T: AsRef&lt;str&gt;&gt;(sql: T) -&gt; Result&lt;DataSet&gt; {</span></div><div class="token-line"><span class="token plain">        let ast = Parser::parse_sql(&amp;TyrDialect::default(), sql.as_ref())?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        if ast.len() != 1 {</span></div><div class="token-line"><span class="token plain">            return Err(anyhow!(&quot;Only support single sql at the moment&quot;));</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        let sql = &amp;ast[0];</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 整个 SQL AST 转换成我们定义的 Sql 结构的细节都埋藏在 try_into() 中</span></div><div class="token-line"><span class="token plain">        // 我们只需关注数据结构的使用，怎么转换可以之后需要的时候才关注，这是</span></div><div class="token-line"><span class="token plain">        // 关注点分离，是我们控制软件复杂度的法宝。</span></div><div class="token-line"><span class="token plain">        let Sql {</span></div><div class="token-line"><span class="token plain">            source,</span></div><div class="token-line"><span class="token plain">            condition,</span></div><div class="token-line"><span class="token plain">            selection,</span></div><div class="token-line"><span class="token plain">            offset,</span></div><div class="token-line"><span class="token plain">            limit,</span></div><div class="token-line"><span class="token plain">            order_by,</span></div><div class="token-line"><span class="token plain">        } = sql.try_into()?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        info!(&quot;retrieving data from source: {}&quot;, source);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 从 source 读入一个 DataSet</span></div><div class="token-line"><span class="token plain">        // detect_content，怎么 detect 不重要，重要的是它能根据内容返回 DataSet</span></div><div class="token-line"><span class="token plain">        let ds = detect_content(retrieve_data(source).await?).load()?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        let mut filtered = match condition {</span></div><div class="token-line"><span class="token plain">            Some(expr) =&gt; ds.0.lazy().filter(expr),</span></div><div class="token-line"><span class="token plain">            None =&gt; ds.0.lazy(),</span></div><div class="token-line"><span class="token plain">        };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        filtered = order_by</span></div><div class="token-line"><span class="token plain">            .into_iter()</span></div><div class="token-line"><span class="token plain">            .fold(filtered, |acc, (col, desc)| acc.sort(&amp;col, desc));</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        if offset.is_some() || limit.is_some() {</span></div><div class="token-line"><span class="token plain">            filtered = filtered.slice(offset.unwrap_or(0), limit.unwrap_or(usize::MAX));</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        Ok(DataSet(filtered.select(selection).collect()?))</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在 query 函数的主流程中，整个 SQL AST 转换成了我们定义的 Sql 结构，细节都埋藏在 try_into() 中，我们只需关注数据结构 Sql 的使用，怎么转换之后需要的时候再关注。</p><p>这就是<a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Separation_of_concerns">关注点分离（Separation of Concerns）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，是我们控制软件复杂度的法宝。Rust 标准库中那些经过千锤百炼的 trait，就是用来帮助我们写出更好的、复杂度更低的代码。</p><p>主流程里有个 detect_content 函数，它可以识别文本内容，选择相应的加载器把文本加载为 DataSet，因为目前只支持 CSV，但未来可以支持 JSON 等其他格式。这个函数定义在 src/loader.rs 里，我们创建这个文件，并添入下面的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use crate::DataSet;</span></div><div class="token-line"><span class="token plain">    use anyhow::Result;</span></div><div class="token-line"><span class="token plain">    use polars::prelude::*;</span></div><div class="token-line"><span class="token plain">    use std::io::Cursor;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    pub trait Load {</span></div><div class="token-line"><span class="token plain">        type Error;</span></div><div class="token-line"><span class="token plain">        fn load(self) -&gt; Result&lt;DataSet, Self::Error&gt;;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #[derive(Debug)]</span></div><div class="token-line"><span class="token plain">    #[non_exhaustive]</span></div><div class="token-line"><span class="token plain">    pub enum Loader {</span></div><div class="token-line"><span class="token plain">        Csv(CsvLoader),</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #[derive(Default, Debug)]</span></div><div class="token-line"><span class="token plain">    pub struct CsvLoader(pub(crate) String);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl Loader {</span></div><div class="token-line"><span class="token plain">        pub fn load(self) -&gt; Result&lt;DataSet&gt; {</span></div><div class="token-line"><span class="token plain">            match self {</span></div><div class="token-line"><span class="token plain">                Loader::Csv(csv) =&gt; csv.load(),</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    pub fn detect_content(data: String) -&gt; Loader {</span></div><div class="token-line"><span class="token plain">        // TODO: 内容检测</span></div><div class="token-line"><span class="token plain">        Loader::Csv(CsvLoader(data))</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl Load for CsvLoader {</span></div><div class="token-line"><span class="token plain">        type Error = anyhow::Error;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        fn load(self) -&gt; Result&lt;DataSet, Self::Error&gt; {</span></div><div class="token-line"><span class="token plain">            let df = CsvReader::new(Cursor::new(self.0))</span></div><div class="token-line"><span class="token plain">                .infer_schema(Some(16))</span></div><div class="token-line"><span class="token plain">                .finish()?;</span></div><div class="token-line"><span class="token plain">            Ok(DataSet(df))</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>同样，通过 trait，我们虽然目前只支持 CsvLoader，但保留了为未来添加更多 Loader 的接口。</p><p>好，现在这个库就全部写完了，尝试编译一下。如果遇到了问题，不要着急，可以在这门课的 <a target="_blank" rel="noopener noreferrer" href="https://github.com/tyrchen/geektime-rust/blob/master/06_queryer/queryer">GitHub repo<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 里获取完整的代码，然后对应修改你本地的错误。</p><p>如果代码编译通过了，你可以修改之前的 examples/covid.rs，使用 SQL 来查询测试一下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use anyhow::Result;</span></div><div class="token-line"><span class="token plain">    use queryer::query;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #[tokio::main]</span></div><div class="token-line"><span class="token plain">    async fn main() -&gt; Result&lt;()&gt; {</span></div><div class="token-line"><span class="token plain">        tracing_subscriber::fmt::init();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        let url = &quot;https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/latest/owid-covid-latest.csv&quot;;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 使用 sql 从 URL 里获取数据</span></div><div class="token-line"><span class="token plain">        let sql = format!(</span></div><div class="token-line"><span class="token plain">            &quot;SELECT location name, total_cases, new_cases, total_deaths, new_deaths \</span></div><div class="token-line"><span class="token plain">            FROM {} where new_deaths &gt;= 500 ORDER BY new_cases DESC&quot;,</span></div><div class="token-line"><span class="token plain">            url</span></div><div class="token-line"><span class="token plain">        );</span></div><div class="token-line"><span class="token plain">        let df1 = query(sql).await?;</span></div><div class="token-line"><span class="token plain">        println!(&quot;{:?}&quot;, df1);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        Ok(())</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>Bingo！一切正常，我们完成了，用 SQL 语句请求网络上的某个 CSV ，并对 CSV 做查询和排序，返回结果的正确无误！<br/><img src="https://static001.geekbang.org/resource/image/be/7f/be4577cd181ea6e9fc44f5b6e735867f.png?wh=1662x1256" alt=""/></p><p>用 tokei 查看代码行数，可以看到，用了 375 行，远低于 500 行的目标！</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">❯ tokei src/</span></div><div class="token-line"><span class="token plain">    -------------------------------------------------------------------------------</span></div><div class="token-line"><span class="token plain">     Language            Files        Lines         Code     Comments       Blanks</span></div><div class="token-line"><span class="token plain">    -------------------------------------------------------------------------------</span></div><div class="token-line"><span class="token plain">     Rust                    5          466          375           22           69</span></div><div class="token-line"><span class="token plain">    -------------------------------------------------------------------------------</span></div><div class="token-line"><span class="token plain">     Total                   5          466          375           22           69</span></div><div class="token-line"><span class="token plain">    -------------------------------------------------------------------------------</span></div></pre></div><p>在这么小的代码量下，我们在架构上做了很多为解耦考虑的工作：整个架构被拆成了 Sql Parser、Fetcher、Loader 和 query 四个部分。<br/><img src="https://static001.geekbang.org/resource/image/35/1d/3580d96a85486849c9535cbdc6a6e51d.jpg?wh=1920x777" alt=""/><br/>其中未来可能存在变化的 Fetcher 和 Loader 可以轻松扩展，比如我们一开始提到的那个 “select * from ps”，可以用一个 StdoutFetcher 和 TsvLoader 来处理。</p><h2 id="支持其它语言"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/04#支持其它语言"><span class="icon icon-link"></span></a>支持其它语言</h2><p>现在我们的核心代码写完了，有没有感觉自己成就感爆棚，实现的queryer工具可以在 Rust 下作为一个库，提供给其它 Rust 程序用，这很美妙。</p><p>但我们的故事还远不止如此。这么牛的功能，只能 Rust 程序员享用，太暴殄天物了。毕竟独乐乐不如众乐乐。所以，我们来试着<strong>将它集成到其它语言，比如常用的 Node.js/Python</strong>。</p><p>Node.js/Python 中有很多高性能的代码，都是 C/C++ 写的，但跨语言调用往往涉及繁杂的接口转换代码，所以用 C/C++ ，写这些接口转换的时候非常痛苦。</p><p>我们看看如果用 Rust 的话，能否避免这些繁文缛节？毕竟，我们对使用 Rust ，为其它语言提供高性能代码，有很高的期望，如果这个过程也很复杂，那怎么用得起来？</p><p>对于 queryer 库，我们想暴露出来的主要接口是：query，用户传入一个 SQL 字符串和一个输出类型的字符串，返回一个按照 SQL 查询处理过的、符合输出类型的字符串。比如对 Python 来说，就是下面的接口：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">def query(sql, output = &#x27;csv&#x27;)</span></div></pre></div><p>好，我们来试试看。</p><p>先创建一个新的目录 queryer 作为 workspace，把现有的 queryer 移进去，成为它的子目录。然后，我们创建一个 Cargo.toml，包含以下代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[workspace]</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    members = [</span></div><div class="token-line"><span class="token plain">      &quot;queryer&quot;,</span></div><div class="token-line"><span class="token plain">      &quot;queryer-py&quot;</span></div><div class="token-line"><span class="token plain">    ]</span></div></pre></div><h3 id="python"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/04#python"><span class="icon icon-link"></span></a>Python</h3><p>我们在 workspace 的根目录下， <code>cargo new queryer-py \--lib</code> ，生成一个新的 crate。在 queryer-py 下，编辑 Cargo.toml：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[package]</span></div><div class="token-line"><span class="token plain">    name = &quot;queryer_py&quot; # Python 模块需要用下划线</span></div><div class="token-line"><span class="token plain">    version = &quot;0.1.0&quot;</span></div><div class="token-line"><span class="token plain">    edition = &quot;2018&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    [lib]</span></div><div class="token-line"><span class="token plain">    crate-type = [&quot;cdylib&quot;] # 使用 cdylib 类型</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    [dependencies]</span></div><div class="token-line"><span class="token plain">    queryer = { path = &quot;../queryer&quot; } # 引入 queryer</span></div><div class="token-line"><span class="token plain">    tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    [dependencies.pyo3] # 引入 pyo3</span></div><div class="token-line"><span class="token plain">    version = &quot;0.14&quot;</span></div><div class="token-line"><span class="token plain">    features = [&quot;extension-module&quot;]</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    [build-dependencies]</span></div><div class="token-line"><span class="token plain">    pyo3-build-config = &quot;0.14&quot;</span></div></pre></div><p>Rust 和 Python 交互的库是 <a target="_blank" rel="noopener noreferrer" href="https://github.com/PyO3/pyo3">pyo3<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，感兴趣你可以课后看它的文档。在 src/lib.rs 下，添入如下代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use pyo3::{exceptions, prelude::*};</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #[pyfunction]</span></div><div class="token-line"><span class="token plain">    pub fn example_sql() -&gt; PyResult&lt;String&gt; {</span></div><div class="token-line"><span class="token plain">        Ok(queryer::example_sql())</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #[pyfunction]</span></div><div class="token-line"><span class="token plain">    pub fn query(sql: &amp;str, output: Option&lt;&amp;str&gt;) -&gt; PyResult&lt;String&gt; {</span></div><div class="token-line"><span class="token plain">        let rt = tokio::runtime::Runtime::new().unwrap();</span></div><div class="token-line"><span class="token plain">        let data = rt.block_on(async { queryer::query(sql).await.unwrap() });</span></div><div class="token-line"><span class="token plain">        match output {</span></div><div class="token-line"><span class="token plain">            Some(&quot;csv&quot;) | None =&gt; Ok(data.to_csv().unwrap()),</span></div><div class="token-line"><span class="token plain">            Some(v) =&gt; Err(exceptions::PyTypeError::new_err(format!(</span></div><div class="token-line"><span class="token plain">                &quot;Output type {} not supported&quot;,</span></div><div class="token-line"><span class="token plain">                v</span></div><div class="token-line"><span class="token plain">            ))),</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #[pymodule]</span></div><div class="token-line"><span class="token plain">    fn queryer_py(_py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {</span></div><div class="token-line"><span class="token plain">        m.add_function(wrap_pyfunction!(query, m)?)?;</span></div><div class="token-line"><span class="token plain">        m.add_function(wrap_pyfunction!(example_sql, m)?)?;</span></div><div class="token-line"><span class="token plain">        Ok(())</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>即使我不解释这些代码，你也基本能明白它在干嘛。我们为 Python 模块提供了两个接口 example_sql 和 query。</p><p>接下来在 queryer-py 目录下，创建 virtual env，然后用 <code>maturin develop</code> 构建 python 模块：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">python3 -m venv .env</span></div><div class="token-line"><span class="token plain">    source .env/bin/activate</span></div><div class="token-line"><span class="token plain">    pip install maturin ipython</span></div><div class="token-line"><span class="token plain">    maturin develop</span></div></pre></div><p>构建完成后，可以用 ipython 测试：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">In [1]: import queryer_py</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    In [2]: sql = queryer_py.example_sql()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    In [3]: print(queryer_py.query(sql, &#x27;csv&#x27;))</span></div><div class="token-line"><span class="token plain">    name,total_cases,new_cases,total_deaths,new_deaths</span></div><div class="token-line"><span class="token plain">    India,32649947.0,46759.0,437370.0,509.0</span></div><div class="token-line"><span class="token plain">    Iran,4869414.0,36279.0,105287.0,571.0</span></div><div class="token-line"><span class="token plain">    Africa,7695475.0,33957.0,193394.0,764.0</span></div><div class="token-line"><span class="token plain">    South America,36768062.0,33853.0,1126593.0,1019.0</span></div><div class="token-line"><span class="token plain">    Brazil,20703906.0,27345.0,578326.0,761.0</span></div><div class="token-line"><span class="token plain">    Mexico,3311317.0,19556.0,257150.0,863.0</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    In [4]: print(queryer_py.query(sql, &#x27;json&#x27;))</span></div><div class="token-line"><span class="token plain">    ---------------------------------------------------------------------------</span></div><div class="token-line"><span class="token plain">    TypeError                                 Traceback (most recent call last)</span></div><div class="token-line"><span class="token plain">    &lt;ipython-input-4-7082f1ffe46a&gt; in &lt;module&gt;</span></div><div class="token-line"><span class="token plain">    ----&gt; 1 print(queryer_py.query(sql, &#x27;json&#x27;))</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    TypeError: Output type json not supported</span></div></pre></div><p>Cool！仅仅写了 20 行代码，就让我们的模块可以被 Python 调用，错误处理也很正常。你看，在用 Rust 库的基础上，我们稍微写一些辅助代码，就能够让它和不同的语言集成起来。我觉得这是 Rust 非常有潜力的使用方向。</p><p>毕竟，对很多公司来说，原有的代码库想要完整迁移到 Rust 成本很大，但是通过 Rust 和各个语言轻便地集成，可以把部分需要高性能的代码迁移到 Rust，尝到甜头，再一点点推广。这样，Rust 就能应用起来了。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/04#小结"><span class="icon icon-link"></span></a>小结</h2><p>回顾这周的 Rust 代码之旅，我们先做了个 HTTPie，流程简单，青铜级难度，你学完所有权，理解了基本的 trait 后就能写。</p><p>之后的 Thumbor，引入了异步、泛型和更多的 trait，白银级难度，在你学完类型系统，对异步稍有了解后，应该可以搞定。</p><p>今天的 Queryer，使用了大量的 trait ，来让代码结构足够符合开闭原则和关注点分离，用了不少生命周期标注，来减少不必要的内存拷贝，还做了不少复杂的模式匹配来获取数据，是黄金级难度，在学完本课程的进阶篇后，你应该可以理解这些代码。</p><p>很多人觉得 Rust 代码很难写，尤其是泛型数据结构和生命周期搅在一起的时候。但在前两个例子里，生命周期的标注只出现过了一次。所以，<strong>其实大部分时候，你的代码并不需要复杂的生命周期标注</strong>。</p><p>只要对所有权和生命周期的理解没有问题，如果你陷入了无休止的生命周期标注，和编译器痛苦地搏斗，那你也许要停下来先想一想：</p><p>编译器如此不喜欢我的写法，会不会我的设计本身就有问题呢？我是不是该使用更好的数据结构？我是不是该重新设计一下？我的代码是不是过度耦合了？</p><p>就像茴香豆的茴字有四种写法一样，同一个需求，用相同的语言，不同的人也会有不同的写法。但是，<strong>优秀的设计一定是产生简单易读的代码，而不是相反</strong>。</p><p>好，这周的代码之旅就告一段落了，接下来我们就要展开一段壮丽的探险，你将会像比尔博·巴金斯那样，在通往孤山的冒险之旅中，一点点探索迷人的中土世界。等到我们学完了所有权、类型系统、trait、智能指针等内容之后，再来看这三个实例，相信你会有不一样的感悟。我也会在后续的课程中，根据已学内容，回顾今天写的代码，继续优化和完善它们。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/04#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>Node.js 的处理和 Python 非常类似，但接口不太一样，就作为今天的思考题让你尝试一下。小提示：Rust 和 nodejs 间交互可以使用 <a target="_blank" rel="noopener noreferrer" href="https://github.com/neon-bindings/neon">neon<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>欢迎在留言区分享你的思考。你的 Rust 学习第六次打卡成功，我们下一讲见！</p><h2 id="参考资料"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/03.基础篇/04#参考资料"><span class="icon icon-link"></span></a>参考资料</h2><p>我们的 queryer 库目前使用到了操作系统的功能，比如文件系统，所以它无法被编译成 WebAssembly。未来如果能移除对操作系统的依赖，这个代码还能被编译成 WASM，供 Web 前端使用。</p><p>如果想在 iOS/Android 下使用这个库，可以用类似 Python/Node.js 的方法做接口封装，Mozilla 提供了一个 <a target="_blank" rel="noopener noreferrer" href="https://github.com/mozilla/uniffi-rs">uniffi<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的库，它自己的 Firefox 各个端也是这么处理的：</p><p><img src="https://static001.geekbang.org/resource/image/ab/f2/ab423b37a2c4b6bc3f5c17ca2c2e1af2.png?wh=3641x2386" alt=""/></p><p>对于桌面开发，Rust 下有一个很有潜力的客户端开发工具 <a target="_blank" rel="noopener noreferrer" href="https://github.com/tauri-apps/tauri">tauri<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，它很有机会取代很多使用 Electron 的场合。</p><p>我写了一个简单的 tuari App 叫 data-viewer，如果你感兴趣的话，可以在 <a target="_blank" rel="noopener noreferrer" href="https://github.com/tyrchen/geektime-rust/blob/master/06_queryer/data-viewer">github repo<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 下的 data-viewer 目录下看 tauri 使用 queryer 的代码，下面是运行后的效果。为了让代码最简单，前端没有用任何框架，如果你是一名前端开发者，可以用 Vue 或者 React 加上一个合适的 CSS 库让整个界面变得更加友好。<br/><img src="https://static001.geekbang.org/resource/image/82/e7/826ef4913c54c81f8a5fa25ca92481e7.png?wh=2000x1433" alt=""/></p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/陈天rust编程第一课/03.基础篇/04.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:24</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
