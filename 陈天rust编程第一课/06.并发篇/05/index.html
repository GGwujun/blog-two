<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>36｜阶段实操（4）：构建一个简单的KV server-网络处理</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/陈天rust编程第一课/06.并发篇/05" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/陈天rust编程第一课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-two/陈天rust编程第一课/01.开篇词/01"><span>开篇词｜让Rust成为你的下一门主力语言</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/02.前置篇">02.前置篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/02.前置篇/01"><span>01｜内存：值放堆上还是放栈上，这是一个问题</span></a></li><li><a href="/blog-two/陈天rust编程第一课/02.前置篇/02"><span>02｜串讲：编程开发中，那些你需要掌握的基本概念</span></a></li><li><a href="/blog-two/陈天rust编程第一课/02.前置篇/03"><span>加餐｜这个专栏你可以怎么学，以及Rust是否值得学？</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇">03.基础篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/01"><span>03｜初窥门径：从你的第一个Rust程序开始！</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/02"><span>04｜get hands dirty：来写个实用的CLI小工具</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/03"><span>05｜get hands dirty：做一个图片服务器有多难？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/04"><span>06｜get hands dirty：SQL查询工具怎么一鱼多吃？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/05"><span>07｜所有权：值的生杀大权到底在谁手上？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/06"><span>08｜所有权：值的借用是如何工作的？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/07"><span>09｜所有权：一个值可以有多个所有者么？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/08"><span>10｜生命周期：你创建的值究竟能活多久？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/09"><span>11｜内存管理：从创建到消亡，值都经历了什么？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/10"><span>加餐｜愚昧之巅：你的Rust学习常见问题汇总</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/11"><span>12｜类型系统：Rust的类型系统有什么特点？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/12"><span>13｜类型系统：如何使用trait来定义接口？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/13"><span>14｜类型系统：有哪些必须掌握的trait？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/14"><span>15｜数据结构：这些浓眉大眼的结构竟然都是智能指针？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/15"><span>16｜数据结构：Vec、&amp;[T]、Box&lt;[T]&gt; ，你真的了解集合容器么？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/16"><span>17｜数据结构：软件系统核心部件哈希表，内存如何布局？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/17"><span>18｜错误处理：为什么Rust的错误处理与众不同？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/18"><span>19｜闭包：FnOnce、FnMut和Fn，为什么有这么多类型？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/19"><span>20｜4 Steps ：如何更好地阅读Rust源码？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/20"><span>21｜阶段实操（1）：构建一个简单的KV server-基本流程</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/21"><span>22｜阶段实操（2）：构建一个简单的KV server-基本流程</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/04.期中周">04.期中周</a><ul><li><a href="/blog-two/陈天rust编程第一课/04.期中周/01"><span>加餐｜期中测试：来写一个简单的grep命令行</span></a></li><li><a href="/blog-two/陈天rust编程第一课/04.期中周/02"><span>加餐｜期中测试：参考实现讲解</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇">05.进阶篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/01"><span>23｜类型系统：如何在实战中使用泛型编程？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/02"><span>24｜类型系统：如何在实战中使用trait object？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/03"><span>25｜类型系统：如何围绕trait来设计和架构系统？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/04"><span>加餐｜Rust2021版次问世了！</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/05"><span>26｜阶段实操（3）：构建一个简单的KV server-高级trait技巧</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/06"><span>27｜生态系统：有哪些常有的Rust库可以为我所用？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/07"><span>28｜网络开发（上）：如何使用Rust处理网络请求？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/08"><span>29｜网络开发（下）：如何使用Rust处理网络请求？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/09"><span>30｜Unsafe Rust：如何用C++的方式打开Rust？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/10"><span>31｜FFI：Rust如何和你的语言架起沟通桥梁？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/11"><span>32｜实操项目：使用PyO3开发Python3模块</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课/06.并发篇">06.并发篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/01"><span>33｜并发处理（上）：从atomics到Channel，Rust都提供了什么工具？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/02"><span>34｜并发处理（下）：从atomics到Channel，Rust都提供了什么工具？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/03"><span>35｜实操项目：如何实现一个基本的MPSC channel？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/04"><span>用户故事｜绝望之谷：改变从学习开始</span></a></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课/06.并发篇/05"><span>36｜阶段实操（4）：构建一个简单的KV server-网络处理</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/06"><span>37｜阶段实操（5）：构建一个简单的KV server-网络安全</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/07"><span>38｜异步处理：Future是什么？它和async/await是什么关系？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/08"><span>39｜异步处理：async/await内部是怎么实现的？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/09"><span>40｜异步处理：如何处理异步IO？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/10"><span>41｜阶段实操（6）：构建一个简单的KV server-异步处理</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/11"><span>42｜阶段实操（7）：构建一个简单的KV server-如何做大的重构？</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇">07.实战篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/01"><span>43｜生产环境：真实世界下的一个Rust项目包含哪些要素？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/02"><span>44｜数据处理：应用程序和数据如何打交道？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/03"><span>45｜阶段实操（8）：构建一个简单的KV server-配置/测试/监控/CI/CD</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/04"><span>46｜软件架构：如何用Rust架构复杂系统？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/05"><span>大咖助场｜开悟之坡（上）：Rust的现状、机遇与挑战</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/06"><span>大咖助场｜开悟之坡（下）：Rust的现状、机遇与挑战</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/07"><span>用户故事｜语言不仅是工具，还是思维方式</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/08.高级篇">08.高级篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/08.高级篇/01"><span>加餐｜代码即数据：为什么我们需要宏编程能力？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/08.高级篇/02"><span>加餐｜宏编程（上）：用最“笨”的方式撰写宏</span></a></li><li><a href="/blog-two/陈天rust编程第一课/08.高级篇/03"><span>加餐｜宏编程（下）：用 syn/quote 优雅地构建宏</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/09.结束语">09.结束语</a><ul><li><a href="/blog-two/陈天rust编程第一课/09.结束语/01"><span>结束语｜永续之原：Rust学习，如何持续精进？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/09.结束语/02"><span>期末测试｜来赴一场满分之约！</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊">10.学习锦囊</a><ul><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊/01"><span>特别策划｜学习锦囊（一）：听听课代表们怎么说</span></a></li><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊/02"><span>特别策划｜学习锦囊（二）：听听课代表们怎么说</span></a></li><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊/03"><span>特别策划｜学习锦囊（三）：听听课代表们怎么说</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/summary">陈天rust编程第一课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="如何定义协议的 Frame？" data-depth="2"><a href="/blog-two/陈天rust编程第一课/06.并发篇/05#如何定义协议的-frame"><span>如何定义协议的 Frame？</span></a></li><li title="如何撰写处理 Frame 的代码？" data-depth="2"><a href="/blog-two/陈天rust编程第一课/06.并发篇/05#如何撰写处理-frame-的代码"><span>如何撰写处理 Frame 的代码？</span></a></li><li title="让网络层可以像 AsyncProst 那样方便使用" data-depth="2"><a href="/blog-two/陈天rust编程第一课/06.并发篇/05#让网络层可以像-asyncprost-那样方便使用"><span>让网络层可以像 AsyncProst 那样方便使用</span></a></li><li title="正式创建 kv-server 和 kv-client" data-depth="2"><a href="/blog-two/陈天rust编程第一课/06.并发篇/05#正式创建-kv-server-和-kv-client"><span>正式创建 kv-server 和 kv-client</span></a></li><li title="小结" data-depth="2"><a href="/blog-two/陈天rust编程第一课/06.并发篇/05#小结"><span>小结</span></a></li><li title="思考题" data-depth="3"><a href="/blog-two/陈天rust编程第一课/06.并发篇/05#思考题"><span>思考题</span></a></li><li title="延伸阅读" data-depth="3"><a href="/blog-two/陈天rust编程第一课/06.并发篇/05#延伸阅读"><span>延伸阅读</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="36阶段实操4构建一个简单的kv-server-网络处理"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/05#36阶段实操4构建一个简单的kv-server-网络处理"><span class="icon icon-link"></span></a>36｜阶段实操（4）：构建一个简单的KV server-网络处理</h1><p>你好，我是陈天。</p><p>经历了基础篇和进阶篇中两讲的构建和优化，到现在，我们的KV server 核心功能已经比较完善了。不知道你有没有注意，之前一直在使用一个神秘的 <a target="_blank" rel="noopener noreferrer" href="https://github.com/tyrchen/async-prost">async-prost<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 库，我们神奇地完成了TCP frame 的封包和解包。是怎么完成的呢？</p><p>async-prost 是我仿照 Jonhoo 的 <a target="_blank" rel="noopener noreferrer" href="https://github.com/jonhoo/async-bincode">async-bincode<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 做的一个处理 protobuf frame 的库，它可以和各种网络协议适配，包括 TCP / WebSocket / HTTP2 等。由于考虑通用性，它的抽象级别比较高，用了大量的泛型参数，主流程如下图所示：<br/><img src="https://static001.geekbang.org/resource/image/5a/4f/5afafe8646ee8b05b69a463ab5f5554f.png?wh=1428x895" alt=""/></p><p>主要的思路就是在序列化数据的时候，添加一个头部来提供 frame 的长度，反序列化的时候，先读出头部，获得长度，再读取相应的数据。感兴趣的同学可以去看代码，这里就不展开了。</p><p>今天我们的挑战就是，在上一次完成的 KV server 的基础上，来试着不依赖 async-prost，自己处理封包和解包的逻辑。如果你掌握了这个能力，配合 protobuf，就可以设计出任何可以承载实际业务的协议了。</p><h2 id="如何定义协议的-frame"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/05#如何定义协议的-frame"><span class="icon icon-link"></span></a>如何定义协议的 Frame？</h2><p>protobuf 帮我们解决了协议消息如何定义的问题，然而一个消息和另一个消息之间如何区分，是个伤脑筋的事情。我们需要定义合适的分隔符。</p><p>分隔符 + 消息数据，就是一个 Frame。之前在28网络开发<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/432162">那一讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>简单说过如何界定一个frame。</p><p>很多基于 TCP 的协议会使用 \r\n 做分隔符，比如 FTP；也有使用消息长度做分隔符的，比如 gRPC；还有混用两者的，比如 Redis 的 RESP；更复杂的如 HTTP，header 之间使用 \r\n 分隔，header / body 之间使用 \r\n\r\n，header 中会提供 body 的长度等等。</p><p>“\r\n” 这样的分隔符，适合协议报文是 ASCII 数据；而通过长度进行分隔，适合协议报文是二进制数据。<strong>我们的 KV Server 承载的 protobuf 是二进制，所以就在 payload 之前放一个长度，来作为 frame 的分隔</strong>。</p><p>这个长度取什么大小呢？如果使用 2 个字节，那么 payload 最大是 64k；如果使用 4 个字节，payload 可以到 4G。一般的应用取 4 个字节就足够了。如果你想要更灵活些，也可以使用 <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Variable-length_quantity">varint<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>tokio 有个 tokio-util 库，已经帮我们处理了和 frame 相关的封包解包的主要需求，包括 LinesDelimited（处理 \r\n 分隔符）和 LengthDelimited（处理长度分隔符）。我们可以使用它的 <a target="_blank" rel="noopener noreferrer" href="https://docs.rs/tokio-util/0.6.8/tokio_util/codec/length_delimited/index.html">LengthDelimitedCodec<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 尝试一下。</p><p>首先在 Cargo.toml 里添加依赖：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[dev-dependencies]</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    tokio-util = { version = &quot;0.6&quot;, features = [&quot;codec&quot;]}</span></div><div class="token-line"><span class="token plain">    ...</span></div></pre></div><p>然后创建 examples/server_with_codec.rs 文件，添入如下代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use anyhow::Result;</span></div><div class="token-line"><span class="token plain">    use futures::prelude::*;</span></div><div class="token-line"><span class="token plain">    use kv2::{CommandRequest, MemTable, Service, ServiceInner};</span></div><div class="token-line"><span class="token plain">    use prost::Message;</span></div><div class="token-line"><span class="token plain">    use tokio::net::TcpListener;</span></div><div class="token-line"><span class="token plain">    use tokio_util::codec::{Framed, LengthDelimitedCodec};</span></div><div class="token-line"><span class="token plain">    use tracing::info;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #[tokio::main]</span></div><div class="token-line"><span class="token plain">    async fn main() -&gt; Result&lt;()&gt; {</span></div><div class="token-line"><span class="token plain">        tracing_subscriber::fmt::init();</span></div><div class="token-line"><span class="token plain">        let service: Service = ServiceInner::new(MemTable::new()).into();</span></div><div class="token-line"><span class="token plain">        let addr = &quot;127.0.0.1:9527&quot;;</span></div><div class="token-line"><span class="token plain">        let listener = TcpListener::bind(addr).await?;</span></div><div class="token-line"><span class="token plain">        info!(&quot;Start listening on {}&quot;, addr);</span></div><div class="token-line"><span class="token plain">        loop {</span></div><div class="token-line"><span class="token plain">            let (stream, addr) = listener.accept().await?;</span></div><div class="token-line"><span class="token plain">            info!(&quot;Client {:?} connected&quot;, addr);</span></div><div class="token-line"><span class="token plain">            let svc = service.clone();</span></div><div class="token-line"><span class="token plain">            tokio::spawn(async move {</span></div><div class="token-line"><span class="token plain">                let mut stream = Framed::new(stream, LengthDelimitedCodec::new());</span></div><div class="token-line"><span class="token plain">                while let Some(Ok(mut buf)) = stream.next().await {</span></div><div class="token-line"><span class="token plain">                    let cmd = CommandRequest::decode(&amp;buf[..]).unwrap();</span></div><div class="token-line"><span class="token plain">                    info!(&quot;Got a new command: {:?}&quot;, cmd);</span></div><div class="token-line"><span class="token plain">                    let res = svc.execute(cmd);</span></div><div class="token-line"><span class="token plain">                    buf.clear();</span></div><div class="token-line"><span class="token plain">                    res.encode(&amp;mut buf).unwrap();</span></div><div class="token-line"><span class="token plain">                    stream.send(buf.freeze()).await.unwrap();</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">                info!(&quot;Client {:?} disconnected&quot;, addr);</span></div><div class="token-line"><span class="token plain">            });</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>你可以对比一下它和之前的 examples/server.rs 的差别，主要改动了这一行：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// let mut stream = AsyncProstStream::&lt;_, CommandRequest, CommandResponse, _&gt;::from(stream).for_async();</span></div><div class="token-line"><span class="token plain">    let mut stream = Framed::new(stream, LengthDelimitedCodec::new());</span></div></pre></div><p>完成之后，我们打开一个命令行窗口，运行：<code>RUST_LOG=info cargo run \--example server_with_codec \--quiet</code>。然后在另一个命令行窗口，运行：<code>RUST_LOG=info cargo run \--example client \--quiet</code>。此时，服务器和客户端都收到了彼此的请求和响应，并且处理正常。</p><p>你这会是不是有点疑惑，为什么客户端没做任何修改也能和服务器通信？那是因为在目前的使用场景下，使用 AsyncProst 的客户端兼容 LengthDelimitedCodec。</p><h2 id="如何撰写处理-frame-的代码"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/05#如何撰写处理-frame-的代码"><span class="icon icon-link"></span></a>如何撰写处理 Frame 的代码？</h2><p><a target="_blank" rel="noopener noreferrer" href="https://docs.rs/tokio-util/0.6.8/tokio_util/codec/length_delimited/index.html">LengthDelimitedCodec<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 非常好用，它的代码也并不复杂，非常建议你有空研究一下。既然这一讲主要围绕网络开发展开，那么我们也来尝试一下撰写自己的对 Frame 处理的代码吧。</p><p>按照前面分析，我们在 protobuf payload 前加一个 4 字节的长度，这样，对端读取数据时，可以先读 4 字节，然后根据读到的长度，进一步读取满足这个长度的数据，之后就可以用相应的数据结构解包了。</p><p>为了更贴近实际，<strong>我们把4字节长度的最高位拿出来作为是否压缩的信号</strong>，如果设置了，代表后续的 payload 是 gzip 压缩过的 protobuf，否则直接是 protobuf：<br/><img src="https://static001.geekbang.org/resource/image/71/03/712735ae12d0cdf39b3dcf5bb242f103.jpg?wh=2149x1485" alt=""/></p><p>按照惯例，还是先来定义处理这个逻辑的 trait：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pub trait FrameCoder</span></div><div class="token-line"><span class="token plain">    where</span></div><div class="token-line"><span class="token plain">        Self: Message + Sized + Default,</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        /// 把一个 Message encode 成一个 frame</span></div><div class="token-line"><span class="token plain">        fn encode_frame(&amp;self, buf: &amp;mut BytesMut) -&gt; Result&lt;(), KvError&gt;;</span></div><div class="token-line"><span class="token plain">        /// 把一个完整的 frame decode 成一个 Message</span></div><div class="token-line"><span class="token plain">        fn decode_frame(buf: &amp;mut BytesMut) -&gt; Result&lt;Self, KvError&gt;;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>定义了两个方法：</p><ul><li>encode_frame() 可以把诸如 CommandRequest 这样的消息<strong>封装</strong>成一个 frame，写入传进来的 BytesMut；</li><li>decode_frame() 可以把收到的一个完整的、放在 BytesMut 中的数据，<strong>解封装</strong>成诸如 CommandRequest 这样的消息。</li></ul><p>如果要实现这个 trait，Self 需要实现了 prost::Message，大小是固定的，并且实现了 Default（prost 的需求）。</p><p>好，我们再写实现代码。首先创建 src/network 目录，并在其下添加两个文件<a target="_blank" rel="noopener noreferrer" href="http://mod.rs/">mod.rs<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 和 <a target="_blank" rel="noopener noreferrer" href="http://frame.rs/">frame.rs<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。然后在 src/network/mod.rs 里引入 src/network/frame.rs：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">mod frame;</span></div><div class="token-line"><span class="token plain">    pub use frame::FrameCoder;</span></div></pre></div><p>同时在 <a target="_blank" rel="noopener noreferrer" href="http://lib.rs/">lib.rs<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 里引入 network：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">mod network;</span></div><div class="token-line"><span class="token plain">    pub use network::*;</span></div></pre></div><p>因为要处理 gzip 压缩，还需要在 Cargo.toml 中引入 <a target="_blank" rel="noopener noreferrer" href="https://github.com/rust-lang/flate2-rs">flate2<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，同时，因为今天这一讲引入了网络相关的操作和数据结构，我们需要把 tokio 从 dev-dependencies 移到 dependencies 里，为简单起见，就用 full features：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[dependencies]</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    flate2 = &quot;1&quot; # gzip 压缩</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] } # 异步网络库</span></div><div class="token-line"><span class="token plain">    ...</span></div></pre></div><p>然后，在 src/network/frame.rs 里添加 trait 和实现 trait 的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use std::io::{Read, Write};</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    use crate::{CommandRequest, CommandResponse, KvError};</span></div><div class="token-line"><span class="token plain">    use bytes::{Buf, BufMut, BytesMut};</span></div><div class="token-line"><span class="token plain">    use flate2::{read::GzDecoder, write::GzEncoder, Compression};</span></div><div class="token-line"><span class="token plain">    use prost::Message;</span></div><div class="token-line"><span class="token plain">    use tokio::io::{AsyncRead, AsyncReadExt};</span></div><div class="token-line"><span class="token plain">    use tracing::debug;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// 长度整个占用 4 个字节</span></div><div class="token-line"><span class="token plain">    pub const LEN_LEN: usize = 4;</span></div><div class="token-line"><span class="token plain">    /// 长度占 31 bit，所以最大的 frame 是 2G</span></div><div class="token-line"><span class="token plain">    const MAX_FRAME: usize = 2 * 1024 * 1024 * 1024;</span></div><div class="token-line"><span class="token plain">    /// 如果 payload 超过了 1436 字节，就做压缩</span></div><div class="token-line"><span class="token plain">    const COMPRESSION_LIMIT: usize = 1436;</span></div><div class="token-line"><span class="token plain">    /// 代表压缩的 bit（整个长度 4 字节的最高位）</span></div><div class="token-line"><span class="token plain">    const COMPRESSION_BIT: usize = 1 &lt;&lt; 31;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// 处理 Frame 的 encode/decode</span></div><div class="token-line"><span class="token plain">    pub trait FrameCoder</span></div><div class="token-line"><span class="token plain">    where</span></div><div class="token-line"><span class="token plain">        Self: Message + Sized + Default,</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        /// 把一个 Message encode 成一个 frame</span></div><div class="token-line"><span class="token plain">        fn encode_frame(&amp;self, buf: &amp;mut BytesMut) -&gt; Result&lt;(), KvError&gt; {</span></div><div class="token-line"><span class="token plain">            let size = self.encoded_len();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            if size &gt;= MAX_FRAME {</span></div><div class="token-line"><span class="token plain">                return Err(KvError::FrameError);</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 我们先写入长度，如果需要压缩，再重写压缩后的长度</span></div><div class="token-line"><span class="token plain">            buf.put_u32(size as _);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            if size &gt; COMPRESSION_LIMIT {</span></div><div class="token-line"><span class="token plain">                let mut buf1 = Vec::with_capacity(size);</span></div><div class="token-line"><span class="token plain">                self.encode(&amp;mut buf1)?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                // BytesMut 支持逻辑上的 split（之后还能 unsplit）</span></div><div class="token-line"><span class="token plain">                // 所以我们先把长度这 4 字节拿走，清除</span></div><div class="token-line"><span class="token plain">                let payload = buf.split_off(LEN_LEN);</span></div><div class="token-line"><span class="token plain">                buf.clear();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                // 处理 gzip 压缩，具体可以参考 flate2 文档</span></div><div class="token-line"><span class="token plain">                let mut encoder = GzEncoder::new(payload.writer(), Compression::default());</span></div><div class="token-line"><span class="token plain">                encoder.write_all(&amp;buf1[..])?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                // 压缩完成后，从 gzip encoder 中把 BytesMut 再拿回来</span></div><div class="token-line"><span class="token plain">                let payload = encoder.finish()?.into_inner();</span></div><div class="token-line"><span class="token plain">                debug!(&quot;Encode a frame: size {}({})&quot;, size, payload.len());</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                // 写入压缩后的长度</span></div><div class="token-line"><span class="token plain">                buf.put_u32((payload.len() | COMPRESSION_BIT) as _);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                // 把 BytesMut 再合并回来</span></div><div class="token-line"><span class="token plain">                buf.unsplit(payload);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                Ok(())</span></div><div class="token-line"><span class="token plain">            } else {</span></div><div class="token-line"><span class="token plain">                self.encode(buf)?;</span></div><div class="token-line"><span class="token plain">                Ok(())</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        /// 把一个完整的 frame decode 成一个 Message</span></div><div class="token-line"><span class="token plain">        fn decode_frame(buf: &amp;mut BytesMut) -&gt; Result&lt;Self, KvError&gt; {</span></div><div class="token-line"><span class="token plain">            // 先取 4 字节，从中拿出长度和 compression bit</span></div><div class="token-line"><span class="token plain">            let header = buf.get_u32() as usize;</span></div><div class="token-line"><span class="token plain">            let (len, compressed) = decode_header(header);</span></div><div class="token-line"><span class="token plain">            debug!(&quot;Got a frame: msg len {}, compressed {}&quot;, len, compressed);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            if compressed {</span></div><div class="token-line"><span class="token plain">                // 解压缩</span></div><div class="token-line"><span class="token plain">                let mut decoder = GzDecoder::new(&amp;buf[..len]);</span></div><div class="token-line"><span class="token plain">                let mut buf1 = Vec::with_capacity(len * 2);</span></div><div class="token-line"><span class="token plain">                decoder.read_to_end(&amp;mut buf1)?;</span></div><div class="token-line"><span class="token plain">                buf.advance(len);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                // decode 成相应的消息</span></div><div class="token-line"><span class="token plain">                Ok(Self::decode(&amp;buf1[..buf1.len()])?)</span></div><div class="token-line"><span class="token plain">            } else {</span></div><div class="token-line"><span class="token plain">                let msg = Self::decode(&amp;buf[..len])?;</span></div><div class="token-line"><span class="token plain">                buf.advance(len);</span></div><div class="token-line"><span class="token plain">                Ok(msg)</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl FrameCoder for CommandRequest {}</span></div><div class="token-line"><span class="token plain">    impl FrameCoder for CommandResponse {}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fn decode_header(header: usize) -&gt; (usize, bool) {</span></div><div class="token-line"><span class="token plain">        let len = header &amp; !COMPRESSION_BIT;</span></div><div class="token-line"><span class="token plain">        let compressed = header &amp; COMPRESSION_BIT == COMPRESSION_BIT;</span></div><div class="token-line"><span class="token plain">        (len, compressed)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这段代码本身并不难理解。我们直接为 FrameCoder 提供了缺省实现，然后 CommandRequest / CommandResponse 做了空实现。其中使用了之前介绍过的 bytes 库里的 BytesMut，以及新引入的 GzEncoder / GzDecoder。你可以按照 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/424017">20 讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>介绍的阅读源码的方式，了解这几个数据类型的用法。最后还写了个辅助函数 decode_header()，让 decode_frame() 的代码更直观一些。</p><p>如果你有些疑惑为什么 <code>COMPRESSION_LIMIT</code> 设成 1436？</p><p>这是因为以太网的 MTU 是 1500，除去 IP 头 20 字节、TCP 头 20 字节，还剩 1460；一般 TCP 包会包含一些 Option（比如 timestamp），IP 包也可能包含，所以我们预留 20 字节；再减去 4 字节的长度，就是<strong>1436，不用分片的最大消息长度。如果大于这个，很可能会导致分片，我们就干脆压缩一下</strong>。</p><p>现在，CommandRequest / CommandResponse 就可以做 frame 级别的处理了，我们写一些测试验证是否工作。还是在 src/network/frame.rs 里，添加测试代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#[cfg(test)]</span></div><div class="token-line"><span class="token plain">    mod tests {</span></div><div class="token-line"><span class="token plain">        use super::*;</span></div><div class="token-line"><span class="token plain">        use crate::Value;</span></div><div class="token-line"><span class="token plain">        use bytes::Bytes;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        #[test]</span></div><div class="token-line"><span class="token plain">        fn command_request_encode_decode_should_work() {</span></div><div class="token-line"><span class="token plain">            let mut buf = BytesMut::new();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            let cmd = CommandRequest::new_hdel(&quot;t1&quot;, &quot;k1&quot;);</span></div><div class="token-line"><span class="token plain">            cmd.encode_frame(&amp;mut buf).unwrap();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 最高位没设置</span></div><div class="token-line"><span class="token plain">            assert_eq!(is_compressed(&amp;buf), false);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            let cmd1 = CommandRequest::decode_frame(&amp;mut buf).unwrap();</span></div><div class="token-line"><span class="token plain">            assert_eq!(cmd, cmd1);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        #[test]</span></div><div class="token-line"><span class="token plain">        fn command_response_encode_decode_should_work() {</span></div><div class="token-line"><span class="token plain">            let mut buf = BytesMut::new();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            let values: Vec&lt;Value&gt; = vec![1.into(), &quot;hello&quot;.into(), b&quot;data&quot;.into()];</span></div><div class="token-line"><span class="token plain">            let res: CommandResponse = values.into();</span></div><div class="token-line"><span class="token plain">            res.encode_frame(&amp;mut buf).unwrap();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 最高位没设置</span></div><div class="token-line"><span class="token plain">            assert_eq!(is_compressed(&amp;buf), false);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            let res1 = CommandResponse::decode_frame(&amp;mut buf).unwrap();</span></div><div class="token-line"><span class="token plain">            assert_eq!(res, res1);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        #[test]</span></div><div class="token-line"><span class="token plain">        fn command_response_compressed_encode_decode_should_work() {</span></div><div class="token-line"><span class="token plain">            let mut buf = BytesMut::new();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            let value: Value = Bytes::from(vec![0u8; COMPRESSION_LIMIT + 1]).into();</span></div><div class="token-line"><span class="token plain">            let res: CommandResponse = value.into();</span></div><div class="token-line"><span class="token plain">            res.encode_frame(&amp;mut buf).unwrap();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 最高位设置了</span></div><div class="token-line"><span class="token plain">            assert_eq!(is_compressed(&amp;buf), true);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            let res1 = CommandResponse::decode_frame(&amp;mut buf).unwrap();</span></div><div class="token-line"><span class="token plain">            assert_eq!(res, res1);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        fn is_compressed(data: &amp;[u8]) -&gt; bool {</span></div><div class="token-line"><span class="token plain">            if let &amp;[v] = &amp;data[..1] {</span></div><div class="token-line"><span class="token plain">                v &gt;&gt; 7 == 1</span></div><div class="token-line"><span class="token plain">            } else {</span></div><div class="token-line"><span class="token plain">                false</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个测试代码里面有从 [u8; N] 到 Value（<code>b&quot;data&quot;.into()</code>） 以及从 Bytes 到 Value 的转换，所以我们需要在 src/pb/mod.rs 里添加 From trait 的相应实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">impl&lt;const N: usize&gt; From&lt;&amp;[u8; N]&gt; for Value {</span></div><div class="token-line"><span class="token plain">        fn from(buf: &amp;[u8; N]) -&gt; Self {</span></div><div class="token-line"><span class="token plain">            Bytes::copy_from_slice(&amp;buf[..]).into()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl From&lt;Bytes&gt; for Value {</span></div><div class="token-line"><span class="token plain">        fn from(buf: Bytes) -&gt; Self {</span></div><div class="token-line"><span class="token plain">            Self {</span></div><div class="token-line"><span class="token plain">                value: Some(value::Value::Binary(buf)),</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>运行 <code>cargo test</code> ，所有测试都可以通过。</p><p>到这里，我们就完成了 Frame 的序列化（encode_frame）和反序列化（decode_frame），并且用测试确保它的正确性。<strong>做网络开发的时候，要尽可能把实现逻辑和 IO 分离，这样有助于可测性以及应对未来 IO 层的变更</strong>。目前，这个代码没有触及任何和 socket IO 相关的内容，只是纯逻辑，接下来我们要将它和我们用于处理服务器客户端的 TcpStream 联系起来。</p><p>在进一步写网络相关的代码前，还有一个问题需要解决：decode_frame() 函数使用的 BytesMut，是如何从 socket 里拿出来的？显然，先读 4 个字节，取出长度 N，然后再读 N 个字节。这个细节和 frame 关系很大，所以还需要在 src/network/frame.rs 里写个辅助函数 read_frame()：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/// 从 stream 中读取一个完整的 frame</span></div><div class="token-line"><span class="token plain">    pub async fn read_frame&lt;S&gt;(stream: &amp;mut S, buf: &amp;mut BytesMut) -&gt; Result&lt;(), KvError&gt;</span></div><div class="token-line"><span class="token plain">    where</span></div><div class="token-line"><span class="token plain">        S: AsyncRead + Unpin + Send,</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        let header = stream.read_u32().await? as usize;</span></div><div class="token-line"><span class="token plain">        let (len, _compressed) = decode_header(header);</span></div><div class="token-line"><span class="token plain">    		// 如果没有这么大的内存，就分配至少一个 frame 的内存，保证它可用</span></div><div class="token-line"><span class="token plain">        buf.reserve(LEN_LEN + len);</span></div><div class="token-line"><span class="token plain">        buf.put_u32(header as _);</span></div><div class="token-line"><span class="token plain">        // advance_mut 是 unsafe 的原因是，从当前位置 pos 到 pos + len，</span></div><div class="token-line"><span class="token plain">        // 这段内存目前没有初始化。我们就是为了 reserve 这段内存，然后从 stream</span></div><div class="token-line"><span class="token plain">        // 里读取，读取完，它就是初始化的。所以，我们这么用是安全的</span></div><div class="token-line"><span class="token plain">        unsafe { buf.advance_mut(len) };</span></div><div class="token-line"><span class="token plain">        stream.read_exact(&amp;mut buf[LEN_LEN..]).await?;</span></div><div class="token-line"><span class="token plain">        Ok(())</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在写 read_frame() 时，我们不希望它只能被用于 TcpStream，这样太不灵活，<strong>所以用了泛型参数 S，要求传入的 S 必须满足 AsyncRead + Unpin + Send</strong>。我们来看看这3个约束。</p><p><a target="_blank" rel="noopener noreferrer" href="https://docs.rs/tokio/1.12.0/tokio/io/trait.AsyncRead.html">AsyncRead<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 是 tokio 下的一个 trait，用于做异步读取，它有一个方法 poll_read()：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pub trait AsyncRead {</span></div><div class="token-line"><span class="token plain">        fn poll_read(</span></div><div class="token-line"><span class="token plain">            self: Pin&lt;&amp;mut Self&gt;, </span></div><div class="token-line"><span class="token plain">            cx: &amp;mut Context&lt;&#x27;_&gt;, </span></div><div class="token-line"><span class="token plain">            buf: &amp;mut ReadBuf&lt;&#x27;_&gt;</span></div><div class="token-line"><span class="token plain">        ) -&gt; Poll&lt;Result&lt;()&gt;&gt;;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>一旦某个数据结构实现了 AsyncRead，它就可以使用 <a target="_blank" rel="noopener noreferrer" href="https://docs.rs/tokio/1.12.0/tokio/io/trait.AsyncReadExt.html">AsyncReadExt<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 提供的多达 29 个辅助方法。这是因为任何实现了 AsyncRead 的数据结构，都自动实现了 AsyncReadExt：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">impl&lt;R: AsyncRead + ?Sized&gt; AsyncReadExt for R {}</span></div></pre></div><p>我们虽然还没有正式学怎么做异步处理，但是之前已经看到了很多 async/await 的代码。</p><p><strong>异步处理，目前你可以把它想象成一个内部有个状态机的数据结构</strong>，异步运行时根据需要不断地对其做 poll 操作，直到它返回 Poll::Ready，说明得到了处理结果；如果它返回 Poll::Pending，说明目前还无法继续，异步运行时会将其挂起，等下次某个事件将这个任务唤醒。</p><p>对于 Socket 来说，读取 socket 就是一个不断 poll_read() 的过程，直到读到了满足 ReadBuf 需要的内容。</p><p>至于 Send 约束，很好理解，S 需要能在不同线程间移动所有权。对于 Unpin 约束，未来讲 Future 的时候再具体说。现在你就权且记住，如果编译器抱怨一个泛型参数 “cannot be unpinned” ，一般来说，这个泛型参数需要加 Unpin 的约束。你可以试着把 Unpin 去掉，看看编译器的报错。</p><p>好，既然又写了一些代码，自然需为其撰写相应的测试。但是，要测 read_frame() 函数，需要一个支持 AsyncRead 的数据结构，虽然 TcpStream 支持它，但是我们不应该在单元测试中引入太过复杂的行为。<strong>为了测试 read_frame() 而建立 TCP 连接，显然没有必要。怎么办</strong>？</p><p>在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/429063">第 25 讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，我们聊过测试代码和产品代码同等的重要性，所以，在开发中，也要为测试代码创建合适的生态环境，让测试简洁、可读性强。那这里，我们就创建一个简单的数据结构，使其实现 AsyncRead，这样就可以“单元”测试 read_frame() 了。</p><p>在 src/network/frame.rs 里的 mod tests 下加入：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#[cfg(test)]</span></div><div class="token-line"><span class="token plain">    mod tests {</span></div><div class="token-line"><span class="token plain">    		struct DummyStream {</span></div><div class="token-line"><span class="token plain">            buf: BytesMut,</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        impl AsyncRead for DummyStream {</span></div><div class="token-line"><span class="token plain">            fn poll_read(</span></div><div class="token-line"><span class="token plain">                self: std::pin::Pin&lt;&amp;mut Self&gt;,</span></div><div class="token-line"><span class="token plain">                _cx: &amp;mut std::task::Context&lt;&#x27;_&gt;,</span></div><div class="token-line"><span class="token plain">                buf: &amp;mut tokio::io::ReadBuf&lt;&#x27;_&gt;,</span></div><div class="token-line"><span class="token plain">            ) -&gt; std::task::Poll&lt;std::io::Result&lt;()&gt;&gt; {</span></div><div class="token-line"><span class="token plain">    						// 看看 ReadBuf 需要多大的数据</span></div><div class="token-line"><span class="token plain">                let len = buf.capacity();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                // split 出这么大的数据</span></div><div class="token-line"><span class="token plain">                let data = self.get_mut().buf.split_to(len);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                // 拷贝给 ReadBuf</span></div><div class="token-line"><span class="token plain">                buf.put_slice(&amp;data);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                // 直接完工</span></div><div class="token-line"><span class="token plain">                std::task::Poll::Ready(Ok(()))</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>因为只需要保证 AsyncRead 接口的正确性，所以不需要太复杂的逻辑，我们就放一个 buffer，poll_read() 需要读多大的数据，我们就给多大的数据。有了这个 DummyStream，就可以测试 read_frame() 了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#[tokio::test]</span></div><div class="token-line"><span class="token plain">    async fn read_frame_should_work() {</span></div><div class="token-line"><span class="token plain">        let mut buf = BytesMut::new();</span></div><div class="token-line"><span class="token plain">        let cmd = CommandRequest::new_hdel(&quot;t1&quot;, &quot;k1&quot;);</span></div><div class="token-line"><span class="token plain">        cmd.encode_frame(&amp;mut buf).unwrap();</span></div><div class="token-line"><span class="token plain">        let mut stream = DummyStream { buf };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        let mut data = BytesMut::new();</span></div><div class="token-line"><span class="token plain">        read_frame(&amp;mut stream, &amp;mut data).await.unwrap();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        let cmd1 = CommandRequest::decode_frame(&amp;mut data).unwrap();</span></div><div class="token-line"><span class="token plain">        assert_eq!(cmd, cmd1);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>运行 “cargo test”，测试通过。如果你的代码无法编译，可以看看编译错误，是不是缺了一些 use 语句来把某些数据结构和 trait 引入。你也可以对照 GitHub 上的代码修改。</p><h2 id="让网络层可以像-asyncprost-那样方便使用"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/05#让网络层可以像-asyncprost-那样方便使用"><span class="icon icon-link"></span></a>让网络层可以像 AsyncProst 那样方便使用</h2><p>现在，我们的 frame 已经可以正常工作了。接下来要构思一下，服务端和客户端该如何封装。</p><p>对于服务器，我们期望可以对 accept 下来的 TcpStream 提供一个 process() 方法，处理协议的细节：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#[tokio::main]</span></div><div class="token-line"><span class="token plain">    async fn main() -&gt; Result&lt;()&gt; {</span></div><div class="token-line"><span class="token plain">        tracing_subscriber::fmt::init();</span></div><div class="token-line"><span class="token plain">        let addr = &quot;127.0.0.1:9527&quot;;</span></div><div class="token-line"><span class="token plain">        let service: Service = ServiceInner::new(MemTable::new()).into();</span></div><div class="token-line"><span class="token plain">        let listener = TcpListener::bind(addr).await?;</span></div><div class="token-line"><span class="token plain">        info!(&quot;Start listening on {}&quot;, addr);</span></div><div class="token-line"><span class="token plain">        loop {</span></div><div class="token-line"><span class="token plain">            let (stream, addr) = listener.accept().await?;</span></div><div class="token-line"><span class="token plain">            info!(&quot;Client {:?} connected&quot;, addr);</span></div><div class="token-line"><span class="token plain">            let stream = ProstServerStream::new(stream, service.clone());</span></div><div class="token-line"><span class="token plain">            tokio::spawn(async move { stream.process().await });</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个 process() 方法，实际上就是对 examples/server.rs 中 tokio::spawn 里的 while loop 的封装：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">while let Some(Ok(cmd)) = stream.next().await {</span></div><div class="token-line"><span class="token plain">        info!(&quot;Got a new command: {:?}&quot;, cmd);</span></div><div class="token-line"><span class="token plain">        let res = svc.execute(cmd);</span></div><div class="token-line"><span class="token plain">        stream.send(res).await.unwrap();</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>对客户端，我们也希望可以直接 execute() 一个命令，就能得到结果：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#[tokio::main]</span></div><div class="token-line"><span class="token plain">    async fn main() -&gt; Result&lt;()&gt; {</span></div><div class="token-line"><span class="token plain">        tracing_subscriber::fmt::init();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        let addr = &quot;127.0.0.1:9527&quot;;</span></div><div class="token-line"><span class="token plain">        // 连接服务器</span></div><div class="token-line"><span class="token plain">        let stream = TcpStream::connect(addr).await?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        let mut client = ProstClientStream::new(stream);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 生成一个 HSET 命令</span></div><div class="token-line"><span class="token plain">        let cmd = CommandRequest::new_hset(&quot;table1&quot;, &quot;hello&quot;, &quot;world&quot;.to_string().into());</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 发送 HSET 命令</span></div><div class="token-line"><span class="token plain">        let data = client.execute(cmd).await?;</span></div><div class="token-line"><span class="token plain">        info!(&quot;Got response {:?}&quot;, data);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        Ok(())</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个 execute()，实际上就是对 examples/client.rs 中发送和接收代码的封装：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">client.send(cmd).await?;</span></div><div class="token-line"><span class="token plain">    if let Some(Ok(data)) = client.next().await {</span></div><div class="token-line"><span class="token plain">        info!(&quot;Got response {:?}&quot;, data);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这样的代码，看起来很简洁，维护起来也很方便。</p><p>好，先看服务器处理一个 TcpStream 的数据结构，它需要包含 TcpStream，还有我们之前创建的用于处理客户端命令的 Service。所以，让服务器处理 TcpStream 的结构包含这两部分：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pub struct ProstServerStream&lt;S&gt; {</span></div><div class="token-line"><span class="token plain">        inner: S,</span></div><div class="token-line"><span class="token plain">        service: Service,</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>而客户端处理 TcpStream 的结构就只需要包含 TcpStream：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pub struct ProstClientStream&lt;S&gt; {</span></div><div class="token-line"><span class="token plain">        inner: S,</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里，依旧使用了泛型参数 S。未来，如果要支持 WebSocket，或者在 TCP 之上支持 TLS，它都可以让我们无需改变这一层的代码。</p><p>接下来就是具体的实现。有了 frame 的封装，服务器的 process() 方法和客户端的 execute() 方法都很容易实现。我们直接在 src/network/mod.rs 里添加完整代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">mod frame;</span></div><div class="token-line"><span class="token plain">    use bytes::BytesMut;</span></div><div class="token-line"><span class="token plain">    pub use frame::{read_frame, FrameCoder};</span></div><div class="token-line"><span class="token plain">    use tokio::io::{AsyncRead, AsyncWrite, AsyncWriteExt};</span></div><div class="token-line"><span class="token plain">    use tracing::info;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    use crate::{CommandRequest, CommandResponse, KvError, Service};</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// 处理服务器端的某个 accept 下来的 socket 的读写</span></div><div class="token-line"><span class="token plain">    pub struct ProstServerStream&lt;S&gt; {</span></div><div class="token-line"><span class="token plain">        inner: S,</span></div><div class="token-line"><span class="token plain">        service: Service,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// 处理客户端 socket 的读写</span></div><div class="token-line"><span class="token plain">    pub struct ProstClientStream&lt;S&gt; {</span></div><div class="token-line"><span class="token plain">        inner: S,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl&lt;S&gt; ProstServerStream&lt;S&gt;</span></div><div class="token-line"><span class="token plain">    where</span></div><div class="token-line"><span class="token plain">        S: AsyncRead + AsyncWrite + Unpin + Send,</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        pub fn new(stream: S, service: Service) -&gt; Self {</span></div><div class="token-line"><span class="token plain">            Self {</span></div><div class="token-line"><span class="token plain">                inner: stream,</span></div><div class="token-line"><span class="token plain">                service,</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        pub async fn process(mut self) -&gt; Result&lt;(), KvError&gt; {</span></div><div class="token-line"><span class="token plain">            while let Ok(cmd) = self.recv().await {</span></div><div class="token-line"><span class="token plain">                info!(&quot;Got a new command: {:?}&quot;, cmd);</span></div><div class="token-line"><span class="token plain">                let res = self.service.execute(cmd);</span></div><div class="token-line"><span class="token plain">                self.send(res).await?;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            // info!(&quot;Client {:?} disconnected&quot;, self.addr);</span></div><div class="token-line"><span class="token plain">            Ok(())</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        async fn send(&amp;mut self, msg: CommandResponse) -&gt; Result&lt;(), KvError&gt; {</span></div><div class="token-line"><span class="token plain">            let mut buf = BytesMut::new();</span></div><div class="token-line"><span class="token plain">            msg.encode_frame(&amp;mut buf)?;</span></div><div class="token-line"><span class="token plain">            let encoded = buf.freeze();</span></div><div class="token-line"><span class="token plain">            self.inner.write_all(&amp;encoded[..]).await?;</span></div><div class="token-line"><span class="token plain">            Ok(())</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        async fn recv(&amp;mut self) -&gt; Result&lt;CommandRequest, KvError&gt; {</span></div><div class="token-line"><span class="token plain">            let mut buf = BytesMut::new();</span></div><div class="token-line"><span class="token plain">            let stream = &amp;mut self.inner;</span></div><div class="token-line"><span class="token plain">            read_frame(stream, &amp;mut buf).await?;</span></div><div class="token-line"><span class="token plain">            CommandRequest::decode_frame(&amp;mut buf)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl&lt;S&gt; ProstClientStream&lt;S&gt;</span></div><div class="token-line"><span class="token plain">    where</span></div><div class="token-line"><span class="token plain">        S: AsyncRead + AsyncWrite + Unpin + Send,</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        pub fn new(stream: S) -&gt; Self {</span></div><div class="token-line"><span class="token plain">            Self { inner: stream }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        pub async fn execute(&amp;mut self, cmd: CommandRequest) -&gt; Result&lt;CommandResponse, KvError&gt; {</span></div><div class="token-line"><span class="token plain">            self.send(cmd).await?;</span></div><div class="token-line"><span class="token plain">            Ok(self.recv().await?)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        async fn send(&amp;mut self, msg: CommandRequest) -&gt; Result&lt;(), KvError&gt; {</span></div><div class="token-line"><span class="token plain">            let mut buf = BytesMut::new();</span></div><div class="token-line"><span class="token plain">            msg.encode_frame(&amp;mut buf)?;</span></div><div class="token-line"><span class="token plain">            let encoded = buf.freeze();</span></div><div class="token-line"><span class="token plain">            self.inner.write_all(&amp;encoded[..]).await?;</span></div><div class="token-line"><span class="token plain">            Ok(())</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        async fn recv(&amp;mut self) -&gt; Result&lt;CommandResponse, KvError&gt; {</span></div><div class="token-line"><span class="token plain">            let mut buf = BytesMut::new();</span></div><div class="token-line"><span class="token plain">            let stream = &amp;mut self.inner;</span></div><div class="token-line"><span class="token plain">            read_frame(stream, &amp;mut buf).await?;</span></div><div class="token-line"><span class="token plain">            CommandResponse::decode_frame(&amp;mut buf)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这段代码不难阅读，基本上和 frame 的测试代码大同小异。</p><p>当然了，我们还是需要写段代码来测试客户端和服务器交互的整个流程：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#[cfg(test)]</span></div><div class="token-line"><span class="token plain">    mod tests {</span></div><div class="token-line"><span class="token plain">        use anyhow::Result;</span></div><div class="token-line"><span class="token plain">        use bytes::Bytes;</span></div><div class="token-line"><span class="token plain">        use std::net::SocketAddr;</span></div><div class="token-line"><span class="token plain">        use tokio::net::{TcpListener, TcpStream};</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        use crate::{assert_res_ok, MemTable, ServiceInner, Value};</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        use super::*;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        #[tokio::test]</span></div><div class="token-line"><span class="token plain">        async fn client_server_basic_communication_should_work() -&gt; anyhow::Result&lt;()&gt; {</span></div><div class="token-line"><span class="token plain">            let addr = start_server().await?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            let stream = TcpStream::connect(addr).await?;</span></div><div class="token-line"><span class="token plain">            let mut client = ProstClientStream::new(stream);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 发送 HSET，等待回应</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            let cmd = CommandRequest::new_hset(&quot;t1&quot;, &quot;k1&quot;, &quot;v1&quot;.into());</span></div><div class="token-line"><span class="token plain">            let res = client.execute(cmd).await.unwrap();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 第一次 HSET 服务器应该返回 None</span></div><div class="token-line"><span class="token plain">            assert_res_ok(res, &amp;[Value::default()], &amp;[]);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 再发一个 HSET</span></div><div class="token-line"><span class="token plain">            let cmd = CommandRequest::new_hget(&quot;t1&quot;, &quot;k1&quot;);</span></div><div class="token-line"><span class="token plain">            let res = client.execute(cmd).await?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 服务器应该返回上一次的结果</span></div><div class="token-line"><span class="token plain">            assert_res_ok(res, &amp;[&quot;v1&quot;.into()], &amp;[]);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            Ok(())</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        #[tokio::test]</span></div><div class="token-line"><span class="token plain">        async fn client_server_compression_should_work() -&gt; anyhow::Result&lt;()&gt; {</span></div><div class="token-line"><span class="token plain">            let addr = start_server().await?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            let stream = TcpStream::connect(addr).await?;</span></div><div class="token-line"><span class="token plain">            let mut client = ProstClientStream::new(stream);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            let v: Value = Bytes::from(vec![0u8; 16384]).into();</span></div><div class="token-line"><span class="token plain">            let cmd = CommandRequest::new_hset(&quot;t2&quot;, &quot;k2&quot;, v.clone().into());</span></div><div class="token-line"><span class="token plain">            let res = client.execute(cmd).await?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            assert_res_ok(res, &amp;[Value::default()], &amp;[]);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            let cmd = CommandRequest::new_hget(&quot;t2&quot;, &quot;k2&quot;);</span></div><div class="token-line"><span class="token plain">            let res = client.execute(cmd).await?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            assert_res_ok(res, &amp;[v.into()], &amp;[]);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            Ok(())</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        async fn start_server() -&gt; Result&lt;SocketAddr&gt; {</span></div><div class="token-line"><span class="token plain">            let listener = TcpListener::bind(&quot;127.0.0.1:0&quot;).await.unwrap();</span></div><div class="token-line"><span class="token plain">            let addr = listener.local_addr().unwrap();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            tokio::spawn(async move {</span></div><div class="token-line"><span class="token plain">                loop {</span></div><div class="token-line"><span class="token plain">                    let (stream, _) = listener.accept().await.unwrap();</span></div><div class="token-line"><span class="token plain">                    let service: Service = ServiceInner::new(MemTable::new()).into();</span></div><div class="token-line"><span class="token plain">                    let server = ProstServerStream::new(stream, service);</span></div><div class="token-line"><span class="token plain">                    tokio::spawn(server.process());</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            });</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            Ok(addr)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>测试代码基本上是之前 examples 下的 <a target="_blank" rel="noopener noreferrer" href="http://server.rs/client.rs">server.rs/client.rs<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中的内容。我们测试了不做压缩和做压缩的两种情况。运行 <code>cargo test</code> ，应该所有测试都通过了。</p><h2 id="正式创建-kv-server-和-kv-client"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/05#正式创建-kv-server-和-kv-client"><span class="icon icon-link"></span></a>正式创建 kv-server 和 kv-client</h2><p>我们之前写了很多代码，真正可运行的 server/client 都是 examples 下的代码。现在我们终于要正式创建 kv-server / kv-client 了。</p><p>首先在 Cargo.toml 中，加入两个可执行文件：kvs（kv-server）和 kvc（kv-client）。还需要把一些依赖移动到 dependencies 下。修改之后，Cargo.toml 长这个样子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[package]</span></div><div class="token-line"><span class="token plain">    name = &quot;kv2&quot;</span></div><div class="token-line"><span class="token plain">    version = &quot;0.1.0&quot;</span></div><div class="token-line"><span class="token plain">    edition = &quot;2018&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    [[bin]]</span></div><div class="token-line"><span class="token plain">    name = &quot;kvs&quot;</span></div><div class="token-line"><span class="token plain">    path = &quot;src/server.rs&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    [[bin]]</span></div><div class="token-line"><span class="token plain">    name = &quot;kvc&quot;</span></div><div class="token-line"><span class="token plain">    path = &quot;src/client.rs&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    [dependencies]</span></div><div class="token-line"><span class="token plain">    anyhow = &quot;1&quot; # 错误处理</span></div><div class="token-line"><span class="token plain">    bytes = &quot;1&quot; # 高效处理网络 buffer 的库</span></div><div class="token-line"><span class="token plain">    dashmap = &quot;4&quot; # 并发 HashMap</span></div><div class="token-line"><span class="token plain">    flate2 = &quot;1&quot; # gzip 压缩</span></div><div class="token-line"><span class="token plain">    http = &quot;0.2&quot; # 我们使用 HTTP status code 所以引入这个类型库</span></div><div class="token-line"><span class="token plain">    prost = &quot;0.8&quot; # 处理 protobuf 的代码</span></div><div class="token-line"><span class="token plain">    sled = &quot;0.34&quot; # sled db</span></div><div class="token-line"><span class="token plain">    thiserror = &quot;1&quot; # 错误定义和处理</span></div><div class="token-line"><span class="token plain">    tokio = { version = &quot;1&quot;, features = [&quot;full&quot; ] } # 异步网络库</span></div><div class="token-line"><span class="token plain">    tracing = &quot;0.1&quot; # 日志处理</span></div><div class="token-line"><span class="token plain">    tracing-subscriber = &quot;0.2&quot; # 日志处理</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    [dev-dependencies]</span></div><div class="token-line"><span class="token plain">    async-prost = &quot;0.2.1&quot; # 支持把 protobuf 封装成 TCP frame</span></div><div class="token-line"><span class="token plain">    futures = &quot;0.3&quot; # 提供 Stream trait</span></div><div class="token-line"><span class="token plain">    tempfile = &quot;3&quot; # 处理临时目录和临时文件</span></div><div class="token-line"><span class="token plain">    tokio-util = { version = &quot;0.6&quot;, features = [&quot;codec&quot;]}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    [build-dependencies]</span></div><div class="token-line"><span class="token plain">    prost-build = &quot;0.8&quot; # 编译 protobuf</span></div></pre></div><p>然后，创建 src/client.rs 和 src/server.rs，分别写入下面的代码。src/client.rs：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use anyhow::Result;</span></div><div class="token-line"><span class="token plain">    use kv2::{CommandRequest, ProstClientStream};</span></div><div class="token-line"><span class="token plain">    use tokio::net::TcpStream;</span></div><div class="token-line"><span class="token plain">    use tracing::info;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #[tokio::main]</span></div><div class="token-line"><span class="token plain">    async fn main() -&gt; Result&lt;()&gt; {</span></div><div class="token-line"><span class="token plain">        tracing_subscriber::fmt::init();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        let addr = &quot;127.0.0.1:9527&quot;;</span></div><div class="token-line"><span class="token plain">        // 连接服务器</span></div><div class="token-line"><span class="token plain">        let stream = TcpStream::connect(addr).await?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        let mut client = ProstClientStream::new(stream);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 生成一个 HSET 命令</span></div><div class="token-line"><span class="token plain">        let cmd = CommandRequest::new_hset(&quot;table1&quot;, &quot;hello&quot;, &quot;world&quot;.to_string().into());</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 发送 HSET 命令</span></div><div class="token-line"><span class="token plain">        let data = client.execute(cmd).await?;</span></div><div class="token-line"><span class="token plain">        info!(&quot;Got response {:?}&quot;, data);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        Ok(())</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>src/server.rs：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use anyhow::Result;</span></div><div class="token-line"><span class="token plain">    use kv2::{MemTable, ProstServerStream, Service, ServiceInner};</span></div><div class="token-line"><span class="token plain">    use tokio::net::TcpListener;</span></div><div class="token-line"><span class="token plain">    use tracing::info;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #[tokio::main]</span></div><div class="token-line"><span class="token plain">    async fn main() -&gt; Result&lt;()&gt; {</span></div><div class="token-line"><span class="token plain">        tracing_subscriber::fmt::init();</span></div><div class="token-line"><span class="token plain">        let addr = &quot;127.0.0.1:9527&quot;;</span></div><div class="token-line"><span class="token plain">        let service: Service = ServiceInner::new(MemTable::new()).into();</span></div><div class="token-line"><span class="token plain">        let listener = TcpListener::bind(addr).await?;</span></div><div class="token-line"><span class="token plain">        info!(&quot;Start listening on {}&quot;, addr);</span></div><div class="token-line"><span class="token plain">        loop {</span></div><div class="token-line"><span class="token plain">            let (stream, addr) = listener.accept().await?;</span></div><div class="token-line"><span class="token plain">            info!(&quot;Client {:?} connected&quot;, addr);</span></div><div class="token-line"><span class="token plain">            let stream = ProstServerStream::new(stream, service.clone());</span></div><div class="token-line"><span class="token plain">            tokio::spawn(async move { stream.process().await });</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这和之前的 client / server 的代码几乎一致，不同的是，我们使用了自己撰写的 frame 处理方法。</p><p>完成之后，我们可以打开一个命令行窗口，运行：<code>RUST_LOG=info cargo run \--bin kvs \--quiet</code>。然后在另一个命令行窗口，运行：<code>RUST_LOG=info cargo run \--bin kvc \--quiet</code>。此时，服务器和客户端都收到了彼此的请求和响应，并且处理正常。现在，我们的 KV server 越来越像回事了！</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/05#小结"><span class="icon icon-link"></span></a>小结</h2><p>网络开发是 Rust 下一个很重要的应用场景。tokio 为我们提供了很棒的异步网络开发的支持。</p><p>在开发网络协议时，你要确定你的 frame 如何封装，一般来说，长度 + protobuf 足以应付绝大多数复杂的协议需求。这一讲我们虽然详细介绍了自己该如何处理用长度封装 frame 的方法，其实 tokio-util 提供了 <a target="_blank" rel="noopener noreferrer" href="https://docs.rs/tokio-util/0.6.8/tokio_util/codec/length_delimited/index.html">LengthDelimitedCodec<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，可以完成今天关于 frame 部分的处理。如果你自己撰写网络程序，可以直接使用它。</p><p><strong>在网络开发的时候，如何做单元测试是一大痛点，我们可以根据其实现的接口，围绕着接口来构建测试数据结构</strong>，比如 TcpStream 实现了 AsycnRead / AsyncWrite。考虑简洁和可读，为了测试read_frame() ，我们构建了 DummyStream 来协助测试。你也可以用类似的方式处理你所做项目的测试需求。</p><p>结构良好架构清晰的代码，一定是容易测试的代码，纵观整个项目，从 CommandService trait 和 Storage trait 的测试，一路到现在网络层的测试。如果使用 <a target="_blank" rel="noopener noreferrer" href="https://github.com/xd009642/tarpaulin">tarpaulin<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 来看测试覆盖率，你会发现，这个项目目前已经有 89%了，如果不算 src/server.rs 和 src/client.rs 的话，有接近 92% 的测试覆盖率。即便在生产环境的代码里，这也算是很高质量的测试覆盖率了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">INFO cargo_tarpaulin::report: Coverage Results:</span></div><div class="token-line"><span class="token plain">    || Tested/Total Lines:</span></div><div class="token-line"><span class="token plain">    || src/client.rs: 0/9 +0.00%</span></div><div class="token-line"><span class="token plain">    || src/network/frame.rs: 80/82 +0.00%</span></div><div class="token-line"><span class="token plain">    || src/network/mod.rs: 65/66 +4.66%</span></div><div class="token-line"><span class="token plain">    || src/pb/mod.rs: 54/75 +0.00%</span></div><div class="token-line"><span class="token plain">    || src/server.rs: 0/11 +0.00%</span></div><div class="token-line"><span class="token plain">    || src/service/command_service.rs: 120/129 +0.00%</span></div><div class="token-line"><span class="token plain">    || src/service/mod.rs: 79/84 +0.00%</span></div><div class="token-line"><span class="token plain">    || src/storage/memory.rs: 34/37 +0.00%</span></div><div class="token-line"><span class="token plain">    || src/storage/mod.rs: 58/58 +0.00%</span></div><div class="token-line"><span class="token plain">    || src/storage/sleddb.rs: 40/43 +0.00%</span></div><div class="token-line"><span class="token plain">    ||</span></div><div class="token-line"><span class="token plain">    89.23% coverage, 530/594 lines covered</span></div></pre></div><h3 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/05#思考题"><span class="icon icon-link"></span></a>思考题</h3><ol><li>在设计 frame 的时候，如果我们的压缩方法不止 gzip 一种，而是服务器或客户端都会根据各自的情况，在需要的时候做某种算法的压缩。假设服务器和客户端都支持 gzip、lz4 和 zstd 这三种压缩算法。那么 frame 该如何设计呢？需要用几个 bit 来存放压缩算法的信息？</li><li>目前我们的 client 只适合测试，你可以将其修改成一个完整的命令行程序么？小提示，可以使用 clap 或 structopt，用户可以输入不同的命令；或者做一个交互式的命令行，使用 <a target="_blank" rel="noopener noreferrer" href="https://docs.rs/shellfish">shellfish<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 或 <a target="_blank" rel="noopener noreferrer" href="https://github.com/kkawakam/rustyline">rustyline<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，就像 redis-cli 那样。</li><li>试着使用 LengthDelimitedCodec 来重写 frame 这一层。</li></ol><p>欢迎在留言区分享你的思考，感谢你的收听。你已经完成Rust学习的第36次打卡啦。</p><h3 id="延伸阅读"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/05#延伸阅读"><span class="icon icon-link"></span></a>延伸阅读</h3><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/xd009642/tarpaulin">tarpaulin<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 是 Rust 下做测试覆盖率的工具。因为使用了操作系统和 CPU 的特殊指令追踪代码的执行，所以它目前只支持 x86_64 / Linux。测试覆盖率一般在 CI 中使用，所以有 Linux 的支持也足够了。</p><p>一般来说，我们在生产环境中运行的代码，都要求至少有 80% 以上的测试覆盖率。为项目构建足够好的测试覆盖率并不容易，因为这首先意味着写出来的代码要容易测试。所以，<strong>对于新的项目，最好一开始就在 CI 中为测试覆盖率设置一个门槛</strong>，这样可以倒逼着大家保证单元测试的数量。同时，单元测试又会倒逼代码要有良好的结构和良好的接口，否则不容易测试。</p><p>如果觉得有收获，也欢迎你分享给身边的朋友，邀他一起讨论。我们下节课见～</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/陈天rust编程第一课/06.并发篇/05.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:25</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
