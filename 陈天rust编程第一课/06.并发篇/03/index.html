<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>35｜实操项目：如何实现一个基本的MPSC channel？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/陈天rust编程第一课/06.并发篇/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/陈天rust编程第一课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-two/陈天rust编程第一课/01.开篇词/01"><span>开篇词｜让Rust成为你的下一门主力语言</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/02.前置篇">02.前置篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/02.前置篇/01"><span>01｜内存：值放堆上还是放栈上，这是一个问题</span></a></li><li><a href="/blog-two/陈天rust编程第一课/02.前置篇/02"><span>02｜串讲：编程开发中，那些你需要掌握的基本概念</span></a></li><li><a href="/blog-two/陈天rust编程第一课/02.前置篇/03"><span>加餐｜这个专栏你可以怎么学，以及Rust是否值得学？</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇">03.基础篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/01"><span>03｜初窥门径：从你的第一个Rust程序开始！</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/02"><span>04｜get hands dirty：来写个实用的CLI小工具</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/03"><span>05｜get hands dirty：做一个图片服务器有多难？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/04"><span>06｜get hands dirty：SQL查询工具怎么一鱼多吃？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/05"><span>07｜所有权：值的生杀大权到底在谁手上？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/06"><span>08｜所有权：值的借用是如何工作的？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/07"><span>09｜所有权：一个值可以有多个所有者么？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/08"><span>10｜生命周期：你创建的值究竟能活多久？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/09"><span>11｜内存管理：从创建到消亡，值都经历了什么？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/10"><span>加餐｜愚昧之巅：你的Rust学习常见问题汇总</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/11"><span>12｜类型系统：Rust的类型系统有什么特点？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/12"><span>13｜类型系统：如何使用trait来定义接口？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/13"><span>14｜类型系统：有哪些必须掌握的trait？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/14"><span>15｜数据结构：这些浓眉大眼的结构竟然都是智能指针？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/15"><span>16｜数据结构：Vec、&amp;[T]、Box&lt;[T]&gt; ，你真的了解集合容器么？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/16"><span>17｜数据结构：软件系统核心部件哈希表，内存如何布局？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/17"><span>18｜错误处理：为什么Rust的错误处理与众不同？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/18"><span>19｜闭包：FnOnce、FnMut和Fn，为什么有这么多类型？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/19"><span>20｜4 Steps ：如何更好地阅读Rust源码？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/20"><span>21｜阶段实操（1）：构建一个简单的KV server-基本流程</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/21"><span>22｜阶段实操（2）：构建一个简单的KV server-基本流程</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/04.期中周">04.期中周</a><ul><li><a href="/blog-two/陈天rust编程第一课/04.期中周/01"><span>加餐｜期中测试：来写一个简单的grep命令行</span></a></li><li><a href="/blog-two/陈天rust编程第一课/04.期中周/02"><span>加餐｜期中测试：参考实现讲解</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇">05.进阶篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/01"><span>23｜类型系统：如何在实战中使用泛型编程？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/02"><span>24｜类型系统：如何在实战中使用trait object？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/03"><span>25｜类型系统：如何围绕trait来设计和架构系统？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/04"><span>加餐｜Rust2021版次问世了！</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/05"><span>26｜阶段实操（3）：构建一个简单的KV server-高级trait技巧</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/06"><span>27｜生态系统：有哪些常有的Rust库可以为我所用？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/07"><span>28｜网络开发（上）：如何使用Rust处理网络请求？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/08"><span>29｜网络开发（下）：如何使用Rust处理网络请求？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/09"><span>30｜Unsafe Rust：如何用C++的方式打开Rust？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/10"><span>31｜FFI：Rust如何和你的语言架起沟通桥梁？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/11"><span>32｜实操项目：使用PyO3开发Python3模块</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课/06.并发篇">06.并发篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/01"><span>33｜并发处理（上）：从atomics到Channel，Rust都提供了什么工具？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/02"><span>34｜并发处理（下）：从atomics到Channel，Rust都提供了什么工具？</span></a></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课/06.并发篇/03"><span>35｜实操项目：如何实现一个基本的MPSC channel？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/04"><span>用户故事｜绝望之谷：改变从学习开始</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/05"><span>36｜阶段实操（4）：构建一个简单的KV server-网络处理</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/06"><span>37｜阶段实操（5）：构建一个简单的KV server-网络安全</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/07"><span>38｜异步处理：Future是什么？它和async/await是什么关系？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/08"><span>39｜异步处理：async/await内部是怎么实现的？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/09"><span>40｜异步处理：如何处理异步IO？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/10"><span>41｜阶段实操（6）：构建一个简单的KV server-异步处理</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/11"><span>42｜阶段实操（7）：构建一个简单的KV server-如何做大的重构？</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇">07.实战篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/01"><span>43｜生产环境：真实世界下的一个Rust项目包含哪些要素？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/02"><span>44｜数据处理：应用程序和数据如何打交道？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/03"><span>45｜阶段实操（8）：构建一个简单的KV server-配置/测试/监控/CI/CD</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/04"><span>46｜软件架构：如何用Rust架构复杂系统？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/05"><span>大咖助场｜开悟之坡（上）：Rust的现状、机遇与挑战</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/06"><span>大咖助场｜开悟之坡（下）：Rust的现状、机遇与挑战</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/07"><span>用户故事｜语言不仅是工具，还是思维方式</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/08.高级篇">08.高级篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/08.高级篇/01"><span>加餐｜代码即数据：为什么我们需要宏编程能力？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/08.高级篇/02"><span>加餐｜宏编程（上）：用最“笨”的方式撰写宏</span></a></li><li><a href="/blog-two/陈天rust编程第一课/08.高级篇/03"><span>加餐｜宏编程（下）：用 syn/quote 优雅地构建宏</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/09.结束语">09.结束语</a><ul><li><a href="/blog-two/陈天rust编程第一课/09.结束语/01"><span>结束语｜永续之原：Rust学习，如何持续精进？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/09.结束语/02"><span>期末测试｜来赴一场满分之约！</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊">10.学习锦囊</a><ul><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊/01"><span>特别策划｜学习锦囊（一）：听听课代表们怎么说</span></a></li><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊/02"><span>特别策划｜学习锦囊（二）：听听课代表们怎么说</span></a></li><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊/03"><span>特别策划｜学习锦囊（三）：听听课代表们怎么说</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/summary">陈天rust编程第一课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="测试驱动的设计" data-depth="2"><a href="/blog-two/陈天rust编程第一课/06.并发篇/03#测试驱动的设计"><span>测试驱动的设计</span></a></li><li title="需求 1" data-depth="3"><a href="/blog-two/陈天rust编程第一课/06.并发篇/03#需求-1"><span>需求 1</span></a></li><li title="需求 2" data-depth="3"><a href="/blog-two/陈天rust编程第一课/06.并发篇/03#需求-2"><span>需求 2</span></a></li><li title="需求 3" data-depth="3"><a href="/blog-two/陈天rust编程第一课/06.并发篇/03#需求-3"><span>需求 3</span></a></li><li title="需求 4" data-depth="3"><a href="/blog-two/陈天rust编程第一课/06.并发篇/03#需求-4"><span>需求 4</span></a></li><li title="需求 5" data-depth="3"><a href="/blog-two/陈天rust编程第一课/06.并发篇/03#需求-5"><span>需求 5</span></a></li><li title="实现 MPSC channel" data-depth="2"><a href="/blog-two/陈天rust编程第一课/06.并发篇/03#实现-mpsc-channel"><span>实现 MPSC channel</span></a></li><li title="创建 unbounded channel" data-depth="3"><a href="/blog-two/陈天rust编程第一课/06.并发篇/03#创建-unbounded-channel"><span>创建 unbounded channel</span></a></li><li title="实现消费者" data-depth="3"><a href="/blog-two/陈天rust编程第一课/06.并发篇/03#实现消费者"><span>实现消费者</span></a></li><li title="实现生产者" data-depth="3"><a href="/blog-two/陈天rust编程第一课/06.并发篇/03#实现生产者"><span>实现生产者</span></a></li><li title="其它功能" data-depth="3"><a href="/blog-two/陈天rust编程第一课/06.并发篇/03#其它功能"><span>其它功能</span></a></li><li title="性能优化" data-depth="2"><a href="/blog-two/陈天rust编程第一课/06.并发篇/03#性能优化"><span>性能优化</span></a></li><li title="小结" data-depth="2"><a href="/blog-two/陈天rust编程第一课/06.并发篇/03#小结"><span>小结</span></a></li><li title="思考题" data-depth="3"><a href="/blog-two/陈天rust编程第一课/06.并发篇/03#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="35实操项目如何实现一个基本的mpsc-channel"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/03#35实操项目如何实现一个基本的mpsc-channel"><span class="icon icon-link"></span></a>35｜实操项目：如何实现一个基本的MPSC channel？</h1><p>你好，我是陈天。</p><p>通过上两讲的学习，相信你已经意识到，虽然并发原语看上去是很底层、很神秘的东西，但实现起来也并不像想象中的那么困难，尤其是在 Rust 下，在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/442216">第 33 讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中，我们用了几十行代码就实现了一个简单的 SpinLock。</p><p>你也许会觉得不太过瘾，而且 SpinLock 也不是经常使用的并发原语，那么今天，我们试着实现一个使用非常广泛的 MPSC channel 如何？</p><p>之前我们谈论了如何在搜索引擎的 Index writer 上使用 MPSC channel：要更新 index 的上下文有很多（可以是线程也可以是异步任务），而 IndexWriter 只能是唯一的。为了避免在访问 IndexWriter 时加锁，我们可以使用 MPSC channel，在多个上下文中给 channel 发消息，然后在唯一拥有 IndexWriter 的线程中读取这些消息，非常高效。</p><p>好，来看看今天要实现的 MPSC channel 的基本功能。为了简便起见，我们只关心 unbounded MPSC channel。也就是说，当队列容量不够时，会自动扩容，所以，<strong>任何时候生产者写入数据都不会被阻塞，但是当队列中没有数据时，消费者会被阻塞</strong>：<br/><img src="https://static001.geekbang.org/resource/image/cf/a2/cfb839fc9c21f9ec51930c063f0ffda2.jpg?wh=2364x1355" alt=""/></p><h2 id="测试驱动的设计"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/03#测试驱动的设计"><span class="icon icon-link"></span></a>测试驱动的设计</h2><p>之前我们会从需求的角度来设计接口和数据结构，今天我们就换种方式，完全站在使用者的角度，用使用实例（测试）来驱动接口和数据结构的设计。</p><h3 id="需求-1"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/03#需求-1"><span class="icon icon-link"></span></a>需求 1</h3><p>要实现刚才说的 MPSC channel，都有什么需求呢？首先，生产者可以产生数据，消费者能够消费产生出来的数据，也就是基本的 send/recv，我们以下面这个单元测试 1 来描述这个需求：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#[test]</span></div><div class="token-line"><span class="token plain">    fn channel_should_work() {</span></div><div class="token-line"><span class="token plain">        let (mut s, mut r) = unbounded();</span></div><div class="token-line"><span class="token plain">        s.send(&quot;hello world!&quot;.to_string()).unwrap();</span></div><div class="token-line"><span class="token plain">        let msg = r.recv().unwrap();</span></div><div class="token-line"><span class="token plain">        assert_eq!(msg, &quot;hello world!&quot;);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里，通过 unbounded() 方法， 可以创建一个 sender和一个 receiver，sender 有 send() 方法，可以发送数据，receiver 有 recv() 方法，可以接受数据。整体的接口，我们设计和 <a target="_blank" rel="noopener noreferrer" href="https://doc.rust-lang.org/std/sync/mpsc/index.html">std::sync::mpsc<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 保持一致，避免使用者使用上的心智负担。</p><p>为了实现这样一个接口，需要什么样的数据结构呢？首先，生产者和消费者之间会共享一个队列，上一讲我们说到，可以用 VecDeque。显然，这个队列在插入和取出数据时需要互斥，所以需要用 Mutex 来保护它。所以，我们大概可以得到这样一个结构：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct Shared&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        queue: Mutex&lt;VecDeque&lt;T&gt;&gt;,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    pub struct Sender&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        shared: Arc&lt;Shared&lt;T&gt;&gt;,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    pub struct Receiver&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        shared: Arc&lt;Shared&lt;T&gt;&gt;,</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这样的数据结构应该可以满足单元测试 1。</p><h3 id="需求-2"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/03#需求-2"><span class="icon icon-link"></span></a>需求 2</h3><p>由于需要的是 MPSC，所以，我们允许多个 sender 往 channel 里发送数据，用单元测试 2 来描述这个需求：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#[test]</span></div><div class="token-line"><span class="token plain">    fn multiple_senders_should_work() {</span></div><div class="token-line"><span class="token plain">        let (mut s, mut r) = unbounded();</span></div><div class="token-line"><span class="token plain">        let mut s1 = s.clone();</span></div><div class="token-line"><span class="token plain">        let mut s2 = s.clone();</span></div><div class="token-line"><span class="token plain">        let t = thread::spawn(move || {</span></div><div class="token-line"><span class="token plain">            s.send(1).unwrap();</span></div><div class="token-line"><span class="token plain">        });</span></div><div class="token-line"><span class="token plain">        let t1 = thread::spawn(move || {</span></div><div class="token-line"><span class="token plain">            s1.send(2).unwrap();</span></div><div class="token-line"><span class="token plain">        });</span></div><div class="token-line"><span class="token plain">        let t2 = thread::spawn(move || {</span></div><div class="token-line"><span class="token plain">            s2.send(3).unwrap();</span></div><div class="token-line"><span class="token plain">        });</span></div><div class="token-line"><span class="token plain">        for handle in [t, t1, t2] {</span></div><div class="token-line"><span class="token plain">            handle.join().unwrap();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        let mut result = [r.recv().unwrap(), r.recv().unwrap(), r.recv().unwrap()];</span></div><div class="token-line"><span class="token plain">        // 在这个测试里，数据到达的顺序是不确定的，所以我们排个序再 assert</span></div><div class="token-line"><span class="token plain">        result.sort();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        assert_eq!(result, [1, 2, 3]);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个需求，刚才的数据结构就可以满足，只是 Sender 需要实现 Clone trait。不过我们在写这个测试的时候稍微有些别扭，因为这一行有不断重复的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">let mut result = [r.recv().unwrap(), r.recv().unwrap(), r.recv().unwrap()];</span></div></pre></div><p>注意，测试代码的 DRY 也很重要，我们之前强调过。所以，当写下这个测试的时候，也许会想，我们可否提供 Iterator 的实现？恩这个想法先暂存下来。</p><h3 id="需求-3"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/03#需求-3"><span class="icon icon-link"></span></a>需求 3</h3><p>接下来考虑当队列空的时候，receiver 所在的线程会被阻塞这个需求。那么，如何对这个需求进行测试呢？这并不简单，我们没有比较直观的方式来检测线程的状态。</p><p><strong>不过，我们可以通过检测“线程是否退出”来间接判断线程是否被阻塞</strong>。理由很简单，如果线程没有继续工作，又没有退出，那么一定被阻塞住了。阻塞住之后，我们继续发送数据，消费者所在的线程会被唤醒，继续工作，所以最终队列长度应该为 0。我们看单元测试 3：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#[test]</span></div><div class="token-line"><span class="token plain">    fn receiver_should_be_blocked_when_nothing_to_read() {</span></div><div class="token-line"><span class="token plain">        let (mut s, r) = unbounded();</span></div><div class="token-line"><span class="token plain">        let mut s1 = s.clone();</span></div><div class="token-line"><span class="token plain">        thread::spawn(move || {</span></div><div class="token-line"><span class="token plain">            for (idx, i) in r.into_iter().enumerate() {</span></div><div class="token-line"><span class="token plain">                // 如果读到数据，确保它和发送的数据一致</span></div><div class="token-line"><span class="token plain">                assert_eq!(idx, i);</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            // 读不到应该休眠，所以不会执行到这一句，执行到这一句说明逻辑出错</span></div><div class="token-line"><span class="token plain">            assert!(false);</span></div><div class="token-line"><span class="token plain">        });</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        thread::spawn(move || {</span></div><div class="token-line"><span class="token plain">            for i in 0..100usize {</span></div><div class="token-line"><span class="token plain">                s.send(i).unwrap();</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        });</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 1ms 足够让生产者发完 100 个消息，消费者消费完 100 个消息并阻塞</span></div><div class="token-line"><span class="token plain">        thread::sleep(Duration::from_millis(1));</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 再次发送数据，唤醒消费者</span></div><div class="token-line"><span class="token plain">        for i in 100..200usize {</span></div><div class="token-line"><span class="token plain">            s1.send(i).unwrap();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 留点时间让 receiver 处理</span></div><div class="token-line"><span class="token plain">        thread::sleep(Duration::from_millis(1));</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 如果 receiver 被正常唤醒处理，那么队列里的数据会都被读完</span></div><div class="token-line"><span class="token plain">        assert_eq!(s1.total_queued_items(), 0);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个测试代码中，我们假定 receiver 实现了 Iterator，还假定 sender 提供了一个方法total_queued_items()。这些可以在实现的时候再处理。</p><p>你可以花些时间仔细看看这段代码，想想其中的处理逻辑。虽然代码很简单，不难理解，但是把一个完整的需求转化成合适的测试代码，还是要颇费些心思的。</p><p>好，如果要能支持队列为空时阻塞，我们需要使用 <a target="_blank" rel="noopener noreferrer" href="https://doc.rust-lang.org/std/sync/struct.Condvar.html">Condvar<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。所以 Shared&lt;T&gt; 需要修改一下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct Shared&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        queue: Mutex&lt;VecDeque&lt;T&gt;&gt;,</span></div><div class="token-line"><span class="token plain">        available: Condvar,</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这样当实现 Receiver 的 recv() 方法后，我们可以在读不到数据时阻塞线程：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 拿到锁</span></div><div class="token-line"><span class="token plain">    let mut inner = self.shared.queue.lock().unwrap();</span></div><div class="token-line"><span class="token plain">    // ... 假设读不到数据</span></div><div class="token-line"><span class="token plain">    // 使用 condvar 和 MutexGuard 阻塞当前线程</span></div><div class="token-line"><span class="token plain">    self.shared.available.wait(inner)</span></div></pre></div><h3 id="需求-4"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/03#需求-4"><span class="icon icon-link"></span></a>需求 4</h3><p>顺着刚才的多个 sender想，如果现在所有 Sender 都退出作用域，Receiver 继续接收，到没有数据可读了，该怎么处理？是不是应该产生一个错误，让调用者知道，现在 channel 的另一侧已经没有生产者了，再读也读不出数据了？</p><p>我们来写单元测试 4：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#[test]</span></div><div class="token-line"><span class="token plain">    fn last_sender_drop_should_error_when_receive() {</span></div><div class="token-line"><span class="token plain">        let (s, mut r) = unbounded();</span></div><div class="token-line"><span class="token plain">        let s1 = s.clone();</span></div><div class="token-line"><span class="token plain">        let senders = [s, s1];</span></div><div class="token-line"><span class="token plain">        let total = senders.len();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // sender 即用即抛</span></div><div class="token-line"><span class="token plain">        for mut sender in senders {</span></div><div class="token-line"><span class="token plain">            thread::spawn(move || {</span></div><div class="token-line"><span class="token plain">                sender.send(&quot;hello&quot;).unwrap();</span></div><div class="token-line"><span class="token plain">                // sender 在此被丢弃</span></div><div class="token-line"><span class="token plain">            })</span></div><div class="token-line"><span class="token plain">            .join()</span></div><div class="token-line"><span class="token plain">            .unwrap();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 虽然没有 sender 了，接收者依然可以接受已经在队列里的数据</span></div><div class="token-line"><span class="token plain">        for _ in 0..total {</span></div><div class="token-line"><span class="token plain">            r.recv().unwrap();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 然而，读取更多数据时会出错</span></div><div class="token-line"><span class="token plain">        assert!(r.recv().is_err());</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个测试依旧很简单。你可以想象一下，使用什么样的数据结构可以达到这样的目的。</p><p>首先，每次 Clone 时，要增加 Sender 的计数；在 Sender Drop 时，减少这个计数；然后，我们为 Receiver 提供一个方法 total_senders()，来读取 Sender 的计数，当计数为 0，且队列中没有数据可读时，recv() 方法就报错。</p><p>有了这个思路，你想一想，这个计数器用什么数据结构呢？用锁保护么？</p><p>哈，你一定想到了可以使用 atomics。对，我们可以用 AtomicUsize。所以，Shared 数据结构需要更新一下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct Shared&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        queue: Mutex&lt;VecDeque&lt;T&gt;&gt;,</span></div><div class="token-line"><span class="token plain">        available: Condvar,</span></div><div class="token-line"><span class="token plain">        senders: AtomicUsize,</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="需求-5"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/03#需求-5"><span class="icon icon-link"></span></a>需求 5</h3><p>既然没有 Sender 了要报错，那么如果没有 Receiver了，Sender 发送时是不是也应该错误返回？这个需求和上面类似，就不赘述了。看构造的单元测试 5：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#[test]</span></div><div class="token-line"><span class="token plain">    fn receiver_drop_should_error_when_send() {</span></div><div class="token-line"><span class="token plain">        let (mut s1, mut s2) = {</span></div><div class="token-line"><span class="token plain">            let (s, _) = unbounded();</span></div><div class="token-line"><span class="token plain">            let s1 = s.clone();</span></div><div class="token-line"><span class="token plain">            let s2 = s.clone();</span></div><div class="token-line"><span class="token plain">            (s1, s2)</span></div><div class="token-line"><span class="token plain">        };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        assert!(s1.send(1).is_err());</span></div><div class="token-line"><span class="token plain">        assert!(s2.send(1).is_err());</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里，我们创建一个 channel，产生两个 Sender 后便立即丢弃 Receiver。两个 Sender 在发送时都会出错。</p><p>同样的，Shared 数据结构要更新一下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct Shared&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        queue: Mutex&lt;VecDeque&lt;T&gt;&gt;,</span></div><div class="token-line"><span class="token plain">        available: Condvar,</span></div><div class="token-line"><span class="token plain">        senders: AtomicUsize,</span></div><div class="token-line"><span class="token plain">        receivers: AtomicUsize,</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h2 id="实现-mpsc-channel"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/03#实现-mpsc-channel"><span class="icon icon-link"></span></a>实现 MPSC channel</h2><p>现在写了五个单元测试，我们已经把需求摸透了，并且有了基本的接口和数据结构的设计。接下来，我们来写实现的代码。</p><p>创建一个新的项目 <code>cargo new con_utils \--lib</code>。在 cargo.toml 中添加 anyhow 作为依赖。在 <a target="_blank" rel="noopener noreferrer" href="http://lib.rs/">lib.rs<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 里，我们就写入一句：<code>pub mod channel</code> , 然后创建 src/channel.rs，把刚才设计时使用的 test case、设计的数据结构，以及 test case 里使用到的接口，用代码全部放进来：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use anyhow::Result;</span></div><div class="token-line"><span class="token plain">    use std::{</span></div><div class="token-line"><span class="token plain">        collections::VecDeque,</span></div><div class="token-line"><span class="token plain">        sync::{atomic::AtomicUsize, Arc, Condvar, Mutex},</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// 发送者</span></div><div class="token-line"><span class="token plain">    pub struct Sender&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        shared: Arc&lt;Shared&lt;T&gt;&gt;,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// 接收者</span></div><div class="token-line"><span class="token plain">    pub struct Receiver&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        shared: Arc&lt;Shared&lt;T&gt;&gt;,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// 发送者和接收者之间共享一个 VecDeque，用 Mutex 互斥，用 Condvar 通知</span></div><div class="token-line"><span class="token plain">    /// 同时，我们记录有多少个 senders 和 receivers</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    struct Shared&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        queue: Mutex&lt;VecDeque&lt;T&gt;&gt;,</span></div><div class="token-line"><span class="token plain">        available: Condvar,</span></div><div class="token-line"><span class="token plain">        senders: AtomicUsize,</span></div><div class="token-line"><span class="token plain">        receivers: AtomicUsize,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl&lt;T&gt; Sender&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        /// 生产者写入一个数据</span></div><div class="token-line"><span class="token plain">        pub fn send(&amp;mut self, t: T) -&gt; Result&lt;()&gt; {</span></div><div class="token-line"><span class="token plain">            todo!()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        pub fn total_receivers(&amp;self) -&gt; usize {</span></div><div class="token-line"><span class="token plain">            todo!()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        pub fn total_queued_items(&amp;self) -&gt; usize {</span></div><div class="token-line"><span class="token plain">            todo!()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl&lt;T&gt; Receiver&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        pub fn recv(&amp;mut self) -&gt; Result&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">            todo!()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        pub fn total_senders(&amp;self) -&gt; usize {</span></div><div class="token-line"><span class="token plain">            todo!()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl&lt;T&gt; Iterator for Receiver&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        type Item = T;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {</span></div><div class="token-line"><span class="token plain">            todo!()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// 克隆 sender</span></div><div class="token-line"><span class="token plain">    impl&lt;T&gt; Clone for Sender&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        fn clone(&amp;self) -&gt; Self {</span></div><div class="token-line"><span class="token plain">            todo!()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// Drop sender</span></div><div class="token-line"><span class="token plain">    impl&lt;T&gt; Drop for Sender&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        fn drop(&amp;mut self) {</span></div><div class="token-line"><span class="token plain">            todo!()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl&lt;T&gt; Drop for Receiver&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        fn drop(&amp;mut self) {</span></div><div class="token-line"><span class="token plain">            todo!()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// 创建一个 unbounded channel</span></div><div class="token-line"><span class="token plain">    pub fn unbounded&lt;T&gt;() -&gt; (Sender&lt;T&gt;, Receiver&lt;T&gt;) {</span></div><div class="token-line"><span class="token plain">        todo!()</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #[cfg(test)]</span></div><div class="token-line"><span class="token plain">    mod tests {</span></div><div class="token-line"><span class="token plain">        use std::{thread, time::Duration};</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        use super::*;</span></div><div class="token-line"><span class="token plain">    		// 此处省略所有 test case</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>目前这个代码虽然能够编译通过，但因为没有任何实现，所以 cargo test 全部出错。接下来，我们就来一点点实现功能。</p><h3 id="创建-unbounded-channel"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/03#创建-unbounded-channel"><span class="icon icon-link"></span></a>创建 unbounded channel</h3><p>创建 unbounded channel 的接口很简单：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pub fn unbounded&lt;T&gt;() -&gt; (Sender&lt;T&gt;, Receiver&lt;T&gt;) {</span></div><div class="token-line"><span class="token plain">        let shared = Shared::default();</span></div><div class="token-line"><span class="token plain">        let shared = Arc::new(shared);</span></div><div class="token-line"><span class="token plain">        (</span></div><div class="token-line"><span class="token plain">            Sender {</span></div><div class="token-line"><span class="token plain">                shared: shared.clone(),</span></div><div class="token-line"><span class="token plain">            },</span></div><div class="token-line"><span class="token plain">            Receiver { shared },</span></div><div class="token-line"><span class="token plain">        )</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    const INITIAL_SIZE: usize = 32;</span></div><div class="token-line"><span class="token plain">    impl&lt;T&gt; Default for Shared&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        fn default() -&gt; Self {</span></div><div class="token-line"><span class="token plain">            Self {</span></div><div class="token-line"><span class="token plain">                queue: Mutex::new(VecDeque::with_capacity(INITIAL_SIZE)),</span></div><div class="token-line"><span class="token plain">                available: Condvar::new(),</span></div><div class="token-line"><span class="token plain">                senders: AtomicUsize::new(1),</span></div><div class="token-line"><span class="token plain">                receivers: AtomicUsize::new(1),</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>因为这里使用 default() 创建了 Shared&lt;T&gt; 结构，所以我们需要为其实现 Default。创建时，我们有 1 个生产者和1 个消费者。</p><h3 id="实现消费者"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/03#实现消费者"><span class="icon icon-link"></span></a>实现消费者</h3><p>对于消费者，我们主要需要实现 recv 方法。</p><p>在 recv 中，如果队列中有数据，那么直接返回；如果没数据，且所有生产者都离开了，我们就返回错误；如果没数据，但还有生产者，我们就阻塞消费者的线程：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">impl&lt;T&gt; Receiver&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        pub fn recv(&amp;mut self) -&gt; Result&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">            // 拿到队列的锁</span></div><div class="token-line"><span class="token plain">            let mut inner = self.shared.queue.lock().unwrap();</span></div><div class="token-line"><span class="token plain">            loop {</span></div><div class="token-line"><span class="token plain">                match inner.pop_front() {</span></div><div class="token-line"><span class="token plain">                    // 读到数据返回，锁被释放</span></div><div class="token-line"><span class="token plain">                    Some(t) =&gt; {</span></div><div class="token-line"><span class="token plain">                        return Ok(t);</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                    // 读不到数据，并且生产者都退出了，释放锁并返回错误</span></div><div class="token-line"><span class="token plain">                    None if self.total_senders() == 0 =&gt; return Err(anyhow!(&quot;no sender left&quot;)),</span></div><div class="token-line"><span class="token plain">                    // 读不到数据，把锁提交给 available Condvar，它会释放锁并挂起线程，等待 notify</span></div><div class="token-line"><span class="token plain">                    None =&gt; {</span></div><div class="token-line"><span class="token plain">                        // 当 Condvar 被唤醒后会返回 MutexGuard，我们可以 loop 回去拿数据</span></div><div class="token-line"><span class="token plain">                        // 这是为什么 Condvar 要在 loop 里使用</span></div><div class="token-line"><span class="token plain">                        inner = self</span></div><div class="token-line"><span class="token plain">                            .shared</span></div><div class="token-line"><span class="token plain">                            .available</span></div><div class="token-line"><span class="token plain">                            .wait(inner)</span></div><div class="token-line"><span class="token plain">                            .map_err(|_| anyhow!(&quot;lock poisoned&quot;))?;</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        pub fn total_senders(&amp;self) -&gt; usize {</span></div><div class="token-line"><span class="token plain">            self.shared.senders.load(Ordering::SeqCst)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>注意看这里 Condvar 的使用。</p><p>在 wait() 方法里，它接收一个 MutexGuard，然后释放这个 Mutex，挂起线程。等得到通知后，它会再获取锁，得到一个 MutexGuard，返回。所以这里是：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">inner = self.shared.available.wait(inner).map_err(|_| anyhow!(&quot;lock poisoned&quot;))?;</span></div></pre></div><p>因为 recv() 会返回一个值，所以阻塞回来之后，我们应该循环回去拿数据。这是为什么这段逻辑要被 loop <!-- -->{<!-- -->}<!-- --> 包裹。我们前面在设计时考虑过：当发送者发送数据时，应该通知被阻塞的消费者。所以，在实现 Sender 的 send() 时，需要做相应的 notify 处理。</p><p>记得还要处理消费者的 drop：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">impl&lt;T&gt; Drop for Receiver&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        fn drop(&amp;mut self) {</span></div><div class="token-line"><span class="token plain">            self.shared.receivers.fetch_sub(1, Ordering::AcqRel);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>很简单，消费者离开时，将 receivers 减一。</p><h3 id="实现生产者"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/03#实现生产者"><span class="icon icon-link"></span></a>实现生产者</h3><p>接下来我们看生产者的功能怎么实现。</p><p>首先，在没有消费者的情况下，应该报错。正常应该使用 thiserror 定义自己的错误，不过这里为了简化代码，就使用 anyhow! 宏产生一个 adhoc 的错误。如果消费者还在，那么我们获取 VecDeque 的锁，把数据压入：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">impl&lt;T&gt; Sender&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        /// 生产者写入一个数据</span></div><div class="token-line"><span class="token plain">        pub fn send(&amp;mut self, t: T) -&gt; Result&lt;()&gt; {</span></div><div class="token-line"><span class="token plain">            // 如果没有消费者了，写入时出错</span></div><div class="token-line"><span class="token plain">            if self.total_receivers() == 0 {</span></div><div class="token-line"><span class="token plain">                return Err(anyhow!(&quot;no receiver left&quot;));</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 加锁，访问 VecDeque，压入数据，然后立刻释放锁</span></div><div class="token-line"><span class="token plain">            let was_empty = {</span></div><div class="token-line"><span class="token plain">                let mut inner = self.shared.queue.lock().unwrap();</span></div><div class="token-line"><span class="token plain">                let empty = inner.is_empty();</span></div><div class="token-line"><span class="token plain">                inner.push_back(t);</span></div><div class="token-line"><span class="token plain">                empty</span></div><div class="token-line"><span class="token plain">            };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 通知任意一个被挂起等待的消费者有数据</span></div><div class="token-line"><span class="token plain">            if was_empty {</span></div><div class="token-line"><span class="token plain">                self.shared.available.notify_one();</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            Ok(())</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        pub fn total_receivers(&amp;self) -&gt; usize {</span></div><div class="token-line"><span class="token plain">            self.shared.receivers.load(Ordering::SeqCst)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        pub fn total_queued_items(&amp;self) -&gt; usize {</span></div><div class="token-line"><span class="token plain">            let queue = self.shared.queue.lock().unwrap();</span></div><div class="token-line"><span class="token plain">            queue.len()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里，获取 total_receivers 时，我们使用了 Ordering::SeqCst，保证所有线程看到同样顺序的对 receivers 的操作。这个值是最新的值。</p><p><strong>在压入数据时，需要判断一下之前是队列是否为空，因为队列为空的时候，我们需要用 notify_one() 来唤醒消费者</strong>。这个非常重要，如果没处理的话，会导致消费者阻塞后无法复原接收数据。</p><p>由于我们可以有多个生产者，所以要允许它 clone：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">impl&lt;T&gt; Clone for Sender&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        fn clone(&amp;self) -&gt; Self {</span></div><div class="token-line"><span class="token plain">            self.shared.senders.fetch_add(1, Ordering::AcqRel);</span></div><div class="token-line"><span class="token plain">            Self {</span></div><div class="token-line"><span class="token plain">                shared: Arc::clone(&amp;self.shared),</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>实现 Clone trait 的方法很简单，但记得要把 shared.senders 加 1，使其保持和当前的 senders 的数量一致。</p><p>当然，在 drop 的时候我们也要维护 shared.senders 使其减 1：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">impl&lt;T&gt; Drop for Sender&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        fn drop(&amp;mut self) {</span></div><div class="token-line"><span class="token plain">            self.shared.senders.fetch_sub(1, Ordering::AcqRel);</span></div><div class="token-line"><span class="token plain">            </span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="其它功能"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/03#其它功能"><span class="icon icon-link"></span></a>其它功能</h3><p>目前还缺乏 Receiver 的 Iterator 的实现，这个很简单，就是在 next() 里调用 recv() 方法，Rust 提供了支持在 Option / Result 之间很方便转换的函数，所以这里我们可以直接通过 ok() 来将 Result 转换成 Option：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">impl&lt;T&gt; Iterator for Receiver&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        type Item = T;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {</span></div><div class="token-line"><span class="token plain">            self.recv().ok()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>好，目前所有需要实现的代码都实现完毕， <code>cargo test</code> 测试一下。wow！测试一次性通过！这也太顺利了吧！</p><p>最后来仔细审视一下代码。很快，我们发现 Sender 的 Drop 实现似乎有点问题。<strong>如果 Receiver 被阻塞，而此刻所有 Sender 都走了，那么 Receiver 就没有人唤醒，会带来资源的泄露</strong>。这是一个很边边角角的问题，所以之前的测试没有覆盖到。</p><p>我们来设计一个场景让这个问题暴露：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#[test]</span></div><div class="token-line"><span class="token plain">    fn receiver_shall_be_notified_when_all_senders_exit() {</span></div><div class="token-line"><span class="token plain">        let (s, mut r) = unbounded::&lt;usize&gt;();</span></div><div class="token-line"><span class="token plain">        // 用于两个线程同步</span></div><div class="token-line"><span class="token plain">        let (mut sender, mut receiver) = unbounded::&lt;usize&gt;();</span></div><div class="token-line"><span class="token plain">        let t1 = thread::spawn(move || {</span></div><div class="token-line"><span class="token plain">            // 保证 r.recv() 先于 t2 的 drop 执行</span></div><div class="token-line"><span class="token plain">            sender.send(0).unwrap();</span></div><div class="token-line"><span class="token plain">            assert!(r.recv().is_err());</span></div><div class="token-line"><span class="token plain">        });</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        thread::spawn(move || {</span></div><div class="token-line"><span class="token plain">            receiver.recv().unwrap();</span></div><div class="token-line"><span class="token plain">            drop(s);</span></div><div class="token-line"><span class="token plain">        });</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        t1.join().unwrap();</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在我进一步解释之前，你可以停下来想想为什么这个测试可以保证暴露这个问题？它是怎么暴露的？如果想不到，再 <code>cargo test</code> 看看会出现什么问题。</p><p>来一起分析分析，这里，我们创建了两个线程 t1 和 t2，分别让它们处理消费者和生产者。<strong>t1 读取数据，此时没有数据，所以会阻塞，而t2 直接把生产者 drop 掉</strong>。所以，此刻如果没有人唤醒 t1，那么 t1.join() 就会一直等待，因为 t1 一直没有退出。</p><p>所以，为了保证一定是 t1 <code>r.recv()</code>先执行导致阻塞、t2 再 <code>drop(s)</code>，我们（eat your own dog food）用另一个 channel 来控制两个线程的执行顺序。这是一种很通用的做法，你可以好好琢磨一下。</p><p>运行 <code>cargo test</code> 后，测试被阻塞。这是因为，t1 没有机会得到唤醒，所以这个测试就停在那里不动了。</p><p>要修复这个问题，我们需要妥善处理 Sender 的 Drop：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">impl&lt;T&gt; Drop for Sender&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        fn drop(&amp;mut self) {</span></div><div class="token-line"><span class="token plain">            let old = self.shared.senders.fetch_sub(1, Ordering::AcqRel);</span></div><div class="token-line"><span class="token plain">            // sender 走光了，唤醒 receiver 读取数据（如果队列中还有的话），读不到就出错</span></div><div class="token-line"><span class="token plain">            if old &lt;= 1 {</span></div><div class="token-line"><span class="token plain">                // 因为我们实现的是 MPSC，receiver 只有一个，所以 notify_all 实际等价 notify_one</span></div><div class="token-line"><span class="token plain">                self.shared.available.notify_all();</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里，如果减一之前，旧的 senders 的数量小于等于 1，意味着现在是最后一个 Sender 要离开了，不管怎样我们都要唤醒 Receiver ，所以这里使用了 notify_all()。如果 Receiver 之前已经被阻塞，此刻就能被唤醒。修改完成，<code>cargo test</code> 一切正常。</p><h2 id="性能优化"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/03#性能优化"><span class="icon icon-link"></span></a>性能优化</h2><p>从功能上来说，目前我们的 MPSC unbounded channel 没有太多的问题，可以应用在任何需要 MPSC channel 的场景。然而，每次读写都需要获取锁，虽然锁的粒度很小，但还是让整体的性能打了个折扣。有没有可能优化锁呢？</p><p>之前我们讲到，优化锁的手段无非是<strong>减小临界区的大小</strong>，让每次加锁的时间很短，这样冲突的几率就变小。另外，就是**降低加锁的频率，**对于消费者来说，如果我们能够一次性把队列中的所有数据都读完缓存起来，以后在需要的时候从缓存中读取，这样就可以大大减少消费者加锁的频次。</p><p>顺着这个思路，我们可以在 Receiver 的结构中放一个 cache：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pub struct Receiver&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        shared: Arc&lt;Shared&lt;T&gt;&gt;,</span></div><div class="token-line"><span class="token plain">        cache: VecDeque&lt;T&gt;,</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>如果你之前有 C 语言开发的经验，也许会想，到了这一步，何必把 queue 中的数据全部读出来，存入 Receiver 的 cache 呢？这样效率太低，如果能够直接 swap 两个结构内部的指针，这样，即便队列中有再多的数据，也是一个 O(1) 的操作。</p><p>嗯，别急，Rust 有类似的 <a target="_blank" rel="noopener noreferrer" href="https://doc.rust-lang.org/std/mem/fn.swap.html">std::mem::swap<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 方法。比如（<a target="_blank" rel="noopener noreferrer" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=b68e503ae3413338f770fde2f6c7e861">代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use std::mem;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fn main() {</span></div><div class="token-line"><span class="token plain">        let mut x = &quot;hello world&quot;.to_string();</span></div><div class="token-line"><span class="token plain">        let mut y = &quot;goodbye world&quot;.to_string();</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        mem::swap(&amp;mut x, &amp;mut y);</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        assert_eq!(&quot;goodbye world&quot;, x);</span></div><div class="token-line"><span class="token plain">        assert_eq!(&quot;hello world&quot;, y);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>好，了解了 swap 方法，我们看看如何修改 Receiver 的 recv() 方法来提升性能：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pub fn recv(&amp;mut self) -&gt; Result&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        // 无锁 fast path</span></div><div class="token-line"><span class="token plain">        if let Some(v) = self.cache.pop_front() {</span></div><div class="token-line"><span class="token plain">            return Ok(v);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 拿到队列的锁</span></div><div class="token-line"><span class="token plain">        let mut inner = self.shared.queue.lock().unwrap();</span></div><div class="token-line"><span class="token plain">        loop {</span></div><div class="token-line"><span class="token plain">            match inner.pop_front() {</span></div><div class="token-line"><span class="token plain">                // 读到数据返回，锁被释放</span></div><div class="token-line"><span class="token plain">                Some(t) =&gt; {</span></div><div class="token-line"><span class="token plain">                    // 如果当前队列中还有数据，那么就把消费者自身缓存的队列（空）和共享队列 swap 一下</span></div><div class="token-line"><span class="token plain">                    // 这样之后再读取，就可以从 self.queue 中无锁读取</span></div><div class="token-line"><span class="token plain">                    if !inner.is_empty() {</span></div><div class="token-line"><span class="token plain">                        std::mem::swap(&amp;mut self.cache, &amp;mut inner);</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                    return Ok(t);</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">                // 读不到数据，并且生产者都退出了，释放锁并返回错误</span></div><div class="token-line"><span class="token plain">                None if self.total_senders() == 0 =&gt; return Err(anyhow!(&quot;no sender left&quot;)),</span></div><div class="token-line"><span class="token plain">                // 读不到数据，把锁提交给 available Condvar，它会释放锁并挂起线程，等待 notify</span></div><div class="token-line"><span class="token plain">                None =&gt; {</span></div><div class="token-line"><span class="token plain">                    // 当 Condvar 被唤醒后会返回 MutexGuard，我们可以 loop 回去拿数据</span></div><div class="token-line"><span class="token plain">                    // 这是为什么 Condvar 要在 loop 里使用</span></div><div class="token-line"><span class="token plain">                    inner = self</span></div><div class="token-line"><span class="token plain">                        .shared</span></div><div class="token-line"><span class="token plain">                        .available</span></div><div class="token-line"><span class="token plain">                        .wait(inner)</span></div><div class="token-line"><span class="token plain">                        .map_err(|_| anyhow!(&quot;lock poisoned&quot;))?;</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>当 cache 中有数据时，总是从 cache 中读取；当 cache 中没有，我们拿到队列的锁，读取一个数据，然后看看队列是否还有数据，有的话，就 swap cache 和 queue，然后返回之前读取的数据。</p><p>好，做完这个重构和优化，我们可以运行 <code>cargo test</code>，看看已有的测试是否正常。如果你遇到报错，应该是 cache 没有初始化，你可以自行解决，也可以参考：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pub fn unbounded&lt;T&gt;() -&gt; (Sender&lt;T&gt;, Receiver&lt;T&gt;) {</span></div><div class="token-line"><span class="token plain">        let shared = Shared::default();</span></div><div class="token-line"><span class="token plain">        let shared = Arc::new(shared);</span></div><div class="token-line"><span class="token plain">        (</span></div><div class="token-line"><span class="token plain">            Sender {</span></div><div class="token-line"><span class="token plain">                shared: shared.clone(),</span></div><div class="token-line"><span class="token plain">            },</span></div><div class="token-line"><span class="token plain">            Receiver {</span></div><div class="token-line"><span class="token plain">                shared,</span></div><div class="token-line"><span class="token plain">                cache: VecDeque::with_capacity(INITIAL_SIZE),</span></div><div class="token-line"><span class="token plain">            },</span></div><div class="token-line"><span class="token plain">        )</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>虽然现有的测试全数通过，但我们并没有为这个优化写测试，这里补个测试：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#[test]</span></div><div class="token-line"><span class="token plain">        fn channel_fast_path_should_work() {</span></div><div class="token-line"><span class="token plain">        let (mut s, mut r) = unbounded();</span></div><div class="token-line"><span class="token plain">        for i in 0..10usize {</span></div><div class="token-line"><span class="token plain">            s.send(i).unwrap();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        assert!(r.cache.is_empty());</span></div><div class="token-line"><span class="token plain">        // 读取一个数据，此时应该会导致 swap，cache 中有数据</span></div><div class="token-line"><span class="token plain">        assert_eq!(0, r.recv().unwrap());</span></div><div class="token-line"><span class="token plain">        // 还有 9 个数据在 cache 中</span></div><div class="token-line"><span class="token plain">        assert_eq!(r.cache.len(), 9);</span></div><div class="token-line"><span class="token plain">        // 在 queue 里没有数据了</span></div><div class="token-line"><span class="token plain">        assert_eq!(s.total_queued_items(), 0);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 从 cache 里读取剩下的数据</span></div><div class="token-line"><span class="token plain">        for (idx, i) in r.into_iter().take(9).enumerate() {</span></div><div class="token-line"><span class="token plain">            assert_eq!(idx + 1, i);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个测试很简单，详细注释也都写上了。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/03#小结"><span class="icon icon-link"></span></a>小结</h2><p>今天我们一起研究了如何使用 atomics 和 Condvar，结合 VecDeque 来创建一个 MPSC unbounded channel。完整的代码见 <a target="_blank" rel="noopener noreferrer" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=042ee12817442a32bcfa05e31a1084f9">playground<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，你也可以在 GitHub repo 这一讲的目录中找到。</p><p>不同于以往的实操项目，这一讲，我们完全顺着需求写测试，然后在写测试的过程中进行数据结构和接口的设计。和普通的 TDD 不同的是，我们<strong>先一口气把主要需求涉及的行为用测试来表述，然后通过这个表述，构建合适的接口，以及能够运行这个接口的数据结构</strong>。</p><p>在开发产品的时候，这也是一种非常有效的手段，可以让我们通过测试完善设计，最终得到一个能够让测试编译通过的、完全没有实现代码、只有接口的版本。之后，我们再一个接口一个接口实现，全部实现完成之后，运行测试，看看是否出问题。</p><p>在学习这一讲的内容时，你可以多多关注构建测试用例的技巧。之前的课程中，我反复强调过单元测试的重要性，也以身作则在几个重要的实操中都有详尽地测试。不过相比之前写的测试，这一讲中的测试要更难写一些，尤其是在并发场景下那些边边角角的功能测试。</p><p>不要小看测试代码，有时候构造测试代码比撰写功能代码还要烧脑。但是，当你有了扎实的单元测试覆盖后，再做重构，比如最后我们做和性能相关的重构，就变得轻松很多，<strong>因为只要</strong><code>cargo test</code><strong>通过，起码这个重构没有引起任何回归问题（regression bug）</strong>。</p><p>当然，重构没有引入回归问题，并不意味着重构完全没有问题，我们还需要考虑撰写新的测试，覆盖重构带来的改动。</p><h3 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/03#思考题"><span class="icon icon-link"></span></a>思考题</h3><p>我们实现了一个 unbounded MPSC channel，如果要将其修改为 bounded MPSC channel（队列大小是受限的），需要怎么做？</p><p>欢迎在留言区交流你的学习心得和思考，感谢你的收听，今天你已经完成了Rust学习的第35次打卡。如果你觉得有收获，也欢迎你分享给身边的朋友，邀他一起讨论。我们下节课见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/陈天rust编程第一课/06.并发篇/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:25</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
