<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>37｜阶段实操（5）：构建一个简单的KV server-网络安全</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/陈天rust编程第一课/06.并发篇/06" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/陈天rust编程第一课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-two/陈天rust编程第一课/01.开篇词/01"><span>开篇词｜让Rust成为你的下一门主力语言</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/02.前置篇">02.前置篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/02.前置篇/01"><span>01｜内存：值放堆上还是放栈上，这是一个问题</span></a></li><li><a href="/blog-two/陈天rust编程第一课/02.前置篇/02"><span>02｜串讲：编程开发中，那些你需要掌握的基本概念</span></a></li><li><a href="/blog-two/陈天rust编程第一课/02.前置篇/03"><span>加餐｜这个专栏你可以怎么学，以及Rust是否值得学？</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇">03.基础篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/01"><span>03｜初窥门径：从你的第一个Rust程序开始！</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/02"><span>04｜get hands dirty：来写个实用的CLI小工具</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/03"><span>05｜get hands dirty：做一个图片服务器有多难？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/04"><span>06｜get hands dirty：SQL查询工具怎么一鱼多吃？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/05"><span>07｜所有权：值的生杀大权到底在谁手上？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/06"><span>08｜所有权：值的借用是如何工作的？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/07"><span>09｜所有权：一个值可以有多个所有者么？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/08"><span>10｜生命周期：你创建的值究竟能活多久？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/09"><span>11｜内存管理：从创建到消亡，值都经历了什么？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/10"><span>加餐｜愚昧之巅：你的Rust学习常见问题汇总</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/11"><span>12｜类型系统：Rust的类型系统有什么特点？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/12"><span>13｜类型系统：如何使用trait来定义接口？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/13"><span>14｜类型系统：有哪些必须掌握的trait？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/14"><span>15｜数据结构：这些浓眉大眼的结构竟然都是智能指针？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/15"><span>16｜数据结构：Vec、&amp;[T]、Box&lt;[T]&gt; ，你真的了解集合容器么？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/16"><span>17｜数据结构：软件系统核心部件哈希表，内存如何布局？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/17"><span>18｜错误处理：为什么Rust的错误处理与众不同？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/18"><span>19｜闭包：FnOnce、FnMut和Fn，为什么有这么多类型？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/19"><span>20｜4 Steps ：如何更好地阅读Rust源码？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/20"><span>21｜阶段实操（1）：构建一个简单的KV server-基本流程</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/21"><span>22｜阶段实操（2）：构建一个简单的KV server-基本流程</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/04.期中周">04.期中周</a><ul><li><a href="/blog-two/陈天rust编程第一课/04.期中周/01"><span>加餐｜期中测试：来写一个简单的grep命令行</span></a></li><li><a href="/blog-two/陈天rust编程第一课/04.期中周/02"><span>加餐｜期中测试：参考实现讲解</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇">05.进阶篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/01"><span>23｜类型系统：如何在实战中使用泛型编程？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/02"><span>24｜类型系统：如何在实战中使用trait object？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/03"><span>25｜类型系统：如何围绕trait来设计和架构系统？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/04"><span>加餐｜Rust2021版次问世了！</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/05"><span>26｜阶段实操（3）：构建一个简单的KV server-高级trait技巧</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/06"><span>27｜生态系统：有哪些常有的Rust库可以为我所用？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/07"><span>28｜网络开发（上）：如何使用Rust处理网络请求？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/08"><span>29｜网络开发（下）：如何使用Rust处理网络请求？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/09"><span>30｜Unsafe Rust：如何用C++的方式打开Rust？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/10"><span>31｜FFI：Rust如何和你的语言架起沟通桥梁？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/11"><span>32｜实操项目：使用PyO3开发Python3模块</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课/06.并发篇">06.并发篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/01"><span>33｜并发处理（上）：从atomics到Channel，Rust都提供了什么工具？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/02"><span>34｜并发处理（下）：从atomics到Channel，Rust都提供了什么工具？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/03"><span>35｜实操项目：如何实现一个基本的MPSC channel？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/04"><span>用户故事｜绝望之谷：改变从学习开始</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/05"><span>36｜阶段实操（4）：构建一个简单的KV server-网络处理</span></a></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课/06.并发篇/06"><span>37｜阶段实操（5）：构建一个简单的KV server-网络安全</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/07"><span>38｜异步处理：Future是什么？它和async/await是什么关系？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/08"><span>39｜异步处理：async/await内部是怎么实现的？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/09"><span>40｜异步处理：如何处理异步IO？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/10"><span>41｜阶段实操（6）：构建一个简单的KV server-异步处理</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/11"><span>42｜阶段实操（7）：构建一个简单的KV server-如何做大的重构？</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇">07.实战篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/01"><span>43｜生产环境：真实世界下的一个Rust项目包含哪些要素？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/02"><span>44｜数据处理：应用程序和数据如何打交道？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/03"><span>45｜阶段实操（8）：构建一个简单的KV server-配置/测试/监控/CI/CD</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/04"><span>46｜软件架构：如何用Rust架构复杂系统？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/05"><span>大咖助场｜开悟之坡（上）：Rust的现状、机遇与挑战</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/06"><span>大咖助场｜开悟之坡（下）：Rust的现状、机遇与挑战</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/07"><span>用户故事｜语言不仅是工具，还是思维方式</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/08.高级篇">08.高级篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/08.高级篇/01"><span>加餐｜代码即数据：为什么我们需要宏编程能力？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/08.高级篇/02"><span>加餐｜宏编程（上）：用最“笨”的方式撰写宏</span></a></li><li><a href="/blog-two/陈天rust编程第一课/08.高级篇/03"><span>加餐｜宏编程（下）：用 syn/quote 优雅地构建宏</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/09.结束语">09.结束语</a><ul><li><a href="/blog-two/陈天rust编程第一课/09.结束语/01"><span>结束语｜永续之原：Rust学习，如何持续精进？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/09.结束语/02"><span>期末测试｜来赴一场满分之约！</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊">10.学习锦囊</a><ul><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊/01"><span>特别策划｜学习锦囊（一）：听听课代表们怎么说</span></a></li><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊/02"><span>特别策划｜学习锦囊（二）：听听课代表们怎么说</span></a></li><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊/03"><span>特别策划｜学习锦囊（三）：听听课代表们怎么说</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/summary">陈天rust编程第一课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="生成 x509 证书" data-depth="2"><a href="/blog-two/陈天rust编程第一课/06.并发篇/06#生成-x509-证书"><span>生成 x509 证书</span></a></li><li title="在 KV server 中使用 TLS" data-depth="2"><a href="/blog-two/陈天rust编程第一课/06.并发篇/06#在-kv-server-中使用-tls"><span>在 KV server 中使用 TLS</span></a></li><li title="让 KV client/server 支持 TLS" data-depth="2"><a href="/blog-two/陈天rust编程第一课/06.并发篇/06#让-kv-clientserver-支持-tls"><span>让 KV client/server 支持 TLS</span></a></li><li title="小结" data-depth="2"><a href="/blog-two/陈天rust编程第一课/06.并发篇/06#小结"><span>小结</span></a></li><li title="思考题" data-depth="3"><a href="/blog-two/陈天rust编程第一课/06.并发篇/06#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="37阶段实操5构建一个简单的kv-server-网络安全"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/06#37阶段实操5构建一个简单的kv-server-网络安全"><span class="icon icon-link"></span></a>37｜阶段实操（5）：构建一个简单的KV server-网络安全</h1><p>你好，我是陈天。</p><p>上一讲我们完成了KV server整个网络部分的构建。而安全是和网络密不可分的组成部分，在构建应用程序的时候，一定要把网络安全也考虑进去。当然，如果不考虑极致的性能，我们可以使用诸如 gRPC 这样的系统，在提供良好性能的基础上，它还通过 <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Transport_Layer_Security">TLS<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 保证了安全性。</p><p>那么，当我们的应用架构在 TCP 上时，如何使用 TLS 来保证客户端和服务器间的安全性呢？</p><h2 id="生成-x509-证书"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/06#生成-x509-证书"><span class="icon icon-link"></span></a>生成 x509 证书</h2><p>想要使用 TLS，我们首先需要 <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/X.509">x509 证书<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。TLS 需要 x509 证书让客户端验证服务器是否是一个受信的服务器，甚至服务器验证客户端，确认对方是一个受信的客户端。</p><p>为了测试方便，我们要有能力生成自己的 CA 证书、服务端证书，甚至客户端证书。证书生成的细节今天就不详细介绍了，我之前做了一个叫 <a target="_blank" rel="noopener noreferrer" href="https://github.com/tyrchen/certify">certify<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的库，可以用来生成各种证书。我们可以在 Cargo.toml 里加入这个库：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[dev-dependencies]</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    certify = &quot;0.3&quot;</span></div><div class="token-line"><span class="token plain">    ...</span></div></pre></div><p>然后在根目录下创建 fixtures 目录存放证书，再创建 examples/gen_cert.rs 文件，添入如下代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use anyhow::Result;</span></div><div class="token-line"><span class="token plain">    use certify::{generate_ca, generate_cert, load_ca, CertType, CA};</span></div><div class="token-line"><span class="token plain">    use tokio::fs;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    struct CertPem {</span></div><div class="token-line"><span class="token plain">        cert_type: CertType,</span></div><div class="token-line"><span class="token plain">        cert: String,</span></div><div class="token-line"><span class="token plain">        key: String,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #[tokio::main]</span></div><div class="token-line"><span class="token plain">    async fn main() -&gt; Result&lt;()&gt; {</span></div><div class="token-line"><span class="token plain">        let pem = create_ca()?;</span></div><div class="token-line"><span class="token plain">        gen_files(&amp;pem).await?;</span></div><div class="token-line"><span class="token plain">        let ca = load_ca(&amp;pem.cert, &amp;pem.key)?;</span></div><div class="token-line"><span class="token plain">        let pem = create_cert(&amp;ca, &amp;[&quot;kvserver.acme.inc&quot;], &quot;Acme KV server&quot;, false)?;</span></div><div class="token-line"><span class="token plain">        gen_files(&amp;pem).await?;</span></div><div class="token-line"><span class="token plain">        let pem = create_cert(&amp;ca, &amp;[], &quot;awesome-device-id&quot;, true)?;</span></div><div class="token-line"><span class="token plain">        gen_files(&amp;pem).await?;</span></div><div class="token-line"><span class="token plain">        Ok(())</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fn create_ca() -&gt; Result&lt;CertPem&gt; {</span></div><div class="token-line"><span class="token plain">        let (cert, key) = generate_ca(</span></div><div class="token-line"><span class="token plain">            &amp;[&quot;acme.inc&quot;],</span></div><div class="token-line"><span class="token plain">            &quot;CN&quot;,</span></div><div class="token-line"><span class="token plain">            &quot;Acme Inc.&quot;,</span></div><div class="token-line"><span class="token plain">            &quot;Acme CA&quot;,</span></div><div class="token-line"><span class="token plain">            None,</span></div><div class="token-line"><span class="token plain">            Some(10 * 365),</span></div><div class="token-line"><span class="token plain">        )?;</span></div><div class="token-line"><span class="token plain">        Ok(CertPem {</span></div><div class="token-line"><span class="token plain">            cert_type: CertType::CA,</span></div><div class="token-line"><span class="token plain">            cert,</span></div><div class="token-line"><span class="token plain">            key,</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fn create_cert(ca: &amp;CA, domains: &amp;[&amp;str], cn: &amp;str, is_client: bool) -&gt; Result&lt;CertPem&gt; {</span></div><div class="token-line"><span class="token plain">        let (days, cert_type) = if is_client {</span></div><div class="token-line"><span class="token plain">            (Some(365), CertType::Client)</span></div><div class="token-line"><span class="token plain">        } else {</span></div><div class="token-line"><span class="token plain">            (Some(5 * 365), CertType::Server)</span></div><div class="token-line"><span class="token plain">        };</span></div><div class="token-line"><span class="token plain">        let (cert, key) = generate_cert(ca, domains, &quot;CN&quot;, &quot;Acme Inc.&quot;, cn, None, is_client, days)?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        Ok(CertPem {</span></div><div class="token-line"><span class="token plain">            cert_type,</span></div><div class="token-line"><span class="token plain">            cert,</span></div><div class="token-line"><span class="token plain">            key,</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    async fn gen_files(pem: &amp;CertPem) -&gt; Result&lt;()&gt; {</span></div><div class="token-line"><span class="token plain">        let name = match pem.cert_type {</span></div><div class="token-line"><span class="token plain">            CertType::Client =&gt; &quot;client&quot;,</span></div><div class="token-line"><span class="token plain">            CertType::Server =&gt; &quot;server&quot;,</span></div><div class="token-line"><span class="token plain">            CertType::CA =&gt; &quot;ca&quot;,</span></div><div class="token-line"><span class="token plain">        };</span></div><div class="token-line"><span class="token plain">        fs::write(format!(&quot;fixtures/{}.cert&quot;, name), pem.cert.as_bytes()).await?;</span></div><div class="token-line"><span class="token plain">        fs::write(format!(&quot;fixtures/{}.key&quot;, name), pem.key.as_bytes()).await?;</span></div><div class="token-line"><span class="token plain">        Ok(())</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个代码很简单，它先生成了一个 CA 证书，然后再生成服务器和客户端证书，全部存入刚创建的 fixtures 目录下。你需要 <code>cargo run \--examples gen_cert</code> 运行一下这个命令，待会我们会在测试中用到这些证书和密钥。</p><h2 id="在-kv-server-中使用-tls"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/06#在-kv-server-中使用-tls"><span class="icon icon-link"></span></a>在 KV server 中使用 TLS</h2><p>TLS 是目前最主要的应用层安全协议，被广泛用于保护架构在 TCP 之上的，比如 MySQL、HTTP 等各种协议。一个网络应用，即便是在内网使用，如果没有安全协议来保护，都是很危险的。</p><p>下图展示了客户端和服务器进行 TLS 握手的过程，来源<a target="_blank" rel="noopener noreferrer" href="https://commons.wikimedia.org/wiki/File:Full_TLS_1.3_Handshake.svg">wikimedia<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：<br/><img src="https://static001.geekbang.org/resource/image/71/f7/71befa0bbf5225582dd01a7330c641f7.png?wh=1280x877" alt=""/></p><p>对于 KV server 来说，使用 TLS 之后，整个协议的数据封装如下图所示：<br/><img src="https://static001.geekbang.org/resource/image/07/13/077659d231dd45b1617ed3707c74cf13.jpg?wh=2364x1027" alt=""/></p><p>所以今天要做的就是在上一讲的网络处理的基础上，添加 TLS 支持，使得 KV server 的客户端服务器之间的通讯被严格保护起来，确保最大程度的安全，免遭第三方的偷窥、篡改以及仿造。</p><p>好，接下来我们看看 TLS 怎么实现。</p><p>估计很多人一听 TLS 或者 SSL，就头皮发麻，因为之前跟 <a target="_blank" rel="noopener noreferrer" href="https://www.openssl.org/">openssl<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 打交道有过很多不好的经历。openssl 的代码库太庞杂，API 不友好，编译链接都很费劲。</p><p>不过，在 Rust 下使用 TLS 的体验还是很不错的，Rust 对 openssl 有很不错的<a target="_blank" rel="noopener noreferrer" href="https://github.com/sfackler/rust-openssl">封装<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，也有不依赖 openssl 用 Rust 撰写的 <a target="_blank" rel="noopener noreferrer" href="https://github.com/rustls/rustls">rustls<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。tokio 进一步提供了符合 tokio 生态圈的 <a target="_blank" rel="noopener noreferrer" href="https://github.com/tokio-rs/tls">tls 支持<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，有 openssl 版本和 rustls 版本可选。</p><p>我们今天就用 <a target="_blank" rel="noopener noreferrer" href="https://github.com/tokio-rs/tls/tree/master/tokio-rustls">tokio-rustls<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 来撰写 TLS 的支持。相信你在实现过程中可以看到，在应用程序中加入 TLS 协议来保护网络层，是多么轻松的一件事情。</p><p>先在 Cargo.toml 中添加 tokio-rustls：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[dependencies]</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    tokio-rustls = &quot;0.22&quot;</span></div><div class="token-line"><span class="token plain">    ...</span></div></pre></div><p>然后创建 src/network/tls.rs，撰写如下代码（记得在 src/network/mod.rs 中引入这个文件哦）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use std::io::Cursor;</span></div><div class="token-line"><span class="token plain">    use std::sync::Arc;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    use tokio::io::{AsyncRead, AsyncWrite};</span></div><div class="token-line"><span class="token plain">    use tokio_rustls::rustls::{internal::pemfile, Certificate, ClientConfig, ServerConfig};</span></div><div class="token-line"><span class="token plain">    use tokio_rustls::rustls::{AllowAnyAuthenticatedClient, NoClientAuth, PrivateKey, RootCertStore};</span></div><div class="token-line"><span class="token plain">    use tokio_rustls::webpki::DNSNameRef;</span></div><div class="token-line"><span class="token plain">    use tokio_rustls::TlsConnector;</span></div><div class="token-line"><span class="token plain">    use tokio_rustls::{</span></div><div class="token-line"><span class="token plain">        client::TlsStream as ClientTlsStream, server::TlsStream as ServerTlsStream, TlsAcceptor,</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    use crate::KvError;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// KV Server 自己的 ALPN (Application-Layer Protocol Negotiation)</span></div><div class="token-line"><span class="token plain">    const ALPN_KV: &amp;str = &quot;kv&quot;;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// 存放 TLS ServerConfig 并提供方法 accept 把底层的协议转换成 TLS</span></div><div class="token-line"><span class="token plain">    #[derive(Clone)]</span></div><div class="token-line"><span class="token plain">    pub struct TlsServerAcceptor {</span></div><div class="token-line"><span class="token plain">        inner: Arc&lt;ServerConfig&gt;,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// 存放 TLS Client 并提供方法 connect 把底层的协议转换成 TLS</span></div><div class="token-line"><span class="token plain">    #[derive(Clone)]</span></div><div class="token-line"><span class="token plain">    pub struct TlsClientConnector {</span></div><div class="token-line"><span class="token plain">        pub config: Arc&lt;ClientConfig&gt;,</span></div><div class="token-line"><span class="token plain">        pub domain: Arc&lt;String&gt;,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl TlsClientConnector {</span></div><div class="token-line"><span class="token plain">        /// 加载 client cert / CA cert，生成 ClientConfig</span></div><div class="token-line"><span class="token plain">        pub fn new(</span></div><div class="token-line"><span class="token plain">            domain: impl Into&lt;String&gt;,</span></div><div class="token-line"><span class="token plain">            identity: Option&lt;(&amp;str, &amp;str)&gt;,</span></div><div class="token-line"><span class="token plain">            server_ca: Option&lt;&amp;str&gt;,</span></div><div class="token-line"><span class="token plain">        ) -&gt; Result&lt;Self, KvError&gt; {</span></div><div class="token-line"><span class="token plain">            let mut config = ClientConfig::new();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 如果有客户端证书，加载之</span></div><div class="token-line"><span class="token plain">            if let Some((cert, key)) = identity {</span></div><div class="token-line"><span class="token plain">                let certs = load_certs(cert)?;</span></div><div class="token-line"><span class="token plain">                let key = load_key(key)?;</span></div><div class="token-line"><span class="token plain">                config.set_single_client_cert(certs, key)?;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 加载本地信任的根证书链</span></div><div class="token-line"><span class="token plain">            config.root_store = match rustls_native_certs::load_native_certs() {</span></div><div class="token-line"><span class="token plain">                Ok(store) | Err((Some(store), _)) =&gt; store,</span></div><div class="token-line"><span class="token plain">                Err((None, error)) =&gt; return Err(error.into()),</span></div><div class="token-line"><span class="token plain">            };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 如果有签署服务器的 CA 证书，则加载它，这样服务器证书不在根证书链</span></div><div class="token-line"><span class="token plain">            // 但是这个 CA 证书能验证它，也可以</span></div><div class="token-line"><span class="token plain">            if let Some(cert) = server_ca {</span></div><div class="token-line"><span class="token plain">                let mut buf = Cursor::new(cert);</span></div><div class="token-line"><span class="token plain">                config.root_store.add_pem_file(&amp;mut buf).unwrap();</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            Ok(Self {</span></div><div class="token-line"><span class="token plain">                config: Arc::new(config),</span></div><div class="token-line"><span class="token plain">                domain: Arc::new(domain.into()),</span></div><div class="token-line"><span class="token plain">            })</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        /// 触发 TLS 协议，把底层的 stream 转换成 TLS stream</span></div><div class="token-line"><span class="token plain">        pub async fn connect&lt;S&gt;(&amp;self, stream: S) -&gt; Result&lt;ClientTlsStream&lt;S&gt;, KvError&gt;</span></div><div class="token-line"><span class="token plain">        where</span></div><div class="token-line"><span class="token plain">            S: AsyncRead + AsyncWrite + Unpin + Send,</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            let dns = DNSNameRef::try_from_ascii_str(self.domain.as_str())</span></div><div class="token-line"><span class="token plain">                .map_err(|_| KvError::Internal(&quot;Invalid DNS name&quot;.into()))?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            let stream = TlsConnector::from(self.config.clone())</span></div><div class="token-line"><span class="token plain">                .connect(dns, stream)</span></div><div class="token-line"><span class="token plain">                .await?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            Ok(stream)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl TlsServerAcceptor {</span></div><div class="token-line"><span class="token plain">        /// 加载 server cert / CA cert，生成 ServerConfig</span></div><div class="token-line"><span class="token plain">        pub fn new(cert: &amp;str, key: &amp;str, client_ca: Option&lt;&amp;str&gt;) -&gt; Result&lt;Self, KvError&gt; {</span></div><div class="token-line"><span class="token plain">            let certs = load_certs(cert)?;</span></div><div class="token-line"><span class="token plain">            let key = load_key(key)?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            let mut config = match client_ca {</span></div><div class="token-line"><span class="token plain">                None =&gt; ServerConfig::new(NoClientAuth::new()),</span></div><div class="token-line"><span class="token plain">                Some(cert) =&gt; {</span></div><div class="token-line"><span class="token plain">                    // 如果客户端证书是某个 CA 证书签发的，则把这个 CA 证书加载到信任链中</span></div><div class="token-line"><span class="token plain">                    let mut cert = Cursor::new(cert);</span></div><div class="token-line"><span class="token plain">                    let mut client_root_cert_store = RootCertStore::empty();</span></div><div class="token-line"><span class="token plain">                    client_root_cert_store</span></div><div class="token-line"><span class="token plain">                        .add_pem_file(&amp;mut cert)</span></div><div class="token-line"><span class="token plain">                        .map_err(|_| KvError::CertifcateParseError(&quot;CA&quot;, &quot;cert&quot;))?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                    let client_auth = AllowAnyAuthenticatedClient::new(client_root_cert_store);</span></div><div class="token-line"><span class="token plain">                    ServerConfig::new(client_auth)</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 加载服务器证书</span></div><div class="token-line"><span class="token plain">            config</span></div><div class="token-line"><span class="token plain">                .set_single_cert(certs, key)</span></div><div class="token-line"><span class="token plain">                .map_err(|_| KvError::CertifcateParseError(&quot;server&quot;, &quot;cert&quot;))?;</span></div><div class="token-line"><span class="token plain">            config.set_protocols(&amp;[Vec::from(&amp;ALPN_KV[..])]);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            Ok(Self {</span></div><div class="token-line"><span class="token plain">                inner: Arc::new(config),</span></div><div class="token-line"><span class="token plain">            })</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        /// 触发 TLS 协议，把底层的 stream 转换成 TLS stream</span></div><div class="token-line"><span class="token plain">        pub async fn accept&lt;S&gt;(&amp;self, stream: S) -&gt; Result&lt;ServerTlsStream&lt;S&gt;, KvError&gt;</span></div><div class="token-line"><span class="token plain">        where</span></div><div class="token-line"><span class="token plain">            S: AsyncRead + AsyncWrite + Unpin + Send,</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            let acceptor = TlsAcceptor::from(self.inner.clone());</span></div><div class="token-line"><span class="token plain">            Ok(acceptor.accept(stream).await?)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fn load_certs(cert: &amp;str) -&gt; Result&lt;Vec&lt;Certificate&gt;, KvError&gt; {</span></div><div class="token-line"><span class="token plain">        let mut cert = Cursor::new(cert);</span></div><div class="token-line"><span class="token plain">        pemfile::certs(&amp;mut cert).map_err(|_| KvError::CertifcateParseError(&quot;server&quot;, &quot;cert&quot;))</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fn load_key(key: &amp;str) -&gt; Result&lt;PrivateKey, KvError&gt; {</span></div><div class="token-line"><span class="token plain">        let mut cursor = Cursor::new(key);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 先尝试用 PKCS8 加载私钥</span></div><div class="token-line"><span class="token plain">        if let Ok(mut keys) = pemfile::pkcs8_private_keys(&amp;mut cursor) {</span></div><div class="token-line"><span class="token plain">            if !keys.is_empty() {</span></div><div class="token-line"><span class="token plain">                return Ok(keys.remove(0));</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 再尝试加载 RSA key</span></div><div class="token-line"><span class="token plain">        cursor.set_position(0);</span></div><div class="token-line"><span class="token plain">        if let Ok(mut keys) = pemfile::rsa_private_keys(&amp;mut cursor) {</span></div><div class="token-line"><span class="token plain">            if !keys.is_empty() {</span></div><div class="token-line"><span class="token plain">                return Ok(keys.remove(0));</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 不支持的私钥类型</span></div><div class="token-line"><span class="token plain">        Err(KvError::CertifcateParseError(&quot;private&quot;, &quot;key&quot;))</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个代码创建了两个数据结构 TlsServerAcceptor / TlsClientConnector。虽然它有 100 多行，但主要的工作其实就是<strong>根据提供的证书，来生成 tokio-tls 需要的 ServerConfig / ClientConfig</strong>。</p><p>因为 TLS 需要验证证书的 CA，所以还需要加载 CA 证书。虽然平时在做 Web 开发时，我们都只使用服务器证书，但其实 TLS 支持双向验证，服务器也可以验证客户端的证书是否是它认识的 CA 签发的。</p><p>处理完 config 后，这段代码的核心逻辑其实就是客户端的 connect() 方法和服务器的 accept() 方法，它们都接受一个满足 AsyncRead + AsyncWrite + Unpin + Send 的 stream。类似上一讲，我们不希望 TLS 代码只能接受 TcpStream，所以这里提供了一个泛型参数 S：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/// 触发 TLS 协议，把底层的 stream 转换成 TLS stream</span></div><div class="token-line"><span class="token plain">    pub async fn connect&lt;S&gt;(&amp;self, stream: S) -&gt; Result&lt;ClientTlsStream&lt;S&gt;, KvError&gt;</span></div><div class="token-line"><span class="token plain">    where</span></div><div class="token-line"><span class="token plain">        S: AsyncRead + AsyncWrite + Unpin + Send,</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        let dns = DNSNameRef::try_from_ascii_str(self.domain.as_str())</span></div><div class="token-line"><span class="token plain">            .map_err(|_| KvError::Internal(&quot;Invalid DNS name&quot;.into()))?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        let stream = TlsConnector::from(self.config.clone())</span></div><div class="token-line"><span class="token plain">            .connect(dns, stream)</span></div><div class="token-line"><span class="token plain">            .await?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        Ok(stream)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// 触发 TLS 协议，把底层的 stream 转换成 TLS stream</span></div><div class="token-line"><span class="token plain">    pub async fn accept&lt;S&gt;(&amp;self, stream: S) -&gt; Result&lt;ServerTlsStream&lt;S&gt;, KvError&gt;</span></div><div class="token-line"><span class="token plain">    where</span></div><div class="token-line"><span class="token plain">        S: AsyncRead + AsyncWrite + Unpin + Send,</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        let acceptor = TlsAcceptor::from(self.inner.clone());</span></div><div class="token-line"><span class="token plain">        Ok(acceptor.accept(stream).await?)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在使用 TlsConnector 或者 TlsAcceptor 处理完 connect/accept 后，我们得到了一个 TlsStream，它也满足 AsyncRead + AsyncWrite + Unpin + Send，后续的操作就可以在其上完成了。百来行代码就搞定了 TLS，是不是很轻松？</p><p>我们来顺着往下写段测试：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#[cfg(test)]</span></div><div class="token-line"><span class="token plain">    mod tests {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        use std::net::SocketAddr;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        use super::*;</span></div><div class="token-line"><span class="token plain">        use anyhow::Result;</span></div><div class="token-line"><span class="token plain">        use tokio::{</span></div><div class="token-line"><span class="token plain">            io::{AsyncReadExt, AsyncWriteExt},</span></div><div class="token-line"><span class="token plain">            net::{TcpListener, TcpStream},</span></div><div class="token-line"><span class="token plain">        };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        const CA_CERT: &amp;str = include_str!(&quot;../../fixtures/ca.cert&quot;);</span></div><div class="token-line"><span class="token plain">        const CLIENT_CERT: &amp;str = include_str!(&quot;../../fixtures/client.cert&quot;);</span></div><div class="token-line"><span class="token plain">        const CLIENT_KEY: &amp;str = include_str!(&quot;../../fixtures/client.key&quot;);</span></div><div class="token-line"><span class="token plain">        const SERVER_CERT: &amp;str = include_str!(&quot;../../fixtures/server.cert&quot;);</span></div><div class="token-line"><span class="token plain">        const SERVER_KEY: &amp;str = include_str!(&quot;../../fixtures/server.key&quot;);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        #[tokio::test]</span></div><div class="token-line"><span class="token plain">        async fn tls_should_work() -&gt; Result&lt;()&gt; {</span></div><div class="token-line"><span class="token plain">            let ca = Some(CA_CERT);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            let addr = start_server(None).await?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            let connector = TlsClientConnector::new(&quot;kvserver.acme.inc&quot;, None, ca)?;</span></div><div class="token-line"><span class="token plain">            let stream = TcpStream::connect(addr).await?;</span></div><div class="token-line"><span class="token plain">            let mut stream = connector.connect(stream).await?;</span></div><div class="token-line"><span class="token plain">            stream.write_all(b&quot;hello world!&quot;).await?;</span></div><div class="token-line"><span class="token plain">            let mut buf = [0; 12];</span></div><div class="token-line"><span class="token plain">            stream.read_exact(&amp;mut buf).await?;</span></div><div class="token-line"><span class="token plain">            assert_eq!(&amp;buf, b&quot;hello world!&quot;);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            Ok(())</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        #[tokio::test]</span></div><div class="token-line"><span class="token plain">        async fn tls_with_client_cert_should_work() -&gt; Result&lt;()&gt; {</span></div><div class="token-line"><span class="token plain">            let client_identity = Some((CLIENT_CERT, CLIENT_KEY));</span></div><div class="token-line"><span class="token plain">            let ca = Some(CA_CERT);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            let addr = start_server(ca.clone()).await?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            let connector = TlsClientConnector::new(&quot;kvserver.acme.inc&quot;, client_identity, ca)?;</span></div><div class="token-line"><span class="token plain">            let stream = TcpStream::connect(addr).await?;</span></div><div class="token-line"><span class="token plain">            let mut stream = connector.connect(stream).await?;</span></div><div class="token-line"><span class="token plain">            stream.write_all(b&quot;hello world!&quot;).await?;</span></div><div class="token-line"><span class="token plain">            let mut buf = [0; 12];</span></div><div class="token-line"><span class="token plain">            stream.read_exact(&amp;mut buf).await?;</span></div><div class="token-line"><span class="token plain">            assert_eq!(&amp;buf, b&quot;hello world!&quot;);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            Ok(())</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        #[tokio::test]</span></div><div class="token-line"><span class="token plain">        async fn tls_with_bad_domain_should_not_work() -&gt; Result&lt;()&gt; {</span></div><div class="token-line"><span class="token plain">            let addr = start_server(None).await?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            let connector = TlsClientConnector::new(&quot;kvserver1.acme.inc&quot;, None, Some(CA_CERT))?;</span></div><div class="token-line"><span class="token plain">            let stream = TcpStream::connect(addr).await?;</span></div><div class="token-line"><span class="token plain">            let result = connector.connect(stream).await;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            assert!(result.is_err());</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            Ok(())</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        async fn start_server(ca: Option&lt;&amp;str&gt;) -&gt; Result&lt;SocketAddr&gt; {</span></div><div class="token-line"><span class="token plain">            let acceptor = TlsServerAcceptor::new(SERVER_CERT, SERVER_KEY, ca)?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            let echo = TcpListener::bind(&quot;127.0.0.1:0&quot;).await.unwrap();</span></div><div class="token-line"><span class="token plain">            let addr = echo.local_addr().unwrap();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            tokio::spawn(async move {</span></div><div class="token-line"><span class="token plain">                let (stream, _) = echo.accept().await.unwrap();</span></div><div class="token-line"><span class="token plain">                let mut stream = acceptor.accept(stream).await.unwrap();</span></div><div class="token-line"><span class="token plain">                let mut buf = [0; 12];</span></div><div class="token-line"><span class="token plain">                stream.read_exact(&amp;mut buf).await.unwrap();</span></div><div class="token-line"><span class="token plain">                stream.write_all(&amp;buf).await.unwrap();</span></div><div class="token-line"><span class="token plain">            });</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            Ok(addr)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这段测试代码使用了 include_str! 宏，在编译期把文件加载成字符串放在 RODATA 段。我们测试了三种情况：标准的 TLS 连接、带有客户端证书的 TLS 连接，以及客户端提供了错的域名的情况。运行 <code>cargo test</code> ，所有测试都能通过。</p><h2 id="让-kv-clientserver-支持-tls"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/06#让-kv-clientserver-支持-tls"><span class="icon icon-link"></span></a>让 KV client/server 支持 TLS</h2><p>在 TLS 的测试都通过后，就可以添加 kvs和 kvc对 TLS 的支持了。</p><p>由于我们一路以来良好的接口设计，尤其是 ProstClientStream / ProstServerStream 都接受泛型参数，使得 TLS 的代码可以无缝嵌入。比如客户端：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 新加的代码</span></div><div class="token-line"><span class="token plain">    let connector = TlsClientConnector::new(&quot;kvserver.acme.inc&quot;, None, Some(ca_cert))?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    let stream = TcpStream::connect(addr).await?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 新加的代码</span></div><div class="token-line"><span class="token plain">    let stream = connector.connect(stream).await?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    let mut client = ProstClientStream::new(stream);</span></div></pre></div><p>仅仅需要把传给 ProstClientStream 的 stream，从 TcpStream 换成生成的 TlsStream，就无缝支持了 TLS。</p><p>我们看完整的代码，src/server.rs：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use anyhow::Result;</span></div><div class="token-line"><span class="token plain">    use kv3::{MemTable, ProstServerStream, Service, ServiceInner, TlsServerAcceptor};</span></div><div class="token-line"><span class="token plain">    use tokio::net::TcpListener;</span></div><div class="token-line"><span class="token plain">    use tracing::info;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #[tokio::main]</span></div><div class="token-line"><span class="token plain">    async fn main() -&gt; Result&lt;()&gt; {</span></div><div class="token-line"><span class="token plain">        tracing_subscriber::fmt::init();</span></div><div class="token-line"><span class="token plain">        let addr = &quot;127.0.0.1:9527&quot;;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 以后从配置文件取</span></div><div class="token-line"><span class="token plain">        let server_cert = include_str!(&quot;../fixtures/server.cert&quot;);</span></div><div class="token-line"><span class="token plain">        let server_key = include_str!(&quot;../fixtures/server.key&quot;);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        let acceptor = TlsServerAcceptor::new(server_cert, server_key, None)?;</span></div><div class="token-line"><span class="token plain">        let service: Service = ServiceInner::new(MemTable::new()).into();</span></div><div class="token-line"><span class="token plain">        let listener = TcpListener::bind(addr).await?;</span></div><div class="token-line"><span class="token plain">        info!(&quot;Start listening on {}&quot;, addr);</span></div><div class="token-line"><span class="token plain">        loop {</span></div><div class="token-line"><span class="token plain">            let tls = acceptor.clone();</span></div><div class="token-line"><span class="token plain">            let (stream, addr) = listener.accept().await?;</span></div><div class="token-line"><span class="token plain">            info!(&quot;Client {:?} connected&quot;, addr);</span></div><div class="token-line"><span class="token plain">            let stream = tls.accept(stream).await?;</span></div><div class="token-line"><span class="token plain">            let stream = ProstServerStream::new(stream, service.clone());</span></div><div class="token-line"><span class="token plain">            tokio::spawn(async move { stream.process().await });</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>src/client.rs：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use anyhow::Result;</span></div><div class="token-line"><span class="token plain">    use kv3::{CommandRequest, ProstClientStream, TlsClientConnector};</span></div><div class="token-line"><span class="token plain">    use tokio::net::TcpStream;</span></div><div class="token-line"><span class="token plain">    use tracing::info;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    #[tokio::main]</span></div><div class="token-line"><span class="token plain">    async fn main() -&gt; Result&lt;()&gt; {</span></div><div class="token-line"><span class="token plain">        tracing_subscriber::fmt::init();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 以后用配置替换</span></div><div class="token-line"><span class="token plain">        let ca_cert = include_str!(&quot;../fixtures/ca.cert&quot;);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        let addr = &quot;127.0.0.1:9527&quot;;</span></div><div class="token-line"><span class="token plain">        // 连接服务器</span></div><div class="token-line"><span class="token plain">        let connector = TlsClientConnector::new(&quot;kvserver.acme.inc&quot;, None, Some(ca_cert))?;</span></div><div class="token-line"><span class="token plain">        let stream = TcpStream::connect(addr).await?;</span></div><div class="token-line"><span class="token plain">        let stream = connector.connect(stream).await?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        let mut client = ProstClientStream::new(stream);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 生成一个 HSET 命令</span></div><div class="token-line"><span class="token plain">        let cmd = CommandRequest::new_hset(&quot;table1&quot;, &quot;hello&quot;, &quot;world&quot;.to_string().into());</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 发送 HSET 命令</span></div><div class="token-line"><span class="token plain">        let data = client.execute(cmd).await?;</span></div><div class="token-line"><span class="token plain">        info!(&quot;Got response {:?}&quot;, data);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        Ok(())</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>和上一讲的代码项目相比，更新后的客户端和服务器代码，各自仅仅多了一行，就把 TcpStream 封装成了 TlsStream。这就是使用 trait 做面向接口编程的巨大威力，系统的各个组件可以来自不同的 crates，但只要其接口一致（或者我们创建 adapter 使其接口一致），就可以无缝插入。</p><p>完成之后，打开一个命令行窗口，运行：<code>RUST_LOG=info cargo run \--bin kvs \--quiet</code>。然后在另一个命令行窗口，运行：<code>RUST_LOG=info cargo run \--bin kvc \--quiet</code>。此时，服务器和客户端都收到了彼此的请求和响应，并且处理正常。</p><p>现在，我们的 KV server 已经具备足够的安全性了！以后，等我们使用配置文件，就可以根据配置文件读取证书和私钥。这样可以在部署的时候，才从 vault 中获取私钥，既保证灵活性，又能保证系统自身的安全。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/06#小结"><span class="icon icon-link"></span></a>小结</h2><p>网络安全是开发网络相关的应用程序中非常重要的一个环节。虽然 KV Server 这样的服务基本上会运行在云端受控的网络环境中，不会对 internet 提供服务，然而云端内部的安全性也不容忽视。你不希望数据在流动的过程中被篡改。</p><p>TLS 很好地解决了安全性的问题，可以保证整个传输过程中数据的机密性和完整性。如果使用客户端证书的话，还可以做一定程度的客户端合法性的验证。比如你可以在云端为所有有权访问 KV server 的客户端签发客户端证书，这样，只要客户端的私钥不泄露，就只有拥有证书的客户端才能访问 KV server。</p><p>不知道你现在有没有觉得，在 Rust 下使用 TLS 是非常方便的一件事情。并且，我们构建的 ProstServerStream / ProstClientStream，因为<strong>有足够好的抽象，可以在 TcpStream 和 TlsStream 之间游刃有余地切换</strong>。当你构建好相关的代码，只需要把 TcpStream 换成 TlsStream，KV server 就可以无缝切换到一个安全的网络协议栈。</p><h3 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/06#思考题"><span class="icon icon-link"></span></a>思考题</h3><ol><li>目前我们的 kvc / kvs 只做了单向的验证，如果服务器要验证客户端的证书，该怎么做？如果你没有头绪，可以再仔细看看测试 TLS 的代码，然后改动 kvc/kvs 使得双向验证也能通过吧。</li><li>除了 TLS，另外一个被广泛使用的处理应用层安全的协议是 <a target="_blank" rel="noopener noreferrer" href="https://noiseprotocol.org/">noise protocol<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。你可以阅读我的<a target="_blank" rel="noopener noreferrer" href="https://zhuanlan.zhihu.com/p/96944134">这篇文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>了解 noise protocol。Rust 下有 <a target="_blank" rel="noopener noreferrer" href="https://github.com/mcginty/snow">snow<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 这个很优秀的库处理 noise protocol。对于有余力的同学，你们可以看看它的文档，尝试着写段类似 <a target="_blank" rel="noopener noreferrer" href="http://tls.rs/">tls.rs<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的代码，让我们的 kvs / kvc 可以使用 noise protocol。</li></ol><p>欢迎在留言区分享你的思考，感谢你的收听，如果你觉得有收获，也欢迎你分享给身边的朋友，邀他一起讨论。</p><p>恭喜你完成了第37次打卡，我们的Rust学习之旅已经过一大半啦，曙光就在前方，坚持下去，我们下节课见～</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/陈天rust编程第一课/06.并发篇/06.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:25</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
