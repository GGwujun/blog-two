<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>41｜阶段实操（6）：构建一个简单的KV server-异步处理</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/陈天rust编程第一课/06.并发篇/10" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/陈天rust编程第一课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-two/陈天rust编程第一课/01.开篇词/01"><span>开篇词｜让Rust成为你的下一门主力语言</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/02.前置篇">02.前置篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/02.前置篇/01"><span>01｜内存：值放堆上还是放栈上，这是一个问题</span></a></li><li><a href="/blog-two/陈天rust编程第一课/02.前置篇/02"><span>02｜串讲：编程开发中，那些你需要掌握的基本概念</span></a></li><li><a href="/blog-two/陈天rust编程第一课/02.前置篇/03"><span>加餐｜这个专栏你可以怎么学，以及Rust是否值得学？</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇">03.基础篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/01"><span>03｜初窥门径：从你的第一个Rust程序开始！</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/02"><span>04｜get hands dirty：来写个实用的CLI小工具</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/03"><span>05｜get hands dirty：做一个图片服务器有多难？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/04"><span>06｜get hands dirty：SQL查询工具怎么一鱼多吃？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/05"><span>07｜所有权：值的生杀大权到底在谁手上？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/06"><span>08｜所有权：值的借用是如何工作的？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/07"><span>09｜所有权：一个值可以有多个所有者么？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/08"><span>10｜生命周期：你创建的值究竟能活多久？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/09"><span>11｜内存管理：从创建到消亡，值都经历了什么？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/10"><span>加餐｜愚昧之巅：你的Rust学习常见问题汇总</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/11"><span>12｜类型系统：Rust的类型系统有什么特点？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/12"><span>13｜类型系统：如何使用trait来定义接口？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/13"><span>14｜类型系统：有哪些必须掌握的trait？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/14"><span>15｜数据结构：这些浓眉大眼的结构竟然都是智能指针？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/15"><span>16｜数据结构：Vec、&amp;[T]、Box&lt;[T]&gt; ，你真的了解集合容器么？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/16"><span>17｜数据结构：软件系统核心部件哈希表，内存如何布局？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/17"><span>18｜错误处理：为什么Rust的错误处理与众不同？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/18"><span>19｜闭包：FnOnce、FnMut和Fn，为什么有这么多类型？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/19"><span>20｜4 Steps ：如何更好地阅读Rust源码？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/20"><span>21｜阶段实操（1）：构建一个简单的KV server-基本流程</span></a></li><li><a href="/blog-two/陈天rust编程第一课/03.基础篇/21"><span>22｜阶段实操（2）：构建一个简单的KV server-基本流程</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/04.期中周">04.期中周</a><ul><li><a href="/blog-two/陈天rust编程第一课/04.期中周/01"><span>加餐｜期中测试：来写一个简单的grep命令行</span></a></li><li><a href="/blog-two/陈天rust编程第一课/04.期中周/02"><span>加餐｜期中测试：参考实现讲解</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇">05.进阶篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/01"><span>23｜类型系统：如何在实战中使用泛型编程？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/02"><span>24｜类型系统：如何在实战中使用trait object？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/03"><span>25｜类型系统：如何围绕trait来设计和架构系统？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/04"><span>加餐｜Rust2021版次问世了！</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/05"><span>26｜阶段实操（3）：构建一个简单的KV server-高级trait技巧</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/06"><span>27｜生态系统：有哪些常有的Rust库可以为我所用？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/07"><span>28｜网络开发（上）：如何使用Rust处理网络请求？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/08"><span>29｜网络开发（下）：如何使用Rust处理网络请求？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/09"><span>30｜Unsafe Rust：如何用C++的方式打开Rust？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/10"><span>31｜FFI：Rust如何和你的语言架起沟通桥梁？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/05.进阶篇/11"><span>32｜实操项目：使用PyO3开发Python3模块</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课/06.并发篇">06.并发篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/01"><span>33｜并发处理（上）：从atomics到Channel，Rust都提供了什么工具？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/02"><span>34｜并发处理（下）：从atomics到Channel，Rust都提供了什么工具？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/03"><span>35｜实操项目：如何实现一个基本的MPSC channel？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/04"><span>用户故事｜绝望之谷：改变从学习开始</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/05"><span>36｜阶段实操（4）：构建一个简单的KV server-网络处理</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/06"><span>37｜阶段实操（5）：构建一个简单的KV server-网络安全</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/07"><span>38｜异步处理：Future是什么？它和async/await是什么关系？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/08"><span>39｜异步处理：async/await内部是怎么实现的？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/09"><span>40｜异步处理：如何处理异步IO？</span></a></li><li><a aria-current="page" class="active" href="/blog-two/陈天rust编程第一课/06.并发篇/10"><span>41｜阶段实操（6）：构建一个简单的KV server-异步处理</span></a></li><li><a href="/blog-two/陈天rust编程第一课/06.并发篇/11"><span>42｜阶段实操（7）：构建一个简单的KV server-如何做大的重构？</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇">07.实战篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/01"><span>43｜生产环境：真实世界下的一个Rust项目包含哪些要素？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/02"><span>44｜数据处理：应用程序和数据如何打交道？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/03"><span>45｜阶段实操（8）：构建一个简单的KV server-配置/测试/监控/CI/CD</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/04"><span>46｜软件架构：如何用Rust架构复杂系统？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/05"><span>大咖助场｜开悟之坡（上）：Rust的现状、机遇与挑战</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/06"><span>大咖助场｜开悟之坡（下）：Rust的现状、机遇与挑战</span></a></li><li><a href="/blog-two/陈天rust编程第一课/07.实战篇/07"><span>用户故事｜语言不仅是工具，还是思维方式</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/08.高级篇">08.高级篇</a><ul><li><a href="/blog-two/陈天rust编程第一课/08.高级篇/01"><span>加餐｜代码即数据：为什么我们需要宏编程能力？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/08.高级篇/02"><span>加餐｜宏编程（上）：用最“笨”的方式撰写宏</span></a></li><li><a href="/blog-two/陈天rust编程第一课/08.高级篇/03"><span>加餐｜宏编程（下）：用 syn/quote 优雅地构建宏</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/09.结束语">09.结束语</a><ul><li><a href="/blog-two/陈天rust编程第一课/09.结束语/01"><span>结束语｜永续之原：Rust学习，如何持续精进？</span></a></li><li><a href="/blog-two/陈天rust编程第一课/09.结束语/02"><span>期末测试｜来赴一场满分之约！</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊">10.学习锦囊</a><ul><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊/01"><span>特别策划｜学习锦囊（一）：听听课代表们怎么说</span></a></li><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊/02"><span>特别策划｜学习锦囊（二）：听听课代表们怎么说</span></a></li><li><a href="/blog-two/陈天rust编程第一课/10.学习锦囊/03"><span>特别策划｜学习锦囊（三）：听听课代表们怎么说</span></a></li></ul></li><li><a href="/blog-two/陈天rust编程第一课/summary">陈天rust编程第一课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="今天做点什么？" data-depth="2"><a href="/blog-two/陈天rust编程第一课/06.并发篇/10#今天做点什么"><span>今天做点什么？</span></a></li><li title="创建 ProstStream" data-depth="2"><a href="/blog-two/陈天rust编程第一课/06.并发篇/10#创建-proststream"><span>创建 ProstStream</span></a></li><li title="Stream 的实现" data-depth="3"><a href="/blog-two/陈天rust编程第一课/06.并发篇/10#stream-的实现"><span>Stream 的实现</span></a></li><li title="Sink 的实现" data-depth="3"><a href="/blog-two/陈天rust编程第一课/06.并发篇/10#sink-的实现"><span>Sink 的实现</span></a></li><li title="ProstStream 的创建" data-depth="3"><a href="/blog-two/陈天rust编程第一课/06.并发篇/10#proststream-的创建"><span>ProstStream 的创建</span></a></li><li title="测试！" data-depth="3"><a href="/blog-two/陈天rust编程第一课/06.并发篇/10#测试"><span>测试！</span></a></li><li title="使用 ProstStream" data-depth="2"><a href="/blog-two/陈天rust编程第一课/06.并发篇/10#使用-proststream"><span>使用 ProstStream</span></a></li><li title="小结" data-depth="2"><a href="/blog-two/陈天rust编程第一课/06.并发篇/10#小结"><span>小结</span></a></li><li title="思考题" data-depth="3"><a href="/blog-two/陈天rust编程第一课/06.并发篇/10#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="41阶段实操6构建一个简单的kv-server-异步处理"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/10#41阶段实操6构建一个简单的kv-server-异步处理"><span class="icon icon-link"></span></a>41｜阶段实操（6）：构建一个简单的KV server-异步处理</h1><p>你好，我是陈天。</p><p>到目前为止，我们已经一起完成了一个相对完善的 KV server。还记得是怎么一步步构建这个服务的么？</p><p>基础篇学完，我们搭好了KV server 的基础功能（<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/425001">21讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/425005">22讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），构造了客户端和服务器间交互的 protobuf，然后设计了 CommandService trait 和 Storage trait，分别处理客户端命令和存储。</p><p>在进阶篇掌握了trait的实战使用技巧之后，（<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/429666">26讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）我们进一步构造了 Service 数据结构，接收 CommandRequest，根据其类型调用相应的 CommandService 处理，并做合适的事件通知，最后返回 CommandResponse。</p><p><strong>但所有这一切都发生在同步的世界</strong>：不管数据是怎么获得的，数据已经在那里，我们需要做的就是把一种数据类型转换成另一种数据类型的运算而已。</p><p>之后我们涉足网络的世界。（<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/446948">36讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）为 KV server 构造了自己的 frame：一个包含长度和是否压缩的信息的 4 字节的头，以及实际的 payload；还设计了一个 FrameCoder 来对 frame 进行封包和拆包，这为接下来构造网络接口打下了坚实的基础。考虑到网络安全，（<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/446949">37讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）我们提供了 TLS 的支持。</p><p>在构建 ProstStream 的时候，我们开始处理异步：ProstStream 内部的 stream 需要支持 AsyncRead + AsyncWrite，这可以让 ProstStream 适配包括 TcpStream 和 TlsStream 在内的一切实现了 AsyncRead 和 AsyncWrite 的异步网络接口。</p><p>至此，我们打通了从远端得到一个命令，历经 TCP、TLS，然后被 FrameCoder 解出来一个 CommandRequest，交由 Service 来处理的过程。<strong>把同步世界和异步世界连接起来的，就是 ProstServerStream 这个结构</strong>。</p><p>这个从收包处理到处理完成后发包的完整流程和系统结构，可以看下图：</p><p><img src="https://static001.geekbang.org/resource/image/82/2c/82da823b4eb16935fdeyy727e3b3262c.jpg?wh=1920x1145" alt="图片"/></p><h2 id="今天做点什么"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/10#今天做点什么"><span class="icon icon-link"></span></a>今天做点什么？</h2><p>虽然我们很早就已经撰写了不少异步或者和异步有关的代码。但是最能体现 Rust 异步本质的 poll()、poll_read()、poll_next() 这样的处理函数还没有怎么写过，之前测试异步的 read_frame() 写过一个 DummyStream，算是体验了一下底层的异步处理函数的复杂接口。不过在 DummyStream 里，我们并没有做任何复杂的动作：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct DummyStream {</span></div><div class="token-line"><span class="token plain">        buf: BytesMut,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl AsyncRead for DummyStream {</span></div><div class="token-line"><span class="token plain">        fn poll_read(</span></div><div class="token-line"><span class="token plain">            self: std::pin::Pin&lt;&amp;mut Self&gt;,</span></div><div class="token-line"><span class="token plain">            _cx: &amp;mut std::task::Context&lt;&#x27;_&gt;,</span></div><div class="token-line"><span class="token plain">            buf: &amp;mut tokio::io::ReadBuf&lt;&#x27;_&gt;,</span></div><div class="token-line"><span class="token plain">        ) -&gt; std::task::Poll&lt;std::io::Result&lt;()&gt;&gt; {</span></div><div class="token-line"><span class="token plain">            // 看看 ReadBuf 需要多大的数据</span></div><div class="token-line"><span class="token plain">            let len = buf.capacity();</span></div><div class="token-line"><span class="token plain">            // split 出这么大的数据</span></div><div class="token-line"><span class="token plain">            let data = self.get_mut().buf.split_to(len);</span></div><div class="token-line"><span class="token plain">            // 拷贝给 ReadBuf</span></div><div class="token-line"><span class="token plain">            buf.put_slice(&amp;data);</span></div><div class="token-line"><span class="token plain">            // 直接完工</span></div><div class="token-line"><span class="token plain">            std::task::Poll::Ready(Ok(()))</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上一讲我们学习了异步 IO，这堂课我们就学以致用，对现有的代码做些重构，让核心的 ProstStream 更符合 Rust 的异步 IO 接口逻辑。具体要做点什么呢？</p><p>看之前写的 ProstServerStream 的 process() 函数，比较一下它和 async_prost 库的 AsyncProst 的调用逻辑：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// process() 函数的内在逻辑</span></div><div class="token-line"><span class="token plain">    while let Ok(cmd) = self.recv().await {</span></div><div class="token-line"><span class="token plain">        info!(&quot;Got a new command: {:?}&quot;, cmd);</span></div><div class="token-line"><span class="token plain">        let res = self.service.execute(cmd);</span></div><div class="token-line"><span class="token plain">        self.send(res).await?;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // async_prost 库的 AsyncProst 的调用逻辑</span></div><div class="token-line"><span class="token plain">    while let Some(Ok(cmd)) = stream.next().await {</span></div><div class="token-line"><span class="token plain">        info!(&quot;Got a new command: {:?}&quot;, cmd);</span></div><div class="token-line"><span class="token plain">        let res = svc.execute(cmd);</span></div><div class="token-line"><span class="token plain">        stream.send(res).await.unwrap();</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到由于 AsyncProst 实现了 <a target="_blank" rel="noopener noreferrer" href="https://docs.rs/futures/0.3.17/futures/stream/trait.Stream.html">Stream<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 和 <a target="_blank" rel="noopener noreferrer" href="https://docs.rs/futures/0.3.17/futures/sink/trait.Sink.html">Sink<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，能更加自然地调用 <a target="_blank" rel="noopener noreferrer" href="https://docs.rs/futures/0.3.17/futures/stream/trait.StreamExt.html">StreamExt<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> trait 的 next() 方法和 <a target="_blank" rel="noopener noreferrer" href="https://docs.rs/futures/0.3.17/futures/sink/trait.SinkExt.html">SinkExt<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> trait 的 send() 方法，来处理数据的收发，而 ProstServerStream 则自己额外实现了函数 recv() 和 send()。</p><p>虽然从代码对比的角度，这两段代码几乎一样，但未来的可扩展性，和整个异步生态的融洽性上，AsyncProst 还是更胜一筹。</p><p>所以今天我们就构造一个 ProstStream 结构，让它实现 Stream 和 Sink 这两个 trait，然后让 ProstServerStream 和 ProstClientStream 使用它。</p><h2 id="创建-proststream"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/10#创建-proststream"><span class="icon icon-link"></span></a>创建 ProstStream</h2><p>在开始重构之前，先来简单复习一下 Stream trait 和 Sink trait：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 可以类比 Iterator</span></div><div class="token-line"><span class="token plain">    pub trait Stream {</span></div><div class="token-line"><span class="token plain">        // 从 Stream 中读取到的数据类型</span></div><div class="token-line"><span class="token plain">        type Item;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// 从 stream 里读取下一个数据</span></div><div class="token-line"><span class="token plain">        fn poll_next(</span></div><div class="token-line"><span class="token plain">    		self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;&#x27;_&gt;</span></div><div class="token-line"><span class="token plain">        ) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt;;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // </span></div><div class="token-line"><span class="token plain">    pub trait Sink&lt;Item&gt; {</span></div><div class="token-line"><span class="token plain">        type Error;</span></div><div class="token-line"><span class="token plain">        fn poll_ready(</span></div><div class="token-line"><span class="token plain">            self: Pin&lt;&amp;mut Self&gt;, </span></div><div class="token-line"><span class="token plain">            cx: &amp;mut Context&lt;&#x27;_&gt;</span></div><div class="token-line"><span class="token plain">        ) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt;;</span></div><div class="token-line"><span class="token plain">        fn start_send(self: Pin&lt;&amp;mut Self&gt;, item: Item) -&gt; Result&lt;(), Self::Error&gt;;</span></div><div class="token-line"><span class="token plain">        fn poll_flush(</span></div><div class="token-line"><span class="token plain">            self: Pin&lt;&amp;mut Self&gt;, </span></div><div class="token-line"><span class="token plain">            cx: &amp;mut Context&lt;&#x27;_&gt;</span></div><div class="token-line"><span class="token plain">        ) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt;;</span></div><div class="token-line"><span class="token plain">        fn poll_close(</span></div><div class="token-line"><span class="token plain">            self: Pin&lt;&amp;mut Self&gt;, </span></div><div class="token-line"><span class="token plain">            cx: &amp;mut Context&lt;&#x27;_&gt;</span></div><div class="token-line"><span class="token plain">        ) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt;;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>那么 ProstStream 具体需要包含什么类型呢？</p><p>因为它的主要职责是从底下的 stream 中读取或者发送数据，所以一个支持 AsyncRead 和 AsyncWrite 的泛型参数 S 是必然需要的。</p><p>另外 Stream trait 和 Sink 都各需要一个 Item 类型，对于我们的系统来说，Item 是 CommandRequest 或者 CommandResponse，但为了灵活性，我们可以用 In 和 Out 这两个泛型参数来表示。</p><p>当然，在处理 Stream 和 Sink 时还需要 read buffer 和 write buffer。</p><p>综上所述，我们的 ProstStream 结构看上去是这样子的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pub struct ProstStream&lt;S, In, Out&gt; {</span></div><div class="token-line"><span class="token plain">        // innner stream</span></div><div class="token-line"><span class="token plain">        stream: S,</span></div><div class="token-line"><span class="token plain">        // 写缓存</span></div><div class="token-line"><span class="token plain">        wbuf: BytesMut,</span></div><div class="token-line"><span class="token plain">        // 读缓存</span></div><div class="token-line"><span class="token plain">        rbuf: BytesMut,</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>然而，Rust 不允许数据结构有超出需要的泛型参数。怎么办？别急，可以用 <a target="_blank" rel="noopener noreferrer" href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html">PhantomData<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，之前讲过它是一个零字节大小的占位符，可以让我们的数据结构携带未使用的泛型参数。</p><p>好，现在有足够的思路了，我们创建 src/network/stream.rs，添加如下代码（记得在 src/network/mod.rs 添加对 <a target="_blank" rel="noopener noreferrer" href="http://stream.rs/">stream.rs<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的引用）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">use bytes::BytesMut;</span></div><div class="token-line"><span class="token plain">    use futures::{Sink, Stream};</span></div><div class="token-line"><span class="token plain">    use std::{</span></div><div class="token-line"><span class="token plain">        marker::PhantomData,</span></div><div class="token-line"><span class="token plain">        pin::Pin,</span></div><div class="token-line"><span class="token plain">        task::{Context, Poll},</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    use tokio::io::{AsyncRead, AsyncWrite};</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    use crate::{FrameCoder, KvError};</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// 处理 KV server prost frame 的 stream</span></div><div class="token-line"><span class="token plain">    pub struct ProstStream&lt;S, In, Out&gt; where {</span></div><div class="token-line"><span class="token plain">        // innner stream</span></div><div class="token-line"><span class="token plain">        stream: S,</span></div><div class="token-line"><span class="token plain">        // 写缓存</span></div><div class="token-line"><span class="token plain">        wbuf: BytesMut,</span></div><div class="token-line"><span class="token plain">        // 读缓存</span></div><div class="token-line"><span class="token plain">        rbuf: BytesMut,</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 类型占位符</span></div><div class="token-line"><span class="token plain">        _in: PhantomData&lt;In&gt;,</span></div><div class="token-line"><span class="token plain">        _out: PhantomData&lt;Out&gt;,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl&lt;S, In, Out&gt; Stream for ProstStream&lt;S, In, Out&gt;</span></div><div class="token-line"><span class="token plain">    where</span></div><div class="token-line"><span class="token plain">        S: AsyncRead + AsyncWrite + Unpin + Send,</span></div><div class="token-line"><span class="token plain">        In: Unpin + Send + FrameCoder,</span></div><div class="token-line"><span class="token plain">        Out: Unpin + Send,</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        /// 当调用 next() 时，得到 Result&lt;In, KvError&gt;</span></div><div class="token-line"><span class="token plain">        type Item = Result&lt;In, KvError&gt;;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        fn poll_next(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;&#x27;_&gt;) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt; {</span></div><div class="token-line"><span class="token plain">            todo!()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// 当调用 send() 时，会把 Out 发出去</span></div><div class="token-line"><span class="token plain">    impl&lt;S, In, Out&gt; Sink&lt;Out&gt; for ProstStream&lt;S, In, Out&gt;</span></div><div class="token-line"><span class="token plain">    where</span></div><div class="token-line"><span class="token plain">        S: AsyncRead + AsyncWrite + Unpin,</span></div><div class="token-line"><span class="token plain">        In: Unpin + Send,</span></div><div class="token-line"><span class="token plain">        Out: Unpin + Send + FrameCoder,</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        /// 如果发送出错，会返回 KvError</span></div><div class="token-line"><span class="token plain">        type Error = KvError;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        fn poll_ready(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;&#x27;_&gt;) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt; {</span></div><div class="token-line"><span class="token plain">            todo!()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        fn start_send(self: Pin&lt;&amp;mut Self&gt;, item: Out) -&gt; Result&lt;(), Self::Error&gt; {</span></div><div class="token-line"><span class="token plain">            todo!()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        fn poll_flush(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;&#x27;_&gt;) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt; {</span></div><div class="token-line"><span class="token plain">            todo!()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        fn poll_close(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;&#x27;_&gt;) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt; {</span></div><div class="token-line"><span class="token plain">            todo!()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这段代码包含了为 ProstStream 实现 Stream 和 Sink 的骨架代码。接下来我们就一个个处理。注意对于 In 和 Out 参数，还为其约束了 FrameCoder，这样，在实现里我们可以使用 decode_frame() 和 encode_frame() 来获取一个 Item 或者 encode 一个 Item。</p><h3 id="stream-的实现"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/10#stream-的实现"><span class="icon icon-link"></span></a>Stream 的实现</h3><p>先来实现 Stream 的 poll_next() 方法。</p><p>poll_next() 可以直接调用我们之前写好的 read_frame()，然后再用 decode_frame() 来解包：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fn poll_next(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;&#x27;_&gt;) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt; {</span></div><div class="token-line"><span class="token plain">        // 上一次调用结束后 rbuf 应该为空</span></div><div class="token-line"><span class="token plain">        assert!(self.rbuf.len() == 0);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 从 rbuf 中分离出 rest（摆脱对 self 的引用）</span></div><div class="token-line"><span class="token plain">        let mut rest = self.rbuf.split_off(0);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 使用 read_frame 来获取数据</span></div><div class="token-line"><span class="token plain">        let fut = read_frame(&amp;mut self.stream, &amp;mut rest);</span></div><div class="token-line"><span class="token plain">        ready!(Box::pin(fut).poll_unpin(cx))?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 拿到一个 frame 的数据，把 buffer 合并回去</span></div><div class="token-line"><span class="token plain">        self.rbuf.unsplit(rest);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 调用 decode_frame 获取解包后的数据</span></div><div class="token-line"><span class="token plain">        Poll::Ready(Some(In::decode_frame(&amp;mut self.rbuf)))</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个不难理解，但中间这段需要稍微解释一下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 使用 read_frame 来获取数据</span></div><div class="token-line"><span class="token plain">    let fut = read_frame(&amp;mut self.stream, &amp;mut rest);</span></div><div class="token-line"><span class="token plain">    ready!(Box::pin(fut).poll_unpin(cx))?;</span></div></pre></div><p>因为 poll_xxx() 方法已经是 async/await 的底层 API 实现，所以我们在 poll_xxx() 方法中，是不能直接使用异步函数的，需要把它看作一个 future，然后调用 future 的 poll 函数。因为 future 是一个 trait，所以需要 Box 将其处理成一个在堆上的 trait object，这样就可以调用 FutureExt 的 <a target="_blank" rel="noopener noreferrer" href="https://docs.rs/futures/0.3.17/futures/future/trait.FutureExt.html#method.poll_unpin">poll_unpin()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 方法了。Box::pin 会生成 Pin&lt;Box&gt;。</p><p>至于 ready! 宏，它会在 Pending 时直接 return Pending，而在 Ready 时，返回 Ready 的值：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">macro_rules! ready {</span></div><div class="token-line"><span class="token plain">        ($e:expr $(,)?) =&gt; {</span></div><div class="token-line"><span class="token plain">            match $e {</span></div><div class="token-line"><span class="token plain">                $crate::task::Poll::Ready(t) =&gt; t,</span></div><div class="token-line"><span class="token plain">                $crate::task::Poll::Pending =&gt; return $crate::task::Poll::Pending,</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        };</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>Stream 我们就实现好了，是不是也没有那么复杂？</p><h3 id="sink-的实现"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/10#sink-的实现"><span class="icon icon-link"></span></a>Sink 的实现</h3><p>再写Sink，看上去要实现好几个方法，其实也不算复杂。四个方法 poll_ready、start_send()、poll_flush 和 poll_close 我们再回顾一下。</p><p><a target="_blank" rel="noopener noreferrer" href="https://docs.rs/futures/0.3.17/futures/prelude/trait.Sink.html#tymethod.poll_ready">poll_ready()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 是做背压的，你可以根据负载来决定要不要返回 Poll::Ready。对于我们的网络层来说，可以先不关心背压，依靠操作系统的 TCP 协议栈提供背压处理即可，所以这里直接返回 Poll::Ready(Ok(()))，也就是说，上层想写数据，可以随时写。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fn poll_ready(self: Pin&lt;&amp;mut Self&gt;, _cx: &amp;mut Context&lt;&#x27;_&gt;) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt; {</span></div><div class="token-line"><span class="token plain">        Poll::Ready(Ok(()))</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>当 poll_ready() 返回 Ready 后，Sink 就走到 <a target="_blank" rel="noopener noreferrer" href="https://docs.rs/futures/0.3.17/futures/prelude/trait.Sink.html#tymethod.start_send">start_send()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。我们在 start_send() 里就把必要的数据准备好。这里把 item 封包成字节流，存入 wbuf 中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fn start_send(self: Pin&lt;&amp;mut Self&gt;, item: Out) -&gt; Result&lt;(), Self::Error&gt; {</span></div><div class="token-line"><span class="token plain">        let this = self.get_mut();</span></div><div class="token-line"><span class="token plain">        item.encode_frame(&amp;mut this.wbuf)?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        Ok(())</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>然后在 <a target="_blank" rel="noopener noreferrer" href="https://docs.rs/futures/0.3.17/futures/prelude/trait.Sink.html#tymethod.poll_flush">poll_flush()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中，我们开始写数据。这里需要记录当前写到哪里，所以需要在 ProstStream 里加一个字段 written，记录写入了多少字节：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/// 处理 KV server prost frame 的 stream</span></div><div class="token-line"><span class="token plain">    pub struct ProstStream&lt;S, In, Out&gt; {</span></div><div class="token-line"><span class="token plain">        // innner stream</span></div><div class="token-line"><span class="token plain">        stream: S,</span></div><div class="token-line"><span class="token plain">        // 写缓存</span></div><div class="token-line"><span class="token plain">        wbuf: BytesMut,</span></div><div class="token-line"><span class="token plain">        // 写入了多少字节</span></div><div class="token-line"><span class="token plain">        written: usize,</span></div><div class="token-line"><span class="token plain">        // 读缓存</span></div><div class="token-line"><span class="token plain">        rbuf: BytesMut,</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 类型占位符</span></div><div class="token-line"><span class="token plain">        _in: PhantomData&lt;In&gt;,</span></div><div class="token-line"><span class="token plain">        _out: PhantomData&lt;Out&gt;,</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>有了这个 written 字段， 就可以循环写入：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fn poll_flush(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;&#x27;_&gt;) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt; {</span></div><div class="token-line"><span class="token plain">        let this = self.get_mut();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 循环写入 stream 中</span></div><div class="token-line"><span class="token plain">        while this.written != this.wbuf.len() {</span></div><div class="token-line"><span class="token plain">            let n = ready!(Pin::new(&amp;mut this.stream).poll_write(cx, &amp;this.wbuf[this.written..]))?;</span></div><div class="token-line"><span class="token plain">            this.written += n;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 清除 wbuf</span></div><div class="token-line"><span class="token plain">        this.wbuf.clear();</span></div><div class="token-line"><span class="token plain">        this.written = 0;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 调用 stream 的 poll_flush 确保写入</span></div><div class="token-line"><span class="token plain">        ready!(Pin::new(&amp;mut this.stream).poll_flush(cx)?);</span></div><div class="token-line"><span class="token plain">        Poll::Ready(Ok(()))</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>最后是 <a target="_blank" rel="noopener noreferrer" href="https://docs.rs/futures/0.3.17/futures/prelude/trait.Sink.html#tymethod.poll_close">poll_close()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，我们只需要调用 stream 的 flush 和 shutdown 方法，确保数据写完并且 stream 关闭：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fn poll_close(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;&#x27;_&gt;) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt; {</span></div><div class="token-line"><span class="token plain">        // 调用 stream 的 poll_flush 确保写入</span></div><div class="token-line"><span class="token plain">        ready!(self.as_mut().poll_flush(cx))?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 调用 stream 的 poll_shutdown 确保 stream 关闭</span></div><div class="token-line"><span class="token plain">        ready!(Pin::new(&amp;mut self.stream).poll_shutdown(cx))?;</span></div><div class="token-line"><span class="token plain">        Poll::Ready(Ok(()))</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="proststream-的创建"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/10#proststream-的创建"><span class="icon icon-link"></span></a>ProstStream 的创建</h3><p>我们的 ProstStream 目前已经实现了 Stream 和 Sink，为了方便使用，再构建一些辅助方法，比如 new()：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">impl&lt;S, In, Out&gt; ProstStream&lt;S, In, Out&gt;</span></div><div class="token-line"><span class="token plain">    where</span></div><div class="token-line"><span class="token plain">        S: AsyncRead + AsyncWrite + Send + Unpin,</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        /// 创建一个 ProstStream</span></div><div class="token-line"><span class="token plain">        pub fn new(stream: S) -&gt; Self {</span></div><div class="token-line"><span class="token plain">            Self {</span></div><div class="token-line"><span class="token plain">                stream,</span></div><div class="token-line"><span class="token plain">                written: 0,</span></div><div class="token-line"><span class="token plain">                wbuf: BytesMut::new(),</span></div><div class="token-line"><span class="token plain">                rbuf: BytesMut::new(),</span></div><div class="token-line"><span class="token plain">                _in: PhantomData::default(),</span></div><div class="token-line"><span class="token plain">                _out: PhantomData::default(),</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 一般来说，如果我们的 Stream 是 Unpin，最好实现一下</span></div><div class="token-line"><span class="token plain">    impl&lt;S, Req, Res&gt; Unpin for ProstStream&lt;S, Req, Res&gt; where S: Unpin {}</span></div></pre></div><p>此外，我们还为其实现 Unpin trait，这会给别人在使用你的代码时带来很多方便。<strong>一般来说，为异步操作而创建的数据结构，如果使用了泛型参数，那么只要内部没有自引用数据，就应该实现 Unpin</strong>。</p><h3 id="测试"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/10#测试"><span class="icon icon-link"></span></a>测试！</h3><p>又到了重要的测试环节。我们需要写点测试来确保 ProstStream 能正常工作。因为之前在 src/network/<a target="_blank" rel="noopener noreferrer" href="http://frame.rs/">frame.rs<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中写了个 DummyStream，实现了 AsyncRead，我们只需要扩展它，让它再实现 AsyncWrite。</p><p>为了让它可以被复用，我们将其从 <a target="_blank" rel="noopener noreferrer" href="http://frame.rs/">frame.rs<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中移出来，放在 src/network/mod.rs 中，并修改成下面的样子（记得在 <a target="_blank" rel="noopener noreferrer" href="http://frame.rs/">frame.rs<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的测试里 use 新的 DummyStream）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#[cfg(test)]</span></div><div class="token-line"><span class="token plain">    pub mod utils {</span></div><div class="token-line"><span class="token plain">    		use bytes::{BufMut, BytesMut};</span></div><div class="token-line"><span class="token plain">        use std::task::Poll;</span></div><div class="token-line"><span class="token plain">        use tokio::io::{AsyncRead, AsyncWrite};</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        pub struct DummyStream {</span></div><div class="token-line"><span class="token plain">            pub buf: BytesMut,</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        impl AsyncRead for DummyStream {</span></div><div class="token-line"><span class="token plain">            fn poll_read(</span></div><div class="token-line"><span class="token plain">                self: std::pin::Pin&lt;&amp;mut Self&gt;,</span></div><div class="token-line"><span class="token plain">                _cx: &amp;mut std::task::Context&lt;&#x27;_&gt;,</span></div><div class="token-line"><span class="token plain">                buf: &amp;mut tokio::io::ReadBuf&lt;&#x27;_&gt;,</span></div><div class="token-line"><span class="token plain">            ) -&gt; Poll&lt;std::io::Result&lt;()&gt;&gt; {</span></div><div class="token-line"><span class="token plain">                let len = buf.capacity();</span></div><div class="token-line"><span class="token plain">                let data = self.get_mut().buf.split_to(len);</span></div><div class="token-line"><span class="token plain">                buf.put_slice(&amp;data);</span></div><div class="token-line"><span class="token plain">                Poll::Ready(Ok(()))</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        impl AsyncWrite for DummyStream {</span></div><div class="token-line"><span class="token plain">            fn poll_write(</span></div><div class="token-line"><span class="token plain">                self: std::pin::Pin&lt;&amp;mut Self&gt;,</span></div><div class="token-line"><span class="token plain">                _cx: &amp;mut std::task::Context&lt;&#x27;_&gt;,</span></div><div class="token-line"><span class="token plain">                buf: &amp;[u8],</span></div><div class="token-line"><span class="token plain">            ) -&gt; Poll&lt;Result&lt;usize, std::io::Error&gt;&gt; {</span></div><div class="token-line"><span class="token plain">                self.get_mut().buf.put_slice(buf);</span></div><div class="token-line"><span class="token plain">                Poll::Ready(Ok(buf.len()))</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            fn poll_flush(</span></div><div class="token-line"><span class="token plain">                self: std::pin::Pin&lt;&amp;mut Self&gt;,</span></div><div class="token-line"><span class="token plain">                _cx: &amp;mut std::task::Context&lt;&#x27;_&gt;,</span></div><div class="token-line"><span class="token plain">            ) -&gt; Poll&lt;Result&lt;(), std::io::Error&gt;&gt; {</span></div><div class="token-line"><span class="token plain">                Poll::Ready(Ok(()))</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            fn poll_shutdown(</span></div><div class="token-line"><span class="token plain">                self: std::pin::Pin&lt;&amp;mut Self&gt;,</span></div><div class="token-line"><span class="token plain">                _cx: &amp;mut std::task::Context&lt;&#x27;_&gt;,</span></div><div class="token-line"><span class="token plain">            ) -&gt; Poll&lt;Result&lt;(), std::io::Error&gt;&gt; {</span></div><div class="token-line"><span class="token plain">                Poll::Ready(Ok(()))</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>好，这样我们就可以在 src/network/stream.rs 下写个测试了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#[cfg(test)]</span></div><div class="token-line"><span class="token plain">    mod tests {</span></div><div class="token-line"><span class="token plain">        use super::*;</span></div><div class="token-line"><span class="token plain">        use crate::{utils::DummyStream, CommandRequest};</span></div><div class="token-line"><span class="token plain">        use anyhow::Result;</span></div><div class="token-line"><span class="token plain">        use futures::prelude::*;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        #[tokio::test]</span></div><div class="token-line"><span class="token plain">        async fn prost_stream_should_work() -&gt; Result&lt;()&gt; {</span></div><div class="token-line"><span class="token plain">            let buf = BytesMut::new();</span></div><div class="token-line"><span class="token plain">            let stream = DummyStream { buf };</span></div><div class="token-line"><span class="token plain">            let mut stream = ProstStream::&lt;_, CommandRequest, CommandRequest&gt;::new(stream);</span></div><div class="token-line"><span class="token plain">            let cmd = CommandRequest::new_hdel(&quot;t1&quot;, &quot;k1&quot;);</span></div><div class="token-line"><span class="token plain">            stream.send(cmd.clone()).await?;</span></div><div class="token-line"><span class="token plain">            if let Some(Ok(s)) = stream.next().await {</span></div><div class="token-line"><span class="token plain">                assert_eq!(s, cmd);</span></div><div class="token-line"><span class="token plain">            } else {</span></div><div class="token-line"><span class="token plain">                assert!(false);</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            Ok(())</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>运行 <code>cargo test</code> ，一切测试通过！（如果你编译错误，可能缺少 use 的问题，可以自行修改，或者参考 GitHub 上的完整代码）。</p><h2 id="使用-proststream"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/10#使用-proststream"><span class="icon icon-link"></span></a>使用 ProstStream</h2><p>接下来，我们可以让 ProstServerStream 和 ProstClientStream 使用新定义的 ProstStream 了，你可以参考下面的对比，看看二者的区别：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 旧的接口</span></div><div class="token-line"><span class="token plain">    // pub struct ProstServerStream&lt;S&gt; {</span></div><div class="token-line"><span class="token plain">    //     inner: S,</span></div><div class="token-line"><span class="token plain">    //     service: Service,</span></div><div class="token-line"><span class="token plain">    // }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    pub struct ProstServerStream&lt;S&gt; {</span></div><div class="token-line"><span class="token plain">        inner: ProstStream&lt;S, CommandRequest, CommandResponse&gt;,</span></div><div class="token-line"><span class="token plain">        service: Service,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 旧的接口</span></div><div class="token-line"><span class="token plain">    // pub struct ProstClientStream&lt;S&gt; {</span></div><div class="token-line"><span class="token plain">    //     inner: S,</span></div><div class="token-line"><span class="token plain">    // }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    pub struct ProstClientStream&lt;S&gt; {</span></div><div class="token-line"><span class="token plain">        inner: ProstStream&lt;S, CommandResponse, CommandRequest&gt;,</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>然后删除 send() / recv() 函数，并修改 process() / execute() 函数使其使用 next() 方法和 send() 方法。主要的改动如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/// 处理服务器端的某个 accept 下来的 socket 的读写</span></div><div class="token-line"><span class="token plain">    pub struct ProstServerStream&lt;S&gt; {</span></div><div class="token-line"><span class="token plain">        inner: ProstStream&lt;S, CommandRequest, CommandResponse&gt;,</span></div><div class="token-line"><span class="token plain">        service: Service,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /// 处理客户端 socket 的读写</span></div><div class="token-line"><span class="token plain">    pub struct ProstClientStream&lt;S&gt; {</span></div><div class="token-line"><span class="token plain">        inner: ProstStream&lt;S, CommandResponse, CommandRequest&gt;,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl&lt;S&gt; ProstServerStream&lt;S&gt;</span></div><div class="token-line"><span class="token plain">    where</span></div><div class="token-line"><span class="token plain">        S: AsyncRead + AsyncWrite + Unpin + Send,</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        pub fn new(stream: S, service: Service) -&gt; Self {</span></div><div class="token-line"><span class="token plain">            Self {</span></div><div class="token-line"><span class="token plain">                inner: ProstStream::new(stream),</span></div><div class="token-line"><span class="token plain">                service,</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        pub async fn process(mut self) -&gt; Result&lt;(), KvError&gt; {</span></div><div class="token-line"><span class="token plain">            let stream = &amp;mut self.inner;</span></div><div class="token-line"><span class="token plain">            while let Some(Ok(cmd)) = stream.next().await {</span></div><div class="token-line"><span class="token plain">                info!(&quot;Got a new command: {:?}&quot;, cmd);</span></div><div class="token-line"><span class="token plain">                let res = self.service.execute(cmd);</span></div><div class="token-line"><span class="token plain">                stream.send(res).await.unwrap();</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            Ok(())</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    impl&lt;S&gt; ProstClientStream&lt;S&gt;</span></div><div class="token-line"><span class="token plain">    where</span></div><div class="token-line"><span class="token plain">        S: AsyncRead + AsyncWrite + Unpin + Send,</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        pub fn new(stream: S) -&gt; Self {</span></div><div class="token-line"><span class="token plain">            Self {</span></div><div class="token-line"><span class="token plain">                inner: ProstStream::new(stream),</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        pub async fn execute(&amp;mut self, cmd: CommandRequest) -&gt; Result&lt;CommandResponse, KvError&gt; {</span></div><div class="token-line"><span class="token plain">            let stream = &amp;mut self.inner;</span></div><div class="token-line"><span class="token plain">            stream.send(cmd).await?;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            match stream.next().await {</span></div><div class="token-line"><span class="token plain">                Some(v) =&gt; v,</span></div><div class="token-line"><span class="token plain">                None =&gt; Err(KvError::Internal(&quot;Didn&#x27;t get any response&quot;.into())),</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>再次运行 <code>cargo test</code> ，所有的测试应该都能通过。同样如果有编译错误，可能是缺少了引用。</p><p>我们也可以打开一个命令行窗口，运行：<code>RUST_LOG=info cargo run \--bin kvs \--quiet</code>。然后在另一个命令行窗口，运行：<code>RUST_LOG=info cargo run \--bin kvc \--quiet</code>。此时，服务器和客户端都收到了彼此的请求和响应，并且处理正常！</p><p>我们重构了 ProstServerStream 和 ProstClientStream 的代码，使其内部使用更符合 futures 库里 Stream / Sink trait 的用法，整体代码改动不小，但是内部实现的变更并不影响系统的其它部分！这简直太棒了！</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/10#小结"><span class="icon icon-link"></span></a>小结</h2><p>在实际开发中，进行重构来改善既有代码的质量是必不可少的。之前在开发 KV server 的过程中，我们在不断地进行一些小的重构。</p><p>今天我们做了个稍微大一些的重构，为已有的代码提供更加符合异步 IO 接口的功能。从对外使用的角度来说，它并没有提供或者满足任何额外的需求，但是从代码结构和质量的角度，它使得我们的 ProstStream 可以更方便和更直观地被其它接口调用，也更容易跟整个 Rust 的现有生态结合起来。</p><p>你可能会好奇，为什么可以这么自然地进行代码重构？这是因为我们有足够的单元测试覆盖来打底。</p><p>就像生物的进化一样，好的代码是在良性的重构中不断演进出来的，<strong>而良性的重构，是在优秀的单元测试的监管下，使代码朝着正确方向迈出的步伐</strong>。在这里，单元测试扮演着生物进化中自然环境的角色，把重构过程中的错误一一扼杀。</p><h3 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-two/陈天rust编程第一课/06.并发篇/10#思考题"><span class="icon icon-link"></span></a>思考题</h3><ol><li>为什么在创建 ProstStream 时，要在数据结构中放 wbuf / rbuf 和 written 字段？为什么不能用局部变量？</li><li>仔细阅读 <a target="_blank" rel="noopener noreferrer" href="https://docs.rs/futures/0.3.17/futures/prelude/trait.Stream.html">Stream<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 和 <a target="_blank" rel="noopener noreferrer" href="https://docs.rs/futures/0.3.17/futures/prelude/trait.Sink.html#">Sink<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的文档。尝试写代码构造实现 Stream 和 Sink 的简单数据结构。</li></ol><p>欢迎在留言区分享你的思考和学习收获，感谢你的收听，你已经完成了Rust学习的第41次打卡啦，我们下节课见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/陈天rust编程第一课/06.并发篇/10.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:25</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
