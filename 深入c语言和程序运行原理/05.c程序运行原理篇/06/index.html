<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>30｜ABI 与 API 究竟有什么区别？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/深入c语言和程序运行原理/05.c程序运行原理篇/06" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a aria-current="page" class="active" href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a aria-current="page" class="active" href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li><li><a href="/blog-two/深入c语言和程序运行原理/01.开篇词">01.开篇词</a><ul><li><a href="/blog-two/深入c语言和程序运行原理/01.开篇词/01"><span>开篇词｜时至今日，如何更好地拥抱现代 C 语言？</span></a></li></ul></li><li><a href="/blog-two/深入c语言和程序运行原理/02.前置篇">02.前置篇</a><ul><li><a href="/blog-two/深入c语言和程序运行原理/02.前置篇/01"><span>课前热身｜学习这门课前，你需要了解哪些知识？</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/02.前置篇/02"><span>01｜快速回顾：一个 C 程序的完整生命周期</span></a></li></ul></li><li><a href="/blog-two/深入c语言和程序运行原理/03.c核心语法实现篇">03.C核心语法实现篇</a><ul><li><a href="/blog-two/深入c语言和程序运行原理/03.c核心语法实现篇/01"><span>02｜程序基石：数据与量值是如何被组织的？</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/03.c核心语法实现篇/02"><span>03｜计算单元：运算符是如何工作的？</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/03.c核心语法实现篇/03"><span>04｜控制逻辑：表达式和语句是如何协调程序运行的？</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/03.c核心语法实现篇/04"><span>05｜代码封装（上）：函数是如何被调用的？</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/03.c核心语法实现篇/05"><span>06｜代码封装（下）：函数是如何被调用的？</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/03.c核心语法实现篇/06"><span>07｜整合数据：枚举、结构与联合是如何实现的？</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/03.c核心语法实现篇/07"><span>08｜操控资源：指针是如何灵活使用内存的？</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/03.c核心语法实现篇/08"><span>09｜编译准备：预处理器是怎样处理程序代码的？</span></a></li></ul></li><li><a href="/blog-two/深入c语言和程序运行原理/04.c工程实战篇">04.C工程实战篇</a><ul><li><a href="/blog-two/深入c语言和程序运行原理/04.c工程实战篇/01"><span>10｜标准库：字符、字符串处理与数学计算</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/04.c工程实战篇/02"><span>11｜标准库：深入理解标准 IO</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/04.c工程实战篇/03"><span>12｜标准库：非本地跳转与可变参数是怎样实现的？</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/04.c工程实战篇/04"><span>13｜标准库：你需要了解的 C 并发编程基础知识有哪些？</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/04.c工程实战篇/05"><span>14｜标准库：如何使用互斥量等技术协调线程运行？</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/04.c工程实战篇/06"><span>15｜标准库：信号与操作系统软中断有什么关系？</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/04.c工程实战篇/07"><span>16｜标准库：日期、时间与实用函数</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/04.c工程实战篇/08"><span>17｜标准库：断言、错误处理与对齐</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/04.c工程实战篇/09"><span>18｜极致优化（上）：如何实现高性能的 C 程序？</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/04.c工程实战篇/10"><span>19｜极致优化（下）：如何实现高性能的 C 程序？</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/04.c工程实战篇/11"><span>20｜生产加速：C 项目需要考虑的编码规范有哪些？</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/04.c工程实战篇/12"><span>21｜生产加速：如何使用自动化测试确保 C 项目质量？</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/04.c工程实战篇/13"><span>22｜生产加速：如何使用结构化编译加速 C 项目构建？</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/04.c工程实战篇/14"><span>期中测试｜来检验下你的学习成果吧！</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/04.c工程实战篇/15"><span>23｜实战项目（上）：一个简单的高性能 HTTP Server</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/04.c工程实战篇/16"><span>24｜实战项目（下）：一个简单的高性能 HTTP Server</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/深入c语言和程序运行原理/05.c程序运行原理篇">05.C程序运行原理篇</a><ul><li><a href="/blog-two/深入c语言和程序运行原理/05.c程序运行原理篇/01"><span>25｜可执行二进制文件里有什么？</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/05.c程序运行原理篇/02"><span>26｜进程是如何使用操作系统内存的？</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/05.c程序运行原理篇/03"><span>27｜编译器在链接程序时发生了什么？</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/05.c程序运行原理篇/04"><span>28｜程序可以在运行时进行链接吗？</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/05.c程序运行原理篇/05"><span>29｜C 程序的入口真的是 main 函数吗？</span></a></li><li><a aria-current="page" class="active" href="/blog-two/深入c语言和程序运行原理/05.c程序运行原理篇/06"><span>30｜ABI 与 API 究竟有什么区别？</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/05.c程序运行原理篇/07"><span>31｜程序如何与操作系统交互？</span></a></li></ul></li><li><a href="/blog-two/深入c语言和程序运行原理/06.春节策划">06.春节策划</a><ul><li><a href="/blog-two/深入c语言和程序运行原理/06.春节策划/01"><span>春节策划一 | 构建自己的知识体系，让学习的“飞轮”持续转动</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/06.春节策划/02"><span>春节策划二 | 关于 C 语言，我有这些书籍想推荐给你</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/06.春节策划/03"><span>春节策划三 | JIT Compilation：一种特殊的程序执行方式</span></a></li></ul></li><li><a href="/blog-two/深入c语言和程序运行原理/07.答疑篇">07.答疑篇</a><ul><li><a href="/blog-two/深入c语言和程序运行原理/07.答疑篇/01"><span>课堂答疑（一）｜前置篇、C 核心语法实现篇问题集锦</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/07.答疑篇/02"><span>课堂答疑（二）｜C 工程实战篇问题集锦</span></a></li></ul></li><li><a href="/blog-two/深入c语言和程序运行原理/08.特别放送">08.特别放送</a><ul><li><a href="/blog-two/深入c语言和程序运行原理/08.特别放送/01"><span>大咖助阵｜LMOS：为什么说 C 语言是一把瑞士军刀？</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/08.特别放送/02"><span>大咖助阵｜LMOS：用面向对象的思想开发 C 语言程序</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/08.特别放送/03"><span>大咖助阵｜罗剑锋：为什么 NGINX 是 C 编程的经典范本？</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/08.特别放送/04"><span>大咖助阵｜海纳：C 语言是如何编译执行的？（一）</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/08.特别放送/05"><span>大咖助阵｜海纳：C 语言是如何编译执行的？（二）</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/08.特别放送/06"><span>加餐 | 和 C 语言相比，C++ 有哪些不同的语言特性？</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/08.特别放送/07"><span>大咖助阵｜海纳：C 语言是如何编译执行的？（三）</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/08.特别放送/08"><span>大咖助阵｜Tony Bai：Go 程序员拥抱 C 语言简明指南</span></a></li></ul></li><li><a href="/blog-two/深入c语言和程序运行原理/09.结束语">09.结束语</a><ul><li><a href="/blog-two/深入c语言和程序运行原理/09.结束语/01"><span>期末考试｜来赴一场满分之约吧！</span></a></li><li><a href="/blog-two/深入c语言和程序运行原理/09.结束语/02"><span>结束语｜工业 4.0 时代，C 语言还有哪些应用场景？</span></a></li></ul></li><li><a href="/blog-two/深入c语言和程序运行原理/summary">深入c语言和程序运行原理</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="API" data-depth="2"><a href="/blog-two/深入c语言和程序运行原理/05.c程序运行原理篇/06#api"><span>API</span></a></li><li title="重要特征" data-depth="3"><a href="/blog-two/深入c语言和程序运行原理/05.c程序运行原理篇/06#重要特征"><span>重要特征</span></a></li><li title="发展简史" data-depth="3"><a href="/blog-two/深入c语言和程序运行原理/05.c程序运行原理篇/06#发展简史"><span>发展简史</span></a></li><li title="ABI" data-depth="2"><a href="/blog-two/深入c语言和程序运行原理/05.c程序运行原理篇/06#abi"><span>ABI</span></a></li><li title="不遵循 ABI 的程序能否运行？" data-depth="3"><a href="/blog-two/深入c语言和程序运行原理/05.c程序运行原理篇/06#不遵循-abi-的程序能否运行"><span>不遵循 ABI 的程序能否运行？</span></a></li><li title="ABI 的主要内容" data-depth="3"><a href="/blog-two/深入c语言和程序运行原理/05.c程序运行原理篇/06#abi-的主要内容"><span>ABI 的主要内容</span></a></li><li title="总结" data-depth="2"><a href="/blog-two/深入c语言和程序运行原理/05.c程序运行原理篇/06#总结"><span>总结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-two/深入c语言和程序运行原理/05.c程序运行原理篇/06#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="30abi-与-api-究竟有什么区别"><a aria-hidden="true" tabindex="-1" href="/blog-two/深入c语言和程序运行原理/05.c程序运行原理篇/06#30abi-与-api-究竟有什么区别"><span class="icon icon-link"></span></a>30｜ABI 与 API 究竟有什么区别？</h1><p>你好，我是于航。</p><p>今天我们来聊另外一个老生常谈的话题：“ ABI 与 API 这两个概念究竟有什么区别？”</p><p>也许你之前也思考过这个问题。ABI 与 API 这两个英文缩写只差一个字符，因此它们对应的概念在很多线下讨论和博客文章中会被经常混用，甚至是乱用。当然，时不时地，这个问题也会成为人们在技术社交圈内的丰富谈资。这一讲，就以你熟悉的 C 语言体系为例，我们来一起看看 ABI 与 API 二者分别指代什么内容，有什么区别。</p><h2 id="api"><a aria-hidden="true" tabindex="-1" href="/blog-two/深入c语言和程序运行原理/05.c程序运行原理篇/06#api"><span class="icon icon-link"></span></a><strong>API</strong></h2><p>API 的全称为“应用程序编程接口（Application Programming Interface）”。从它的名字我们就能看出来，这一类接口的侧重点在于“编程”。因此，通过遵循 API 规范，我们可以在相应的编程语言代码中使用这些接口，以操作计算机系统来完成某项特定任务。而对 C 语言来说，那些由 C 标准库提供的，被定义在不同头文件中的函数原型，便是一种 API 的具体表现形式。</p><h3 id="重要特征"><a aria-hidden="true" tabindex="-1" href="/blog-two/深入c语言和程序运行原理/05.c程序运行原理篇/06#重要特征"><span class="icon icon-link"></span></a>重要特征</h3><p><strong>API 具有的一个最重要特征，便是隐藏了其背后具体功能的内部实现细节，<strong><strong>只</strong></strong>公开对编码有意义的部分</strong>（如接口名称、可接收参数的个数与类型等）。通过保持这部分特征的一致性，API 提供者与调用者便可在相对隔离的环境下被独立维护。在这种情况下，这部分相对统一和稳定的特征也可被单独抽离出来，成为相应的 API 规范。</p><p>如下面的代码所示，C 标准库函数 fopen 在 API 层面有着稳定的特征，但实际上，使用这些 API 构建的应用程序却可以在不修改代码的情况下，灵活选用不同的接口实现方案（如 musl 和 glibc）。这其中的一个重要原因，便是<strong>C 标准库的 API 规范是独立于具体实现的</strong>。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">FILE *fopen(const char* filename, const char* mode)</span></div></pre></div><h3 id="发展简史"><a aria-hidden="true" tabindex="-1" href="/blog-two/深入c语言和程序运行原理/05.c程序运行原理篇/06#发展简史"><span class="icon icon-link"></span></a>发展简史</h3><p>API 对应的概念最早出现于上世纪 40 年代，而直到 1968 年，API 这个术语才在发表于 AFIPS（American Federation of Information Processing Societies）会议的一篇论文中首次出现，随后逐渐被业界广泛采用。而随着计算机互联网的普及，API 一词开始被更多地用于表示与 Web 领域相关的标准接口。其中，使用最为广泛的当属那些基于 REST、SOAP 等风格构架的 Web API。下面是一个简单的例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">POST https://docs.googleapis.com/v1/documents/{documentId}:batchUpdate</span></div></pre></div><p>截至目前，在没有具体上下文的情况下，我们通常默认用 API 一词来表示那些与 Web 领域相关的标准接口。</p><p>总的来看，API 的最重要特征在于<strong>提供相应功能的同时隐藏实现细节，让其使用者可以按照较为统一和稳定的方式来使用系统能力</strong>。按照这个结论，API 的概念可以被应用在更加广泛的领域中。比如，对于操作系统调用来说，我们也可以称其为由操作系统内核提供的一种 API。通过这些 API，系统库乃至上层应用都可以使用内核的能力，但使用者又无需了解它的内部具体实现细节。</p><p>可以看到，API 的概念还是十分简单和清晰的。接下来我们看看与它仅有一字之差的 ABI，到这里，事情变得复杂了起来。</p><h2 id="abi"><a aria-hidden="true" tabindex="-1" href="/blog-two/深入c语言和程序运行原理/05.c程序运行原理篇/06#abi"><span class="icon icon-link"></span></a><strong>ABI</strong></h2><p>ABI 的全称为“应用程序二进制接口（Application Binary Interface）”。与 API 不同的是，ABI 的侧重点并不在于 “Programming”，而在于 “Binary”，即机器指令层面的具体格式。因此，与 API 相反，<strong>ABI 将程序与操作系统</strong>**、**<strong>硬件平台之间紧密协作需要遵守的特定规则暴露了出来</strong>。这些规则指定了基于这个体系运行的二进制应用程序，应该如何在机器代码层面进行数据访问或函数调用等一系列操作。</p><p>规则的重要性不言而喻。我曾在 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/468171">05讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中介绍过，运行在 x86-64 平台上的类 Unix 系统会遵循名为 “System V AMD64 ABI” 的调用约定，来进行函数的实际调用过程。而在这个约定中，函数调用需要使用固定的寄存器传递参数，并按照一定顺序，在满足栈对齐等一系列要求的情况下进行。当然，你可能会问：如果不满足这些要求，程序就无法正常运行吗？下面，让我们来做一个简单的实验。</p><h3 id="不遵循-abi-的程序能否运行"><a aria-hidden="true" tabindex="-1" href="/blog-two/深入c语言和程序运行原理/05.c程序运行原理篇/06#不遵循-abi-的程序能否运行"><span class="icon icon-link"></span></a>不遵循 ABI 的程序能否运行？</h3><p>这里，为了验证不满足 ABI 要求的程序能否正常运行，我们将直接使用 Intel 格式的汇编代码来编写程序入口函数 _start 的具体实现。在该函数内部，我们会按照违背 SysV 调用约定的方式，调用直接由 C 代码编译而来的函数 sub，并将所得计算结果作为程序的最终返回值。</p><p>首先，我们来看 sub 函数的实现代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// sub.c</span></div><div class="token-line"><span class="token plain">    int sub(int x, int y) {</span></div><div class="token-line"><span class="token plain">      return x - y;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>该函数的逻辑十分简单：它接收两个整型参数 x 与 y，并返回表达式 <code>x \- y</code> 的值。紧接着，我们来编写 _start 部分的逻辑，代码如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># main.asm</span></div><div class="token-line"><span class="token plain">    extern sub</span></div><div class="token-line"><span class="token plain">    global _start</span></div><div class="token-line"><span class="token plain">    section .text</span></div><div class="token-line"><span class="token plain">    _start:</span></div><div class="token-line"><span class="token plain">      and   rsp, 0xfffffffffffffff0</span></div><div class="token-line"><span class="token plain">      sub   rsp, 1</span></div><div class="token-line"><span class="token plain">      mov   esi, 2  # the 1st param.</span></div><div class="token-line"><span class="token plain">      mov   edi, 1  # the 2nd param.</span></div><div class="token-line"><span class="token plain">      call  sub</span></div><div class="token-line"><span class="token plain">      mov   edi, eax</span></div><div class="token-line"><span class="token plain">      mov   eax, 60</span></div><div class="token-line"><span class="token plain">      syscall</span></div></pre></div><p>这部分逻辑的实现过程主要分为下面几个步骤：</p><ol><li>代码第 6 行，通过 <code>and</code> 指令，栈顶首先被对齐到 ABI 要求的 16 字节，接着通过下一行的 <code>sub</code> 指令，我们让栈失去“对齐”这一特性；</li><li>代码第 8~9 行，我们使用寄存器 esi 存放传入 sub 函数的第一个参数，使用 edi 存放其第二个参数（与 SysV 中的规定相反）；</li><li>代码第 10 行，调用 sub 函数；</li><li>代码第 11~13 行，调用 exit 系统调用，并将存放在寄存器 eax 中的计算结果作为程序结束的返回值。</li></ol><p>紧接着，分别执行下面这几行命令，以完成上述代码的编译过程（注：这里我们使用的 nasm 是一个 x86 汇编器，详情可以参考<a target="_blank" rel="noopener noreferrer" href="https://www.nasm.us/">这个链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">gcc -c sub.c -o sub.o</span></div><div class="token-line"><span class="token plain">    nasm -f elf64 ./main.asm -o ./main.o</span></div><div class="token-line"><span class="token plain">    ld ./main.o ./sub.o -o ./main</span></div></pre></div><p>最后，运行程序，通过命令 <code>echo $?</code> ，我们可以查看到程序退出时的实际返回值。</p><p>在这一系列操作后，你会发现程序可以被正常编译和执行，只是得到的返回结果并不符合我们的预期。实际上，出现这个问题的原因正是由于我们编写的 _start 入口代码没有遵循统一的 SysV 调用规范。</p><p>在代码的第 8~9 行，我们以相反的顺序（即先 esi 后 edi）传入了 sub 函数需要的两个实参。而在 sub 函数对应的机器代码实现中，GCC 会按照 SysV 规范来分配该函数需要使用的各个参数。因此，实际上由 esi 传入的第一个参数，便会被 sub 函数当作第二个参数。同样地，由 edi 传入的第二个参数则会被当作第一个参数。</p><p>除此之外，虽然未对齐的栈顶并未导致 sub 函数的调用失败，但这只是由于我们的实验用例比较幸运。在真实的 x86-64 体系中，有很多指令（如 <code>movapd</code> 、<code>movaps</code>）在被实际调用前，都是需要栈顶位于特定边界（如 16、32、64 字节）对齐的，否则会抛出相应异常（如 #GP）。这些指令可能被广泛地使用在各类标准库实现中，因此，<strong>为了能够正确使用这些函数，满足栈对齐这一要求也是不可或缺的</strong>。</p><h3 id="abi-的主要内容"><a aria-hidden="true" tabindex="-1" href="/blog-two/深入c语言和程序运行原理/05.c程序运行原理篇/06#abi-的主要内容"><span class="icon icon-link"></span></a>ABI 的主要内容</h3><p>总的来看，ABI 规范通常会涵盖以下这些内容：</p><ul><li>函数调用规范；</li><li>处理器可以访问的数据类型其大小与对齐方式；</li><li>进程初始化细节（如栈和寄存器的状态变化）；</li><li>对象文件（如 .o）的基本结构；</li><li>程序载入和动态链接的细节；</li><li>……</li></ul><p>对于 C 程序来说，稳定的 ABI 对<strong>保障同一个程序<strong><strong>在</strong></strong>多个不同平台（如不同的类 Unix 系统）上的兼容性</strong>有着重要作用。C 标准中并未规定 C 代码应该按照怎样的方式执行，内存应该如何布局和分配。而与 C 程序运行时相关的一切细节，实际上都是由相应平台的 ABI 来决定的。比如，在 SysV ABI 规范手册的第一章内容中，我们可以看到下面这句话：</p><blockquote><p>No attempt has been made to specify an ABI for languages other than C. However, it is assumed that many programming languages will wish to link with code written in C, so that the ABI specifications documented here apply there too.</p></blockquote><p>翻译过来就是：“我们没有尝试为 C 以外的语言指定 ABI。然而，假定许多其他编程语言都希望与使用 C 语言编写的代码进行链接，那么这里记录的 ABI 规范也同样适用于那些情况。”可以看到，C 语言的特殊地位使得操作系统厂商会选择使用它来作为编写相应 ABI 规范的“基准语言”。</p><p>比如在 SysV 中，规范将 C 语言里的各种基本类型与处理器类型进行了一一映射，对结构和联合的对齐要求进行了说明，对可变参数列表的具体实现方式进行了说明，等等。所有这些细则都将共同约束编译器，使其按照某一特定方式编译和构建 C 程序。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-two/深入c语言和程序运行原理/05.c程序运行原理篇/06#总结"><span class="icon icon-link"></span></a>总结</h2><p>今天，我主要为你讲解了 API 与 ABI 这两个概念之间的区别。</p><p>API 的全称为“应用程序编程接口”，它是程序员可以通过编程语言调用的一种特殊资源。API 通过隐藏功能的内部实现细节隔离了其使用方与提供方，使得 API 实现与应用程序实现可以通过遵循统一、稳定的 API 规范，来达到各自独立维护的目的。API 有着多种具体表现形式，比如源代码形式的函数，或是基于互联网的 Web 接口。</p><p>ABI 的全称为“应用程序二进制接口”，它是一套描述了应用程序应该如何在机器指令层面与特定操作系统和硬件平台正常协作的一系列规范。这些规范决定了应用程序应该如何进行数据访问、函数调用，乃至使用操作系统的能力。不遵循 ABI 规范的应用程序也许可以运行，但它却可能会失去在同一个体系下的兼容性以及运行正确性。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-two/深入c语言和程序运行原理/05.c程序运行原理篇/06#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>尝试使用 x86-64 汇编语言编写一个程序，使它能够产生由于栈未对齐而导致的异常。希望你可以动手实践下，然后在评论区分享你的经验，或者提出你遇到的问题。</p><p>今天的课程到这里就结束了，希望可以帮助到你，也希望你在下方的留言区和我一起讨论。同时，欢迎你把这节课分享给你的朋友或同事，我们一起交流。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/深入c语言和程序运行原理/05.C程序运行原理篇/06.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:40</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
