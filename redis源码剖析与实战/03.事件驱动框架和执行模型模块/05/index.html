<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>12 | Redis真的是单线程吗？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/redis源码剖析与实战/03.事件驱动框架和执行模型模块/05" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a aria-current="page" class="active" href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a aria-current="page" class="active" href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/redis源码剖析与实战/01.课前导读">01.课前导读</a><ul><li><a href="/blog-two/redis源码剖析与实战/01.课前导读/01"><span>开篇词 | 阅读Redis源码能给你带来什么？</span></a></li><li><a href="/blog-two/redis源码剖析与实战/01.课前导读/02"><span>01 | 带你快速攻略Redis源码的整体架构</span></a></li></ul></li><li><a href="/blog-two/redis源码剖析与实战/02.数据结构模块">02.数据结构模块</a><ul><li><a href="/blog-two/redis源码剖析与实战/02.数据结构模块/01"><span>02 | 键值对中字符串的实现，用char*还是结构体？</span></a></li><li><a href="/blog-two/redis源码剖析与实战/02.数据结构模块/02"><span>03 | 如何实现一个性能优异的Hash表？</span></a></li><li><a href="/blog-two/redis源码剖析与实战/02.数据结构模块/03"><span>04 | 内存友好的数据结构该如何细化设计？</span></a></li><li><a href="/blog-two/redis源码剖析与实战/02.数据结构模块/04"><span>05 | 有序集合为何能同时支持点查询和范围查询？</span></a></li><li><a href="/blog-two/redis源码剖析与实战/02.数据结构模块/05"><span>06 | 从ziplist到quicklist，再到listpack的启发</span></a></li><li><a href="/blog-two/redis源码剖析与实战/02.数据结构模块/06"><span>07 | 为什么Stream使用了Radix Tree？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/redis源码剖析与实战/03.事件驱动框架和执行模型模块">03.事件驱动框架和执行模型模块</a><ul><li><a href="/blog-two/redis源码剖析与实战/03.事件驱动框架和执行模型模块/01"><span>08 | Redis server启动后会做哪些操作？</span></a></li><li><a href="/blog-two/redis源码剖析与实战/03.事件驱动框架和执行模型模块/02"><span>09 | Redis事件驱动框架（上）：何时使用select、poll、epoll？</span></a></li><li><a href="/blog-two/redis源码剖析与实战/03.事件驱动框架和执行模型模块/03"><span>10 | Redis事件驱动框架（中）：Redis实现了Reactor模型吗？</span></a></li><li><a href="/blog-two/redis源码剖析与实战/03.事件驱动框架和执行模型模块/04"><span>11 | Redis事件驱动框架（下）：Redis有哪些事件？</span></a></li><li><a aria-current="page" class="active" href="/blog-two/redis源码剖析与实战/03.事件驱动框架和执行模型模块/05"><span>12 | Redis真的是单线程吗？</span></a></li><li><a href="/blog-two/redis源码剖析与实战/03.事件驱动框架和执行模型模块/06"><span>13 | Redis 6.0多IO线程的效率提高了吗？</span></a></li><li><a href="/blog-two/redis源码剖析与实战/03.事件驱动框架和执行模型模块/07"><span>14 | 从代码实现看分布式锁的原子性保证</span></a></li></ul></li><li><a href="/blog-two/redis源码剖析与实战/04.缓存模块">04.缓存模块</a><ul><li><a href="/blog-two/redis源码剖析与实战/04.缓存模块/01"><span>15 | 为什么LRU算法原理和代码实现不一样？</span></a></li><li><a href="/blog-two/redis源码剖析与实战/04.缓存模块/02"><span>16 | LFU算法和其他算法相比有优势吗？</span></a></li><li><a href="/blog-two/redis源码剖析与实战/04.缓存模块/03"><span>17 | Lazy Free会影响缓存替换吗？</span></a></li></ul></li><li><a href="/blog-two/redis源码剖析与实战/05.期中测试">05.期中测试</a><ul><li><a href="/blog-two/redis源码剖析与实战/05.期中测试/01"><span>期中测试 | 这些Redis源码知识，你都掌握了吗？</span></a></li><li><a href="/blog-two/redis源码剖析与实战/05.期中测试/02"><span>期中测试题答案 | 这些问题你都答对了吗？</span></a></li></ul></li><li><a href="/blog-two/redis源码剖析与实战/06.可靠性保证模块">06.可靠性保证模块</a><ul><li><a href="/blog-two/redis源码剖析与实战/06.可靠性保证模块/01"><span>18 | 如何生成和解读RDB文件？</span></a></li><li><a href="/blog-two/redis源码剖析与实战/06.可靠性保证模块/02"><span>19 | AOF重写（上）：触发时机与重写的影响</span></a></li><li><a href="/blog-two/redis源码剖析与实战/06.可靠性保证模块/03"><span>20 | AOF重写（下）：重写时的新写操作记录在哪里？</span></a></li><li><a href="/blog-two/redis源码剖析与实战/06.可靠性保证模块/04"><span>21 | 主从复制：基于状态机的设计与实现</span></a></li><li><a href="/blog-two/redis源码剖析与实战/06.可靠性保证模块/05"><span>22 | 哨兵也和Redis实例一样初始化吗？</span></a></li><li><a href="/blog-two/redis源码剖析与实战/06.可靠性保证模块/06"><span>23 | 从哨兵Leader选举学习Raft协议实现（上）</span></a></li><li><a href="/blog-two/redis源码剖析与实战/06.可靠性保证模块/07"><span>24 | 从哨兵Leader选举学习Raft协议实现（下）</span></a></li><li><a href="/blog-two/redis源码剖析与实战/06.可靠性保证模块/08"><span>25 | Pub/Sub在主从故障切换时是如何发挥作用的？</span></a></li></ul></li><li><a href="/blog-two/redis源码剖析与实战/07.不定期加餐">07.不定期加餐</a><ul><li><a href="/blog-two/redis源码剖析与实战/07.不定期加餐/01"><span>加餐1 | Redis性能测试工具的使用</span></a></li><li><a href="/blog-two/redis源码剖析与实战/07.不定期加餐/02"><span>加餐2 | 用户Kaito：我是怎么读Redis源码的？</span></a></li><li><a href="/blog-two/redis源码剖析与实战/07.不定期加餐/03"><span>加餐3 | 从Redis到其他键值数据库的学习体会</span></a></li><li><a href="/blog-two/redis源码剖析与实战/07.不定期加餐/04"><span>加餐4 | RDB和AOF文件损坏了咋办？</span></a></li><li><a href="/blog-two/redis源码剖析与实战/07.不定期加餐/05"><span>用户故事 | 曾轼麟：世上无难事，只怕有心人</span></a></li></ul></li><li><a href="/blog-two/redis源码剖析与实战/08.redis-cluster模块">08.RedisCluster模块</a><ul><li><a href="/blog-two/redis源码剖析与实战/08.redis-cluster模块/01"><span>26 | 从Ping-Pong消息学习Gossip协议的实现</span></a></li><li><a href="/blog-two/redis源码剖析与实战/08.redis-cluster模块/02"><span>27 | 从MOVED、ASK看集群节点如何处理命令？</span></a></li><li><a href="/blog-two/redis源码剖析与实战/08.redis-cluster模块/03"><span>28 | Redis Cluster数据迁移会阻塞吗？</span></a></li></ul></li><li><a href="/blog-two/redis源码剖析与实战/09.编程技巧模块">09.编程技巧模块</a><ul><li><a href="/blog-two/redis源码剖析与实战/09.编程技巧模块/01"><span>29 | 如何正确实现循环缓冲区？</span></a></li><li><a href="/blog-two/redis源码剖析与实战/09.编程技巧模块/02"><span>30 | 如何在系统中实现延迟监控？</span></a></li><li><a href="/blog-two/redis源码剖析与实战/09.编程技巧模块/03"><span>31 | 从Module的实现学习动态扩展功能</span></a></li><li><a href="/blog-two/redis源码剖析与实战/09.编程技巧模块/04"><span>32 | 如何在一个系统中实现单元测试？</span></a></li></ul></li><li><a href="/blog-two/redis源码剖析与实战/10.问题答疑">10.问题答疑</a><ul><li><a href="/blog-two/redis源码剖析与实战/10.问题答疑/01"><span>答疑1 | 第1~6讲课后思考题答案及常见问题答疑</span></a></li><li><a href="/blog-two/redis源码剖析与实战/10.问题答疑/02"><span>答疑2 | 第7~12讲课后思考题答案及常见问题答疑</span></a></li><li><a href="/blog-two/redis源码剖析与实战/10.问题答疑/03"><span>答疑3 | 第13~18讲课后思考题答案及常见问题答疑</span></a></li><li><a href="/blog-two/redis源码剖析与实战/10.问题答疑/04"><span>答疑4 | 第19~24讲课后思考题答案及常见问题答疑</span></a></li><li><a href="/blog-two/redis源码剖析与实战/10.问题答疑/05"><span>答疑5 | 第25~32讲课后思考题答案及常见问题答疑</span></a></li></ul></li><li><a href="/blog-two/redis源码剖析与实战/11.结束语">11.结束语</a><ul><li><a href="/blog-two/redis源码剖析与实战/11.结束语/01"><span>结束语 | Redis源码阅读，让我们从新开始</span></a></li><li><a href="/blog-two/redis源码剖析与实战/11.结束语/02"><span>结课测试 | 一套习题，测测你的Redis源码知识掌握程度</span></a></li></ul></li><li><a href="/blog-two/redis源码剖析与实战/summary">redis源码剖析与实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="从shell命令执行到Redis进程创建" data-depth="2"><a href="/blog-two/redis源码剖析与实战/03.事件驱动框架和执行模型模块/05#从shell命令执行到redis进程创建"><span>从shell命令执行到Redis进程创建</span></a></li><li title="从daemonize函数的执行学习守护进程的创建" data-depth="2"><a href="/blog-two/redis源码剖析与实战/03.事件驱动框架和执行模型模块/05#从daemonize函数的执行学习守护进程的创建"><span>从daemonize函数的执行学习守护进程的创建</span></a></li><li title="从bio.c文件学习Redis的后台线程" data-depth="2"><a href="/blog-two/redis源码剖析与实战/03.事件驱动框架和执行模型模块/05#从bioc文件学习redis的后台线程"><span>从bio.c文件学习Redis的后台线程</span></a></li><li title="bioInit函数：初始化数组" data-depth="3"><a href="/blog-two/redis源码剖析与实战/03.事件驱动框架和执行模型模块/05#bioinit函数初始化数组"><span>bioInit函数：初始化数组</span></a></li><li title="bioInit函数：设置线程属性并创建线程" data-depth="3"><a href="/blog-two/redis源码剖析与实战/03.事件驱动框架和执行模型模块/05#bioinit函数设置线程属性并创建线程"><span>bioInit函数：设置线程属性并创建线程</span></a></li><li title="bioProcessBackgroundJobs函数：处理后台任务" data-depth="3"><a href="/blog-two/redis源码剖析与实战/03.事件驱动框架和执行模型模块/05#bioprocessbackgroundjobs函数处理后台任务"><span>bioProcessBackgroundJobs函数：处理后台任务</span></a></li><li title="bioCreateBackgroundJob函数：创建后台任务" data-depth="3"><a href="/blog-two/redis源码剖析与实战/03.事件驱动框架和执行模型模块/05#biocreatebackgroundjob函数创建后台任务"><span>bioCreateBackgroundJob函数：创建后台任务</span></a></li><li title="小结" data-depth="2"><a href="/blog-two/redis源码剖析与实战/03.事件驱动框架和执行模型模块/05#小结"><span>小结</span></a></li><li title="每课一问" data-depth="2"><a href="/blog-two/redis源码剖析与实战/03.事件驱动框架和执行模型模块/05#每课一问"><span>每课一问</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="12--redis真的是单线程吗"><a aria-hidden="true" tabindex="-1" href="/blog-two/redis源码剖析与实战/03.事件驱动框架和执行模型模块/05#12--redis真的是单线程吗"><span class="icon icon-link"></span></a>12 | Redis真的是单线程吗？</h1><p>你好，我是蒋德钧。今天这节课，我们来聊聊Redis的执行模型。</p><p>所谓的执行模型，就是指Redis运行时使用的进程、子进程和线程的个数，以及它们各自负责的工作任务。</p><p>你在实际使用Redis的时候，可能经常会听到类似“Redis是单线程”“Redis的主IO线程”，“Redis包含多线程”等不同说法。我也听到不少同学提出困惑和疑问：<strong>Redis到底是不是一个单线程的程序？</strong></p><p>其实，彻底理解这个问题，有助于指导我们保持Redis高性能、低延迟的特性。如果说Redis就是单线程程序，那么，我们就需要避免所有容易引起线程阻塞的操作；而如果说Redis不只是单线程，还有其他线程在工作，那么，我们就需要了解多线程各自负责什么任务，负责请求解析和数据读写的线程有几个，有哪些操作是后台线程在完成，而不会影响请求解析和数据读写的。</p><p>所以，今天这节课，我就从Redis server启动后运行的进程开始，带你一边学习Redis源码中子进程和线程的创建方式，一边掌握Redis server运行时涉及到的进程、子进程和线程情况。</p><p>下面，我们先来看Redis server启动时的进程运行。</p><h2 id="从shell命令执行到redis进程创建"><a aria-hidden="true" tabindex="-1" href="/blog-two/redis源码剖析与实战/03.事件驱动框架和执行模型模块/05#从shell命令执行到redis进程创建"><span class="icon icon-link"></span></a>从shell命令执行到Redis进程创建</h2><p>我们在启动Redis实例时，可以在shell命令行环境中，执行redis-server这个可执行文件，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">./redis-server  /etc/redis/redis.conf</span></div></pre></div><p>shell运行这个命令后，它实际会调用fork系统调用函数，来新建一个进程。因为shell本身是一个进程，所以，这个通过fork新创建的进程就被称为是shell进程的子进程，而shell进程被称为父进程。关于fork函数的具体用法，我一会儿还会给你具体介绍。</p><p>紧接着，shell进程会调用execve系统调用函数，将子进程执行的主体替换成Redis的可执行文件。而Redis可执行文件的入口函数就是main函数，这样一来，子进程就会开始执行Redis server的main函数了。</p><p>下面的代码显示了execve系统调用函数原型。其中，filename是要运行的程序的文件名，argv[]和envp[]分别是要运行程序的参数和环境变量。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int execve(const char *filename, char *const argv[], char *const envp[]))</span></div></pre></div><p>下图显示了从shell执行命令到创建Redis进程的过程，你可以看下。</p><p><img src="https://static001.geekbang.org/resource/image/d7/b5/d7ec5ef2698cyyd1973a6afbb0c7dfb5.jpg?wh=2000x510" alt=""/></p><p>当我们用刚才介绍的shell命令运行Redis server后，我们会看到Redis server启动后的日志输出会打印到终端屏幕上，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">37807:M 19 Aug 2021 07:29:36.372 # Server initialized</span></div><div class="token-line"><span class="token plain">    37807:M 19 Aug 2021 07:29:36.372 * DB loaded from disk: 0.000 seconds</span></div><div class="token-line"><span class="token plain">    37807:M 19 Aug 2021 07:29:36.372 * Ready to accept connections</span></div></pre></div><p>这是因为shell进程调用fork函数创建的子进程，会从父进程中继承一些属性，比如父进程打开的文件描述符。对于shell进程来说，它打开的文件描述符包括0和1，这两个描述符分别代表了标准输入和标准输出。而execve函数只是把子进程的执行内容替换成Redis可执行文件，子进程从shell父进程继承到的标准输入和标准输出保持不变。</p><p>所以，Redis运行时通过serverLog函数打印的日志信息，就会默认输出到终端屏幕上了，也就是shell进程的标准输出。</p><p>而一旦Redis进程创建开始运行后，它就会从main函数开始执行。我们在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/406556">第8讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中已经学习了main函数的主要执行过程，所以我们会发现，它会调用不同的函数来执行相关功能。比如，main函数调用initServerConfig函数初始化Redis server的运行参数，调用loadServerConfig函数解析配置文件参数。当main函数调用这些函数时，这些函数仍然是由原来的进程执行的。所以，在这种情况下，Redis仍然是单个进程在运行。</p><p>不过，在main函数完成参数解析后，会根据两个配置参数daemonize和supervised，来设置变量background的值。它们的含义分别是：</p><ul><li>参数daemonize表示，是否要设置Redis以守护进程方式运行；</li><li>参数supervised表示，是否使用upstart或是systemd这两种守护进程的管理程序来管理Redis。</li></ul><p>那么，我们来进一步了解下守护进程。守护进程是在系统后台运行的进程，独立于shell终端，不再需要用户在shell中进行输入了。一般来说，守护进程用于执行周期性任务或是等待相应事件发生再进行处理。Redis server本身就是在启动后，等待客户端输入，再进行处理。所以对于Redis这类服务器程序来说，我们通常会让它以守护进程方式运行。</p><p>好了，如果设置了Redis以守护进程方式执行，那么守护进程具体是怎么创建的呢？这就和main函数调用的daemonize函数相关了。daemonize函数就是用来将Redis进程转换为守护进程来运行。</p><p>下面的代码显示了main函数根据变量background值，来判断是否执行daemonize函数的逻辑，你可以看下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//如果配置参数daemonize为1，supervised值为0，那么设置background值为1，否则，设置其为0。</span></div><div class="token-line"><span class="token plain">    int main(int argc, char **argv) {</span></div><div class="token-line"><span class="token plain">    …</span></div><div class="token-line"><span class="token plain">    int background = server.daemonize &amp;&amp; !server.supervised;</span></div><div class="token-line"><span class="token plain">    //如果background值为1，调用daemonize函数。</span></div><div class="token-line"><span class="token plain">    if (background) daemonize();</span></div><div class="token-line"><span class="token plain">    …</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>也就是说，如果background的值为1，就表示Redis被设置为以守护进程方式运行，因此main函数就会调用daemonize函数。</p><p>那么，接下来，我们就来学习下daemonize函数是如何将Redis转为守护进程运行的。</p><h2 id="从daemonize函数的执行学习守护进程的创建"><a aria-hidden="true" tabindex="-1" href="/blog-two/redis源码剖析与实战/03.事件驱动框架和执行模型模块/05#从daemonize函数的执行学习守护进程的创建"><span class="icon icon-link"></span></a>从daemonize函数的执行学习守护进程的创建</h2><p>我们首先来看daemonize函数的部分执行内容，如下所示。我们可以看到，daemonize函数调用了fork函数，并根据fork函数返回值有不同的分支代码。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void daemonize(void) {</span></div><div class="token-line"><span class="token plain">    …</span></div><div class="token-line"><span class="token plain">    if (fork() != 0) exit(0); //fork成功执行或失败，则父进程退出</span></div><div class="token-line"><span class="token plain">    setsid(); //创建新的session</span></div><div class="token-line"><span class="token plain">    …</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>从刚才的介绍中，我们已经知道，当我们在一个程序的函数中调用fork函数时，fork函数会创建一个子进程。而原本这个程序对应的进程，就称为这个子进程的父进程。那么，fork函数执行后的不同分支和父、子进程是什么关系呢？这就和fork函数的使用有关了。</p><p>实际上，fork函数的使用是比较有意思的，我们可以根据fork函数的不同返回值，来编写相应的分支代码，这些分支代码就对应了父进程和子进程各自要执行的逻辑。</p><p>为了便于你理解，我给你举个例子。我写了一段示例代码，这段代码的main函数会调用fork函数，并进一步根据fork函数的返回值是小于0、等于0，还是大于0，来执行不同的分支。注意，fork函数的不同返回值，其实代表了不同的含义，具体来说：</p><ul><li>当返回值小于0时，此时表明fork函数执行有误；</li><li>当返回值等于0时，此时，返回值对应的代码分支就会在子进程中运行；</li><li>当返回值大于0时，此时，返回值对应的代码分支仍然会在父进程中运行。</li></ul><p>这段示例代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#include &lt;stdio.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;unistd.h&gt;</span></div><div class="token-line"><span class="token plain">     </span></div><div class="token-line"><span class="token plain">    int main(int argc, char *argv[]) {</span></div><div class="token-line"><span class="token plain">    	printf(&quot;hello main\n&quot;);</span></div><div class="token-line"><span class="token plain">        int rv = fork(); //fork函数的返回值</span></div><div class="token-line"><span class="token plain">        //返回值小于0，表示fork执行错误</span></div><div class="token-line"><span class="token plain">        if (rv &lt; 0) {</span></div><div class="token-line"><span class="token plain">            fprintf(stderr, &quot;fork failed\n&quot;);</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	//返回值等于0，对应子进程执行</span></div><div class="token-line"><span class="token plain">        else if (rv == 0) {</span></div><div class="token-line"><span class="token plain">            printf(&quot;I am child process %d\n&quot;, getpid());</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	//返回值大于0，对应父进程执行</span></div><div class="token-line"><span class="token plain">        else {</span></div><div class="token-line"><span class="token plain">            printf(&quot;I am parent process of (%d), %d\n&quot;, rc, getpid());</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这段代码中，我根据fork函数的返回值，分别写了三个分支代码，其中返回值等于0对应的代码分支，是子进程执行的代码。子进程会打印字符串“I am child process”，并打印子进程的进程号。而返回值大于0对应的代码分支，是父进程的代码。父进程会打印字符串“I am parent process of”，并打印它所创建的子进程进程号和它自身的进程号。</p><p>那么，如果你把这段代码编译后执行，你可以看到类似如下的结果，父进程打印了它的进程号62794，而子进程则打印了它的进程号62795。这表明刚才示例代码中的不同分支的确是由父、子进程来执行的。这也就是说，我们可以在fork函数执行后，使用不同分支，让父、子进程执行不同内容。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">hello main</span></div><div class="token-line"><span class="token plain">    I am parent process of (62795), 62794</span></div><div class="token-line"><span class="token plain">    I am child process 62795</span></div></pre></div><p>好了，了解了fork函数创建子进程的知识后，我们再来看下刚才介绍的daemonize函数。</p><p>现在我们已经知道，daemonize函数调用fork函数后，可以根据fork函数返回值设置不同代码分支，对应父、子进程执行内容。其实，daemonize函数也的确设置了两个代码分支。</p><ul><li><strong>分支一</strong></li></ul><p>这个分支对应fork函数返回值不为0，表示fork函数成功执行后的父进程执行逻辑或是fork函数执行失败的执行逻辑。此时，父进程会调用exit(0)函数退出。也就是说，如果fork函数成功执行，父进程就退出了。当然，如果fork函数执行失败了，那么子进程也没有能成功创建，父进程也就退出执行了。你可以看下下面的代码，展示了这个分支。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void daemonize(void) {</span></div><div class="token-line"><span class="token plain">    …</span></div><div class="token-line"><span class="token plain">    if (fork() != 0) exit(0); //fork成功执行或失败，则父进程退出</span></div><div class="token-line"><span class="token plain">    …</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><ul><li><strong>分支二</strong></li></ul><p>这个分支对应fork函数返回值为0，为子进程的执行逻辑。子进程首先会调用setsid函数，创建一个新的会话。</p><p>然后，子进程会用open函数打开/dev/null设备，并把它的标准输入、标准输出和标准错误输出，重新定向到/dev/null设备。因为守护进程是在后台运行，它的输入输出是独立于shell终端的。所以，为了让Redis能以守护进程方式运行，这几步操作的目的就是把当前子进程的输入、输出由原来的shell终端，转向/dev/null设备，这样一来，就不再依赖于shell终端了，满足了守护进程的要求。</p><p>我把daemonize函数的代码放在这里，你可以看下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void daemonize(void) {</span></div><div class="token-line"><span class="token plain">        …</span></div><div class="token-line"><span class="token plain">        setsid(); //为子进程创建新的session</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">        //将子进程的标准输入、标准输出、标准错误输出重定向到/dev/null中</span></div><div class="token-line"><span class="token plain">        if ((fd = open(&quot;/dev/null&quot;, O_RDWR, 0)) != -1) {</span></div><div class="token-line"><span class="token plain">            dup2(fd, STDIN_FILENO);</span></div><div class="token-line"><span class="token plain">            dup2(fd, STDOUT_FILENO);</span></div><div class="token-line"><span class="token plain">            dup2(fd, STDERR_FILENO);</span></div><div class="token-line"><span class="token plain">            if (fd &gt; STDERR_FILENO) close(fd);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>好了，到这里，我们就了解了，Redis的main函数会根据配置参数daemonize和supervised，来判断是否以守护进程方式运行Redis。</p><p>那么，一旦Redis要以守护进程方式运行，main函数会调用daemonize函数。daemonize函数会进一步调用fork函数创建子进程，并根据返回值，分别执行父进程和子进程的代码分支。其中，父进程会退出。而子进程会代替原来的父进程，继续执行main函数的代码。</p><p>下面的图展示了daemonize函数调用fork函数后的两个分支的执行逻辑，你可以再回顾下。</p><p><img src="https://static001.geekbang.org/resource/image/b9/11/b9fa1ea3962e18be5ca9973a2feeb111.jpg?wh=2000x947" alt=""/></p><p>事实上，Redis server启动后无论是否以守护进程形式运行，都还是一个进程在运行。对于一个进程来说，如果该进程启动后没有创建新的线程，那么这个进程的工作任务默认就是由一个线程来执行的，而这个线程我一般也称它为主线程。</p><p>对于Redis来说，它的主要工作，包括接收客户端请求、解析请求和进行数据读写等操作，都没有创建新线程来执行，所以，Redis主要工作的确是由单线程来执行的，这也是我们常说Redis是单线程程序的原因。因为Redis主要工作都是IO读写操作，所以，我也会把这个单线程称为主IO线程。</p><p>但其实，Redis 在3.0版本后，除了主IO线程外，的确还会启动一些后台线程来处理部分任务，从而避免这些任务对主IO线程的影响。那么，这些后台线程是在哪里启动的，又是如何执行的呢？</p><p>这就和Redis的<a target="_blank" rel="noopener noreferrer" href="https://github.com/redis/redis/tree/5.0/src/bio.c">bio.c<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>文件相关了。接下来，我们就来从这个文件中学习下Redis的后台线程。</p><h2 id="从bioc文件学习redis的后台线程"><a aria-hidden="true" tabindex="-1" href="/blog-two/redis源码剖析与实战/03.事件驱动框架和执行模型模块/05#从bioc文件学习redis的后台线程"><span class="icon icon-link"></span></a>从bio.c文件学习Redis的后台线程</h2><p>我们先来看下main函数在初始化过程最后调用的InitServerLast函数。InitServerLast函数的作用是进一步调用bioInit函数，来创建后台线程，让Redis把部分任务交给后台线程处理。这个过程如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void InitServerLast() {</span></div><div class="token-line"><span class="token plain">        bioInit();</span></div><div class="token-line"><span class="token plain">        …</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>bioInit函数是在<a target="_blank" rel="noopener noreferrer" href="https://github.com/redis/redis/tree/5.0/src/bio.c">bio.c<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>文件中实现的，它的主要作用调用pthread_create函数创建多个后台线程。不过在具体了解bioInit函数之前，我们先来看下bio.c文件中定义的主要数组，这也是在bioInit函数中要进行初始化的。</p><p>bio.c文件针对要创建的线程，定义了pthread_t类型的数组bio_threads，用来保存创建的线程描述符。此外，bio.c文件还创建了一个保存互斥锁的数组bio_mutex，以及两个保存条件变量的数组bio_newjob_cond和bio_step_cond。以下代码展示了这些数组的创建逻辑，你可以看下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//保存线程描述符的数组</span></div><div class="token-line"><span class="token plain">    static pthread_t bio_threads[BIO_NUM_OPS]; </span></div><div class="token-line"><span class="token plain">    //保存互斥锁的数组</span></div><div class="token-line"><span class="token plain">    static pthread_mutex_t bio_mutex[BIO_NUM_OPS];</span></div><div class="token-line"><span class="token plain">    //保存条件变量的两个数组</span></div><div class="token-line"><span class="token plain">    static pthread_cond_t bio_newjob_cond[BIO_NUM_OPS];</span></div><div class="token-line"><span class="token plain">    static pthread_cond_t bio_step_cond[BIO_NUM_OPS];</span></div></pre></div><p>从中你可以注意到，这些数组的大小都是宏定义BIO_NUM_OPS，这个宏定义是在<a target="_blank" rel="noopener noreferrer" href="https://github.com/redis/redis/tree/5.0/src/bio.h">bio.h<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>文件中定义的，默认值为3。</p><p>同时在bio.h文件中，你还可以看到另外三个宏定义，分别是BIO_CLOSE_FILE、BIO_AOF_FSYNC和BIO_LAZY_FREE。它们的代码如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#define BIO_CLOSE_FILE    0 /* Deferred close(2) syscall. */</span></div><div class="token-line"><span class="token plain">    #define BIO_AOF_FSYNC    1 /* Deferred AOF fsync. */</span></div><div class="token-line"><span class="token plain">    #define BIO_LAZY_FREE     2 /* Deferred objects freeing. */</span></div><div class="token-line"><span class="token plain">    #define BIO_NUM_OPS       3</span></div></pre></div><p>其中，BIO_NUM_OPS表示的是Redis后台任务的类型有三种。而BIO_CLOSE_FILE、BIO_AOF_FSYNC和BIO_LAZY_FREE，它们分别表示三种后台任务的操作码，这些操作码可以用来标识不同的任务。</p><ul><li><strong>BIO_CLOSE_FILE</strong>：文件关闭后台任务。</li><li><strong>BIO_AOF_FSYNC</strong>：AOF日志同步写回后台任务。</li><li><strong>BIO_LAZY_FREE</strong>：惰性删除后台任务。</li></ul><p>实际上，bio.c文件创建的线程数组、互斥锁数组和条件变量数组，大小都是包含三个元素，也正是对应了这三种任务。</p><h3 id="bioinit函数初始化数组"><a aria-hidden="true" tabindex="-1" href="/blog-two/redis源码剖析与实战/03.事件驱动框架和执行模型模块/05#bioinit函数初始化数组"><span class="icon icon-link"></span></a>bioInit函数：初始化数组</h3><p>接下来，我们再来了解下bio.c文件中的初始化和线程创建函数bioInit。我刚才也给你介绍过这个函数，它是main函数执行完server初始化后，通过InitServerLast函数调用的。也就是说，Redis在完成server初始化后，就会创建线程来执行后台任务。</p><p>所以从这里来看，<strong>Redis在运行时其实已经不止是单个线程（也就是主IO线程）在运行了，还会有后台线程在运行</strong>。如果你以后遇到Redis是否是单线程的问题时，你就可以给出准确答案了。</p><p>bioInit函数首先会初始化互斥锁数组和条件变量数组。然后，该函数会调用listCreate函数，给bio_jobs这个数组的每个元素创建一个列表，同时给bio_pending数组的每个元素赋值为0。这部分代码如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">for (j = 0; j &lt; BIO_NUM_OPS; j++) {</span></div><div class="token-line"><span class="token plain">            pthread_mutex_init(&amp;bio_mutex[j],NULL);</span></div><div class="token-line"><span class="token plain">            pthread_cond_init(&amp;bio_newjob_cond[j],NULL);</span></div><div class="token-line"><span class="token plain">            pthread_cond_init(&amp;bio_step_cond[j],NULL);</span></div><div class="token-line"><span class="token plain">            bio_jobs[j] = listCreate();</span></div><div class="token-line"><span class="token plain">            bio_pending[j] = 0;</span></div><div class="token-line"><span class="token plain">        }</span></div></pre></div><p>那么，要想了解给bio_jobs数组和bio_pending数组元素赋值的作用，我们就需要先搞清楚这两个数组的含义：</p><ul><li><strong>bio_jobs数组</strong>的元素是bio_jobs结构体类型，用来表示后台任务。该结构体的成员变量包括了后台任务的创建时间time，以及任务的参数。为该数组的每个元素创建一个列表，其实就是为每个后台线程创建一个要处理的任务列表。</li><li><strong>bio_pending数组</strong>的元素类型是unsigned long long，用来表示每种任务中，处于等待状态的任务个数。将该数组每个元素初始化为0，其实就是表示初始时，每种任务都没有待处理的具体任务。</li></ul><p>下面的代码展示了bio_job结构体，以及bio_jobs和bio_pending这两个数组的定义，你也可以看下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct bio_job {</span></div><div class="token-line"><span class="token plain">        time_t time; //任务创建时间</span></div><div class="token-line"><span class="token plain">        void *arg1, *arg2, *arg3;  //任务参数</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    //以后台线程方式运行的任务列表</span></div><div class="token-line"><span class="token plain">    static list *bio_jobs[BIO_NUM_OPS];</span></div><div class="token-line"><span class="token plain">    //被阻塞的后台任务数组</span></div><div class="token-line"><span class="token plain">    static unsigned long long bio_pending[BIO_NUM_OPS];</span></div></pre></div><p>好了，到这里，你就了解了bioInit函数执行时，会把线程互斥锁、条件变量对应数组初始化为NULL，同时会给每个后台线程创建一个任务列表（对应bio_jobs数组的元素），以及会设置每种任务的待处理个数为0（对应bio_pending数组的元素）。</p><h3 id="bioinit函数设置线程属性并创建线程"><a aria-hidden="true" tabindex="-1" href="/blog-two/redis源码剖析与实战/03.事件驱动框架和执行模型模块/05#bioinit函数设置线程属性并创建线程"><span class="icon icon-link"></span></a>bioInit函数：设置线程属性并创建线程</h3><p>在完成了初始化之后，接下来，bioInit函数会先通过pthread_attr_t类型的变量，给线程设置属性。然后，bioInit函数会调用前面我提到的pthread_create函数来创建线程。</p><p>不过，为了能更好地理解bioInit函数设置线程属性和创建线程的过程，我们需要先对pthread_create函数本身有所了解，该函数的原型如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int  pthread_create(pthread_t *tidp, const  pthread_attr_t *attr,</span></div><div class="token-line"><span class="token plain">    ( void *)(*start_routine)( void *), void  *arg);</span></div></pre></div><p>可以看到，pthread_create函数一共有4个参数，分别是：</p><ul><li>*<strong>tidp</strong>，指向线程数据结构pthread_t的指针；</li><li>*<strong>attr</strong>，指向线程属性结构pthread_attr_t的指针；</li><li>*<strong>start_routine</strong>，线程所要运行的函数的起始地址，也是指向函数的指针；</li><li>*<strong>arg</strong>，传给运行函数的参数。</li></ul><p>了解了pthread_create函数之后，我们来看下bioInit函数的具体操作。</p><p>首先，bioInit函数会调用pthread_attr_init函数，初始化线程属性变量attr，然后调用pthread_attr_getstacksize函数，获取线程的栈大小这一属性的当前值，并根据当前栈大小和REDIS_THREAD_STACK_SIZE宏定义的大小（默认值为4MB），来计算最终的栈大小属性值。紧接着，bioInit函数会调用pthread_attr_setstacksize函数，来设置栈大小这一属性值。</p><p>下面的代码展示了线程属性的获取、计算和设置逻辑，你可以看下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pthread_attr_init(&amp;attr);</span></div><div class="token-line"><span class="token plain">    pthread_attr_getstacksize(&amp;attr,&amp;stacksize);</span></div><div class="token-line"><span class="token plain">    if (!stacksize) stacksize = 1; /针对Solaris系统做处理</span></div><div class="token-line"><span class="token plain">        while (stacksize &lt; REDIS_THREAD_STACK_SIZE) stacksize *= 2;</span></div><div class="token-line"><span class="token plain">        pthread_attr_setstacksize(&amp;attr, stacksize);</span></div></pre></div><p>我也画了一张图，展示了线程属性的这一操作过程，你可以看下。</p><p><img src="https://static001.geekbang.org/resource/image/0c/9a/0c9a1dd6f5038f05716d916c588d599a.jpg?wh=2000x1125" alt=""/></p><p>在完成线程属性的设置后，接下来，bioInit函数会通过一个for循环，来依次为每种后台任务创建一个线程。循环的次数是由BIO_NUM_OPS宏定义决定的，也就是3次。相应的，bioInit函数就会调用3次pthread_create函数，并创建3个线程。bioInit函数让这3个线程执行的函数都是<strong>bioProcessBackgroundJobs</strong>。</p><p>不过这里要注意一点，就是在这三次线程的创建过程中，传给这个函数的参数分别是0、1、2。这个创建过程如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">for (j = 0; j &lt; BIO_NUM_OPS; j++) {</span></div><div class="token-line"><span class="token plain">            void *arg = (void*)(unsigned long) j;</span></div><div class="token-line"><span class="token plain">            if (pthread_create(&amp;thread,&amp;attr,bioProcessBackgroundJobs,arg) != 0) {</span></div><div class="token-line"><span class="token plain">                … //报错信息</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            bio_threads[j] = thread;</span></div><div class="token-line"><span class="token plain">        }</span></div></pre></div><p>你看了这个代码，可能会有一个小疑问：<strong>为什么创建的3个线程，它们所运行的bioProcessBackgroundJobs函数接收的参数分别是0、1、2呢？</strong></p><p>这就和bioProcessBackgroundJobs函数的实现有关了，我们来具体看下。</p><h3 id="bioprocessbackgroundjobs函数处理后台任务"><a aria-hidden="true" tabindex="-1" href="/blog-two/redis源码剖析与实战/03.事件驱动框架和执行模型模块/05#bioprocessbackgroundjobs函数处理后台任务"><span class="icon icon-link"></span></a>bioProcessBackgroundJobs函数：处理后台任务</h3><p>首先，bioProcessBackgroundJobs函数会把接收到的参数arg，转成unsigned long类型，并赋值给type变量，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void *bioProcessBackgroundJobs(void *arg) {</span></div><div class="token-line"><span class="token plain">        …</span></div><div class="token-line"><span class="token plain">    	unsigned long type = (unsigned long) arg;</span></div><div class="token-line"><span class="token plain">    	…</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>而<strong>type变量表示的就是后台任务的操作码</strong>。这也是我刚才给你介绍的三种后台任务类型BIO_CLOSE_FILE、BIO_AOF_FSYNC和BIO_LAZY_FREE对应的操作码，它们的取值分别为0、1、2。</p><p>bioProcessBackgroundJobs函数的主要执行逻辑是一个while(1)的循环。在这个循环中，bioProcessBackgroundJobs函数会从bio_jobs这个数组中取出相应任务，并根据任务类型，调用具体的函数来执行。</p><p>我刚才已经介绍过，bio_jobs数组的每一个元素是一个队列。而因为bio_jobs数组的元素个数，等于后台任务的类型个数（也就是BIO_NUM_OPS），所以，bio_jobs数组的每个元素，实际上是对应了某一种后台任务的任务队列。</p><p>在了解了这一点后，我们就容易理解bioProcessBackgroundJobs函数中的while循环了。因为传给bioProcessBackgroundJobs函数的参数，分别是0、1、2，对应了三种任务类型，所以在这个循环中，bioProcessBackgroundJobs函数会一直不停地从某一种任务队列中，取出一个任务来执行。</p><p>同时，bioProcessBackgroundJobs函数会根据传入的任务操作类型调用相应函数，具体来说：</p><ul><li>任务类型是BIO_CLOSE_FILE，则调用close函数；</li><li>任务类型是BIO_AOF_FSYNC，则调用redis_fsync函数；</li><li>任务类型是BIO_LAZY_FREE，则再根据参数个数等情况，分别调用lazyfreeFreeObjectFromBioThread、lazyfreeFreeDatabaseFromBioThread和lazyfreeFreeSlotsMapFromBioThread这三个函数。</li></ul><p>最后，当某个任务执行完成后，bioProcessBackgroundJobs函数会从任务队列中，把这个任务对应的数据结构删除。我把这部分代码放在这里，你可以看下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">while(1) {</span></div><div class="token-line"><span class="token plain">            listNode *ln;</span></div><div class="token-line"><span class="token plain">     </span></div><div class="token-line"><span class="token plain">            …</span></div><div class="token-line"><span class="token plain">            //从类型为type的任务队列中获取第一个任务</span></div><div class="token-line"><span class="token plain">            ln = listFirst(bio_jobs[type]);</span></div><div class="token-line"><span class="token plain">            job = ln-&gt;value;</span></div><div class="token-line"><span class="token plain">            </span></div><div class="token-line"><span class="token plain">            …</span></div><div class="token-line"><span class="token plain">            //判断当前处理的后台任务类型是哪一种</span></div><div class="token-line"><span class="token plain">            if (type == BIO_CLOSE_FILE) {</span></div><div class="token-line"><span class="token plain">                close((long)job-&gt;arg1);  //如果是关闭文件任务，那就调用close函数</span></div><div class="token-line"><span class="token plain">            } else if (type == BIO_AOF_FSYNC) {</span></div><div class="token-line"><span class="token plain">                redis_fsync((long)job-&gt;arg1); //如果是AOF同步写任务，那就调用redis_fsync函数</span></div><div class="token-line"><span class="token plain">            } else if (type == BIO_LAZY_FREE) {</span></div><div class="token-line"><span class="token plain">                //如果是惰性删除任务，那根据任务的参数分别调用不同的惰性删除函数执行</span></div><div class="token-line"><span class="token plain">                if (job-&gt;arg1)</span></div><div class="token-line"><span class="token plain">                    lazyfreeFreeObjectFromBioThread(job-&gt;arg1);</span></div><div class="token-line"><span class="token plain">                else if (job-&gt;arg2 &amp;&amp; job-&gt;arg3)</span></div><div class="token-line"><span class="token plain">                    lazyfreeFreeDatabaseFromBioThread(job-&gt;arg2,job-&gt;arg3);</span></div><div class="token-line"><span class="token plain">                else if (job-&gt;arg3)</span></div><div class="token-line"><span class="token plain">                    lazyfreeFreeSlotsMapFromBioThread(job-&gt;arg3);</span></div><div class="token-line"><span class="token plain">            } else {</span></div><div class="token-line"><span class="token plain">                serverPanic(&quot;Wrong job type in bioProcessBackgroundJobs().&quot;);</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            …</span></div><div class="token-line"><span class="token plain">            //任务执行完成后，调用listDelNode在任务队列中删除该任务</span></div><div class="token-line"><span class="token plain">            listDelNode(bio_jobs[type],ln);</span></div><div class="token-line"><span class="token plain">            //将对应的等待任务个数减一。</span></div><div class="token-line"><span class="token plain">            bio_pending[type]--;</span></div><div class="token-line"><span class="token plain">            …</span></div><div class="token-line"><span class="token plain">        }</span></div></pre></div><p>所以说，bioInit函数其实就是创建了3个线程，每个线程不停地去查看任务队列中是否有任务，如果有任务，就调用具体函数执行。</p><p>你可以再参考回顾下图所展示的bioInit函数和bioProcessBackgroundJobs函数的基本处理流程。</p><p><img src="https://static001.geekbang.org/resource/image/d8/c4/d8cb6f9f2e410e7680ef0e674b50efc4.jpg?wh=2000x1125" alt=""/></p><p>不过接下来你或许还会疑惑：既然bioProcessBackgroundJobs函数是负责执行任务的，<strong>那么哪个函数负责生成任务呢？</strong></p><p>这就是下面，我要给你介绍的<strong>后台任务创建函数bioCreateBackgroundJob</strong>。</p><h3 id="biocreatebackgroundjob函数创建后台任务"><a aria-hidden="true" tabindex="-1" href="/blog-two/redis源码剖析与实战/03.事件驱动框架和执行模型模块/05#biocreatebackgroundjob函数创建后台任务"><span class="icon icon-link"></span></a>bioCreateBackgroundJob函数：创建后台任务</h3><p>bioCreateBackgroundJob函数的原型如下，它会接收4个参数，其中，参数type表示该后台任务的类型，剩下来的3个参数，则对应了后台任务函数的参数，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void bioCreateBackgroundJob(int type, void *arg1, void *arg2, void *arg3)</span></div></pre></div><p>bioCreateBackgroundJob函数在执行时，会先创建bio_job，这是后台任务对应的数据结构。然后，后台任务数据结构中的参数，会被设置为bioCreateBackgroundJob函数传入的参数arg1、arg2和arg3。</p><p>最后，bioCreateBackgroundJob函数调用listAddNodeTail函数，将刚才创建的任务加入到对应的bio_jobs队列中，同时，将bio_pending数组的对应值加1，表示有个任务在等待执行。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">{</span></div><div class="token-line"><span class="token plain">        //创建新的任务</span></div><div class="token-line"><span class="token plain">        struct bio_job *job = zmalloc(sizeof(*job));</span></div><div class="token-line"><span class="token plain">        //设置任务数据结构中的参数</span></div><div class="token-line"><span class="token plain">        job-&gt;time = time(NULL);</span></div><div class="token-line"><span class="token plain">        job-&gt;arg1 = arg1;</span></div><div class="token-line"><span class="token plain">        job-&gt;arg2 = arg2;</span></div><div class="token-line"><span class="token plain">        job-&gt;arg3 = arg3;</span></div><div class="token-line"><span class="token plain">        pthread_mutex_lock(&amp;bio_mutex[type]);</span></div><div class="token-line"><span class="token plain">        listAddNodeTail(bio_jobs[type],job);  //将任务加到bio_jobs数组的对应任务列表中</span></div><div class="token-line"><span class="token plain">        bio_pending[type]++; //将对应任务列表上等待处理的任务个数加1</span></div><div class="token-line"><span class="token plain">        pthread_cond_signal(&amp;bio_newjob_cond[type]);</span></div><div class="token-line"><span class="token plain">        pthread_mutex_unlock(&amp;bio_mutex[type]);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>好了，这样一来，当Redis进程想要启动一个后台任务时，只要调用bioCreateBackgroundJob函数，并设置好该任务对应的类型和参数即可。然后，bioCreateBackgroundJob函数就会把创建好的任务数据结构，放到后台任务对应的队列中。另一方面，bioInit函数在Redis server启动时，创建的线程会不断地轮询后台任务队列，一旦发现有任务可以执行，就会将该任务取出并执行。</p><p>其实，这种设计方式是典型的<strong>生产者-消费者模型</strong>。bioCreateBackgroundJob函数是生产者，负责往每种任务队列中加入要执行的后台任务，而bioProcessBackgroundJobs函数是消费者，负责从每种任务队列中取出任务来执行。然后Redis创建的后台线程，会调用bioProcessBackgroundJobs函数，从而实现一直循环检查任务队列。</p><p>下图展示的就是bioCreateBackgroundJob和bioProcessBackgroundJobs两者间的生产者-消费者模型，你可以看下。</p><p><img src="https://static001.geekbang.org/resource/image/f5/ab/f5a7c20b6a826cf79c0675d11ea037ab.jpg?wh=2000x850" alt=""/></p><p>好了，到这里，我们就学习了Redis后台线程的创建和运行机制。简单来说，主要是以下三个关键点：</p><ul><li>Redis是先通过bioInit函数初始化和创建后台线程；</li><li>后台线程运行的是bioProcessBackgroundJobs函数，这个函数会轮询任务队列，并根据要处理的任务类型，调用相应函数进行处理；</li><li>后台线程要处理的任务是由bioCreateBackgroundJob函数来创建的，这些任务创建后会被放到任务队列中，等待bioProcessBackgroundJobs函数处理。</li></ul><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-two/redis源码剖析与实战/03.事件驱动框架和执行模型模块/05#小结"><span class="icon icon-link"></span></a>小结</h2><p>今天这节课，我给你介绍了Redis的执行模型，并且也从源码的角度出发，通过分析代码，带你了解了Redis进程创建、以子进程方式创建的守护进程、以及后台线程和它们负责的工作任务。同时，这也解答了你在面试中可能经常会被问到的问题：<strong>Redis是单线程程序吗？</strong></p><p>事实上，Redis server启动后，它的主要工作包括接收客户端请求、解析请求和进行数据读写等操作，是由单线程来执行的，这也是我们常说Redis是单线程程序的原因。</p><p>但是，学完这节课你应该也知道，Redis还启动了3个线程来执行文件关闭、AOF同步写和惰性删除等操作，从这个角度来说，Redis又不能算单线程程序，它还是有多线程的。而且，在下节课，我会给你介绍Redis 6.0中多IO线程的实现，从多IO线程角度看，Redis也无法称为是单线程程序了。</p><p>另外学完了这节课之后，你还需要重点注意下，fork函数使用和生产者-消费者模型这两个关键知识点。</p><p><strong>首先是fork函数的使用</strong>。fork函数可以在一个进程运行时，再创建一个子进程。当Redis被配置为以守护进程方式运行时，Redis的main函数就是调用fork函数，创建子进程，让子进程以守护进程形式执行，并让一开始启动执行的父进程退出。因为，子进程会从父进程那继承代码，所以main函数中的执行逻辑就交给了子进程继续执行。</p><p><strong>其次是生产者-消费者模型</strong>。Redis在bio.c和bio.h文件中创建了后台线程，并实现了后台任务的执行。你要重点关注一下这里使用的生产者-消费者执行模型，这也是bio.c实现后台任务执行的核心设计思想。而且，当你需要实现异步的任务执行时，生产者-消费者模型就是一个很好的解决方案，你可以从Redis源码中掌握这个方案的实现思路。</p><h2 id="每课一问"><a aria-hidden="true" tabindex="-1" href="/blog-two/redis源码剖析与实战/03.事件驱动框架和执行模型模块/05#每课一问"><span class="icon icon-link"></span></a>每课一问</h2><p>Redis后台任务使用bio_job结构体来描述，该结构体用了三个指针变量来表示任务参数，如下所示。如果我们创建的任务，所需要的参数大于3个，你有什么应对方法来传参么？</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct bio_job {</span></div><div class="token-line"><span class="token plain">        time_t time;</span></div><div class="token-line"><span class="token plain">        void *arg1, *arg2, *arg3;  //传递给任务的参数</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>欢迎在留言区分享你的答案和思考过程，如果觉得有收获，也欢迎你把今天的内容分享给更多的朋友。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/redis源码剖析与实战/03.事件驱动框架和执行模型模块/05.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:22</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
