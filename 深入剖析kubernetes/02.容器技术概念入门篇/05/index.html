<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>09 | 从容器到容器云：谈谈Kubernetes的本质</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/深入剖析kubernetes/02.容器技术概念入门篇/05" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a aria-current="page" class="active" href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a aria-current="page" class="active" href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/深入剖析kubernetes/01.课前必读">01.课前必读</a><ul><li><a href="/blog-two/深入剖析kubernetes/01.课前必读/01"><span>开篇词 | 打通“容器技术”的任督二脉</span></a></li><li><a href="/blog-two/深入剖析kubernetes/01.课前必读/02"><span>01 | 预习篇 · 小鲸鱼大事记（一）：初出茅庐</span></a></li><li><a href="/blog-two/深入剖析kubernetes/01.课前必读/03"><span>02 | 预习篇 · 小鲸鱼大事记（二）：崭露头角</span></a></li><li><a href="/blog-two/深入剖析kubernetes/01.课前必读/04"><span>03 | 预习篇 · 小鲸鱼大事记（三）：群雄并起</span></a></li><li><a href="/blog-two/深入剖析kubernetes/01.课前必读/05"><span>04 | 预习篇 · 小鲸鱼大事记（四）：尘埃落定</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇">02.容器技术概念入门篇</a><ul><li><a href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇/01"><span>05 | 白话容器基础（一）：从进程说开去</span></a></li><li><a href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇/02"><span>06 | 白话容器基础（二）：隔离与限制</span></a></li><li><a href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇/03"><span>07 | 白话容器基础（三）：深入理解容器镜像</span></a></li><li><a href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇/04"><span>08 | 白话容器基础（四）：重新认识Docker容器</span></a></li><li><a aria-current="page" class="active" href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇/05"><span>09 | 从容器到容器云：谈谈Kubernetes的本质</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/03.kubernetes集群搭建与实践">03.Kubernetes集群搭建与实践</a><ul><li><a href="/blog-two/深入剖析kubernetes/03.kubernetes集群搭建与实践/01"><span>10 | Kubernetes一键部署利器：kubeadm</span></a></li><li><a href="/blog-two/深入剖析kubernetes/03.kubernetes集群搭建与实践/02"><span>11 | 从0到1：搭建一个完整的Kubernetes集群</span></a></li><li><a href="/blog-two/深入剖析kubernetes/03.kubernetes集群搭建与实践/03"><span>12 | 牛刀小试：我的第一个容器化应用</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理">04.容器编排与Kubernetes作业管理</a><ul><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/01"><span>13 | 为什么我们需要Pod？</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/02"><span>14 | 深入解析Pod对象（一）：基本概念</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/03"><span>15 | 深入解析Pod对象（二）：使用进阶</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/04"><span>16 | 编排其实很简单：谈谈“控制器”模型</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/05"><span>17 | 经典PaaS的记忆：作业副本与水平扩展</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/06"><span>18 | 深入理解StatefulSet（一）：拓扑状态</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/07"><span>19 | 深入理解StatefulSet（二）：存储状态</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/08"><span>20 | 深入理解StatefulSet（三）：有状态应用实践</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/09"><span>21 | 容器化守护进程的意义：DaemonSet</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/10"><span>22 | 撬动离线业务：Job与CronJob</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/11"><span>23 | 声明式API与Kubernetes编程范式</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/12"><span>24 | 深入解析声明式API（一）：API对象的奥秘</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/13"><span>25 | 深入解析声明式API（二）：编写自定义控制器</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/14"><span>26 | 基于角色的权限控制：RBAC</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/15"><span>27 | 聪明的微创新：Operator工作原理解读</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/05.kubernetes容器持久化存储">05.Kubernetes容器持久化存储</a><ul><li><a href="/blog-two/深入剖析kubernetes/05.kubernetes容器持久化存储/01"><span>28 | PV、PVC、StorageClass，这些到底在说啥？</span></a></li><li><a href="/blog-two/深入剖析kubernetes/05.kubernetes容器持久化存储/02"><span>29 | PV、PVC体系是不是多此一举？从本地持久化卷谈起</span></a></li><li><a href="/blog-two/深入剖析kubernetes/05.kubernetes容器持久化存储/03"><span>30 | 编写自己的存储插件：FlexVolume与CSI</span></a></li><li><a href="/blog-two/深入剖析kubernetes/05.kubernetes容器持久化存储/04"><span>31 | 容器存储实践：CSI插件编写指南</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络">06.Kubernetes容器网络</a><ul><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/01"><span>32 | 浅谈容器网络</span></a></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/02"><span>33 | 深入解析容器跨主机网络</span></a></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/03"><span>34 | Kubernetes网络模型与CNI网络插件</span></a></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/04"><span>35 | 解读Kubernetes三层网络方案</span></a></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/05"><span>36 | 为什么说Kubernetes只有soft multi-tenancy？</span></a></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/06"><span>37 | 找到容器不容易：Service、DNS与服务发现</span></a></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/07"><span>38 | 从外界连通Service与Service调试“三板斧”</span></a></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/08"><span>39 | 谈谈Service与Ingress</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/07.kubernetes作业调度与资源管理">07.Kubernetes作业调度与资源管理</a><ul><li><a href="/blog-two/深入剖析kubernetes/07.kubernetes作业调度与资源管理/01"><span>40 | Kubernetes的资源模型与资源管理</span></a></li><li><a href="/blog-two/深入剖析kubernetes/07.kubernetes作业调度与资源管理/02"><span>41 | 十字路口上的Kubernetes默认调度器</span></a></li><li><a href="/blog-two/深入剖析kubernetes/07.kubernetes作业调度与资源管理/03"><span>42 | Kubernetes默认调度器调度策略解析</span></a></li><li><a href="/blog-two/深入剖析kubernetes/07.kubernetes作业调度与资源管理/04"><span>43 | Kubernetes默认调度器的优先级与抢占机制</span></a></li><li><a href="/blog-two/深入剖析kubernetes/07.kubernetes作业调度与资源管理/05"><span>44 | Kubernetes GPU管理与Device Plugin机制</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/08.kubernetes容器运行时">08.Kubernetes容器运行时</a><ul><li><a href="/blog-two/深入剖析kubernetes/08.kubernetes容器运行时/01"><span>45 | 幕后英雄：SIG-Node与CRI</span></a></li><li><a href="/blog-two/深入剖析kubernetes/08.kubernetes容器运行时/02"><span>46 | 解读 CRI 与 容器运行时</span></a></li><li><a href="/blog-two/深入剖析kubernetes/08.kubernetes容器运行时/03"><span>47 | 绝不仅仅是安全：Kata Containers 与 gVisor</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/09.kubernetes容器监控与日志">09.Kubernetes容器监控与日志</a><ul><li><a href="/blog-two/深入剖析kubernetes/09.kubernetes容器监控与日志/01"><span>48 | Prometheus、Metrics Server与Kubernetes监控体系</span></a></li><li><a href="/blog-two/深入剖析kubernetes/09.kubernetes容器监控与日志/02"><span>49 | Custom Metrics: 让Auto Scaling不再“食之无味”</span></a></li><li><a href="/blog-two/深入剖析kubernetes/09.kubernetes容器监控与日志/03"><span>50 | 让日志无处可逃：容器日志收集与管理</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/10.再谈开源与社区">10.再谈开源与社区</a><ul><li><a href="/blog-two/深入剖析kubernetes/10.再谈开源与社区/01"><span>51 | 谈谈Kubernetes开源社区和未来走向</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/11.答疑文章">11.答疑文章</a><ul><li><a href="/blog-two/深入剖析kubernetes/11.答疑文章/01"><span>52 | 答疑：在问题中解决问题，在思考中产生思考</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/12.特别放送">12.特别放送</a><ul><li><a href="/blog-two/深入剖析kubernetes/12.特别放送/01"><span>特别放送 | 2019 年，容器技术生态会发生些什么？</span></a></li><li><a href="/blog-two/深入剖析kubernetes/12.特别放送/02"><span>特别放送 | 基于 Kubernetes 的云原生应用管理，到底应该怎么做？</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/13.结束语">13.结束语</a><ul><li><a href="/blog-two/深入剖析kubernetes/13.结束语/01"><span>结束语 | Kubernetes：赢开发者赢天下</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/14.结课测试">14.结课测试</a><ul><li><a href="/blog-two/深入剖析kubernetes/14.结课测试/01"><span>结课测试｜这些Kubernetes的相关知识，你都掌握了吗？</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/summary">深入剖析kubernetes</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="总结" data-depth="2"><a href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇/05#总结"><span>总结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇/05#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="09--从容器到容器云谈谈kubernetes的本质"><a aria-hidden="true" tabindex="-1" href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇/05#09--从容器到容器云谈谈kubernetes的本质"><span class="icon icon-link"></span></a>09 | 从容器到容器云：谈谈Kubernetes的本质</h1><p>你好，我是张磊。今天我和你分享的主题是：从容器到容器云，谈谈Kubernetes的本质。</p><p>在前面的四篇文章中，我以Docker项目为例，一步步剖析了Linux容器的具体实现方式。通过这些讲解你应该能够明白：一个“容器”，实际上是一个由Linux Namespace、Linux Cgroups和rootfs三种技术构建出来的进程的隔离环境。</p><p>从这个结构中我们不难看出，一个正在运行的Linux容器，其实可以被“一分为二”地看待：</p><ol><li><p>一组联合挂载在/var/lib/docker/aufs/mnt上的rootfs，这一部分我们称为“容器镜像”（Container Image），是容器的静态视图；</p></li><li><p>一个由Namespace+Cgroups构成的隔离环境，这一部分我们称为“容器运行时”（Container Runtime），是容器的动态视图。</p></li></ol><p>更进一步地说，作为一名开发者，我并不关心容器运行时的差异。因为，在整个“开发-测试-发布”的流程中，真正承载着容器信息进行传递的，是容器镜像，而不是容器运行时。</p><p>这个重要假设，正是容器技术圈在Docker项目成功后不久，就迅速走向了“容器编排”这个“上层建筑”的主要原因：作为一家云服务商或者基础设施提供商，我只要能够将用户提交的Docker镜像以容器的方式运行起来，就能成为这个非常热闹的容器生态图上的一个承载点，从而将整个容器技术栈上的价值，沉淀在我的这个节点上。</p><p>更重要的是，只要从我这个承载点向Docker镜像制作者和使用者方向回溯，整条路径上的各个服务节点，比如CI/CD、监控、安全、网络、存储等等，都有我可以发挥和盈利的余地。这个逻辑，正是所有云计算提供商如此热衷于容器技术的重要原因：通过容器镜像，它们可以和潜在用户（即，开发者）直接关联起来。</p><p>从一个开发者和单一的容器镜像，到无数开发者和庞大的容器集群，容器技术实现了从“容器”到“容器云”的飞跃，标志着它真正得到了市场和生态的认可。</p><p>这样，<strong>容器就从一个开发者手里的小工具，一跃成为了云计算领域的绝对主角；而能够定义容器组织和管理规范的“容器编排”技术，则当仁不让地坐上了容器技术领域的“头把交椅”。</strong></p><p>这其中，最具代表性的容器编排工具，当属Docker公司的Compose+Swarm组合，以及Google与RedHat公司共同主导的Kubernetes项目。</p><p>我在前面介绍容器技术发展历史的四篇预习文章中，已经对这两个开源项目做了详细的剖析和评述。所以，在今天的这次分享中，我会专注于本专栏的主角Kubernetes项目，谈一谈它的设计与架构。</p><p>跟很多基础设施领域先有工程实践、后有方法论的发展路线不同，Kubernetes项目的理论基础则要比工程实践走得靠前得多，这当然要归功于Google公司在2015年4月发布的Borg论文了。</p><p>Borg系统，一直以来都被誉为Google公司内部最强大的“秘密武器”。虽然略显夸张，但这个说法倒不算是吹牛。</p><p>因为，相比于Spanner、BigTable等相对上层的项目，Borg要承担的责任，是承载Google公司整个基础设施的核心依赖。在Google公司已经公开发表的基础设施体系论文中，Borg项目当仁不让地位居整个基础设施技术栈的最底层。</p><p><img src="https://static001.geekbang.org/resource/image/c7/bd/c7ed0043465bccff2efc1a1257e970bd.png" alt=""/><br/>图片来源：<a target="_blank" rel="noopener noreferrer" href="http://malteschwarzkopf.de/research/assets/google-stack.pdf">Malte Schwarzkopf. “Operating system support for warehouse-scale computing”. PhD thesis. University of Cambridge Computer Laboratory (to appear), 2015, Chapter 2.<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>上面这幅图，来自于Google Omega论文的第一作者的博士毕业论文。它描绘了当时Google已经公开发表的整个基础设施栈。在这个图里，你既可以找到MapReduce、BigTable等知名项目，也能看到Borg和它的继任者Omega位于整个技术栈的最底层。</p><p>正是由于这样的定位，Borg可以说是Google最不可能开源的一个项目。而幸运的是，得益于Docker项目和容器技术的风靡，它却终于得以以另一种方式与开源社区见面，这个方式就是Kubernetes项目。</p><p>所以，相比于“小打小闹”的Docker公司、“旧瓶装新酒”的Mesos社区，<strong>Kubernetes项目从一开始就比较幸运地站上了一个他人难以企及的高度</strong>：在它的成长阶段，这个项目每一个核心特性的提出，几乎都脱胎于Borg/Omega系统的设计与经验。更重要的是，这些特性在开源社区落地的过程中，又在整个社区的合力之下得到了极大的改进，修复了很多当年遗留在Borg体系中的缺陷和问题。</p><p>所以，尽管在发布之初被批评是“曲高和寡”，但是在逐渐觉察到Docker技术栈的“稚嫩”和Mesos社区的“老迈”之后，这个社区很快就明白了：Kubernetes项目在Borg体系的指导下，体现出了一种独有的“先进性”与“完备性”，而这些特质才是一个基础设施领域开源项目赖以生存的核心价值。</p><p>为了更好地理解这两种特质，我们不妨从Kubernetes的顶层设计说起。</p><p>首先，Kubernetes项目要解决的问题是什么？</p><p>编排？调度？容器云？还是集群管理？</p><p>实际上，这个问题到目前为止都没有固定的答案。因为在不同的发展阶段，Kubernetes需要着重解决的问题是不同的。</p><p>但是，对于大多数用户来说，他们希望Kubernetes项目带来的体验是确定的：现在我有了应用的容器镜像，请帮我在一个给定的集群上把这个应用运行起来。</p><p>更进一步地说，我还希望Kubernetes能给我提供路由网关、水平扩展、监控、备份、灾难恢复等一系列运维能力。</p><p>等一下，这些功能听起来好像有些耳熟？这不就是经典PaaS（比如，Cloud Foundry）项目的能力吗？</p><p>而且，有了Docker之后，我根本不需要什么Kubernetes、PaaS，只要使用Docker公司的Compose+Swarm项目，就完全可以很方便地DIY出这些功能了！</p><p>所以说，如果Kubernetes项目只是停留在拉取用户镜像、运行容器，以及提供常见的运维功能的话，那么别说跟“原生”的Docker Swarm项目竞争了，哪怕跟经典的PaaS项目相比也难有什么优势可言。</p><p>而实际上，在定义核心功能的过程中，Kubernetes项目正是依托着Borg项目的理论优势，才在短短几个月内迅速站稳了脚跟，进而确定了一个如下图所示的全局架构：</p><p><img src="https://static001.geekbang.org/resource/image/8e/67/8ee9f2fa987eccb490cfaa91c6484f67.png" alt=""/></p><p>我们可以看到，Kubernetes项目的架构，跟它的原型项目Borg非常类似，都由Master和Node两种节点组成，而这两种角色分别对应着控制节点和计算节点。</p><p>其中，控制节点，即Master节点，由三个紧密协作的独立组件组合而成，它们分别是负责API服务的kube-apiserver、负责调度的kube-scheduler，以及负责容器编排的kube-controller-manager。整个集群的持久化数据，则由kube-apiserver处理后保存在Etcd中。</p><p>而计算节点上最核心的部分，则是一个叫作kubelet的组件。</p><p><strong>在Kubernetes项目中，kubelet主要负责同容器运行时（比如Docker项目）打交道</strong>。而这个交互所依赖的，是一个称作CRI（Container Runtime Interface）的远程调用接口，这个接口定义了容器运行时的各项核心操作，比如：启动一个容器需要的所有参数。</p><p>这也是为何，Kubernetes项目并不关心你部署的是什么容器运行时、使用的什么技术实现，只要你的这个容器运行时能够运行标准的容器镜像，它就可以通过实现CRI接入到Kubernetes项目当中。</p><p>而具体的容器运行时，比如Docker项目，则一般通过OCI这个容器运行时规范同底层的Linux操作系统进行交互，即：把CRI请求翻译成对Linux操作系统的调用（操作Linux Namespace和Cgroups等）。</p><p><strong>此外，kubelet还通过gRPC协议同一个叫作Device Plugin的插件进行交互</strong>。这个插件，是Kubernetes项目用来管理GPU等宿主机物理设备的主要组件，也是基于Kubernetes项目进行机器学习训练、高性能作业支持等工作必须关注的功能。</p><p>而<strong>kubelet的另一个重要功能，则是调用网络插件和存储插件为容器配置网络和持久化存储</strong>。这两个插件与kubelet进行交互的接口，分别是CNI（Container Networking Interface）和CSI（Container Storage Interface）。</p><p>实际上，kubelet这个奇怪的名字，来自于Borg项目里的同源组件Borglet。不过，如果你浏览过Borg论文的话，就会发现，这个命名方式可能是kubelet组件与Borglet组件的唯一相似之处。因为Borg项目，并不支持我们这里所讲的容器技术，而只是简单地使用了Linux Cgroups对进程进行限制。</p><p>这就意味着，像Docker这样的“容器镜像”在Borg中是不存在的，Borglet组件也自然不需要像kubelet这样考虑如何同Docker进行交互、如何对容器镜像进行管理的问题，也不需要支持CRI、CNI、CSI等诸多容器技术接口。</p><p>可以说，kubelet完全就是为了实现Kubernetes项目对容器的管理能力而重新实现的一个组件，与Borg之间并没有直接的传承关系。</p><blockquote><p>备注：虽然不使用Docker，但Google内部确实在使用一个包管理工具，名叫Midas Package Manager (MPM)，其实它可以部分取代Docker镜像的角色。</p></blockquote><p>那么，Borg对于Kubernetes项目的指导作用又体现在哪里呢？</p><p>答案是，Master节点。</p><p>虽然在Master节点的实现细节上Borg项目与Kubernetes项目不尽相同，但它们的出发点却高度一致，即：如何编排、管理、调度用户提交的作业？</p><p>所以，Borg项目完全可以把Docker镜像看作一种新的应用打包方式。这样，Borg团队过去在大规模作业管理与编排上的经验就可以直接“套”在Kubernetes项目上了。</p><p>这些经验最主要的表现就是，<strong>从一开始，Kubernetes项目就没有像同时期的各种“容器云”项目那样，把Docker作为整个架构的核心，而仅仅把它作为最底层的一个容器运行时实现。</strong></p><p>而Kubernetes项目要着重解决的问题，则来自于Borg的研究人员在论文中提到的一个非常重要的观点：</p><blockquote><p>运行在大规模集群中的各种任务之间，实际上存在着各种各样的关系。这些关系的处理，才是作业编排和管理系统最困难的地方。</p></blockquote><p>事实也正是如此。</p><p>其实，这种任务与任务之间的关系，在我们平常的各种技术场景中随处可见。比如，一个Web应用与数据库之间的访问关系，一个负载均衡器和它的后端服务之间的代理关系，一个门户应用与授权组件之间的调用关系。</p><p>更进一步地说，同属于一个服务单位的不同功能之间，也完全可能存在这样的关系。比如，一个Web应用与日志搜集组件之间的文件交换关系。</p><p>而在容器技术普及之前，传统虚拟机环境对这种关系的处理方法都是比较“粗粒度”的。你会经常发现很多功能并不相关的应用被一股脑儿地部署在同一台虚拟机中，只是因为它们之间偶尔会互相发起几个HTTP请求。</p><p>更常见的情况则是，一个应用被部署在虚拟机里之后，你还得手动维护很多跟它协作的守护进程（Daemon），用来处理它的日志搜集、灾难恢复、数据备份等辅助工作。</p><p>但容器技术出现以后，你就不难发现，在“功能单位”的划分上，容器有着独一无二的“细粒度”优势：毕竟容器的本质，只是一个进程而已。</p><p>也就是说，只要你愿意，那些原先拥挤在同一个虚拟机里的各个应用、组件、守护进程，都可以被分别做成镜像，然后运行在一个个专属的容器中。它们之间互不干涉，拥有各自的资源配额，可以被调度在整个集群里的任何一台机器上。而这，正是一个PaaS系统最理想的工作状态，也是所谓“微服务”思想得以落地的先决条件。</p><p>当然，如果只做到“封装微服务、调度单容器”这一层次，Docker Swarm项目就已经绰绰有余了。如果再加上Compose项目，你甚至还具备了处理一些简单依赖关系的能力，比如：一个“Web容器”和它要访问的数据库“DB容器”。</p><p>在Compose项目中，你可以为这样的两个容器定义一个“link”，而Docker项目则会负责维护这个“link”关系，其具体做法是：Docker会在Web容器中，将DB容器的IP地址、端口等信息以环境变量的方式注入进去，供应用进程使用，比如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">DB_NAME=/web/db</span></div><div class="token-line"><span class="token plain">        DB_PORT=tcp://172.17.0.5:5432</span></div><div class="token-line"><span class="token plain">        DB_PORT_5432_TCP=tcp://172.17.0.5:5432</span></div><div class="token-line"><span class="token plain">        DB_PORT_5432_TCP_PROTO=tcp</span></div><div class="token-line"><span class="token plain">        DB_PORT_5432_TCP_PORT=5432</span></div><div class="token-line"><span class="token plain">        DB_PORT_5432_TCP_ADDR=172.17.0.5</span></div></pre></div><p>而当DB容器发生变化时（比如，镜像更新，被迁移到其他宿主机上等等），这些环境变量的值会由Docker项目自动更新。<strong>这就是平台项目自动地处理容器间关系的典型例子。</strong></p><p>可是，如果我们现在的需求是，要求这个项目能够处理前面提到的所有类型的关系，甚至还要能够支持未来可能出现的更多种类的关系呢？</p><p>这时，“link”这种单独针对一种案例设计的解决方案就太过简单了。如果你做过架构方面的工作，就会深有感触：一旦要追求项目的普适性，那就一定要从顶层开始做好设计。</p><p>所以，<strong>Kubernetes项目最主要的设计思想是，从更宏观的角度，以统一的方式来定义任务之间的各种关系，并且为将来支持更多种类的关系留有余地。</strong></p><p>比如，Kubernetes项目对容器间的“访问”进行了分类，首先总结出了一类非常常见的“紧密交互”的关系，即：这些应用之间需要非常频繁的交互和访问；又或者，它们会直接通过本地文件进行信息交换。</p><p>在常规环境下，这些应用往往会被直接部署在同一台机器上，通过Localhost通信，通过本地磁盘目录交换文件。而在Kubernetes项目中，这些容器则会被划分为一个“Pod”，Pod里的容器共享同一个Network Namespace、同一组数据卷，从而达到高效率交换信息的目的。</p><p>Pod是Kubernetes项目中最基础的一个对象，源自于Google Borg论文中一个名叫Alloc的设计。在后续的章节中，我们会对Pod做更进一步地阐述。</p><p>而对于另外一种更为常见的需求，比如Web应用与数据库之间的访问关系，Kubernetes项目则提供了一种叫作“Service”的服务。像这样的两个应用，往往故意不部署在同一台机器上，这样即使Web应用所在的机器宕机了，数据库也完全不受影响。可是，我们知道，对于一个容器来说，它的IP地址等信息不是固定的，那么Web应用又怎么找到数据库容器的Pod呢？</p><p>所以，Kubernetes项目的做法是给Pod绑定一个Service服务，而Service服务声明的IP地址等信息是“终生不变”的。这个<strong>Service服务的主要作用，就是作为Pod的代理入口（Portal），从而代替Pod对外暴露一个固定的网络地址</strong>。</p><p>这样，对于Web应用的Pod来说，它需要关心的就是数据库Pod的Service信息。不难想象，Service后端真正代理的Pod的IP地址、端口等信息的自动更新、维护，则是Kubernetes项目的职责。</p><p>像这样，围绕着容器和Pod不断向真实的技术场景扩展，我们就能够摸索出一幅如下所示的Kubernetes项目核心功能的“全景图”。</p><p><img src="https://static001.geekbang.org/resource/image/16/06/16c095d6efb8d8c226ad9b098689f306.png" alt=""/></p><p>按照这幅图的线索，我们从容器这个最基础的概念出发，首先遇到了容器间“紧密协作”关系的难题，于是就扩展到了Pod；有了Pod之后，我们希望能一次启动多个应用的实例，这样就需要Deployment这个Pod的多实例管理器；而有了这样一组相同的Pod后，我们又需要通过一个固定的IP地址和端口以负载均衡的方式访问它，于是就有了Service。</p><p>可是，如果现在两个不同Pod之间不仅有“访问关系”，还要求在发起时加上授权信息。最典型的例子就是Web应用对数据库访问时需要Credential（数据库的用户名和密码）信息。那么，在Kubernetes中这样的关系又如何处理呢？</p><p>Kubernetes项目提供了一种叫作Secret的对象，它其实是一个保存在Etcd里的键值对数据。这样，你把Credential信息以Secret的方式存在Etcd里，Kubernetes就会在你指定的Pod（比如，Web应用的Pod）启动时，自动把Secret里的数据以Volume的方式挂载到容器里。这样，这个Web应用就可以访问数据库了。</p><p><strong>除了应用与应用之间的关系外，应用运行的形态是影响“如何容器化这个应用”的第二个重要因素。</strong></p><p>为此，Kubernetes定义了新的、基于Pod改进后的对象。比如Job，用来描述一次性运行的Pod（比如，大数据任务）；再比如DaemonSet，用来描述每个宿主机上必须且只能运行一个副本的守护进程服务；又比如CronJob，则用于描述定时任务等等。</p><p>如此种种，正是Kubernetes项目定义容器间关系和形态的主要方法。</p><p>可以看到，Kubernetes项目并没有像其他项目那样，为每一个管理功能创建一个指令，然后在项目中实现其中的逻辑。这种做法，的确可以解决当前的问题，但是在更多的问题来临之后，往往会力不从心。</p><p>相比之下，在Kubernetes项目中，我们所推崇的使用方法是：</p><ul><li>首先，通过一个“编排对象”，比如Pod、Job、CronJob等，来描述你试图管理的应用；</li><li>然后，再为它定义一些“服务对象”，比如Service、Secret、Horizontal Pod Autoscaler（自动水平扩展器）等。这些对象，会负责具体的平台级功能。</li></ul><p><strong>这种使用方法，就是所谓的“声明式API”。这种API对应的“编排对象”和“服务对象”，都是Kubernetes项目中的API对象（API Object）。</strong></p><p>这就是Kubernetes最核心的设计理念，也是接下来我会重点剖析的关键技术点。</p><p>最后，我来回答一个更直接的问题：Kubernetes项目如何启动一个容器化任务呢？</p><p>比如，我现在已经制作好了一个Nginx容器镜像，希望让平台帮我启动这个镜像。并且，我要求平台帮我运行两个完全相同的Nginx副本，以负载均衡的方式共同对外提供服务。</p><ul><li><p>如果是自己DIY的话，可能需要启动两台虚拟机，分别安装两个Nginx，然后使用keepalived为这两个虚拟机做一个虚拟IP。</p><ul><li>而如果使用Kubernetes项目呢？你需要做的则是编写如下这样一个YAML文件（比如名叫nginx-deployment.yaml）：</li></ul></li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">apiVersion: apps/v1</span></div><div class="token-line"><span class="token plain">    kind: Deployment</span></div><div class="token-line"><span class="token plain">    metadata:</span></div><div class="token-line"><span class="token plain">      name: nginx-deployment</span></div><div class="token-line"><span class="token plain">      labels:</span></div><div class="token-line"><span class="token plain">        app: nginx</span></div><div class="token-line"><span class="token plain">    spec:</span></div><div class="token-line"><span class="token plain">      replicas: 2</span></div><div class="token-line"><span class="token plain">      selector:</span></div><div class="token-line"><span class="token plain">        matchLabels:</span></div><div class="token-line"><span class="token plain">          app: nginx</span></div><div class="token-line"><span class="token plain">      template:</span></div><div class="token-line"><span class="token plain">        metadata:</span></div><div class="token-line"><span class="token plain">          labels:</span></div><div class="token-line"><span class="token plain">            app: nginx</span></div><div class="token-line"><span class="token plain">        spec:</span></div><div class="token-line"><span class="token plain">          containers:</span></div><div class="token-line"><span class="token plain">          - name: nginx</span></div><div class="token-line"><span class="token plain">            image: nginx:1.7.9</span></div><div class="token-line"><span class="token plain">            ports:</span></div><div class="token-line"><span class="token plain">            - containerPort: 80</span></div></pre></div><p>在上面这个YAML文件中，我们定义了一个Deployment对象，它的主体部分（spec.template部分）是一个使用Nginx镜像的Pod，而这个Pod的副本数是2（replicas=2）。</p><p>然后执行：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ kubectl create -f nginx-deployment.yaml</span></div></pre></div><p>这样，两个完全相同的Nginx容器副本就被启动了。</p><p>不过，这么看来，做同样一件事情，Kubernetes用户要做的工作也不少嘛。</p><p>别急，在后续的讲解中，我会陆续介绍Kubernetes项目这种“声明式API”的种种好处，以及基于它实现的强大的编排能力。</p><p>拭目以待吧。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇/05#总结"><span class="icon icon-link"></span></a>总结</h2><p>首先，我和你一起回顾了容器的核心知识，说明了容器其实可以分为两个部分：容器运行时和容器镜像。</p><p>然后，我重点介绍了Kubernetes项目的架构，详细讲解了它如何使用“声明式API”来描述容器化业务和容器间关系的设计思想。</p><p>实际上，过去很多的集群管理项目（比如Yarn、Mesos，以及Swarm）所擅长的，都是把一个容器，按照某种规则，放置在某个最佳节点上运行起来。这种功能，我们称为“调度”。</p><p>而Kubernetes项目所擅长的，是按照用户的意愿和整个系统的规则，完全自动化地处理好容器之间的各种关系。<strong>这种功能，就是我们经常听到的一个概念：编排。</strong></p><p>所以说，Kubernetes项目的本质，是为用户提供一个具有普遍意义的容器编排工具。</p><p>不过，更重要的是，Kubernetes项目为用户提供的不仅限于一个工具。它真正的价值，乃在于提供了一套基于容器构建分布式系统的基础依赖。关于这一点，相信你会在今后的学习中，体会越来越深。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇/05#思考题"><span class="icon icon-link"></span></a>思考题</h2><ol><li><p>这今天的分享中，我介绍了Kubernetes项目的架构。你是否了解了Docker Swarm（SwarmKit项目）和Kubernetes在架构上和使用方法上的异同呢？</p></li><li><p>在Kubernetes之前，很多项目都没办法管理“有状态”的容器，即，不能从一台宿主机“迁移”到另一台宿主机上的容器。你是否能列举出，阻止这种“迁移”的原因都有哪些呢？</p></li></ol><p>感谢你的收听，欢迎你给我留言，也欢迎分享给更多的朋友一起阅读。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/深入剖析kubernetes/02.容器技术概念入门篇/05.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:08</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
