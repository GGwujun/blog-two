<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>20 | 深入理解StatefulSet（三）：有状态应用实践</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/深入剖析kubernetes/04.容器编排与kubernetes作业管理/08" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a aria-current="page" class="active" href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a aria-current="page" class="active" href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/深入剖析kubernetes/01.课前必读">01.课前必读</a><ul><li><a href="/blog-two/深入剖析kubernetes/01.课前必读/01"><span>开篇词 | 打通“容器技术”的任督二脉</span></a></li><li><a href="/blog-two/深入剖析kubernetes/01.课前必读/02"><span>01 | 预习篇 · 小鲸鱼大事记（一）：初出茅庐</span></a></li><li><a href="/blog-two/深入剖析kubernetes/01.课前必读/03"><span>02 | 预习篇 · 小鲸鱼大事记（二）：崭露头角</span></a></li><li><a href="/blog-two/深入剖析kubernetes/01.课前必读/04"><span>03 | 预习篇 · 小鲸鱼大事记（三）：群雄并起</span></a></li><li><a href="/blog-two/深入剖析kubernetes/01.课前必读/05"><span>04 | 预习篇 · 小鲸鱼大事记（四）：尘埃落定</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇">02.容器技术概念入门篇</a><ul><li><a href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇/01"><span>05 | 白话容器基础（一）：从进程说开去</span></a></li><li><a href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇/02"><span>06 | 白话容器基础（二）：隔离与限制</span></a></li><li><a href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇/03"><span>07 | 白话容器基础（三）：深入理解容器镜像</span></a></li><li><a href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇/04"><span>08 | 白话容器基础（四）：重新认识Docker容器</span></a></li><li><a href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇/05"><span>09 | 从容器到容器云：谈谈Kubernetes的本质</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/03.kubernetes集群搭建与实践">03.Kubernetes集群搭建与实践</a><ul><li><a href="/blog-two/深入剖析kubernetes/03.kubernetes集群搭建与实践/01"><span>10 | Kubernetes一键部署利器：kubeadm</span></a></li><li><a href="/blog-two/深入剖析kubernetes/03.kubernetes集群搭建与实践/02"><span>11 | 从0到1：搭建一个完整的Kubernetes集群</span></a></li><li><a href="/blog-two/深入剖析kubernetes/03.kubernetes集群搭建与实践/03"><span>12 | 牛刀小试：我的第一个容器化应用</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理">04.容器编排与Kubernetes作业管理</a><ul><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/01"><span>13 | 为什么我们需要Pod？</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/02"><span>14 | 深入解析Pod对象（一）：基本概念</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/03"><span>15 | 深入解析Pod对象（二）：使用进阶</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/04"><span>16 | 编排其实很简单：谈谈“控制器”模型</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/05"><span>17 | 经典PaaS的记忆：作业副本与水平扩展</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/06"><span>18 | 深入理解StatefulSet（一）：拓扑状态</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/07"><span>19 | 深入理解StatefulSet（二）：存储状态</span></a></li><li><a aria-current="page" class="active" href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/08"><span>20 | 深入理解StatefulSet（三）：有状态应用实践</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/09"><span>21 | 容器化守护进程的意义：DaemonSet</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/10"><span>22 | 撬动离线业务：Job与CronJob</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/11"><span>23 | 声明式API与Kubernetes编程范式</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/12"><span>24 | 深入解析声明式API（一）：API对象的奥秘</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/13"><span>25 | 深入解析声明式API（二）：编写自定义控制器</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/14"><span>26 | 基于角色的权限控制：RBAC</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/15"><span>27 | 聪明的微创新：Operator工作原理解读</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/05.kubernetes容器持久化存储">05.Kubernetes容器持久化存储</a><ul><li><a href="/blog-two/深入剖析kubernetes/05.kubernetes容器持久化存储/01"><span>28 | PV、PVC、StorageClass，这些到底在说啥？</span></a></li><li><a href="/blog-two/深入剖析kubernetes/05.kubernetes容器持久化存储/02"><span>29 | PV、PVC体系是不是多此一举？从本地持久化卷谈起</span></a></li><li><a href="/blog-two/深入剖析kubernetes/05.kubernetes容器持久化存储/03"><span>30 | 编写自己的存储插件：FlexVolume与CSI</span></a></li><li><a href="/blog-two/深入剖析kubernetes/05.kubernetes容器持久化存储/04"><span>31 | 容器存储实践：CSI插件编写指南</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络">06.Kubernetes容器网络</a><ul><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/01"><span>32 | 浅谈容器网络</span></a></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/02"><span>33 | 深入解析容器跨主机网络</span></a></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/03"><span>34 | Kubernetes网络模型与CNI网络插件</span></a></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/04"><span>35 | 解读Kubernetes三层网络方案</span></a></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/05"><span>36 | 为什么说Kubernetes只有soft multi-tenancy？</span></a></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/06"><span>37 | 找到容器不容易：Service、DNS与服务发现</span></a></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/07"><span>38 | 从外界连通Service与Service调试“三板斧”</span></a></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/08"><span>39 | 谈谈Service与Ingress</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/07.kubernetes作业调度与资源管理">07.Kubernetes作业调度与资源管理</a><ul><li><a href="/blog-two/深入剖析kubernetes/07.kubernetes作业调度与资源管理/01"><span>40 | Kubernetes的资源模型与资源管理</span></a></li><li><a href="/blog-two/深入剖析kubernetes/07.kubernetes作业调度与资源管理/02"><span>41 | 十字路口上的Kubernetes默认调度器</span></a></li><li><a href="/blog-two/深入剖析kubernetes/07.kubernetes作业调度与资源管理/03"><span>42 | Kubernetes默认调度器调度策略解析</span></a></li><li><a href="/blog-two/深入剖析kubernetes/07.kubernetes作业调度与资源管理/04"><span>43 | Kubernetes默认调度器的优先级与抢占机制</span></a></li><li><a href="/blog-two/深入剖析kubernetes/07.kubernetes作业调度与资源管理/05"><span>44 | Kubernetes GPU管理与Device Plugin机制</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/08.kubernetes容器运行时">08.Kubernetes容器运行时</a><ul><li><a href="/blog-two/深入剖析kubernetes/08.kubernetes容器运行时/01"><span>45 | 幕后英雄：SIG-Node与CRI</span></a></li><li><a href="/blog-two/深入剖析kubernetes/08.kubernetes容器运行时/02"><span>46 | 解读 CRI 与 容器运行时</span></a></li><li><a href="/blog-two/深入剖析kubernetes/08.kubernetes容器运行时/03"><span>47 | 绝不仅仅是安全：Kata Containers 与 gVisor</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/09.kubernetes容器监控与日志">09.Kubernetes容器监控与日志</a><ul><li><a href="/blog-two/深入剖析kubernetes/09.kubernetes容器监控与日志/01"><span>48 | Prometheus、Metrics Server与Kubernetes监控体系</span></a></li><li><a href="/blog-two/深入剖析kubernetes/09.kubernetes容器监控与日志/02"><span>49 | Custom Metrics: 让Auto Scaling不再“食之无味”</span></a></li><li><a href="/blog-two/深入剖析kubernetes/09.kubernetes容器监控与日志/03"><span>50 | 让日志无处可逃：容器日志收集与管理</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/10.再谈开源与社区">10.再谈开源与社区</a><ul><li><a href="/blog-two/深入剖析kubernetes/10.再谈开源与社区/01"><span>51 | 谈谈Kubernetes开源社区和未来走向</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/11.答疑文章">11.答疑文章</a><ul><li><a href="/blog-two/深入剖析kubernetes/11.答疑文章/01"><span>52 | 答疑：在问题中解决问题，在思考中产生思考</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/12.特别放送">12.特别放送</a><ul><li><a href="/blog-two/深入剖析kubernetes/12.特别放送/01"><span>特别放送 | 2019 年，容器技术生态会发生些什么？</span></a></li><li><a href="/blog-two/深入剖析kubernetes/12.特别放送/02"><span>特别放送 | 基于 Kubernetes 的云原生应用管理，到底应该怎么做？</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/13.结束语">13.结束语</a><ul><li><a href="/blog-two/深入剖析kubernetes/13.结束语/01"><span>结束语 | Kubernetes：赢开发者赢天下</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/14.结课测试">14.结课测试</a><ul><li><a href="/blog-two/深入剖析kubernetes/14.结课测试/01"><span>结课测试｜这些Kubernetes的相关知识，你都掌握了吗？</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/summary">深入剖析kubernetes</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="总结" data-depth="2"><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/08#总结"><span>总结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/08#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="20--深入理解statefulset三有状态应用实践"><a aria-hidden="true" tabindex="-1" href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/08#20--深入理解statefulset三有状态应用实践"><span class="icon icon-link"></span></a>20 | 深入理解StatefulSet（三）：有状态应用实践</h1><p>你好，我是张磊。今天我和你分享的主题是：深入理解StatefulSet之有状态应用实践。</p><p>在前面的两篇文章中，我详细讲解了StatefulSet的工作原理，以及处理拓扑状态和存储状态的方法。而在今天这篇文章中，我将通过一个实际的例子，再次为你深入解读一下部署一个StatefulSet的完整流程。</p><p>今天我选择的实例是部署一个MySQL集群，这也是Kubernetes官方文档里的一个经典案例。但是，很多工程师都曾向我吐槽说这个例子“完全看不懂”。</p><p>其实，这样的吐槽也可以理解：相比于Etcd、Cassandra等“原生”就考虑了分布式需求的项目，MySQL以及很多其他的数据库项目，在分布式集群的搭建上并不友好，甚至有点“原始”。</p><p>所以，这次我就直接选择了这个具有挑战性的例子，和你分享如何使用StatefulSet将它的集群搭建过程“容器化”。</p><blockquote><p>备注：在开始实践之前，请确保我们之前一起部署的那个Kubernetes集群还是可用的，并且网络插件和存储插件都能正常运行。具体的做法，请参考第11篇文章<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/39724">《从0到1：搭建一个完整的Kubernetes集群》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的内容。</p></blockquote><p>首先，用自然语言来描述一下我们想要部署的“有状态应用”。</p><ol><li><p>是一个“主从复制”（Maser-Slave Replication）的MySQL集群；</p></li><li><p>有1个主节点（Master）；</p></li><li><p>有多个从节点（Slave）；</p></li><li><p>从节点需要能水平扩展；</p></li><li><p>所有的写操作，只能在主节点上执行；</p></li><li><p>读操作可以在所有节点上执行。</p></li></ol><p>这就是一个非常典型的主从模式的MySQL集群了。我们可以把上面描述的“有状态应用”的需求，通过一张图来表示。</p><p><img src="https://static001.geekbang.org/resource/image/bb/02/bb2d7f03443392ca40ecde6b1a91c002.png" alt=""/><br/>在常规环境里，部署这样一个主从模式的MySQL集群的主要难点在于：如何让从节点能够拥有主节点的数据，即：如何配置主（Master）从（Slave）节点的复制与同步。</p><p>所以，在安装好MySQL的Master节点之后，你需要做的第一步工作，就是<strong>通过XtraBackup将Master节点的数据备份到指定目录。</strong></p><blockquote><p>备注：XtraBackup是业界主要使用的开源MySQL备份和恢复工具。</p></blockquote><p>这一步会自动在目标目录里生成一个备份信息文件，名叫：xtrabackup_binlog_info。这个文件一般会包含如下两个信息：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ cat xtrabackup_binlog_info</span></div><div class="token-line"><span class="token plain">    TheMaster-bin.000001     481</span></div></pre></div><p>这两个信息会在接下来配置Slave节点的时候用到。</p><p><strong>第二步：配置Slave节点</strong>。Slave节点在第一次启动前，需要先把Master节点的备份数据，连同备份信息文件，一起拷贝到自己的数据目录（/var/lib/mysql）下。然后，我们执行这样一句SQL：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">TheSlave|mysql&gt; CHANGE MASTER TO</span></div><div class="token-line"><span class="token plain">                    MASTER_HOST=&#x27;$masterip&#x27;,</span></div><div class="token-line"><span class="token plain">                    MASTER_USER=&#x27;xxx&#x27;,</span></div><div class="token-line"><span class="token plain">                    MASTER_PASSWORD=&#x27;xxx&#x27;,</span></div><div class="token-line"><span class="token plain">                    MASTER_LOG_FILE=&#x27;TheMaster-bin.000001&#x27;,</span></div><div class="token-line"><span class="token plain">                    MASTER_LOG_POS=481;</span></div></pre></div><p>其中，MASTER_LOG_FILE和MASTER_LOG_POS，就是该备份对应的二进制日志（Binary Log）文件的名称和开始的位置（偏移量），也正是xtrabackup_binlog_info文件里的那两部分内容（即：TheMaster-bin.000001和481）。</p><p><strong>第三步，启动Slave节点</strong>。在这一步，我们需要执行这样一句SQL：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">TheSlave|mysql&gt; START SLAVE;</span></div></pre></div><p>这样，Slave节点就启动了。它会使用备份信息文件中的二进制日志文件和偏移量，与主节点进行数据同步。</p><p><strong>第四步，在这个集群中添加更多的Slave节点</strong>。</p><p>需要注意的是，新添加的Slave节点的备份数据，来自于已经存在的Slave节点。</p><p>所以，在这一步，我们需要将Slave节点的数据备份在指定目录。而这个备份操作会自动生成另一种备份信息文件，名叫：xtrabackup_slave_info。同样地，这个文件也包含了MASTER_LOG_FILE和MASTER_LOG_POS两个字段。</p><p>然后，我们就可以执行跟前面一样的“CHANGE MASTER TO”和“START SLAVE” 指令，来初始化并启动这个新的Slave节点了。</p><p>通过上面的叙述，我们不难看到，<strong>将部署MySQL集群的流程迁移到Kubernetes项目上，需要能够“容器化”地解决下面的“三座大山”：</strong></p><ol><li><p>Master节点和Slave节点需要有不同的配置文件（即：不同的my.cnf）；</p></li><li><p>Master节点和Slave节点需要能够传输备份信息文件；</p></li><li><p>在Slave节点第一次启动之前，需要执行一些初始化SQL操作；</p></li></ol><p>而由于MySQL本身同时拥有拓扑状态（主从节点的区别）和存储状态（MySQL保存在本地的数据），我们自然要通过StatefulSet来解决这“三座大山”的问题。</p><p><strong>其中，“第一座大山：Master节点和Slave节点需要有不同的配置文件”，很容易处理</strong>：我们只需要给主从节点分别准备两份不同的MySQL配置文件，然后根据Pod的序号（Index）挂载进去即可。</p><p>正如我在前面文章中介绍过的，这样的配置文件信息，应该保存在ConfigMap里供Pod使用。它的定义如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">apiVersion: v1</span></div><div class="token-line"><span class="token plain">    kind: ConfigMap</span></div><div class="token-line"><span class="token plain">    metadata:</span></div><div class="token-line"><span class="token plain">      name: mysql</span></div><div class="token-line"><span class="token plain">      labels:</span></div><div class="token-line"><span class="token plain">        app: mysql</span></div><div class="token-line"><span class="token plain">    data:</span></div><div class="token-line"><span class="token plain">      master.cnf: |</span></div><div class="token-line"><span class="token plain">        # 主节点MySQL的配置文件</span></div><div class="token-line"><span class="token plain">        [mysqld]</span></div><div class="token-line"><span class="token plain">        log-bin</span></div><div class="token-line"><span class="token plain">      slave.cnf: |</span></div><div class="token-line"><span class="token plain">        # 从节点MySQL的配置文件</span></div><div class="token-line"><span class="token plain">        [mysqld]</span></div><div class="token-line"><span class="token plain">        super-read-only</span></div></pre></div><p>在这里，我们定义了master.cnf和slave.cnf两个MySQL的配置文件。</p><ul><li>master.cnf开启了log-bin，即：使用二进制日志文件的方式进行主从复制，这是一个标准的设置。</li><li>slave.cnf的开启了super-read-only，代表的是从节点会拒绝除了主节点的数据同步操作之外的所有写操作，即：它对用户是只读的。</li></ul><p>而上述ConfigMap定义里的data部分，是Key-Value格式的。比如，master.cnf就是这份配置数据的Key，而“|”后面的内容，就是这份配置数据的Value。这份数据将来挂载进Master节点对应的Pod后，就会在Volume目录里生成一个叫作master.cnf的文件。</p><blockquote><p>备注：如果你对ConfigMap的用法感到陌生的话，可以稍微复习一下第15篇文章<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/40466">《深入解析Pod对象（二）：使用进阶》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中，我讲解Secret对象部分的内容。因为，ConfigMap跟Secret，无论是使用方法还是实现原理，几乎都是一样的。</p></blockquote><p>接下来，我们需要创建两个Service来供StatefulSet以及用户使用。这两个Service的定义如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">apiVersion: v1</span></div><div class="token-line"><span class="token plain">    kind: Service</span></div><div class="token-line"><span class="token plain">    metadata:</span></div><div class="token-line"><span class="token plain">      name: mysql</span></div><div class="token-line"><span class="token plain">      labels:</span></div><div class="token-line"><span class="token plain">        app: mysql</span></div><div class="token-line"><span class="token plain">    spec:</span></div><div class="token-line"><span class="token plain">      ports:</span></div><div class="token-line"><span class="token plain">      - name: mysql</span></div><div class="token-line"><span class="token plain">        port: 3306</span></div><div class="token-line"><span class="token plain">      clusterIP: None</span></div><div class="token-line"><span class="token plain">      selector:</span></div><div class="token-line"><span class="token plain">        app: mysql</span></div><div class="token-line"><span class="token plain">    ---</span></div><div class="token-line"><span class="token plain">    apiVersion: v1</span></div><div class="token-line"><span class="token plain">    kind: Service</span></div><div class="token-line"><span class="token plain">    metadata:</span></div><div class="token-line"><span class="token plain">      name: mysql-read</span></div><div class="token-line"><span class="token plain">      labels:</span></div><div class="token-line"><span class="token plain">        app: mysql</span></div><div class="token-line"><span class="token plain">    spec:</span></div><div class="token-line"><span class="token plain">      ports:</span></div><div class="token-line"><span class="token plain">      - name: mysql</span></div><div class="token-line"><span class="token plain">        port: 3306</span></div><div class="token-line"><span class="token plain">      selector:</span></div><div class="token-line"><span class="token plain">        app: mysql</span></div></pre></div><p>可以看到，这两个Service都代理了所有携带app=mysql标签的Pod，也就是所有的MySQL Pod。端口映射都是用Service的3306端口对应Pod的3306端口。</p><p>不同的是，第一个名叫“mysql”的Service是一个Headless Service（即：clusterIP= None）。所以它的作用，是通过为Pod分配DNS记录来固定它的拓扑状态，比如“mysql-0.mysql”和“mysql-1.mysql”这样的DNS名字。其中，编号为0的节点就是我们的主节点。</p><p>而第二个名叫“mysql-read”的Service，则是一个常规的Service。</p><p>并且我们规定，所有用户的读请求，都必须访问第二个Service被自动分配的DNS记录，即：“mysql-read”（当然，也可以访问这个Service的VIP）。这样，读请求就可以被转发到任意一个MySQL的主节点或者从节点上。</p><blockquote><p>备注：Kubernetes中的所有Service、Pod对象，都会被自动分配同名的DNS记录。具体细节，我会在后面Service部分做重点讲解。</p></blockquote><p>而所有用户的写请求，则必须直接以DNS记录的方式访问到MySQL的主节点，也就是：“mysql-0.mysql“这条DNS记录。</p><p>接下来，我们再一起解决“第二座大山：Master节点和Slave节点需要能够传输备份文件”的问题。</p><p><strong>翻越这座大山的思路，我比较推荐的做法是：先搭建框架，再完善细节。其中，Pod部分如何定义，是完善细节时的重点。</strong></p><p><strong>所以首先，我们先为StatefulSet对象规划一个大致的框架，如下图所示：</strong></p><p><img src="https://static001.geekbang.org/resource/image/16/09/16aa2e42034830a0e64120ecc330a509.png" alt=""/></p><p>在这一步，我们可以先为StatefulSet定义一些通用的字段。</p><p>比如：selector表示，这个StatefulSet要管理的Pod必须携带app=mysql标签；它声明要使用的Headless Service的名字是：mysql。</p><p>这个StatefulSet的replicas值是3，表示它定义的MySQL集群有三个节点：一个Master节点，两个Slave节点。</p><p>可以看到，StatefulSet管理的“有状态应用”的多个实例，也都是通过同一份Pod模板创建出来的，使用的是同一个Docker镜像。这也就意味着：如果你的应用要求不同节点的镜像不一样，那就不能再使用StatefulSet了。对于这种情况，应该考虑我后面会讲解到的Operator。</p><p>除了这些基本的字段外，作为一个有存储状态的MySQL集群，StatefulSet还需要管理存储状态。所以，我们需要通过volumeClaimTemplate（PVC模板）来为每个Pod定义PVC。比如，这个PVC模板的resources.requests.strorage指定了存储的大小为10 GiB；ReadWriteOnce指定了该存储的属性为可读写，并且一个PV只允许挂载在一个宿主机上。将来，这个PV对应的的Volume就会充当MySQL Pod的存储数据目录。</p><p><strong>然后，我们来重点设计一下这个StatefulSet的Pod模板，也就是template字段。</strong></p><p>由于StatefulSet管理的Pod都来自于同一个镜像，这就要求我们在编写Pod时，一定要保持清醒，用“人格分裂”的方式进行思考：</p><ol><li><p>如果这个Pod是Master节点，我们要怎么做；</p></li><li><p>如果这个Pod是Slave节点，我们又要怎么做。</p></li></ol><p>想清楚这两个问题，我们就可以按照Pod的启动过程来一步步定义它们了。</p><p><strong>第一步：从ConfigMap中，获取MySQL的Pod对应的配置文件。</strong></p><p>为此，我们需要进行一个初始化操作，根据节点的角色是Master还是Slave节点，为Pod分配对应的配置文件。此外，MySQL还要求集群里的每个节点都有一个唯一的ID文件，名叫server-id.cnf。</p><p>而根据我们已经掌握的Pod知识，这些初始化操作显然适合通过InitContainer来完成。所以，我们首先定义了一个InitContainer，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">...</span></div><div class="token-line"><span class="token plain">          # template.spec</span></div><div class="token-line"><span class="token plain">          initContainers:</span></div><div class="token-line"><span class="token plain">          - name: init-mysql</span></div><div class="token-line"><span class="token plain">            image: mysql:5.7</span></div><div class="token-line"><span class="token plain">            command:</span></div><div class="token-line"><span class="token plain">            - bash</span></div><div class="token-line"><span class="token plain">            - &quot;-c&quot;</span></div><div class="token-line"><span class="token plain">            - |</span></div><div class="token-line"><span class="token plain">              set -ex</span></div><div class="token-line"><span class="token plain">              # 从Pod的序号，生成server-id</span></div><div class="token-line"><span class="token plain">              [[ `hostname` =~ -([0-9]+)$ ]] || exit 1</span></div><div class="token-line"><span class="token plain">              ordinal=${BASH_REMATCH[1]}</span></div><div class="token-line"><span class="token plain">              echo [mysqld] &gt; /mnt/conf.d/server-id.cnf</span></div><div class="token-line"><span class="token plain">              # 由于server-id=0有特殊含义，我们给ID加一个100来避开它</span></div><div class="token-line"><span class="token plain">              echo server-id=$((100 + $ordinal)) &gt;&gt; /mnt/conf.d/server-id.cnf</span></div><div class="token-line"><span class="token plain">              # 如果Pod序号是0，说明它是Master节点，从ConfigMap里把Master的配置文件拷贝到/mnt/conf.d/目录；</span></div><div class="token-line"><span class="token plain">              # 否则，拷贝Slave的配置文件</span></div><div class="token-line"><span class="token plain">              if [[ $ordinal -eq 0 ]]; then</span></div><div class="token-line"><span class="token plain">                cp /mnt/config-map/master.cnf /mnt/conf.d/</span></div><div class="token-line"><span class="token plain">              else</span></div><div class="token-line"><span class="token plain">                cp /mnt/config-map/slave.cnf /mnt/conf.d/</span></div><div class="token-line"><span class="token plain">              fi</span></div><div class="token-line"><span class="token plain">            volumeMounts:</span></div><div class="token-line"><span class="token plain">            - name: conf</span></div><div class="token-line"><span class="token plain">              mountPath: /mnt/conf.d</span></div><div class="token-line"><span class="token plain">            - name: config-map</span></div><div class="token-line"><span class="token plain">              mountPath: /mnt/config-map</span></div></pre></div><p>在这个名叫init-mysql的InitContainer的配置中，它从Pod的hostname里，读取到了Pod的序号，以此作为MySQL节点的server-id。</p><p>然后，init-mysql通过这个序号，判断当前Pod到底是Master节点（即：序号为0）还是Slave节点（即：序号不为0），从而把对应的配置文件从/mnt/config-map目录拷贝到/mnt/conf.d/目录下。</p><p>其中，文件拷贝的源目录/mnt/config-map，正是ConfigMap在这个Pod的Volume，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">...</span></div><div class="token-line"><span class="token plain">          # template.spec</span></div><div class="token-line"><span class="token plain">          volumes:</span></div><div class="token-line"><span class="token plain">          - name: conf</span></div><div class="token-line"><span class="token plain">            emptyDir: {}</span></div><div class="token-line"><span class="token plain">          - name: config-map</span></div><div class="token-line"><span class="token plain">            configMap:</span></div><div class="token-line"><span class="token plain">              name: mysql</span></div></pre></div><p>通过这个定义，init-mysql在声明了挂载config-map这个Volume之后，ConfigMap里保存的内容，就会以文件的方式出现在它的/mnt/config-map目录当中。</p><p>而文件拷贝的目标目录，即容器里的/mnt/conf.d/目录，对应的则是一个名叫conf的、emptyDir类型的Volume。基于Pod Volume共享的原理，当InitContainer复制完配置文件退出后，后面启动的MySQL容器只需要直接声明挂载这个名叫conf的Volume，它所需要的.cnf配置文件已经出现在里面了。这跟我们之前介绍的Tomcat和WAR包的处理方法是完全一样的。</p><p><strong>第二步：在Slave Pod启动前，从Master或者其他Slave Pod里拷贝数据库数据到自己的目录下。</strong></p><p>为了实现这个操作，我们就需要再定义第二个InitContainer，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">...</span></div><div class="token-line"><span class="token plain">          # template.spec.initContainers</span></div><div class="token-line"><span class="token plain">          - name: clone-mysql</span></div><div class="token-line"><span class="token plain">            image: gcr.io/google-samples/xtrabackup:1.0</span></div><div class="token-line"><span class="token plain">            command:</span></div><div class="token-line"><span class="token plain">            - bash</span></div><div class="token-line"><span class="token plain">            - &quot;-c&quot;</span></div><div class="token-line"><span class="token plain">            - |</span></div><div class="token-line"><span class="token plain">              set -ex</span></div><div class="token-line"><span class="token plain">              # 拷贝操作只需要在第一次启动时进行，所以如果数据已经存在，跳过</span></div><div class="token-line"><span class="token plain">              [[ -d /var/lib/mysql/mysql ]] &amp;&amp; exit 0</span></div><div class="token-line"><span class="token plain">              # Master节点(序号为0)不需要做这个操作</span></div><div class="token-line"><span class="token plain">              [[ `hostname` =~ -([0-9]+)$ ]] || exit 1</span></div><div class="token-line"><span class="token plain">              ordinal=${BASH_REMATCH[1]}</span></div><div class="token-line"><span class="token plain">              [[ $ordinal -eq 0 ]] &amp;&amp; exit 0</span></div><div class="token-line"><span class="token plain">              # 使用ncat指令，远程地从前一个节点拷贝数据到本地</span></div><div class="token-line"><span class="token plain">              ncat --recv-only mysql-$(($ordinal-1)).mysql 3307 | xbstream -x -C /var/lib/mysql</span></div><div class="token-line"><span class="token plain">              # 执行--prepare，这样拷贝来的数据就可以用作恢复了</span></div><div class="token-line"><span class="token plain">              xtrabackup --prepare --target-dir=/var/lib/mysql</span></div><div class="token-line"><span class="token plain">            volumeMounts:</span></div><div class="token-line"><span class="token plain">            - name: data</span></div><div class="token-line"><span class="token plain">              mountPath: /var/lib/mysql</span></div><div class="token-line"><span class="token plain">              subPath: mysql</span></div><div class="token-line"><span class="token plain">            - name: conf</span></div><div class="token-line"><span class="token plain">              mountPath: /etc/mysql/conf.d</span></div></pre></div><p>在这个名叫clone-mysql的InitContainer里，我们使用的是xtrabackup镜像（它里面安装了xtrabackup工具）。</p><p>而在它的启动命令里，我们首先做了一个判断。即：当初始化所需的数据（/var/lib/mysql/mysql 目录）已经存在，或者当前Pod是Master节点的时候，不需要做拷贝操作。</p><p>接下来，clone-mysql会使用Linux自带的ncat指令，向DNS记录为“mysql-&lt;当前序号减一&gt;.mysql”的Pod，也就是当前Pod的前一个Pod，发起数据传输请求，并且直接用xbstream指令将收到的备份数据保存在/var/lib/mysql目录下。</p><blockquote><p>备注：3307是一个特殊端口，运行着一个专门负责备份MySQL数据的辅助进程。我们后面马上会讲到它。</p></blockquote><p>当然，这一步你可以随意选择用自己喜欢的方法来传输数据。比如，用scp或者rsync，都没问题。</p><p>你可能已经注意到，这个容器里的/var/lib/mysql目录，<strong>实际上正是一个名为data的PVC</strong>，即：我们在前面声明的持久化存储。</p><p>这就可以保证，哪怕宿主机宕机了，我们数据库的数据也不会丢失。更重要的是，由于Pod Volume是被Pod里的容器共享的，所以后面启动的MySQL容器，就可以把这个Volume挂载到自己的/var/lib/mysql目录下，直接使用里面的备份数据进行恢复操作。</p><p>不过，clone-mysql容器还要对/var/lib/mysql目录，执行一句xtrabackup --prepare操作，目的是让拷贝来的数据进入一致性状态，这样，这些数据才能被用作数据恢复。</p><p>至此，我们就通过InitContainer完成了对“主、从节点间备份文件传输”操作的处理过程，也就是翻越了“第二座大山”。</p><p>接下来，我们可以开始定义MySQL容器,启动MySQL服务了。由于StatefulSet里的所有Pod都来自用同一个Pod模板，所以我们还要“人格分裂”地去思考：这个MySQL容器的启动命令，在Master和Slave两种情况下有什么不同。</p><p>有了Docker镜像，在Pod里声明一个Master角色的MySQL容器并不是什么困难的事情：直接执行MySQL启动命令即可。</p><p>但是，如果这个Pod是一个第一次启动的Slave节点，在执行MySQL启动命令之前，它就需要使用前面InitContainer拷贝来的备份数据进行初始化。</p><p>可是，别忘了，<strong>容器是一个单进程模型。</strong></p><p>所以，一个Slave角色的MySQL容器启动之前，谁能负责给它执行初始化的SQL语句呢？</p><p>这就是我们需要解决的“第三座大山”的问题，即：如何在Slave节点的MySQL容器第一次启动之前，执行初始化SQL。</p><p>你可能已经想到了，我们可以为这个MySQL容器额外定义一个sidecar容器，来完成这个操作，它的定义如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">...</span></div><div class="token-line"><span class="token plain">          # template.spec.containers</span></div><div class="token-line"><span class="token plain">          - name: xtrabackup</span></div><div class="token-line"><span class="token plain">            image: gcr.io/google-samples/xtrabackup:1.0</span></div><div class="token-line"><span class="token plain">            ports:</span></div><div class="token-line"><span class="token plain">            - name: xtrabackup</span></div><div class="token-line"><span class="token plain">              containerPort: 3307</span></div><div class="token-line"><span class="token plain">            command:</span></div><div class="token-line"><span class="token plain">            - bash</span></div><div class="token-line"><span class="token plain">            - &quot;-c&quot;</span></div><div class="token-line"><span class="token plain">            - |</span></div><div class="token-line"><span class="token plain">              set -ex</span></div><div class="token-line"><span class="token plain">              cd /var/lib/mysql</span></div><div class="token-line"><span class="token plain">              </span></div><div class="token-line"><span class="token plain">              # 从备份信息文件里读取MASTER_LOG_FILEM和MASTER_LOG_POS这两个字段的值，用来拼装集群初始化SQL</span></div><div class="token-line"><span class="token plain">              if [[ -f xtrabackup_slave_info ]]; then</span></div><div class="token-line"><span class="token plain">                # 如果xtrabackup_slave_info文件存在，说明这个备份数据来自于另一个Slave节点。这种情况下，XtraBackup工具在备份的时候，就已经在这个文件里自动生成了&quot;CHANGE MASTER TO&quot; SQL语句。所以，我们只需要把这个文件重命名为change_master_to.sql.in，后面直接使用即可</span></div><div class="token-line"><span class="token plain">                mv xtrabackup_slave_info change_master_to.sql.in</span></div><div class="token-line"><span class="token plain">                # 所以，也就用不着xtrabackup_binlog_info了</span></div><div class="token-line"><span class="token plain">                rm -f xtrabackup_binlog_info</span></div><div class="token-line"><span class="token plain">              elif [[ -f xtrabackup_binlog_info ]]; then</span></div><div class="token-line"><span class="token plain">                # 如果只存在xtrabackup_binlog_inf文件，那说明备份来自于Master节点，我们就需要解析这个备份信息文件，读取所需的两个字段的值</span></div><div class="token-line"><span class="token plain">                [[ `cat xtrabackup_binlog_info` =~ ^(.*?)[[:space:]]+(.*?)$ ]] || exit 1</span></div><div class="token-line"><span class="token plain">                rm xtrabackup_binlog_info</span></div><div class="token-line"><span class="token plain">                # 把两个字段的值拼装成SQL，写入change_master_to.sql.in文件</span></div><div class="token-line"><span class="token plain">                echo &quot;CHANGE MASTER TO MASTER_LOG_FILE=&#x27;${BASH_REMATCH[1]}&#x27;,\</span></div><div class="token-line"><span class="token plain">                      MASTER_LOG_POS=${BASH_REMATCH[2]}&quot; &gt; change_master_to.sql.in</span></div><div class="token-line"><span class="token plain">              fi</span></div><div class="token-line"><span class="token plain">              </span></div><div class="token-line"><span class="token plain">              # 如果change_master_to.sql.in，就意味着需要做集群初始化工作</span></div><div class="token-line"><span class="token plain">              if [[ -f change_master_to.sql.in ]]; then</span></div><div class="token-line"><span class="token plain">                # 但一定要先等MySQL容器启动之后才能进行下一步连接MySQL的操作</span></div><div class="token-line"><span class="token plain">                echo &quot;Waiting for mysqld to be ready (accepting connections)&quot;</span></div><div class="token-line"><span class="token plain">                until mysql -h 127.0.0.1 -e &quot;SELECT 1&quot;; do sleep 1; done</span></div><div class="token-line"><span class="token plain">                </span></div><div class="token-line"><span class="token plain">                echo &quot;Initializing replication from clone position&quot;</span></div><div class="token-line"><span class="token plain">                # 将文件change_master_to.sql.in改个名字，防止这个Container重启的时候，因为又找到了change_master_to.sql.in，从而重复执行一遍这个初始化流程</span></div><div class="token-line"><span class="token plain">                mv change_master_to.sql.in change_master_to.sql.orig</span></div><div class="token-line"><span class="token plain">                # 使用change_master_to.sql.orig的内容，也是就是前面拼装的SQL，组成一个完整的初始化和启动Slave的SQL语句</span></div><div class="token-line"><span class="token plain">                mysql -h 127.0.0.1 &lt;&lt;EOF</span></div><div class="token-line"><span class="token plain">              $(&lt;change_master_to.sql.orig),</span></div><div class="token-line"><span class="token plain">                MASTER_HOST=&#x27;mysql-0.mysql&#x27;,</span></div><div class="token-line"><span class="token plain">                MASTER_USER=&#x27;root&#x27;,</span></div><div class="token-line"><span class="token plain">                MASTER_PASSWORD=&#x27;&#x27;,</span></div><div class="token-line"><span class="token plain">                MASTER_CONNECT_RETRY=10;</span></div><div class="token-line"><span class="token plain">              START SLAVE;</span></div><div class="token-line"><span class="token plain">              EOF</span></div><div class="token-line"><span class="token plain">              fi</span></div><div class="token-line"><span class="token plain">              </span></div><div class="token-line"><span class="token plain">              # 使用ncat监听3307端口。它的作用是，在收到传输请求的时候，直接执行&quot;xtrabackup --backup&quot;命令，备份MySQL的数据并发送给请求者</span></div><div class="token-line"><span class="token plain">              exec ncat --listen --keep-open --send-only --max-conns=1 3307 -c \</span></div><div class="token-line"><span class="token plain">                &quot;xtrabackup --backup --slave-info --stream=xbstream --host=127.0.0.1 --user=root&quot;</span></div><div class="token-line"><span class="token plain">            volumeMounts:</span></div><div class="token-line"><span class="token plain">            - name: data</span></div><div class="token-line"><span class="token plain">              mountPath: /var/lib/mysql</span></div><div class="token-line"><span class="token plain">              subPath: mysql</span></div><div class="token-line"><span class="token plain">            - name: conf</span></div><div class="token-line"><span class="token plain">              mountPath: /etc/mysql/conf.d</span></div></pre></div><p>可以看到，<strong>在这个名叫xtrabackup的sidecar容器的启动命令里，其实实现了两部分工作。</strong></p><p><strong>第一部分工作，当然是MySQL节点的初始化工作</strong>。这个初始化需要使用的SQL，是sidecar容器拼装出来、保存在一个名为change_master_to.sql.in的文件里的，具体过程如下所示：</p><p>sidecar容器首先会判断当前Pod的/var/lib/mysql目录下，是否有xtrabackup_slave_info这个备份信息文件。</p><ul><li>如果有，则说明这个目录下的备份数据是由一个Slave节点生成的。这种情况下，XtraBackup工具在备份的时候，就已经在这个文件里自动生成了&quot;CHANGE MASTER TO&quot; SQL语句。所以，我们只需要把这个文件重命名为change_master_to.sql.in，后面直接使用即可。</li><li>如果没有xtrabackup_slave_info文件、但是存在xtrabackup_binlog_info文件，那就说明备份数据来自于Master节点。这种情况下，sidecar容器就需要解析这个备份信息文件，读取MASTER_LOG_FILE和MASTER_LOG_POS这两个字段的值，用它们拼装出初始化SQL语句，然后把这句SQL写入到change_master_to.sql.in文件中。</li></ul><p>接下来，sidecar容器就可以执行初始化了。从上面的叙述中可以看到，只要这个change_master_to.sql.in文件存在，那就说明接下来需要进行集群初始化操作。</p><p>所以，这时候，sidecar容器只需要读取并执行change_master_to.sql.in里面的“CHANGE MASTER TO”指令，再执行一句START SLAVE命令，一个Slave节点就被成功启动了。</p><blockquote><p>需要注意的是：Pod里的容器并没有先后顺序，所以在执行初始化SQL之前，必须先执行一句SQL（select 1）来检查一下MySQL服务是否已经可用。</p></blockquote><p>当然，上述这些初始化操作完成后，我们还要删除掉前面用到的这些备份信息文件。否则，下次这个容器重启时，就会发现这些文件存在，所以又会重新执行一次数据恢复和集群初始化的操作，这是不对的。</p><p>同理，change_master_to.sql.in在使用后也要被重命名，以免容器重启时因为发现这个文件存在又执行一遍初始化。</p><p><strong>在完成MySQL节点的初始化后，这个sidecar容器的第二个工作，则是启动一个数据传输服务。</strong></p><p>具体做法是：sidecar容器会使用ncat命令启动一个工作在3307端口上的网络发送服务。一旦收到数据传输请求时，sidecar容器就会调用xtrabackup --backup指令备份当前MySQL的数据，然后把这些备份数据返回给请求者。这就是为什么我们在InitContainer里定义数据拷贝的时候，访问的是“上一个MySQL节点”的3307端口。</p><p>值得一提的是，由于sidecar容器和MySQL容器同处于一个Pod里，所以它是直接通过Localhost来访问和备份MySQL容器里的数据的，非常方便。</p><p>同样地，我在这里举例用的只是一种备份方法而已，你完全可以选择其他自己喜欢的方案。比如，你可以使用innobackupex命令做数据备份和准备，它的使用方法几乎与本文的备份方法一样。</p><p>至此，我们也就翻越了“第三座大山”，完成了Slave节点第一次启动前的初始化工作。</p><p>扳倒了这“三座大山”后，我们终于可以定义Pod里的主角，MySQL容器了。有了前面这些定义和初始化工作，MySQL容器本身的定义就非常简单了，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">...</span></div><div class="token-line"><span class="token plain">          # template.spec</span></div><div class="token-line"><span class="token plain">          containers:</span></div><div class="token-line"><span class="token plain">          - name: mysql</span></div><div class="token-line"><span class="token plain">            image: mysql:5.7</span></div><div class="token-line"><span class="token plain">            env:</span></div><div class="token-line"><span class="token plain">            - name: MYSQL_ALLOW_EMPTY_PASSWORD</span></div><div class="token-line"><span class="token plain">              value: &quot;1&quot;</span></div><div class="token-line"><span class="token plain">            ports:</span></div><div class="token-line"><span class="token plain">            - name: mysql</span></div><div class="token-line"><span class="token plain">              containerPort: 3306</span></div><div class="token-line"><span class="token plain">            volumeMounts:</span></div><div class="token-line"><span class="token plain">            - name: data</span></div><div class="token-line"><span class="token plain">              mountPath: /var/lib/mysql</span></div><div class="token-line"><span class="token plain">              subPath: mysql</span></div><div class="token-line"><span class="token plain">            - name: conf</span></div><div class="token-line"><span class="token plain">              mountPath: /etc/mysql/conf.d</span></div><div class="token-line"><span class="token plain">            resources:</span></div><div class="token-line"><span class="token plain">              requests:</span></div><div class="token-line"><span class="token plain">                cpu: 500m</span></div><div class="token-line"><span class="token plain">                memory: 1Gi</span></div><div class="token-line"><span class="token plain">            livenessProbe:</span></div><div class="token-line"><span class="token plain">              exec:</span></div><div class="token-line"><span class="token plain">                command: [&quot;mysqladmin&quot;, &quot;ping&quot;]</span></div><div class="token-line"><span class="token plain">              initialDelaySeconds: 30</span></div><div class="token-line"><span class="token plain">              periodSeconds: 10</span></div><div class="token-line"><span class="token plain">              timeoutSeconds: 5</span></div><div class="token-line"><span class="token plain">            readinessProbe:</span></div><div class="token-line"><span class="token plain">              exec:</span></div><div class="token-line"><span class="token plain">                # 通过TCP连接的方式进行健康检查</span></div><div class="token-line"><span class="token plain">                command: [&quot;mysql&quot;, &quot;-h&quot;, &quot;127.0.0.1&quot;, &quot;-e&quot;, &quot;SELECT 1&quot;]</span></div><div class="token-line"><span class="token plain">              initialDelaySeconds: 5</span></div><div class="token-line"><span class="token plain">              periodSeconds: 2</span></div><div class="token-line"><span class="token plain">              timeoutSeconds: 1</span></div></pre></div><p>在这个容器的定义里，我们使用了一个标准的MySQL 5.7 的官方镜像。它的数据目录是/var/lib/mysql，配置文件目录是/etc/mysql/conf.d。</p><p>这时候，你应该能够明白，如果MySQL容器是Slave节点的话，它的数据目录里的数据，就来自于InitContainer从其他节点里拷贝而来的备份。它的配置文件目录/etc/mysql/conf.d里的内容，则来自于ConfigMap对应的Volume。而它的初始化工作，则是由同一个Pod里的sidecar容器完成的。这些操作，正是我刚刚为你讲述的大部分内容。</p><p>另外，我们为它定义了一个livenessProbe，通过mysqladmin ping命令来检查它是否健康；还定义了一个readinessProbe，通过查询SQL（select 1）来检查MySQL服务是否可用。当然，凡是readinessProbe检查失败的MySQL Pod，都会从Service里被摘除掉。</p><p>至此，一个完整的主从复制模式的MySQL集群就定义完了。</p><p>现在，我们就可以使用kubectl命令，尝试运行一下这个StatefulSet了。</p><p><strong>首先，我们需要在Kubernetes集群里创建满足条件的PV</strong>。如果你使用的是我们在第11篇文章《<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/39724">从0到1：搭建一个完整的Kubernetes集群》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>里部署的Kubernetes集群的话，你可以按照如下方式使用存储插件Rook：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ kubectl create -f rook-storage.yaml</span></div><div class="token-line"><span class="token plain">    $ cat rook-storage.yaml</span></div><div class="token-line"><span class="token plain">    apiVersion: ceph.rook.io/v1beta1</span></div><div class="token-line"><span class="token plain">    kind: Pool</span></div><div class="token-line"><span class="token plain">    metadata:</span></div><div class="token-line"><span class="token plain">      name: replicapool</span></div><div class="token-line"><span class="token plain">      namespace: rook-ceph</span></div><div class="token-line"><span class="token plain">    spec:</span></div><div class="token-line"><span class="token plain">      replicated:</span></div><div class="token-line"><span class="token plain">        size: 3</span></div><div class="token-line"><span class="token plain">    ---</span></div><div class="token-line"><span class="token plain">    apiVersion: storage.k8s.io/v1</span></div><div class="token-line"><span class="token plain">    kind: StorageClass</span></div><div class="token-line"><span class="token plain">    metadata:</span></div><div class="token-line"><span class="token plain">      name: rook-ceph-block</span></div><div class="token-line"><span class="token plain">    provisioner: ceph.rook.io/block</span></div><div class="token-line"><span class="token plain">    parameters:</span></div><div class="token-line"><span class="token plain">      pool: replicapool</span></div><div class="token-line"><span class="token plain">      clusterNamespace: rook-ceph</span></div></pre></div><p>在这里，我用到了StorageClass来完成这个操作。它的作用，是自动地为集群里存在的每一个PVC，调用存储插件（Rook）创建对应的PV，从而省去了我们手动创建PV的机械劳动。我在后续讲解容器存储的时候，会再详细介绍这个机制。</p><blockquote><p>备注：在使用Rook的情况下，mysql-statefulset.yaml里的volumeClaimTemplates字段需要加上声明storageClassName=rook-ceph-block，才能使用到这个Rook提供的持久化存储。</p></blockquote><p><strong>然后，我们就可以创建这个StatefulSet了</strong>，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ kubectl create -f mysql-statefulset.yaml</span></div><div class="token-line"><span class="token plain">    $ kubectl get pod -l app=mysql</span></div><div class="token-line"><span class="token plain">    NAME      READY     STATUS    RESTARTS   AGE</span></div><div class="token-line"><span class="token plain">    mysql-0   2/2       Running   0          2m</span></div><div class="token-line"><span class="token plain">    mysql-1   2/2       Running   0          1m</span></div><div class="token-line"><span class="token plain">    mysql-2   2/2       Running   0          1m</span></div></pre></div><p>可以看到，StatefulSet启动成功后，会有三个Pod运行。</p><p><strong>接下来，我们可以尝试向这个MySQL集群发起请求，执行一些SQL操作来验证它是否正常：</strong></p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ kubectl run mysql-client --image=mysql:5.7 -i --rm --restart=Never --\</span></div><div class="token-line"><span class="token plain">      mysql -h mysql-0.mysql &lt;&lt;EOF</span></div><div class="token-line"><span class="token plain">    CREATE DATABASE test;</span></div><div class="token-line"><span class="token plain">    CREATE TABLE test.messages (message VARCHAR(250));</span></div><div class="token-line"><span class="token plain">    INSERT INTO test.messages VALUES (&#x27;hello&#x27;);</span></div><div class="token-line"><span class="token plain">    EOF</span></div></pre></div><p>如上所示，我们通过启动一个容器，使用MySQL client执行了创建数据库和表、以及插入数据的操作。需要注意的是，我们连接的MySQL的地址必须是mysql-0.mysql（即：Master节点的DNS记录）。因为，只有Master节点才能处理写操作。</p><p>而通过连接mysql-read这个Service，我们就可以用SQL进行读操作，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ kubectl run mysql-client --image=mysql:5.7 -i -t --rm --restart=Never --\</span></div><div class="token-line"><span class="token plain">     mysql -h mysql-read -e &quot;SELECT * FROM test.messages&quot;</span></div><div class="token-line"><span class="token plain">    Waiting for pod default/mysql-client to be running, status is Pending, pod ready: false</span></div><div class="token-line"><span class="token plain">    +---------+</span></div><div class="token-line"><span class="token plain">    | message |</span></div><div class="token-line"><span class="token plain">    +---------+</span></div><div class="token-line"><span class="token plain">    | hello   |</span></div><div class="token-line"><span class="token plain">    +---------+</span></div><div class="token-line"><span class="token plain">    pod &quot;mysql-client&quot; deleted</span></div></pre></div><p>在有了StatefulSet以后，你就可以像Deployment那样，非常方便地扩展这个MySQL集群，比如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ kubectl scale statefulset mysql  --replicas=5</span></div></pre></div><p>这时候，你就会发现新的Slave Pod mysql-3和mysql-4被自动创建了出来。</p><p>而如果你像如下所示的这样，直接连接mysql-3.mysql，即mysql-3这个Pod的DNS名字来进行查询操作：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ kubectl run mysql-client --image=mysql:5.7 -i -t --rm --restart=Never --\</span></div><div class="token-line"><span class="token plain">      mysql -h mysql-3.mysql -e &quot;SELECT * FROM test.messages&quot;</span></div><div class="token-line"><span class="token plain">    Waiting for pod default/mysql-client to be running, status is Pending, pod ready: false</span></div><div class="token-line"><span class="token plain">    +---------+</span></div><div class="token-line"><span class="token plain">    | message |</span></div><div class="token-line"><span class="token plain">    +---------+</span></div><div class="token-line"><span class="token plain">    | hello   |</span></div><div class="token-line"><span class="token plain">    +---------+</span></div><div class="token-line"><span class="token plain">    pod &quot;mysql-client&quot; deleted</span></div></pre></div><p>就会看到，从StatefulSet为我们新创建的mysql-3上，同样可以读取到之前插入的记录。也就是说，我们的数据备份和恢复，都是有效的。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/08#总结"><span class="icon icon-link"></span></a>总结</h2><p>在今天这篇文章中，我以MySQL集群为例，和你详细分享了一个实际的StatefulSet的编写过程。这个YAML文件的<a target="_blank" rel="noopener noreferrer" href="https://kubernetes.io/docs/tasks/run-application/run-replicated-stateful-application/#statefulset">链接在这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，希望你能多花一些时间认真消化。</p><p>在这个过程中，有以下几个关键点（坑）特别值得你注意和体会。</p><ol><li><p>“人格分裂”：在解决需求的过程中，一定要记得思考，该Pod在扮演不同角色时的不同操作。</p></li><li><p>“阅后即焚”：很多“有状态应用”的节点，只是在第一次启动的时候才需要做额外处理。所以，在编写YAML文件时，你一定要考虑“容器重启”的情况，不要让这一次的操作干扰到下一次的容器启动。</p></li><li><p>“容器之间平等无序”：除非是InitContainer，否则一个Pod里的多个容器之间，是完全平等的。所以，你精心设计的sidecar，绝不能对容器的顺序做出假设，否则就需要进行前置检查。</p></li></ol><p>最后，相信你也已经能够理解，StatefulSet其实是一种特殊的Deployment，只不过这个“Deployment”的每个Pod实例的名字里，都携带了一个唯一并且固定的编号。这个编号的顺序，固定了Pod的拓扑关系；这个编号对应的DNS记录，固定了Pod的访问方式；这个编号对应的PV，绑定了Pod与持久化存储的关系。所以，当Pod被删除重建时，这些“状态”都会保持不变。</p><p>而一旦你的应用没办法通过上述方式进行状态的管理，那就代表了StatefulSet已经不能解决它的部署问题了。这时候，我后面讲到的Operator，可能才是一个更好的选择。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/08#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>如果我们现在的需求是：所有的读请求，只由Slave节点处理；所有的写请求，只由Master节点处理。那么，你需要在今天这篇文章的基础上再做哪些改动呢？</p><p>感谢你的收听，欢迎你给我留言，也欢迎分享给更多的朋友一起阅读。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/深入剖析kubernetes/04.容器编排与Kubernetes作业管理/08.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:09</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
