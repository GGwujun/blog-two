<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>15 | 深入解析Pod对象（二）：使用进阶</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/深入剖析kubernetes/04.容器编排与kubernetes作业管理/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a aria-current="page" class="active" href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a aria-current="page" class="active" href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/深入剖析kubernetes/01.课前必读">01.课前必读</a><ul><li><a href="/blog-two/深入剖析kubernetes/01.课前必读/01"><span>开篇词 | 打通“容器技术”的任督二脉</span></a></li><li><a href="/blog-two/深入剖析kubernetes/01.课前必读/02"><span>01 | 预习篇 · 小鲸鱼大事记（一）：初出茅庐</span></a></li><li><a href="/blog-two/深入剖析kubernetes/01.课前必读/03"><span>02 | 预习篇 · 小鲸鱼大事记（二）：崭露头角</span></a></li><li><a href="/blog-two/深入剖析kubernetes/01.课前必读/04"><span>03 | 预习篇 · 小鲸鱼大事记（三）：群雄并起</span></a></li><li><a href="/blog-two/深入剖析kubernetes/01.课前必读/05"><span>04 | 预习篇 · 小鲸鱼大事记（四）：尘埃落定</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇">02.容器技术概念入门篇</a><ul><li><a href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇/01"><span>05 | 白话容器基础（一）：从进程说开去</span></a></li><li><a href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇/02"><span>06 | 白话容器基础（二）：隔离与限制</span></a></li><li><a href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇/03"><span>07 | 白话容器基础（三）：深入理解容器镜像</span></a></li><li><a href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇/04"><span>08 | 白话容器基础（四）：重新认识Docker容器</span></a></li><li><a href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇/05"><span>09 | 从容器到容器云：谈谈Kubernetes的本质</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/03.kubernetes集群搭建与实践">03.Kubernetes集群搭建与实践</a><ul><li><a href="/blog-two/深入剖析kubernetes/03.kubernetes集群搭建与实践/01"><span>10 | Kubernetes一键部署利器：kubeadm</span></a></li><li><a href="/blog-two/深入剖析kubernetes/03.kubernetes集群搭建与实践/02"><span>11 | 从0到1：搭建一个完整的Kubernetes集群</span></a></li><li><a href="/blog-two/深入剖析kubernetes/03.kubernetes集群搭建与实践/03"><span>12 | 牛刀小试：我的第一个容器化应用</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理">04.容器编排与Kubernetes作业管理</a><ul><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/01"><span>13 | 为什么我们需要Pod？</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/02"><span>14 | 深入解析Pod对象（一）：基本概念</span></a></li><li><a aria-current="page" class="active" href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/03"><span>15 | 深入解析Pod对象（二）：使用进阶</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/04"><span>16 | 编排其实很简单：谈谈“控制器”模型</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/05"><span>17 | 经典PaaS的记忆：作业副本与水平扩展</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/06"><span>18 | 深入理解StatefulSet（一）：拓扑状态</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/07"><span>19 | 深入理解StatefulSet（二）：存储状态</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/08"><span>20 | 深入理解StatefulSet（三）：有状态应用实践</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/09"><span>21 | 容器化守护进程的意义：DaemonSet</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/10"><span>22 | 撬动离线业务：Job与CronJob</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/11"><span>23 | 声明式API与Kubernetes编程范式</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/12"><span>24 | 深入解析声明式API（一）：API对象的奥秘</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/13"><span>25 | 深入解析声明式API（二）：编写自定义控制器</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/14"><span>26 | 基于角色的权限控制：RBAC</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/15"><span>27 | 聪明的微创新：Operator工作原理解读</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/05.kubernetes容器持久化存储">05.Kubernetes容器持久化存储</a><ul><li><a href="/blog-two/深入剖析kubernetes/05.kubernetes容器持久化存储/01"><span>28 | PV、PVC、StorageClass，这些到底在说啥？</span></a></li><li><a href="/blog-two/深入剖析kubernetes/05.kubernetes容器持久化存储/02"><span>29 | PV、PVC体系是不是多此一举？从本地持久化卷谈起</span></a></li><li><a href="/blog-two/深入剖析kubernetes/05.kubernetes容器持久化存储/03"><span>30 | 编写自己的存储插件：FlexVolume与CSI</span></a></li><li><a href="/blog-two/深入剖析kubernetes/05.kubernetes容器持久化存储/04"><span>31 | 容器存储实践：CSI插件编写指南</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络">06.Kubernetes容器网络</a><ul><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/01"><span>32 | 浅谈容器网络</span></a></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/02"><span>33 | 深入解析容器跨主机网络</span></a></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/03"><span>34 | Kubernetes网络模型与CNI网络插件</span></a></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/04"><span>35 | 解读Kubernetes三层网络方案</span></a></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/05"><span>36 | 为什么说Kubernetes只有soft multi-tenancy？</span></a></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/06"><span>37 | 找到容器不容易：Service、DNS与服务发现</span></a></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/07"><span>38 | 从外界连通Service与Service调试“三板斧”</span></a></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/08"><span>39 | 谈谈Service与Ingress</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/07.kubernetes作业调度与资源管理">07.Kubernetes作业调度与资源管理</a><ul><li><a href="/blog-two/深入剖析kubernetes/07.kubernetes作业调度与资源管理/01"><span>40 | Kubernetes的资源模型与资源管理</span></a></li><li><a href="/blog-two/深入剖析kubernetes/07.kubernetes作业调度与资源管理/02"><span>41 | 十字路口上的Kubernetes默认调度器</span></a></li><li><a href="/blog-two/深入剖析kubernetes/07.kubernetes作业调度与资源管理/03"><span>42 | Kubernetes默认调度器调度策略解析</span></a></li><li><a href="/blog-two/深入剖析kubernetes/07.kubernetes作业调度与资源管理/04"><span>43 | Kubernetes默认调度器的优先级与抢占机制</span></a></li><li><a href="/blog-two/深入剖析kubernetes/07.kubernetes作业调度与资源管理/05"><span>44 | Kubernetes GPU管理与Device Plugin机制</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/08.kubernetes容器运行时">08.Kubernetes容器运行时</a><ul><li><a href="/blog-two/深入剖析kubernetes/08.kubernetes容器运行时/01"><span>45 | 幕后英雄：SIG-Node与CRI</span></a></li><li><a href="/blog-two/深入剖析kubernetes/08.kubernetes容器运行时/02"><span>46 | 解读 CRI 与 容器运行时</span></a></li><li><a href="/blog-two/深入剖析kubernetes/08.kubernetes容器运行时/03"><span>47 | 绝不仅仅是安全：Kata Containers 与 gVisor</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/09.kubernetes容器监控与日志">09.Kubernetes容器监控与日志</a><ul><li><a href="/blog-two/深入剖析kubernetes/09.kubernetes容器监控与日志/01"><span>48 | Prometheus、Metrics Server与Kubernetes监控体系</span></a></li><li><a href="/blog-two/深入剖析kubernetes/09.kubernetes容器监控与日志/02"><span>49 | Custom Metrics: 让Auto Scaling不再“食之无味”</span></a></li><li><a href="/blog-two/深入剖析kubernetes/09.kubernetes容器监控与日志/03"><span>50 | 让日志无处可逃：容器日志收集与管理</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/10.再谈开源与社区">10.再谈开源与社区</a><ul><li><a href="/blog-two/深入剖析kubernetes/10.再谈开源与社区/01"><span>51 | 谈谈Kubernetes开源社区和未来走向</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/11.答疑文章">11.答疑文章</a><ul><li><a href="/blog-two/深入剖析kubernetes/11.答疑文章/01"><span>52 | 答疑：在问题中解决问题，在思考中产生思考</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/12.特别放送">12.特别放送</a><ul><li><a href="/blog-two/深入剖析kubernetes/12.特别放送/01"><span>特别放送 | 2019 年，容器技术生态会发生些什么？</span></a></li><li><a href="/blog-two/深入剖析kubernetes/12.特别放送/02"><span>特别放送 | 基于 Kubernetes 的云原生应用管理，到底应该怎么做？</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/13.结束语">13.结束语</a><ul><li><a href="/blog-two/深入剖析kubernetes/13.结束语/01"><span>结束语 | Kubernetes：赢开发者赢天下</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/14.结课测试">14.结课测试</a><ul><li><a href="/blog-two/深入剖析kubernetes/14.结课测试/01"><span>结课测试｜这些Kubernetes的相关知识，你都掌握了吗？</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/summary">深入剖析kubernetes</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="总结" data-depth="2"><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/03#总结"><span>总结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/03#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="15--深入解析pod对象二使用进阶"><a aria-hidden="true" tabindex="-1" href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/03#15--深入解析pod对象二使用进阶"><span class="icon icon-link"></span></a>15 | 深入解析Pod对象（二）：使用进阶</h1><p>你好，我是张磊。今天我和你分享的主题是：深入解析Pod对象之使用进阶。</p><p>在上一篇文章中，我深入解析了Pod的API对象，讲解了Pod和Container的关系。</p><p>作为Kubernetes项目里最核心的编排对象，Pod携带的信息非常丰富。其中，资源定义（比如CPU、内存等），以及调度相关的字段，我会在后面专门讲解调度器时再进行深入的分析。在本篇，我们就先从一种特殊的Volume开始，来帮助你更加深入地理解Pod对象各个重要字段的含义。</p><p>这种特殊的Volume，叫作Projected Volume，你可以把它翻译为“投射数据卷”。</p><blockquote><p>备注：Projected Volume是Kubernetes v1.11之后的新特性</p></blockquote><p>这是什么意思呢？</p><p>在Kubernetes中，有几种特殊的Volume，它们存在的意义不是为了存放容器里的数据，也不是用来进行容器和宿主机之间的数据交换。这些特殊Volume的作用，是为容器提供预先定义好的数据。所以，从容器的角度来看，这些Volume里的信息就是仿佛是<strong>被Kubernetes“投射”（Project）进入容器当中的</strong>。这正是Projected Volume的含义。</p><p>到目前为止，Kubernetes支持的Projected Volume一共有四种：</p><ol><li><p>Secret；</p></li><li><p>ConfigMap；</p></li><li><p>Downward API；</p></li><li><p>ServiceAccountToken。</p></li></ol><p>在今天这篇文章中，我首先和你分享的是Secret。它的作用，是帮你把Pod想要访问的加密数据，存放到Etcd中。然后，你就可以通过在Pod的容器里挂载Volume的方式，访问到这些Secret里保存的信息了。</p><p>Secret最典型的使用场景，莫过于存放数据库的Credential信息，比如下面这个例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">apiVersion: v1</span></div><div class="token-line"><span class="token plain">    kind: Pod</span></div><div class="token-line"><span class="token plain">    metadata:</span></div><div class="token-line"><span class="token plain">      name: test-projected-volume </span></div><div class="token-line"><span class="token plain">    spec:</span></div><div class="token-line"><span class="token plain">      containers:</span></div><div class="token-line"><span class="token plain">      - name: test-secret-volume</span></div><div class="token-line"><span class="token plain">        image: busybox</span></div><div class="token-line"><span class="token plain">        args:</span></div><div class="token-line"><span class="token plain">        - sleep</span></div><div class="token-line"><span class="token plain">        - &quot;86400&quot;</span></div><div class="token-line"><span class="token plain">        volumeMounts:</span></div><div class="token-line"><span class="token plain">        - name: mysql-cred</span></div><div class="token-line"><span class="token plain">          mountPath: &quot;/projected-volume&quot;</span></div><div class="token-line"><span class="token plain">          readOnly: true</span></div><div class="token-line"><span class="token plain">      volumes:</span></div><div class="token-line"><span class="token plain">      - name: mysql-cred</span></div><div class="token-line"><span class="token plain">        projected:</span></div><div class="token-line"><span class="token plain">          sources:</span></div><div class="token-line"><span class="token plain">          - secret:</span></div><div class="token-line"><span class="token plain">              name: user</span></div><div class="token-line"><span class="token plain">          - secret:</span></div><div class="token-line"><span class="token plain">              name: pass</span></div></pre></div><p>在这个Pod中，我定义了一个简单的容器。它声明挂载的Volume，并不是常见的emptyDir或者hostPath类型，而是projected类型。而这个 Volume的数据来源（sources），则是名为user和pass的Secret对象，分别对应的是数据库的用户名和密码。</p><p>这里用到的数据库的用户名、密码，正是以Secret对象的方式交给Kubernetes保存的。完成这个操作的指令，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ cat ./username.txt</span></div><div class="token-line"><span class="token plain">    admin</span></div><div class="token-line"><span class="token plain">    $ cat ./password.txt</span></div><div class="token-line"><span class="token plain">    c1oudc0w!</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    $ kubectl create secret generic user --from-file=./username.txt</span></div><div class="token-line"><span class="token plain">    $ kubectl create secret generic pass --from-file=./password.txt</span></div></pre></div><p>其中，username.txt和password.txt文件里，存放的就是用户名和密码；而user和pass，则是我为Secret对象指定的名字。而我想要查看这些Secret对象的话，只要执行一条kubectl get命令就可以了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ kubectl get secrets</span></div><div class="token-line"><span class="token plain">    NAME           TYPE                                DATA      AGE</span></div><div class="token-line"><span class="token plain">    user          Opaque                                1         51s</span></div><div class="token-line"><span class="token plain">    pass          Opaque                                1         51s</span></div></pre></div><p>当然，除了使用kubectl create secret指令外，我也可以直接通过编写YAML文件的方式来创建这个Secret对象，比如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">apiVersion: v1</span></div><div class="token-line"><span class="token plain">    kind: Secret</span></div><div class="token-line"><span class="token plain">    metadata:</span></div><div class="token-line"><span class="token plain">      name: mysecret</span></div><div class="token-line"><span class="token plain">    type: Opaque</span></div><div class="token-line"><span class="token plain">    data:</span></div><div class="token-line"><span class="token plain">      user: YWRtaW4=</span></div><div class="token-line"><span class="token plain">      pass: MWYyZDFlMmU2N2Rm</span></div></pre></div><p>可以看到，通过编写YAML文件创建出来的Secret对象只有一个。但它的data字段，却以Key-Value的格式保存了两份Secret数据。其中，“user”就是第一份数据的Key，“pass”是第二份数据的Key。</p><p>需要注意的是，Secret对象要求这些数据必须是经过Base64转码的，以免出现明文密码的安全隐患。这个转码操作也很简单，比如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ echo -n &#x27;admin&#x27; | base64</span></div><div class="token-line"><span class="token plain">    YWRtaW4=</span></div><div class="token-line"><span class="token plain">    $ echo -n &#x27;1f2d1e2e67df&#x27; | base64</span></div><div class="token-line"><span class="token plain">    MWYyZDFlMmU2N2Rm</span></div></pre></div><p>这里需要注意的是，像这样创建的Secret对象，它里面的内容仅仅是经过了转码，而并没有被加密。在真正的生产环境中，你需要在Kubernetes中开启Secret的加密插件，增强数据的安全性。关于开启Secret加密插件的内容，我会在后续专门讲解Secret的时候，再做进一步说明。</p><p>接下来，我们尝试一下创建这个Pod：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ kubectl create -f test-projected-volume.yaml</span></div></pre></div><p>当Pod变成Running状态之后，我们再验证一下这些Secret对象是不是已经在容器里了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ kubectl exec -it test-projected-volume -- /bin/sh</span></div><div class="token-line"><span class="token plain">    $ ls /projected-volume/</span></div><div class="token-line"><span class="token plain">    user</span></div><div class="token-line"><span class="token plain">    pass</span></div><div class="token-line"><span class="token plain">    $ cat /projected-volume/user</span></div><div class="token-line"><span class="token plain">    root</span></div><div class="token-line"><span class="token plain">    $ cat /projected-volume/pass</span></div><div class="token-line"><span class="token plain">    1f2d1e2e67df</span></div></pre></div><p>从返回结果中，我们可以看到，保存在Etcd里的用户名和密码信息，已经以文件的形式出现在了容器的Volume目录里。而这个文件的名字，就是kubectl create secret指定的Key，或者说是Secret对象的data字段指定的Key。</p><p>更重要的是，像这样通过挂载方式进入到容器里的Secret，一旦其对应的Etcd里的数据被更新，这些Volume里的文件内容，同样也会被更新。其实，<strong>这是kubelet组件在定时维护这些Volume。</strong></p><p>需要注意的是，这个更新可能会有一定的延时。所以<strong>在编写应用程序时，在发起数据库连接的代码处写好重试和超时的逻辑，绝对是个好习惯。</strong></p><p><strong>与Secret类似的是ConfigMap</strong>，它与Secret的区别在于，ConfigMap保存的是不需要加密的、应用所需的配置信息。而ConfigMap的用法几乎与Secret完全相同：你可以使用kubectl create configmap从文件或者目录创建ConfigMap，也可以直接编写ConfigMap对象的YAML文件。</p><p>比如，一个Java应用所需的配置文件（.properties文件），就可以通过下面这样的方式保存在ConfigMap里：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># .properties文件的内容</span></div><div class="token-line"><span class="token plain">    $ cat example/ui.properties</span></div><div class="token-line"><span class="token plain">    color.good=purple</span></div><div class="token-line"><span class="token plain">    color.bad=yellow</span></div><div class="token-line"><span class="token plain">    allow.textmode=true</span></div><div class="token-line"><span class="token plain">    how.nice.to.look=fairlyNice</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 从.properties文件创建ConfigMap</span></div><div class="token-line"><span class="token plain">    $ kubectl create configmap ui-config --from-file=example/ui.properties</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 查看这个ConfigMap里保存的信息(data)</span></div><div class="token-line"><span class="token plain">    $ kubectl get configmaps ui-config -o yaml</span></div><div class="token-line"><span class="token plain">    apiVersion: v1</span></div><div class="token-line"><span class="token plain">    data:</span></div><div class="token-line"><span class="token plain">      ui.properties: |</span></div><div class="token-line"><span class="token plain">        color.good=purple</span></div><div class="token-line"><span class="token plain">        color.bad=yellow</span></div><div class="token-line"><span class="token plain">        allow.textmode=true</span></div><div class="token-line"><span class="token plain">        how.nice.to.look=fairlyNice</span></div><div class="token-line"><span class="token plain">    kind: ConfigMap</span></div><div class="token-line"><span class="token plain">    metadata:</span></div><div class="token-line"><span class="token plain">      name: ui-config</span></div><div class="token-line"><span class="token plain">      ...</span></div></pre></div><blockquote><p>备注：kubectl get -o yaml这样的参数，会将指定的Pod API对象以YAML的方式展示出来。</p></blockquote><p><strong>接下来是Downward API</strong>，它的作用是：让Pod里的容器能够直接获取到这个Pod API对象本身的信息。</p><p>举个例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">apiVersion: v1</span></div><div class="token-line"><span class="token plain">    kind: Pod</span></div><div class="token-line"><span class="token plain">    metadata:</span></div><div class="token-line"><span class="token plain">      name: test-downwardapi-volume</span></div><div class="token-line"><span class="token plain">      labels:</span></div><div class="token-line"><span class="token plain">        zone: us-est-coast</span></div><div class="token-line"><span class="token plain">        cluster: test-cluster1</span></div><div class="token-line"><span class="token plain">        rack: rack-22</span></div><div class="token-line"><span class="token plain">    spec:</span></div><div class="token-line"><span class="token plain">      containers:</span></div><div class="token-line"><span class="token plain">        - name: client-container</span></div><div class="token-line"><span class="token plain">          image: k8s.gcr.io/busybox</span></div><div class="token-line"><span class="token plain">          command: [&quot;sh&quot;, &quot;-c&quot;]</span></div><div class="token-line"><span class="token plain">          args:</span></div><div class="token-line"><span class="token plain">          - while true; do</span></div><div class="token-line"><span class="token plain">              if [[ -e /etc/podinfo/labels ]]; then</span></div><div class="token-line"><span class="token plain">                echo -en &#x27;\n\n&#x27;; cat /etc/podinfo/labels; fi;</span></div><div class="token-line"><span class="token plain">              sleep 5;</span></div><div class="token-line"><span class="token plain">            done;</span></div><div class="token-line"><span class="token plain">          volumeMounts:</span></div><div class="token-line"><span class="token plain">            - name: podinfo</span></div><div class="token-line"><span class="token plain">              mountPath: /etc/podinfo</span></div><div class="token-line"><span class="token plain">              readOnly: false</span></div><div class="token-line"><span class="token plain">      volumes:</span></div><div class="token-line"><span class="token plain">        - name: podinfo</span></div><div class="token-line"><span class="token plain">          projected:</span></div><div class="token-line"><span class="token plain">            sources:</span></div><div class="token-line"><span class="token plain">            - downwardAPI:</span></div><div class="token-line"><span class="token plain">                items:</span></div><div class="token-line"><span class="token plain">                  - path: &quot;labels&quot;</span></div><div class="token-line"><span class="token plain">                    fieldRef:</span></div><div class="token-line"><span class="token plain">                      fieldPath: metadata.labels</span></div></pre></div><p>在这个Pod的YAML文件中，我定义了一个简单的容器，声明了一个projected类型的Volume。只不过这次Volume的数据来源，变成了Downward API。而这个Downward API Volume，则声明了要暴露Pod的metadata.labels信息给容器。</p><p>通过这样的声明方式，当前Pod的Labels字段的值，就会被Kubernetes自动挂载成为容器里的/etc/podinfo/labels文件。</p><p>而这个容器的启动命令，则是不断打印出/etc/podinfo/labels里的内容。所以，当我创建了这个Pod之后，就可以通过kubectl logs指令，查看到这些Labels字段被打印出来，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ kubectl create -f dapi-volume.yaml</span></div><div class="token-line"><span class="token plain">    $ kubectl logs test-downwardapi-volume</span></div><div class="token-line"><span class="token plain">    cluster=&quot;test-cluster1&quot;</span></div><div class="token-line"><span class="token plain">    rack=&quot;rack-22&quot;</span></div><div class="token-line"><span class="token plain">    zone=&quot;us-est-coast&quot;</span></div></pre></div><p>目前，Downward API支持的字段已经非常丰富了，比如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">1. 使用fieldRef可以声明使用:</span></div><div class="token-line"><span class="token plain">    spec.nodeName - 宿主机名字</span></div><div class="token-line"><span class="token plain">    status.hostIP - 宿主机IP</span></div><div class="token-line"><span class="token plain">    metadata.name - Pod的名字</span></div><div class="token-line"><span class="token plain">    metadata.namespace - Pod的Namespace</span></div><div class="token-line"><span class="token plain">    status.podIP - Pod的IP</span></div><div class="token-line"><span class="token plain">    spec.serviceAccountName - Pod的Service Account的名字</span></div><div class="token-line"><span class="token plain">    metadata.uid - Pod的UID</span></div><div class="token-line"><span class="token plain">    metadata.labels[&#x27;&lt;KEY&gt;&#x27;] - 指定&lt;KEY&gt;的Label值</span></div><div class="token-line"><span class="token plain">    metadata.annotations[&#x27;&lt;KEY&gt;&#x27;] - 指定&lt;KEY&gt;的Annotation值</span></div><div class="token-line"><span class="token plain">    metadata.labels - Pod的所有Label</span></div><div class="token-line"><span class="token plain">    metadata.annotations - Pod的所有Annotation</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    2. 使用resourceFieldRef可以声明使用:</span></div><div class="token-line"><span class="token plain">    容器的CPU limit</span></div><div class="token-line"><span class="token plain">    容器的CPU request</span></div><div class="token-line"><span class="token plain">    容器的memory limit</span></div><div class="token-line"><span class="token plain">    容器的memory request</span></div></pre></div><p>上面这个列表的内容，随着Kubernetes项目的发展肯定还会不断增加。所以这里列出来的信息仅供参考，你在使用Downward API时，还是要记得去查阅一下官方文档。</p><p>不过，需要注意的是，Downward API能够获取到的信息，<strong>一定是Pod里的容器进程启动之前就能够确定下来的信息</strong>。而如果你想要获取Pod容器运行后才会出现的信息，比如，容器进程的PID，那就肯定不能使用Downward API了，而应该考虑在Pod里定义一个sidecar容器。</p><p>其实，Secret、ConfigMap，以及Downward API这三种Projected Volume定义的信息，大多还可以通过环境变量的方式出现在容器里。但是，通过环境变量获取这些信息的方式，不具备自动更新的能力。所以，一般情况下，我都建议你使用Volume文件的方式获取这些信息。</p><p>在明白了Secret之后，我再为你讲解Pod中一个与它密切相关的概念：Service Account。</p><p>相信你一定有过这样的想法：我现在有了一个Pod，我能不能在这个Pod里安装一个Kubernetes的Client，这样就可以从容器里直接访问并且操作这个Kubernetes的API了呢？</p><p>这当然是可以的。</p><p>不过，你首先要解决API Server的授权问题。</p><p>Service Account对象的作用，就是Kubernetes系统内置的一种“服务账户”，它是Kubernetes进行权限分配的对象。比如，Service Account A，可以只被允许对Kubernetes API进行GET操作，而Service Account B，则可以有Kubernetes API的所有操作权限。</p><p>像这样的Service Account的授权信息和文件，实际上保存在它所绑定的一个特殊的Secret对象里的。这个特殊的Secret对象，就叫作<strong>ServiceAccountToken</strong>。任何运行在Kubernetes集群上的应用，都必须使用这个ServiceAccountToken里保存的授权信息，也就是Token，才可以合法地访问API Server。</p><p>所以说，Kubernetes项目的Projected Volume其实只有三种，因为第四种ServiceAccountToken，只是一种特殊的Secret而已。</p><p>另外，为了方便使用，Kubernetes已经为你提供了一个默认“服务账户”（default Service Account）。并且，任何一个运行在Kubernetes里的Pod，都可以直接使用这个默认的Service Account，而无需显示地声明挂载它。</p><p><strong>这是如何做到的呢？</strong></p><p>当然还是靠Projected Volume机制。</p><p>如果你查看一下任意一个运行在Kubernetes集群里的Pod，就会发现，每一个Pod，都已经自动声明一个类型是Secret、名为default-token-xxxx的Volume，然后 自动挂载在每个容器的一个固定目录上。比如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ kubectl describe pod nginx-deployment-5c678cfb6d-lg9lw</span></div><div class="token-line"><span class="token plain">    Containers:</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">      Mounts:</span></div><div class="token-line"><span class="token plain">        /var/run/secrets/kubernetes.io/serviceaccount from default-token-s8rbq (ro)</span></div><div class="token-line"><span class="token plain">    Volumes:</span></div><div class="token-line"><span class="token plain">      default-token-s8rbq:</span></div><div class="token-line"><span class="token plain">      Type:       Secret (a volume populated by a Secret)</span></div><div class="token-line"><span class="token plain">      SecretName:  default-token-s8rbq</span></div><div class="token-line"><span class="token plain">      Optional:    false</span></div></pre></div><p>这个Secret类型的Volume，正是默认Service Account对应的ServiceAccountToken。所以说，Kubernetes其实在每个Pod创建的时候，自动在它的spec.volumes部分添加上了默认ServiceAccountToken的定义，然后自动给每个容器加上了对应的volumeMounts字段。这个过程对于用户来说是完全透明的。</p><p>这样，一旦Pod创建完成，容器里的应用就可以直接从这个默认ServiceAccountToken的挂载目录里访问到授权信息和文件。这个容器内的路径在Kubernetes里是固定的，即：/var/run/secrets/kubernetes.io/serviceaccount ，而这个Secret类型的Volume里面的内容如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ ls /var/run/secrets/kubernetes.io/serviceaccount </span></div><div class="token-line"><span class="token plain">    ca.crt namespace  token</span></div></pre></div><p>所以，你的应用程序只要直接加载这些授权文件，就可以访问并操作Kubernetes API了。而且，如果你使用的是Kubernetes官方的Client包（<code>k8s.io/client-go</code>）的话，它还可以自动加载这个目录下的文件，你不需要做任何配置或者编码操作。</p><p><strong>这种把Kubernetes客户端以容器的方式运行在集群里，然后使用default Service Account自动授权的方式，被称作“InClusterConfig”，也是我最推荐的进行Kubernetes API编程的授权方式。</strong></p><p>当然，考虑到自动挂载默认ServiceAccountToken的潜在风险，Kubernetes允许你设置默认不为Pod里的容器自动挂载这个Volume。</p><p>除了这个默认的Service Account外，我们很多时候还需要创建一些我们自己定义的Service Account，来对应不同的权限设置。这样，我们的Pod里的容器就可以通过挂载这些Service Account对应的ServiceAccountToken，来使用这些自定义的授权信息。在后面讲解为Kubernetes开发插件的时候，我们将会实践到这个操作。</p><p>接下来，我们再来看Pod的另一个重要的配置：容器健康检查和恢复机制。</p><p>在Kubernetes中，你可以为Pod里的容器定义一个健康检查“探针”（Probe）。这样，kubelet就会根据这个Probe的返回值决定这个容器的状态，而不是直接以容器镜像是否运行（来自Docker返回的信息）作为依据。这种机制，是生产环境中保证应用健康存活的重要手段。</p><p>我们一起来看一个Kubernetes文档中的例子。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">apiVersion: v1</span></div><div class="token-line"><span class="token plain">    kind: Pod</span></div><div class="token-line"><span class="token plain">    metadata:</span></div><div class="token-line"><span class="token plain">      labels:</span></div><div class="token-line"><span class="token plain">        test: liveness</span></div><div class="token-line"><span class="token plain">      name: test-liveness-exec</span></div><div class="token-line"><span class="token plain">    spec:</span></div><div class="token-line"><span class="token plain">      containers:</span></div><div class="token-line"><span class="token plain">      - name: liveness</span></div><div class="token-line"><span class="token plain">        image: busybox</span></div><div class="token-line"><span class="token plain">        args:</span></div><div class="token-line"><span class="token plain">        - /bin/sh</span></div><div class="token-line"><span class="token plain">        - -c</span></div><div class="token-line"><span class="token plain">        - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600</span></div><div class="token-line"><span class="token plain">        livenessProbe:</span></div><div class="token-line"><span class="token plain">          exec:</span></div><div class="token-line"><span class="token plain">            command:</span></div><div class="token-line"><span class="token plain">            - cat</span></div><div class="token-line"><span class="token plain">            - /tmp/healthy</span></div><div class="token-line"><span class="token plain">          initialDelaySeconds: 5</span></div><div class="token-line"><span class="token plain">          periodSeconds: 5</span></div></pre></div><p>在这个Pod中，我们定义了一个有趣的容器。它在启动之后做的第一件事，就是在/tmp目录下创建了一个healthy文件，以此作为自己已经正常运行的标志。而30 s过后，它会把这个文件删除掉。</p><p>与此同时，我们定义了一个这样的livenessProbe（健康检查）。它的类型是exec，这意味着，它会在容器启动后，在容器里面执行一条我们指定的命令，比如：“cat /tmp/healthy”。这时，如果这个文件存在，这条命令的返回值就是0，Pod就会认为这个容器不仅已经启动，而且是健康的。这个健康检查，在容器启动5 s后开始执行（initialDelaySeconds: 5），每5 s执行一次（periodSeconds: 5）。</p><p>现在，让我们来<strong>具体实践一下这个过程</strong>。</p><p>首先，创建这个Pod：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ kubectl create -f test-liveness-exec.yaml</span></div></pre></div><p>然后，查看这个Pod的状态：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ kubectl get pod</span></div><div class="token-line"><span class="token plain">    NAME                READY     STATUS    RESTARTS   AGE</span></div><div class="token-line"><span class="token plain">    test-liveness-exec   1/1       Running   0          10s</span></div></pre></div><p>可以看到，由于已经通过了健康检查，这个Pod就进入了Running状态。</p><p>而30 s之后，我们再查看一下Pod的Events：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ kubectl describe pod test-liveness-exec</span></div></pre></div><p>你会发现，这个Pod在Events报告了一个异常：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">FirstSeen LastSeen    Count   From            SubobjectPath           Type        Reason      Message</span></div><div class="token-line"><span class="token plain">    --------- --------    -----   ----            -------------           --------    ------      -------</span></div><div class="token-line"><span class="token plain">    2s        2s      1   {kubelet worker0}   spec.containers{liveness}   Warning     Unhealthy   Liveness probe failed: cat: can&#x27;t open &#x27;/tmp/healthy&#x27;: No such file or directory</span></div></pre></div><p>显然，这个健康检查探查到/tmp/healthy已经不存在了，所以它报告容器是不健康的。那么接下来会发生什么呢？</p><p>我们不妨再次查看一下这个Pod的状态：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ kubectl get pod test-liveness-exec</span></div><div class="token-line"><span class="token plain">    NAME           READY     STATUS    RESTARTS   AGE</span></div><div class="token-line"><span class="token plain">    liveness-exec   1/1       Running   1          1m</span></div></pre></div><p>这时我们发现，Pod并没有进入Failed状态，而是保持了Running状态。这是为什么呢？</p><p>其实，如果你注意到RESTARTS字段从0到1的变化，就明白原因了：这个异常的容器已经被Kubernetes重启了。在这个过程中，Pod保持Running状态不变。</p><p>需要注意的是：Kubernetes中并没有Docker的Stop语义。所以虽然是Restart（重启），但实际却是重新创建了容器。</p><p>这个功能就是Kubernetes里的<strong>Pod恢复机制</strong>，也叫restartPolicy。它是Pod的Spec部分的一个标准字段（pod.spec.restartPolicy），默认值是Always，即：任何时候这个容器发生了异常，它一定会被重新创建。</p><p>但一定要强调的是，Pod的恢复过程，永远都是发生在当前节点上，而不会跑到别的节点上去。事实上，一旦一个Pod与一个节点（Node）绑定，除非这个绑定发生了变化（pod.spec.node字段被修改），否则它永远都不会离开这个节点。这也就意味着，如果这个宿主机宕机了，这个Pod也不会主动迁移到其他节点上去。</p><p>而如果你想让Pod出现在其他的可用节点上，就必须使用Deployment这样的“控制器”来管理Pod，哪怕你只需要一个Pod副本。这就是我在第12篇文章<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/40008">《牛刀小试：我的第一个容器化应用》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>最后给你留的思考题的答案，即一个单Pod的Deployment与一个Pod最主要的区别。</p><p>而作为用户，你还可以通过设置restartPolicy，改变Pod的恢复策略。除了Always，它还有OnFailure和Never两种情况：</p><ul><li>Always：在任何情况下，只要容器不在运行状态，就自动重启容器；</li><li>OnFailure: 只在容器 异常时才自动重启容器；</li><li>Never: 从来不重启容器。</li></ul><p>在实际使用时，我们需要根据应用运行的特性，合理设置这三种恢复策略。</p><p>比如，一个Pod，它只计算1+1=2，计算完成输出结果后退出，变成Succeeded状态。这时，你如果再用restartPolicy=Always强制重启这个Pod的容器，就没有任何意义了。</p><p>而如果你要关心这个容器退出后的上下文环境，比如容器退出后的日志、文件和目录，就需要将restartPolicy设置为Never。因为一旦容器被自动重新创建，这些内容就有可能丢失掉了（被垃圾回收了）。</p><p>值得一提的是，Kubernetes的官方文档，把restartPolicy和Pod里容器的状态，以及Pod状态的对应关系，<a target="_blank" rel="noopener noreferrer" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#example-states">总结了非常复杂的一大堆情况<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。实际上，你根本不需要死记硬背这些对应关系，只要记住如下两个基本的设计原理即可：</p><ol><li><p><strong>只要Pod的restartPolicy指定的策略允许重启异常的容器（比如：Always），那么这个Pod就会保持Running状态，并进行容器重启</strong>。否则，Pod就会进入Failed状态 。</p></li><li><p><strong>对于包含多个容器的Pod，只有它里面所有的容器都进入异常状态后，Pod才会进入Failed状态</strong>。在此之前，Pod都是Running状态。此时，Pod的READY字段会显示正常容器的个数，比如：</p></li></ol><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ kubectl get pod test-liveness-exec</span></div><div class="token-line"><span class="token plain">    NAME           READY     STATUS    RESTARTS   AGE</span></div><div class="token-line"><span class="token plain">    liveness-exec   0/1       Running   1          1m</span></div></pre></div><p>所以，假如一个Pod里只有一个容器，然后这个容器异常退出了。那么，只有当restartPolicy=Never时，这个Pod才会进入Failed状态。而其他情况下，由于Kubernetes都可以重启这个容器，所以Pod的状态保持Running不变。</p><p>而如果这个Pod有多个容器，仅有一个容器异常退出，它就始终保持Running状态，哪怕即使restartPolicy=Never。只有当所有容器也异常退出之后，这个Pod才会进入Failed状态。</p><p>其他情况，都可以以此类推出来。</p><p>现在，我们一起回到前面提到的livenessProbe上来。</p><p>除了在容器中执行命令外，livenessProbe也可以定义为发起HTTP或者TCP请求的方式，定义格式如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">...</span></div><div class="token-line"><span class="token plain">    livenessProbe:</span></div><div class="token-line"><span class="token plain">         httpGet:</span></div><div class="token-line"><span class="token plain">           path: /healthz</span></div><div class="token-line"><span class="token plain">           port: 8080</span></div><div class="token-line"><span class="token plain">           httpHeaders:</span></div><div class="token-line"><span class="token plain">           - name: X-Custom-Header</span></div><div class="token-line"><span class="token plain">             value: Awesome</span></div><div class="token-line"><span class="token plain">           initialDelaySeconds: 3</span></div><div class="token-line"><span class="token plain">           periodSeconds: 3</span></div></pre></div><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">...</span></div><div class="token-line"><span class="token plain">        livenessProbe:</span></div><div class="token-line"><span class="token plain">          tcpSocket:</span></div><div class="token-line"><span class="token plain">            port: 8080</span></div><div class="token-line"><span class="token plain">          initialDelaySeconds: 15</span></div><div class="token-line"><span class="token plain">          periodSeconds: 20</span></div></pre></div><p>所以，你的Pod其实可以暴露一个健康检查URL（比如/healthz），或者直接让健康检查去检测应用的监听端口。这两种配置方法，在Web服务类的应用中非常常用。</p><p>在Kubernetes的Pod中，还有一个叫readinessProbe的字段。虽然它的用法与livenessProbe类似，但作用却大不一样。readinessProbe检查结果的成功与否，决定的这个Pod是不是能被通过Service的方式访问到，而并不影响Pod的生命周期。这部分内容，我会在讲解Service时重点介绍。</p><p>在讲解了这么多字段之后，想必你对Pod对象的语义和描述能力，已经有了一个初步的感觉。</p><p>这时，你有没有产生这样一个想法：Pod的字段这么多，我又不可能全记住，Kubernetes能不能自动给Pod填充某些字段呢？</p><p>这个需求实际上非常实用。比如，开发人员只需要提交一个基本的、非常简单的Pod YAML，Kubernetes就可以自动给对应的Pod对象加上其他必要的信息，比如labels，annotations，volumes等等。而这些信息，可以是运维人员事先定义好的。</p><p>这么一来，开发人员编写Pod YAML的门槛，就被大大降低了。</p><p>所以，这个叫作PodPreset（Pod预设置）的功能 已经出现在了v1.11版本的Kubernetes中。</p><p>举个例子，现在开发人员编写了如下一个 pod.yaml文件：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">apiVersion: v1</span></div><div class="token-line"><span class="token plain">    kind: Pod</span></div><div class="token-line"><span class="token plain">    metadata:</span></div><div class="token-line"><span class="token plain">      name: website</span></div><div class="token-line"><span class="token plain">      labels:</span></div><div class="token-line"><span class="token plain">        app: website</span></div><div class="token-line"><span class="token plain">        role: frontend</span></div><div class="token-line"><span class="token plain">    spec:</span></div><div class="token-line"><span class="token plain">      containers:</span></div><div class="token-line"><span class="token plain">        - name: website</span></div><div class="token-line"><span class="token plain">          image: nginx</span></div><div class="token-line"><span class="token plain">          ports:</span></div><div class="token-line"><span class="token plain">            - containerPort: 80</span></div></pre></div><p>作为Kubernetes的初学者，你肯定眼前一亮：这不就是我最擅长编写的、最简单的Pod嘛。没错，这个YAML文件里的字段，想必你现在闭着眼睛也能写出来。</p><p>可是，如果运维人员看到了这个Pod，他一定会连连摇头：这种Pod在生产环境里根本不能用啊！</p><p>所以，这个时候，运维人员就可以定义一个PodPreset对象。在这个对象中，凡是他想在开发人员编写的Pod里追加的字段，都可以预先定义好。比如这个preset.yaml：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">apiVersion: settings.k8s.io/v1alpha1</span></div><div class="token-line"><span class="token plain">    kind: PodPreset</span></div><div class="token-line"><span class="token plain">    metadata:</span></div><div class="token-line"><span class="token plain">      name: allow-database</span></div><div class="token-line"><span class="token plain">    spec:</span></div><div class="token-line"><span class="token plain">      selector:</span></div><div class="token-line"><span class="token plain">        matchLabels:</span></div><div class="token-line"><span class="token plain">          role: frontend</span></div><div class="token-line"><span class="token plain">      env:</span></div><div class="token-line"><span class="token plain">        - name: DB_PORT</span></div><div class="token-line"><span class="token plain">          value: &quot;6379&quot;</span></div><div class="token-line"><span class="token plain">      volumeMounts:</span></div><div class="token-line"><span class="token plain">        - mountPath: /cache</span></div><div class="token-line"><span class="token plain">          name: cache-volume</span></div><div class="token-line"><span class="token plain">      volumes:</span></div><div class="token-line"><span class="token plain">        - name: cache-volume</span></div><div class="token-line"><span class="token plain">          emptyDir: {}</span></div></pre></div><p>在这个PodPreset的定义中，首先是一个selector。这就意味着后面这些追加的定义，只会作用于selector所定义的、带有“role: frontend”标签的Pod对象，这就可以防止“误伤”。</p><p>然后，我们定义了一组Pod的Spec里的标准字段，以及对应的值。比如，env里定义了DB_PORT这个环境变量，volumeMounts定义了容器Volume的挂载目录，volumes定义了一个emptyDir的Volume。</p><p>接下来，我们假定运维人员先创建了这个PodPreset，然后开发人员才创建Pod：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ kubectl create -f preset.yaml</span></div><div class="token-line"><span class="token plain">    $ kubectl create -f pod.yaml</span></div></pre></div><p>这时，Pod运行起来之后，我们查看一下这个Pod的API对象：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ kubectl get pod website -o yaml</span></div><div class="token-line"><span class="token plain">    apiVersion: v1</span></div><div class="token-line"><span class="token plain">    kind: Pod</span></div><div class="token-line"><span class="token plain">    metadata:</span></div><div class="token-line"><span class="token plain">      name: website</span></div><div class="token-line"><span class="token plain">      labels:</span></div><div class="token-line"><span class="token plain">        app: website</span></div><div class="token-line"><span class="token plain">        role: frontend</span></div><div class="token-line"><span class="token plain">      annotations:</span></div><div class="token-line"><span class="token plain">        podpreset.admission.kubernetes.io/podpreset-allow-database: &quot;resource version&quot;</span></div><div class="token-line"><span class="token plain">    spec:</span></div><div class="token-line"><span class="token plain">      containers:</span></div><div class="token-line"><span class="token plain">        - name: website</span></div><div class="token-line"><span class="token plain">          image: nginx</span></div><div class="token-line"><span class="token plain">          volumeMounts:</span></div><div class="token-line"><span class="token plain">            - mountPath: /cache</span></div><div class="token-line"><span class="token plain">              name: cache-volume</span></div><div class="token-line"><span class="token plain">          ports:</span></div><div class="token-line"><span class="token plain">            - containerPort: 80</span></div><div class="token-line"><span class="token plain">          env:</span></div><div class="token-line"><span class="token plain">            - name: DB_PORT</span></div><div class="token-line"><span class="token plain">              value: &quot;6379&quot;</span></div><div class="token-line"><span class="token plain">      volumes:</span></div><div class="token-line"><span class="token plain">        - name: cache-volume</span></div><div class="token-line"><span class="token plain">          emptyDir: {}</span></div></pre></div><p>这个时候，我们就可以清楚地看到，这个Pod里多了新添加的labels、env、volumes和volumeMount的定义，它们的配置跟PodPreset的内容一样。此外，这个Pod还被自动加上了一个annotation表示这个Pod对象被PodPreset改动过。</p><p>需要说明的是，<strong>PodPreset里定义的内容，只会在Pod API对象被创建之前追加在这个对象本身上，而不会影响任何Pod的控制器的定义。</strong></p><p>比如，我们现在提交的是一个nginx-deployment，那么这个Deployment对象本身是永远不会被PodPreset改变的，被修改的只是这个Deployment创建出来的所有Pod。这一点请务必区分清楚。</p><p>这里有一个问题：如果你定义了同时作用于一个Pod对象的多个PodPreset，会发生什么呢？</p><p>实际上，Kubernetes项目会帮你合并（Merge）这两个PodPreset要做的修改。而如果它们要做的修改有冲突的话，这些冲突字段就不会被修改。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/03#总结"><span class="icon icon-link"></span></a>总结</h2><p>在今天这篇文章中，我和你详细介绍了Pod对象更高阶的使用方法，希望通过对这些实例的讲解，你可以更深入地理解Pod API对象的各个字段。</p><p>而在学习这些字段的同时，你还应该认真体会一下Kubernetes“一切皆对象”的设计思想：比如应用是Pod对象，应用的配置是ConfigMap对象，应用要访问的密码则是Secret对象。</p><p>所以，也就自然而然地有了PodPreset这样专门用来对Pod进行批量化、自动化修改的工具对象。在后面的内容中，我会为你讲解更多的这种对象，还会和你介绍Kubernetes项目如何围绕着这些对象进行容器编排。</p><p>在本专栏中，Pod对象相关的知识点非常重要，它是接下来Kubernetes能够描述和编排各种复杂应用的基石所在，希望你能够继续多实践、多体会。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/03#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>在没有Kubernetes的时候，你是通过什么方法进行应用的健康检查的？Kubernetes的livenessProbe和readinessProbe提供的几种探测机制，是否能满足你的需求？</p><p>感谢你的收听，欢迎你给我留言，也欢迎分享给更多的朋友一起阅读。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/深入剖析kubernetes/04.容器编排与Kubernetes作业管理/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:09</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
