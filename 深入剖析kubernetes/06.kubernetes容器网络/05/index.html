<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>36 | 为什么说Kubernetes只有soft multi-tenancy？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/深入剖析kubernetes/06.kubernetes容器网络/05" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a aria-current="page" class="active" href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a aria-current="page" class="active" href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/深入剖析kubernetes/01.课前必读">01.课前必读</a><ul><li><a href="/blog-two/深入剖析kubernetes/01.课前必读/01"><span>开篇词 | 打通“容器技术”的任督二脉</span></a></li><li><a href="/blog-two/深入剖析kubernetes/01.课前必读/02"><span>01 | 预习篇 · 小鲸鱼大事记（一）：初出茅庐</span></a></li><li><a href="/blog-two/深入剖析kubernetes/01.课前必读/03"><span>02 | 预习篇 · 小鲸鱼大事记（二）：崭露头角</span></a></li><li><a href="/blog-two/深入剖析kubernetes/01.课前必读/04"><span>03 | 预习篇 · 小鲸鱼大事记（三）：群雄并起</span></a></li><li><a href="/blog-two/深入剖析kubernetes/01.课前必读/05"><span>04 | 预习篇 · 小鲸鱼大事记（四）：尘埃落定</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇">02.容器技术概念入门篇</a><ul><li><a href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇/01"><span>05 | 白话容器基础（一）：从进程说开去</span></a></li><li><a href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇/02"><span>06 | 白话容器基础（二）：隔离与限制</span></a></li><li><a href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇/03"><span>07 | 白话容器基础（三）：深入理解容器镜像</span></a></li><li><a href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇/04"><span>08 | 白话容器基础（四）：重新认识Docker容器</span></a></li><li><a href="/blog-two/深入剖析kubernetes/02.容器技术概念入门篇/05"><span>09 | 从容器到容器云：谈谈Kubernetes的本质</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/03.kubernetes集群搭建与实践">03.Kubernetes集群搭建与实践</a><ul><li><a href="/blog-two/深入剖析kubernetes/03.kubernetes集群搭建与实践/01"><span>10 | Kubernetes一键部署利器：kubeadm</span></a></li><li><a href="/blog-two/深入剖析kubernetes/03.kubernetes集群搭建与实践/02"><span>11 | 从0到1：搭建一个完整的Kubernetes集群</span></a></li><li><a href="/blog-two/深入剖析kubernetes/03.kubernetes集群搭建与实践/03"><span>12 | 牛刀小试：我的第一个容器化应用</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理">04.容器编排与Kubernetes作业管理</a><ul><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/01"><span>13 | 为什么我们需要Pod？</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/02"><span>14 | 深入解析Pod对象（一）：基本概念</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/03"><span>15 | 深入解析Pod对象（二）：使用进阶</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/04"><span>16 | 编排其实很简单：谈谈“控制器”模型</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/05"><span>17 | 经典PaaS的记忆：作业副本与水平扩展</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/06"><span>18 | 深入理解StatefulSet（一）：拓扑状态</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/07"><span>19 | 深入理解StatefulSet（二）：存储状态</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/08"><span>20 | 深入理解StatefulSet（三）：有状态应用实践</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/09"><span>21 | 容器化守护进程的意义：DaemonSet</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/10"><span>22 | 撬动离线业务：Job与CronJob</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/11"><span>23 | 声明式API与Kubernetes编程范式</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/12"><span>24 | 深入解析声明式API（一）：API对象的奥秘</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/13"><span>25 | 深入解析声明式API（二）：编写自定义控制器</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/14"><span>26 | 基于角色的权限控制：RBAC</span></a></li><li><a href="/blog-two/深入剖析kubernetes/04.容器编排与kubernetes作业管理/15"><span>27 | 聪明的微创新：Operator工作原理解读</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/05.kubernetes容器持久化存储">05.Kubernetes容器持久化存储</a><ul><li><a href="/blog-two/深入剖析kubernetes/05.kubernetes容器持久化存储/01"><span>28 | PV、PVC、StorageClass，这些到底在说啥？</span></a></li><li><a href="/blog-two/深入剖析kubernetes/05.kubernetes容器持久化存储/02"><span>29 | PV、PVC体系是不是多此一举？从本地持久化卷谈起</span></a></li><li><a href="/blog-two/深入剖析kubernetes/05.kubernetes容器持久化存储/03"><span>30 | 编写自己的存储插件：FlexVolume与CSI</span></a></li><li><a href="/blog-two/深入剖析kubernetes/05.kubernetes容器持久化存储/04"><span>31 | 容器存储实践：CSI插件编写指南</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络">06.Kubernetes容器网络</a><ul><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/01"><span>32 | 浅谈容器网络</span></a></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/02"><span>33 | 深入解析容器跨主机网络</span></a></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/03"><span>34 | Kubernetes网络模型与CNI网络插件</span></a></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/04"><span>35 | 解读Kubernetes三层网络方案</span></a></li><li><a aria-current="page" class="active" href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/05"><span>36 | 为什么说Kubernetes只有soft multi-tenancy？</span></a></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/06"><span>37 | 找到容器不容易：Service、DNS与服务发现</span></a></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/07"><span>38 | 从外界连通Service与Service调试“三板斧”</span></a></li><li><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/08"><span>39 | 谈谈Service与Ingress</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/07.kubernetes作业调度与资源管理">07.Kubernetes作业调度与资源管理</a><ul><li><a href="/blog-two/深入剖析kubernetes/07.kubernetes作业调度与资源管理/01"><span>40 | Kubernetes的资源模型与资源管理</span></a></li><li><a href="/blog-two/深入剖析kubernetes/07.kubernetes作业调度与资源管理/02"><span>41 | 十字路口上的Kubernetes默认调度器</span></a></li><li><a href="/blog-two/深入剖析kubernetes/07.kubernetes作业调度与资源管理/03"><span>42 | Kubernetes默认调度器调度策略解析</span></a></li><li><a href="/blog-two/深入剖析kubernetes/07.kubernetes作业调度与资源管理/04"><span>43 | Kubernetes默认调度器的优先级与抢占机制</span></a></li><li><a href="/blog-two/深入剖析kubernetes/07.kubernetes作业调度与资源管理/05"><span>44 | Kubernetes GPU管理与Device Plugin机制</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/08.kubernetes容器运行时">08.Kubernetes容器运行时</a><ul><li><a href="/blog-two/深入剖析kubernetes/08.kubernetes容器运行时/01"><span>45 | 幕后英雄：SIG-Node与CRI</span></a></li><li><a href="/blog-two/深入剖析kubernetes/08.kubernetes容器运行时/02"><span>46 | 解读 CRI 与 容器运行时</span></a></li><li><a href="/blog-two/深入剖析kubernetes/08.kubernetes容器运行时/03"><span>47 | 绝不仅仅是安全：Kata Containers 与 gVisor</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/09.kubernetes容器监控与日志">09.Kubernetes容器监控与日志</a><ul><li><a href="/blog-two/深入剖析kubernetes/09.kubernetes容器监控与日志/01"><span>48 | Prometheus、Metrics Server与Kubernetes监控体系</span></a></li><li><a href="/blog-two/深入剖析kubernetes/09.kubernetes容器监控与日志/02"><span>49 | Custom Metrics: 让Auto Scaling不再“食之无味”</span></a></li><li><a href="/blog-two/深入剖析kubernetes/09.kubernetes容器监控与日志/03"><span>50 | 让日志无处可逃：容器日志收集与管理</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/10.再谈开源与社区">10.再谈开源与社区</a><ul><li><a href="/blog-two/深入剖析kubernetes/10.再谈开源与社区/01"><span>51 | 谈谈Kubernetes开源社区和未来走向</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/11.答疑文章">11.答疑文章</a><ul><li><a href="/blog-two/深入剖析kubernetes/11.答疑文章/01"><span>52 | 答疑：在问题中解决问题，在思考中产生思考</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/12.特别放送">12.特别放送</a><ul><li><a href="/blog-two/深入剖析kubernetes/12.特别放送/01"><span>特别放送 | 2019 年，容器技术生态会发生些什么？</span></a></li><li><a href="/blog-two/深入剖析kubernetes/12.特别放送/02"><span>特别放送 | 基于 Kubernetes 的云原生应用管理，到底应该怎么做？</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/13.结束语">13.结束语</a><ul><li><a href="/blog-two/深入剖析kubernetes/13.结束语/01"><span>结束语 | Kubernetes：赢开发者赢天下</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/14.结课测试">14.结课测试</a><ul><li><a href="/blog-two/深入剖析kubernetes/14.结课测试/01"><span>结课测试｜这些Kubernetes的相关知识，你都掌握了吗？</span></a></li></ul></li><li><a href="/blog-two/深入剖析kubernetes/summary">深入剖析kubernetes</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="总结" data-depth="2"><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/05#总结"><span>总结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/05#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="36--为什么说kubernetes只有soft-multi-tenancy"><a aria-hidden="true" tabindex="-1" href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/05#36--为什么说kubernetes只有soft-multi-tenancy"><span class="icon icon-link"></span></a>36 | 为什么说Kubernetes只有soft multi-tenancy？</h1><p>你好，我是张磊。今天我和你分享的主题是：为什么说Kubernetes只有soft multi-tenancy？</p><p>在前面的文章中，我为你详细讲解了Kubernetes生态里，主流容器网络方案的工作原理。</p><p>不难发现，Kubernetes的网络模型，以及前面这些网络方案的实现，都只关注容器之间网络的“连通”，却并不关心容器之间网络的“隔离”。这跟传统的IaaS层的网络方案，区别非常明显。</p><p>你肯定会问了，Kubernetes的网络方案对“隔离”到底是如何考虑的呢？难道Kubernetes就不管网络“多租户”的需求吗？</p><p>接下来，在今天这篇文章中，我就来回答你的这些问题。</p><p>在Kubernetes里，网络隔离能力的定义，是依靠一种专门的API对象来描述的，即：NetworkPolicy。</p><p>一个完整的NetworkPolicy对象的示例，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">apiVersion: networking.k8s.io/v1</span></div><div class="token-line"><span class="token plain">    kind: NetworkPolicy</span></div><div class="token-line"><span class="token plain">    metadata:</span></div><div class="token-line"><span class="token plain">      name: test-network-policy</span></div><div class="token-line"><span class="token plain">      namespace: default</span></div><div class="token-line"><span class="token plain">    spec:</span></div><div class="token-line"><span class="token plain">      podSelector:</span></div><div class="token-line"><span class="token plain">        matchLabels:</span></div><div class="token-line"><span class="token plain">          role: db</span></div><div class="token-line"><span class="token plain">      policyTypes:</span></div><div class="token-line"><span class="token plain">      - Ingress</span></div><div class="token-line"><span class="token plain">      - Egress</span></div><div class="token-line"><span class="token plain">      ingress:</span></div><div class="token-line"><span class="token plain">      - from:</span></div><div class="token-line"><span class="token plain">        - ipBlock:</span></div><div class="token-line"><span class="token plain">            cidr: 172.17.0.0/16</span></div><div class="token-line"><span class="token plain">            except:</span></div><div class="token-line"><span class="token plain">            - 172.17.1.0/24</span></div><div class="token-line"><span class="token plain">        - namespaceSelector:</span></div><div class="token-line"><span class="token plain">            matchLabels:</span></div><div class="token-line"><span class="token plain">              project: myproject</span></div><div class="token-line"><span class="token plain">        - podSelector:</span></div><div class="token-line"><span class="token plain">            matchLabels:</span></div><div class="token-line"><span class="token plain">              role: frontend</span></div><div class="token-line"><span class="token plain">        ports:</span></div><div class="token-line"><span class="token plain">        - protocol: TCP</span></div><div class="token-line"><span class="token plain">          port: 6379</span></div><div class="token-line"><span class="token plain">      egress:</span></div><div class="token-line"><span class="token plain">      - to:</span></div><div class="token-line"><span class="token plain">        - ipBlock:</span></div><div class="token-line"><span class="token plain">            cidr: 10.0.0.0/24</span></div><div class="token-line"><span class="token plain">        ports:</span></div><div class="token-line"><span class="token plain">        - protocol: TCP</span></div><div class="token-line"><span class="token plain">          port: 5978</span></div></pre></div><p>我在和你分享前面的内容时已经说过（这里你可以再回顾下第34篇文章<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/67351">《<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/67351">Kubernetes 网络模型与 CNI 网络插件<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/67351">》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中的相关内容），<strong>Kubernetes里的Pod默认都是“允许所有”（Accept All）的</strong>，即：Pod可以接收来自任何发送方的请求；或者，向任何接收方发送请求。而如果你要对这个情况作出限制，就必须通过NetworkPolicy对象来指定。</p><p>而在上面这个例子里，你首先会看到podSelector字段。它的作用，就是定义这个NetworkPolicy的限制范围，比如：当前Namespace里携带了role=db标签的Pod。</p><p>而如果你把podSelector字段留空：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">spec:</span></div><div class="token-line"><span class="token plain">     podSelector: {}</span></div></pre></div><p>那么这个NetworkPolicy就会作用于当前Namespace下的所有Pod。</p><p>而一旦Pod被NetworkPolicy选中，<strong>那么这个Pod就会进入“拒绝所有”（Deny All）的状态</strong>，即：这个Pod既不允许被外界访问，也不允许对外界发起访问。</p><p><strong>而NetworkPolicy定义的规则，其实就是“白名单”。</strong></p><p>例如，在我们上面这个例子里，我在policyTypes字段，定义了这个NetworkPolicy的类型是ingress和egress，即：它既会影响流入（ingress）请求，也会影响流出（egress）请求。</p><p>然后，在ingress字段里，我定义了from和ports，即：允许流入的“白名单”和端口。其中，这个允许流入的“白名单”里，我指定了<strong>三种并列的情况</strong>，分别是：ipBlock、namespaceSelector和podSelector。</p><p>而在egress字段里，我则定义了to和ports，即：允许流出的“白名单”和端口。这里允许流出的“白名单”的定义方法与ingress类似。只不过，这一次ipblock字段指定的，是目的地址的网段。</p><p>综上所述，这个NetworkPolicy对象，指定的隔离规则如下所示：</p><ol><li>该隔离规则只对default Namespace下的，携带了role=db标签的Pod有效。限制的请求类型包括ingress（流入）和egress（流出）。</li><li>Kubernetes会拒绝任何访问被隔离Pod的请求，除非这个请求来自于以下“白名单”里的对象，并且访问的是被隔离Pod的6379端口。这些“白名单”对象包括：<br/>a. default Namespace里的，携带了role=fronted标签的Pod；<br/>b. 携带了project=myproject 标签的 Namespace 里的任何 Pod；<br/>c. 任何源地址属于172.17.0.0/16网段，且不属于172.17.1.0/24网段的请求。</li><li>Kubernetes会拒绝被隔离Pod对外发起任何请求，除非请求的目的地址属于10.0.0.0/24网段，并且访问的是该网段地址的5978端口。</li></ol><p>需要注意的是，定义一个NetworkPolicy对象的过程，容易犯错的是“白名单”部分（from和to字段）。</p><p>举个例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">...</span></div><div class="token-line"><span class="token plain">      ingress:</span></div><div class="token-line"><span class="token plain">      - from:</span></div><div class="token-line"><span class="token plain">        - namespaceSelector:</span></div><div class="token-line"><span class="token plain">            matchLabels:</span></div><div class="token-line"><span class="token plain">              user: alice</span></div><div class="token-line"><span class="token plain">        - podSelector:</span></div><div class="token-line"><span class="token plain">            matchLabels:</span></div><div class="token-line"><span class="token plain">              role: client</span></div><div class="token-line"><span class="token plain">      ...</span></div></pre></div><p>像上面这样定义的namespaceSelector和podSelector，是“或”（OR）的关系。所以说，这个from字段定义了两种情况，无论是Namespace满足条件，还是Pod满足条件，这个NetworkPolicy都会生效。</p><p>而下面这个例子，虽然看起来类似，但是它定义的规则却完全不同：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">...</span></div><div class="token-line"><span class="token plain">      ingress:</span></div><div class="token-line"><span class="token plain">      - from:</span></div><div class="token-line"><span class="token plain">        - namespaceSelector:</span></div><div class="token-line"><span class="token plain">            matchLabels:</span></div><div class="token-line"><span class="token plain">              user: alice</span></div><div class="token-line"><span class="token plain">          podSelector:</span></div><div class="token-line"><span class="token plain">            matchLabels:</span></div><div class="token-line"><span class="token plain">              role: client</span></div><div class="token-line"><span class="token plain">      ...</span></div></pre></div><p>注意看，这样定义的namespaceSelector和podSelector，其实是“与”（AND）的关系。所以说，这个from字段只定义了一种情况，只有Namespace和Pod同时满足条件，这个NetworkPolicy才会生效。</p><p><strong>这两种定义方式的区别，请你一定要分清楚。</strong></p><p>此外，如果要使上面定义的NetworkPolicy在Kubernetes集群里真正产生作用，你的CNI网络插件就必须是支持Kubernetes的NetworkPolicy的。</p><p>在具体实现上，凡是支持NetworkPolicy的CNI网络插件，都维护着一个NetworkPolicy Controller，通过控制循环的方式对NetworkPolicy对象的增删改查做出响应，然后在宿主机上完成iptables规则的配置工作。</p><p>在Kubernetes生态里，目前已经实现了NetworkPolicy的网络插件包括Calico、Weave和kube-router等多个项目，但是并不包括Flannel项目。</p><p>所以说，如果想要在使用Flannel的同时还使用NetworkPolicy的话，你就需要再额外安装一个网络插件，比如Calico项目，来负责执行NetworkPolicy。</p><blockquote><p>安装Flannel + Calico的流程非常简单，你直接参考这个文档<a target="_blank" rel="noopener noreferrer" href="https://docs.projectcalico.org/v3.2/getting-started/kubernetes/installation/flannel">一键安装<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>即可。</p></blockquote><p>那么，这些网络插件，又是如何根据NetworkPolicy对Pod进行隔离的呢？</p><p>接下来，我就以三层网络插件为例（比如Calico和kube-router），来为你分析一下这部分的原理。</p><p>为了方便讲解，这一次我编写了一个比较简单的NetworkPolicy对象，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">apiVersion: extensions/v1beta1</span></div><div class="token-line"><span class="token plain">    kind: NetworkPolicy</span></div><div class="token-line"><span class="token plain">    metadata:</span></div><div class="token-line"><span class="token plain">      name: test-network-policy</span></div><div class="token-line"><span class="token plain">      namespace: default</span></div><div class="token-line"><span class="token plain">    spec:</span></div><div class="token-line"><span class="token plain">      podSelector:</span></div><div class="token-line"><span class="token plain">        matchLabels:</span></div><div class="token-line"><span class="token plain">          role: db</span></div><div class="token-line"><span class="token plain">      ingress:</span></div><div class="token-line"><span class="token plain">       - from:</span></div><div class="token-line"><span class="token plain">         - namespaceSelector:</span></div><div class="token-line"><span class="token plain">             matchLabels:</span></div><div class="token-line"><span class="token plain">               project: myproject</span></div><div class="token-line"><span class="token plain">         - podSelector:</span></div><div class="token-line"><span class="token plain">             matchLabels:</span></div><div class="token-line"><span class="token plain">               role: frontend</span></div><div class="token-line"><span class="token plain">         ports:</span></div><div class="token-line"><span class="token plain">           - protocol: tcp</span></div><div class="token-line"><span class="token plain">             port: 6379</span></div></pre></div><p>可以看到，我们指定的ingress“白名单”，是任何Namespace里，携带project=myproject标签的Namespace里的Pod；以及default Namespace里，携带了role=frontend标签的Pod。允许被访问的端口是：6379。</p><p>而被隔离的对象，是所有携带了role=db标签的Pod。</p><p>那么这个时候，Kubernetes的网络插件就会使用这个NetworkPolicy的定义，在宿主机上生成iptables规则。这个过程，我可以通过如下所示的一段Go语言风格的伪代码来为你描述：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">for dstIP := range 所有被networkpolicy.spec.podSelector选中的Pod的IP地址</span></div><div class="token-line"><span class="token plain">      for srcIP := range 所有被ingress.from.podSelector选中的Pod的IP地址</span></div><div class="token-line"><span class="token plain">        for port, protocol := range ingress.ports {</span></div><div class="token-line"><span class="token plain">          iptables -A KUBE-NWPLCY-CHAIN -s $srcIP -d $dstIP -p $protocol -m $protocol --dport $port -j ACCEPT </span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，这是一条最基本的、通过匹配条件决定下一步动作的iptables规则。</p><p>这条规则的名字是KUBE-NWPLCY-CHAIN，含义是：当IP包的源地址是srcIP、目的地址是dstIP、协议是protocol、目的端口是port的时候，就允许它通过（ACCEPT）。</p><p>而正如这段伪代码所示，匹配这条规则所需的这四个参数，都是从NetworkPolicy对象里读取出来的。</p><p><strong>可以看到，Kubernetes网络插件对Pod进行隔离，其实是靠在宿主机上生成NetworkPolicy对应的iptable规则来实现的。</strong></p><p>此外，在设置好上述“隔离”规则之后，网络插件还需要想办法，将所有对被隔离Pod的访问请求，都转发到上述KUBE-NWPLCY-CHAIN规则上去进行匹配。并且，如果匹配不通过，这个请求应该被“拒绝”。</p><p>在CNI网络插件中，上述需求可以通过设置两组iptables规则来实现。</p><p><strong>第一组规则，负责“拦截”对被隔离Pod的访问请求</strong>。生成这一组规则的伪代码，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">for pod := range 该Node上的所有Pod {</span></div><div class="token-line"><span class="token plain">        if pod是networkpolicy.spec.podSelector选中的 {</span></div><div class="token-line"><span class="token plain">            iptables -A FORWARD -d $podIP -m physdev --physdev-is-bridged -j KUBE-POD-SPECIFIC-FW-CHAIN</span></div><div class="token-line"><span class="token plain">            iptables -A FORWARD -d $podIP -j KUBE-POD-SPECIFIC-FW-CHAIN</span></div><div class="token-line"><span class="token plain">            ...</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，这里的的iptables规则使用到了内置链：FORWARD。它是什么意思呢？</p><p>说到这里，我就得为你稍微普及一下iptables的知识了。</p><p>实际上，iptables只是一个操作Linux内核Netfilter子系统的“界面”。顾名思义，Netfilter子系统的作用，就是Linux内核里挡在“网卡”和“用户态进程”之间的一道“防火墙”。它们的关系，可以用如下的示意图来表示：</p><p><img src="https://static001.geekbang.org/resource/image/4a/c2/4a012412dd694cb815ac9ee11ce511c2.png" alt=""/><br/>可以看到，这幅示意图中，IP包“一进一出”的两条路径上，有几个关键的“检查点”，它们正是Netfilter设置“防火墙”的地方。<strong>在iptables中，这些“检查点”被称为：链（Chain）</strong>。这是因为这些“检查点”对应的iptables规则，是按照定义顺序依次进行匹配的。这些“检查点”的具体工作原理，可以用如下所示的示意图进行描述：</p><p><img src="https://static001.geekbang.org/resource/image/f7/8e/f722f0f8b16338b02aa02904729dbc8e.jpg" alt=""/></p><p>可以看到，当一个IP包通过网卡进入主机之后，它就进入了Netfilter定义的流入路径（Input Path）里。</p><p>在这个路径中，IP包要经过路由表路由来决定下一步的去向。而在这次路由之前，Netfilter设置了一个名叫PREROUTING的“检查点”。在Linux内核的实现里，所谓“检查点”实际上就是内核网络协议栈代码里的Hook（比如，在执行路由判断的代码之前，内核会先调用PREROUTING的Hook）。</p><p>而在经过路由之后，IP包的去向就分为了两种：</p><ul><li>第一种，继续在本机处理；</li><li>第二种，被转发到其他目的地。</li></ul><p><strong>我们先说一下IP包的第一种去向</strong>。这时候，IP包将继续向上层协议栈流动。在它进入传输层之前，Netfilter会设置一个名叫INPUT的“检查点”。到这里，IP包流入路径（Input Path）结束。</p><p>接下来，这个IP包通过传输层进入用户空间，交给用户进程处理。而处理完成后，用户进程会通过本机发出返回的IP包。这时候，这个IP包就进入了流出路径（Output Path）。</p><p>此时，IP包首先还是会经过主机的路由表进行路由。路由结束后，Netfilter就会设置一个名叫OUTPUT的“检查点”。然后，在OUTPUT之后，再设置一个名叫POSTROUTING“检查点”。</p><p>你可能会觉得奇怪，为什么在流出路径结束后，Netfilter会连着设置两个“检查点”呢？</p><p>这就要说到在流入路径里，<strong>路由判断后的第二种去向</strong>了。</p><p>在这种情况下，这个IP包不会进入传输层，而是会继续在网络层流动，从而进入到转发路径（Forward Path）。在转发路径中，Netfilter会设置一个名叫FORWARD的“检查点”。</p><p>而在FORWARD“检查点”完成后，IP包就会来到流出路径。而转发的IP包由于目的地已经确定，它就不会再经过路由，也自然不会经过OUTPUT，而是会直接来到POSTROUTING“检查点”。</p><p>所以说，POSTROUTING的作用，其实就是上述两条路径，最终汇聚在一起的“最终检查点”。</p><p>需要注意的是，在有网桥参与的情况下，上述Netfilter设置“检查点”的流程，实际上也会出现在链路层（二层），并且会跟我在上面讲述的网络层（三层）的流程有交互。</p><p>这些链路层的“检查点”对应的操作界面叫作ebtables。所以，准确地说，数据包在Linux Netfilter子系统里完整的流动过程，其实应该如下所示（这是一幅来自<a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Iptables#/media/File:Netfilter-packet-flow.svg">Netfilter官方的原理图<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，建议你点击图片以查看大图）：</p><p><img src="https://static001.geekbang.org/resource/image/e9/32/e96b58808bf16039e9975e947a6c7532.jpg" alt=""/></p><p>可以看到，我前面为你讲述的，正是上图中绿色部分，也就是网络层的iptables链的工作流程。</p><p>另外，你应该还能看到，每一个白色的“检查点”上，还有一个绿色的“标签”，比如：raw、nat、filter等等。</p><p>在iptables里，这些标签叫作：表。比如，同样是OUTPUT这个“检查点”，filter Output和nat Output在iptables里的语法和参数，就完全不一样，实现的功能也完全不同。</p><p>所以说，iptables表的作用，就是在某个具体的“检查点”（比如Output）上，按顺序执行几个不同的检查动作（比如，先执行nat，再执行filter）。</p><p>在理解了iptables的工作原理之后，我们再回到NetworkPolicy上来。这时候，前面由网络插件设置的、负责“拦截”进入Pod的请求的三条iptables规则，就很容易读懂了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">iptables -A FORWARD -d $podIP -m physdev --physdev-is-bridged -j KUBE-POD-SPECIFIC-FW-CHAIN</span></div><div class="token-line"><span class="token plain">    iptables -A FORWARD -d $podIP -j KUBE-POD-SPECIFIC-FW-CHAIN</span></div><div class="token-line"><span class="token plain">    ...</span></div></pre></div><p>其中，<strong>第一条FORWARD链“拦截”的是一种特殊情况</strong>：它对应的是同一台宿主机上容器之间经过CNI网桥进行通信的流入数据包。其中，--physdev-is-bridged的意思就是，这个FORWARD链匹配的是，通过本机上的网桥设备，发往目的地址是podIP的IP包。</p><p>当然，如果是像Calico这样的非网桥模式的CNI插件，就不存在这个情况了。</p><blockquote><p>kube-router其实是一个简化版的Calico，它也使用BGP来维护路由信息，但是使用CNI bridge插件负责跟Kubernetes进行交互。</p></blockquote><p>而<strong>第二条FORWARD链“拦截”的则是最普遍的情况，即：容器跨主通信</strong>。这时候，流入容器的数据包都是经过路由转发（FORWARD检查点）来的。</p><p>不难看到，这些规则最后都跳转（即：-j）到了名叫KUBE-POD-SPECIFIC-FW-CHAIN的规则上。它正是网络插件为NetworkPolicy设置的第二组规则。</p><p>而这个KUBE-POD-SPECIFIC-FW-CHAIN的作用，就是做出“允许”或者“拒绝”的判断。这部分功能的实现，可以简单描述为下面这样的iptables规则：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">iptables -A KUBE-POD-SPECIFIC-FW-CHAIN -j KUBE-NWPLCY-CHAIN</span></div><div class="token-line"><span class="token plain">    iptables -A KUBE-POD-SPECIFIC-FW-CHAIN -j REJECT --reject-with icmp-port-unreachable</span></div></pre></div><p>可以看到，首先在第一条规则里，我们会把IP包转交给前面定义的KUBE-NWPLCY-CHAIN规则去进行匹配。按照我们之前的讲述，如果匹配成功，那么IP包就会被“允许通过”。</p><p>而如果匹配失败，IP包就会来到第二条规则上。可以看到，它是一条REJECT规则。通过这条规则，不满足NetworkPolicy定义的请求就会被拒绝掉，从而实现了对该容器的“隔离”。</p><p>以上，就是CNI网络插件实现NetworkPolicy的基本方法了。当然，对于不同的插件来说，上述实现过程可能有不同的手段，但根本原理是不变的。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/05#总结"><span class="icon icon-link"></span></a>总结</h2><p>在本篇文章中，我主要和你分享了Kubernetes对Pod进行“隔离”的手段，即：NetworkPolicy。</p><p>可以看到，NetworkPolicy实际上只是宿主机上的一系列iptables规则。这跟传统IaaS里面的安全组（Security Group）其实是非常类似的。</p><p>而基于上述讲述，你就会发现这样一个事实：</p><p>Kubernetes的网络模型以及大多数容器网络实现，其实既不会保证容器之间二层网络的互通，也不会实现容器之间的二层网络隔离。这跟IaaS项目管理虚拟机的方式，是完全不同的。</p><p>所以说，Kubernetes从底层的设计和实现上，更倾向于假设你已经有了一套完整的物理基础设施。然后，Kubernetes负责在此基础上提供一种“弱多租户”（soft multi-tenancy）的能力。</p><p>并且，基于上述思路，Kubernetes将来也不大可能把Namespace变成一个具有实质意义的隔离机制，或者把它映射成为“子网”或者“租户”。毕竟你可以看到，NetworkPolicy对象的描述能力，要比基于Namespace的划分丰富得多。</p><p>这也是为什么，到目前为止，Kubernetes项目在云计算生态里的定位，其实是基础设施与PaaS之间的中间层。这是非常符合“容器”这个本质上就是进程的抽象粒度的。</p><p>当然，随着Kubernetes社区以及CNCF生态的不断发展，Kubernetes项目也已经开始逐步下探，“吃”掉了基础设施领域的很多“蛋糕”。这也正是容器生态继续发展的一个必然方向。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-two/深入剖析kubernetes/06.kubernetes容器网络/05#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>请你编写这样一个NetworkPolicy：它使得指定的Namespace（比如my-namespace）里的所有Pod，都不能接收任何Ingress请求。然后，请你说说，这样的NetworkPolicy有什么实际的作用？</p><p>感谢你的收听，欢迎你给我留言，也欢迎分享给更多的朋友一起阅读。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/深入剖析kubernetes/06.Kubernetes容器网络/05.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:09</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
