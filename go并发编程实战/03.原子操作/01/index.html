<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>12 | atomic：要保证原子操作，一定要使用这几种方法</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/go并发编程实战/03.原子操作/01" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a aria-current="page" class="active" href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a aria-current="page" class="active" href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/go并发编程实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-two/go并发编程实战/01.开篇词/01"><span>开篇词 | 想吃透Go并发编程，你得这样学！</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语">02.基本并发原语</a><ul><li><a href="/blog-two/go并发编程实战/02.基本并发原语/01"><span>01 | Mutex：如何解决资源并发访问问题？</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/02"><span>02 | Mutex：庖丁解牛看实现</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/03"><span>03｜Mutex：4种易错场景大盘点</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/04"><span>04｜ Mutex：骇客编程，如何拓展额外功能？</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/05"><span>05｜ RWMutex：读写锁的实现原理及避坑指南</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/06"><span>06 | WaitGroup：协同等待，任务编排利器</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/07"><span>07 | Cond：条件变量的实现机制及避坑指南</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/08"><span>08 | Once：一个简约而不简单的并发原语</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/09"><span>09 | map：如何实现线程安全的map类型？</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/10"><span>10 | Pool：性能提升大杀器</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/11"><span>11 | Context：信息穿透上下文</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/go并发编程实战/03.原子操作">03.原子操作</a><ul><li><a aria-current="page" class="active" href="/blog-two/go并发编程实战/03.原子操作/01"><span>12 | atomic：要保证原子操作，一定要使用这几种方法</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/04.channel">04.Channel</a><ul><li><a href="/blog-two/go并发编程实战/04.channel/01"><span>13 | Channel：另辟蹊径，解决并发问题</span></a></li><li><a href="/blog-two/go并发编程实战/04.channel/02"><span>14 | Channel：透过代码看典型的应用模式</span></a></li><li><a href="/blog-two/go并发编程实战/04.channel/03"><span>15 | 内存模型：Go如何保证并发读写的顺序？</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/05.扩展并发原语">05.扩展并发原语</a><ul><li><a href="/blog-two/go并发编程实战/05.扩展并发原语/01"><span>16 | Semaphore：一篇文章搞懂信号量</span></a></li><li><a href="/blog-two/go并发编程实战/05.扩展并发原语/02"><span>17 | SingleFlight 和 CyclicBarrier：请求合并和循环栅栏该怎么用？</span></a></li><li><a href="/blog-two/go并发编程实战/05.扩展并发原语/03"><span>18 | 分组操作：处理一组子任务，该用什么并发原语？</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/06.分布式并发原语">06.分布式并发原语</a><ul><li><a href="/blog-two/go并发编程实战/06.分布式并发原语/01"><span>19 |  在分布式环境中，Leader选举、互斥锁和读写锁该如何实现？</span></a></li><li><a href="/blog-two/go并发编程实战/06.分布式并发原语/02"><span>20 | 在分布式环境中，队列、栅栏和STM该如何实现？</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/07.结束语">07.结束语</a><ul><li><a href="/blog-two/go并发编程实战/07.结束语/01"><span>结束语 | 再聊Go并发编程的价值和精进之路</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/summary">go并发编程实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="Add" data-depth="2"><a href="/blog-two/go并发编程实战/03.原子操作/01#add"><span>Add</span></a></li><li title="CAS （CompareAndSwap）" data-depth="2"><a href="/blog-two/go并发编程实战/03.原子操作/01#cas-compareandswap"><span>CAS （CompareAndSwap）</span></a></li><li title="Swap" data-depth="2"><a href="/blog-two/go并发编程实战/03.原子操作/01#swap"><span>Swap</span></a></li><li title="Load" data-depth="2"><a href="/blog-two/go并发编程实战/03.原子操作/01#load"><span>Load</span></a></li><li title="Store" data-depth="2"><a href="/blog-two/go并发编程实战/03.原子操作/01#store"><span>Store</span></a></li><li title="Value类型" data-depth="2"><a href="/blog-two/go并发编程实战/03.原子操作/01#value类型"><span>Value类型</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="12--atomic要保证原子操作一定要使用这几种方法"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/03.原子操作/01#12--atomic要保证原子操作一定要使用这几种方法"><span class="icon icon-link"></span></a>12 | atomic：要保证原子操作，一定要使用这几种方法</h1><p>你好，我是鸟窝。</p><p>前面我们在学习Mutex、RWMutex等并发原语的实现时，你可以看到，最底层是通过atomic包中的一些原子操作来实现的。当时，为了让你的注意力集中在这些原语的功能实现上，我并没有展开介绍这些原子操作是干什么用的。</p><p>你可能会说，这些并发原语已经可以应对大多数的并发场景了，为啥还要学习原子操作呢？其实，这是因为，在很多场景中，使用并发原语实现起来比较复杂，而原子操作可以帮助我们更轻松地实现底层的优化。</p><p>所以，现在，我会专门用一节课，带你仔细地了解一下什么是原子操作，atomic包都提供了哪些实现原子操作的方法。另外，我还会带你实现一个基于原子操作的数据结构。好了，接下来我们先来学习下什么是原子操作。</p><h1 id="原子操作的基础知识"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/03.原子操作/01#原子操作的基础知识"><span class="icon icon-link"></span></a>原子操作的基础知识</h1><p>Package sync/atomic 实现了同步算法底层的原子的内存操作原语，我们把它叫做原子操作原语，它提供了一些实现原子操作的方法。</p><p>之所以叫原子操作，是因为一个原子在执行的时候，其它线程不会看到执行一半的操作结果。在其它线程看来，原子操作要么执行完了，要么还没有执行，就像一个最小的粒子-原子一样，不可分割。</p><p>CPU提供了基础的原子操作，不过，不同架构的系统的原子操作是不一样的。</p><p>对于单处理器单核系统来说，如果一个操作是由一个CPU指令来实现的，那么它就是原子操作，比如它的XCHG和INC等指令。如果操作是基于多条指令来实现的，那么，执行的过程中可能会被中断，并执行上下文切换，这样的话，原子性的保证就被打破了，因为这个时候，操作可能只执行了一半。</p><p>在多处理器多核系统中，原子操作的实现就比较复杂了。</p><p>由于cache的存在，单个核上的单个指令进行原子操作的时候，你要确保其它处理器或者核不访问此原子操作的地址，或者是确保其它处理器或者核总是访问原子操作之后的最新的值。x86架构中提供了指令前缀LOCK，LOCK保证了指令（比如LOCK CMPXCHG op1、op2）不会受其它处理器或CPU核的影响，有些指令（比如XCHG）本身就提供Lock的机制。不同的CPU架构提供的原子操作指令的方式也是不同的，比如对于多核的MIPS和ARM，提供了LL/SC（Load Link/Store Conditional）指令，可以帮助实现原子操作（ARMLL/SC指令 LDREX和STREX）。</p><p><strong>因为不同的CPU架构甚至不同的版本提供的原子操作的指令是不同的，所以，要用一种编程语言实现支持不同架构的原子操作是相当有难度的</strong>。不过，还好这些都不需要你操心，因为Go提供了一个通用的原子操作的API，将更底层的不同的架构下的实现封装成atomic包，提供了修改类型的原子操作（<a target="_blank" rel="noopener noreferrer" href="https://preshing.com/20150402/you-can-do-any-kind-of-atomic-read-modify-write-operation/">atomic read-modify-write<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，RMW）和加载存储类型的原子操作（<a target="_blank" rel="noopener noreferrer" href="https://preshing.com/20130618/atomic-vs-non-atomic-operations/">Load和Store<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）的API，稍后我会一一介绍。</p><p>有的代码也会因为架构的不同而不同。有时看起来貌似一个操作是原子操作，但实际上，对于不同的架构来说，情况是不一样的。比如下面的代码的第4行，是将一个64位的值赋值给变量i：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const x int64 = 1 + 1&lt;&lt;33</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">        var i = x</span></div><div class="token-line"><span class="token plain">        _ = i</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>如果你使用GOARCH=386的架构去编译这段代码，那么，第5行其实是被拆成了两个指令，分别操作低32位和高32位（使用 GOARCH=386 go tool compile -N -l test.go；GOARCH=386 go tool objdump -gnu test.o反编译试试）：</p><p><img src="https://static001.geekbang.org/resource/image/45/62/4563ac42f379d1500d191377db16a162.png" alt=""/></p><p>如果GOARCH=amd64的架构去编译这段代码，那么，第5行其中的赋值操作其实是一条指令：</p><p><img src="https://static001.geekbang.org/resource/image/6e/66/6e20a0f44d95d78c1bca4303f1a32966.png" alt=""/></p><p>所以，如果要想保证原子操作，切记一定要使用atomic提供的方法。</p><p>好了，了解了什么是原子操作以及不同系统的不同原子操作，接下来，我来介绍下atomic原子操作的应用场景。</p><h1 id="atomic原子操作的应用场景"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/03.原子操作/01#atomic原子操作的应用场景"><span class="icon icon-link"></span></a>atomic原子操作的应用场景</h1><p>开篇我说过，使用atomic的一些方法，我们可以实现更底层的一些优化。如果使用Mutex等并发原语进行这些优化，虽然可以解决问题，但是这些并发原语的实现逻辑比较复杂，对性能还是有一定的影响的。</p><p>举个例子：假设你想在程序中使用一个标志（flag，比如一个bool类型的变量），来标识一个定时任务是否已经启动执行了，你会怎么做呢？</p><p>我们先来看看加锁的方法。如果使用Mutex和RWMutex，在读取和设置这个标志的时候加锁，是可以做到互斥的、保证同一时刻只有一个定时任务在执行的，所以使用Mutex或者RWMutex是一种解决方案。</p><p>其实，这个场景中的问题不涉及到对资源复杂的竞争逻辑，只是会并发地读写这个标志，这类场景就适合使用atomic的原子操作。具体怎么做呢？你可以使用一个uint32类型的变量，如果这个变量的值是0，就标识没有任务在执行，如果它的值是1，就标识已经有任务在完成了。你看，是不是很简单呢？</p><p>再来看一个例子。假设你在开发应用程序的时候，需要从配置服务器中读取一个节点的配置信息。而且，在这个节点的配置发生变更的时候，你需要重新从配置服务器中拉取一份新的配置并更新。你的程序中可能有多个goroutine都依赖这份配置，涉及到对这个配置对象的并发读写，你可以使用读写锁实现对配置对象的保护。在大部分情况下，你也可以利用atomic实现配置对象的更新和加载。</p><p>分析到这里，可以看到，这两个例子都可以使用基本并发原语来实现的，只不过，我们不需要这些基本并发原语里面的复杂逻辑，而是只需要其中的简单原子操作，所以，这些场景可以直接使用atomic包中的方法去实现。</p><p><strong>有时候，你也可以使用atomic实现自己定义的基本并发原语</strong>，比如Go issue有人提议的CondMutex、Mutex.LockContext、WaitGroup.Go等，我们可以使用atomic或者基于它的更高一级的并发原语去实现。我先前讲的几种基本并发原语的底层（比如Mutex），就是基于通过atomic的方法实现的。</p><p>除此之外，atomic原子操作还是实现lock-free数据结构的基石。</p><p>在实现lock-free的数据结构时，我们可以不使用互斥锁，这样就不会让线程因为等待互斥锁而阻塞休眠，而是让线程保持继续处理的状态。另外，不使用互斥锁的话，lock-free的数据结构还可以提供并发的性能。</p><p>不过，lock-free的数据结构实现起来比较复杂，需要考虑的东西很多，有兴趣的同学可以看一位微软专家写的一篇经验分享：<a target="_blank" rel="noopener noreferrer" href="https://docs.microsoft.com/zh-cn/windows/win32/dxtecharts/lockless-programming">Lockless Programming Considerations for Xbox 360 and Microsoft Windows<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，这里我们不细谈了。不过，这节课的最后我会带你开发一个lock-free的queue，来学习下使用atomic操作实现lock-free数据结构的方法，你可以拿它和使用互斥锁实现的queue做性能对比，看看在性能上是否有所提升。</p><p>看到这里，你是不是觉得atomic非常重要呢？不过，要想能够灵活地应用atomic，我们首先得知道atomic提供的所有方法。</p><h1 id="atomic提供的方法"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/03.原子操作/01#atomic提供的方法"><span class="icon icon-link"></span></a>atomic提供的方法</h1><p>目前的Go的泛型的特性还没有发布，Go的标准库中的很多实现会显得非常啰嗦，多个类型会实现很多类似的方法，尤其是atomic包，最为明显。相信泛型支持之后，atomic的API会清爽很多。</p><p>atomic为了支持int32、int64、uint32、uint64、uintptr、Pointer（Add方法不支持）类型，分别提供了AddXXX、CompareAndSwapXXX、SwapXXX、LoadXXX、StoreXXX等方法。不过，你也不要担心，你只要记住了一种数据类型的方法的意义，其它数据类型的方法也是一样的。</p><p>关于atomic，还有一个地方你一定要记住，<strong>atomic操作的对象是一个地址，你需要把可寻址的变量的地址作为参数传递给方法，而不是把变量的值传递给方法</strong>。</p><p>好了，下面我就来给你介绍一下atomic提供的方法。掌握了这些，你就可以说完全掌握了atomic包。</p><h2 id="add"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/03.原子操作/01#add"><span class="icon icon-link"></span></a>Add</h2><p>首先，我们来看Add方法的签名：</p><p><img src="https://static001.geekbang.org/resource/image/95/de/95dcf8742593b1191e87beaca16f59de.png" alt=""/></p><p>其实，Add方法就是给第一个参数地址中的值增加一个delta值。</p><p>对于有符号的整数来说，delta可以是一个负数，相当于减去一个值。对于无符号的整数和uinptr类型来说，怎么实现减去一个值呢？毕竟，atomic并没有提供单独的减法操作。</p><p>我来跟你说一种方法。你可以利用计算机补码的规则，把减法变成加法。以uint32类型为例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">AddUint32(&amp;x, ^uint32(c-1)).</span></div></pre></div><p>如果是对uint64的值进行操作，那么，就把上面的代码中的uint32替换成uint64。</p><p>尤其是减1这种特殊的操作，我们可以简化为：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">AddUint32(&amp;x, ^uint32(0))</span></div></pre></div><p>好了，我们再来看看CAS方法。</p><h2 id="cas-compareandswap"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/03.原子操作/01#cas-compareandswap"><span class="icon icon-link"></span></a>CAS （CompareAndSwap）</h2><p>以int32为例，我们学习一下CAS提供的功能。在CAS的方法签名中，需要提供要操作的地址、原数据值、新值，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)</span></div></pre></div><p>我们来看下这个方法的功能。</p><p>这个方法会比较当前addr地址里的值是不是old，如果不等于old，就返回false；如果等于old，就把此地址的值替换成new值，返回true。这就相当于“判断相等才替换”。</p><p>如果使用伪代码来表示这个原子操作，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">if *addr == old {</span></div><div class="token-line"><span class="token plain">    	*addr = new</span></div><div class="token-line"><span class="token plain">    	return true</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    return false</span></div></pre></div><p>它支持的类型和方法如图所示：</p><p><img src="https://static001.geekbang.org/resource/image/1b/77/1b0ffac37d8f952ca485ff58daf27177.png" alt=""/></p><h2 id="swap"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/03.原子操作/01#swap"><span class="icon icon-link"></span></a>Swap</h2><p>如果不需要比较旧值，只是比较粗暴地替换的话，就可以使用Swap方法，它替换后还可以返回旧值，伪代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">old = *addr</span></div><div class="token-line"><span class="token plain">    *addr = new</span></div><div class="token-line"><span class="token plain">    return old</span></div></pre></div><p>它支持的数据类型和方法如图所示：</p><p><img src="https://static001.geekbang.org/resource/image/c0/0a/c02e210607aa45734bb1812c97f77c0a.png" alt=""/></p><h2 id="load"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/03.原子操作/01#load"><span class="icon icon-link"></span></a>Load</h2><p>Load方法会取出addr地址中的值，即使在多处理器、多核、有CPU cache的情况下，这个操作也能保证Load是一个原子操作。</p><p>它支持的数据类型和方法如图所示：</p><p><img src="https://static001.geekbang.org/resource/image/3f/5d/3faba284bda2a666caa5727d0f0c275d.png" alt=""/></p><h2 id="store"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/03.原子操作/01#store"><span class="icon icon-link"></span></a>Store</h2><p>Store方法会把一个值存入到指定的addr地址中，即使在多处理器、多核、有CPU cache的情况下，这个操作也能保证Store是一个原子操作。别的goroutine通过Load读取出来，不会看到存取了一半的值。</p><p>它支持的数据类型和方法如图所示：</p><p><img src="https://static001.geekbang.org/resource/image/8b/a0/8b77dc0e1ede98394aa21cf10fecc9a0.png" alt=""/></p><h2 id="value类型"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/03.原子操作/01#value类型"><span class="icon icon-link"></span></a>Value类型</h2><p>刚刚说的都是一些比较常见的类型，其实，atomic还提供了一个特殊的类型：Value。它可以原子地存取对象类型，但也只能存取，不能CAS和Swap，常常用在配置变更等场景中。</p><p><img src="https://static001.geekbang.org/resource/image/47/76/478b665391766de77043ffeb0d6fff76.png" alt=""/></p><p>接下来，我以一个配置变更的例子，来演示Value类型的使用。这里定义了一个Value类型的变量config， 用来存储配置信息。</p><p>首先，我们启动一个goroutine，然后让它随机sleep一段时间，之后就变更一下配置，并通过我们前面学到的Cond并发原语，通知其它的reader去加载新的配置。</p><p>接下来，我们启动一个goroutine等待配置变更的信号，一旦有变更，它就会加载最新的配置。</p><p>通过这个例子，你可以了解到Value的Store/Load方法的使用，因为它只有这两个方法，只要掌握了它们的使用，你就完全掌握了Value类型。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type Config struct {</span></div><div class="token-line"><span class="token plain">        NodeName string</span></div><div class="token-line"><span class="token plain">        Addr     string</span></div><div class="token-line"><span class="token plain">        Count    int32</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func loadNewConfig() Config {</span></div><div class="token-line"><span class="token plain">        return Config{</span></div><div class="token-line"><span class="token plain">            NodeName: &quot;北京&quot;,</span></div><div class="token-line"><span class="token plain">            Addr:     &quot;10.77.95.27&quot;,</span></div><div class="token-line"><span class="token plain">            Count:    rand.Int31(),</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">        var config atomic.Value</span></div><div class="token-line"><span class="token plain">        config.Store(loadNewConfig())</span></div><div class="token-line"><span class="token plain">        var cond = sync.NewCond(&amp;sync.Mutex{})</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 设置新的config</span></div><div class="token-line"><span class="token plain">        go func() {</span></div><div class="token-line"><span class="token plain">            for {</span></div><div class="token-line"><span class="token plain">                time.Sleep(time.Duration(5+rand.Int63n(5)) * time.Second)</span></div><div class="token-line"><span class="token plain">                config.Store(loadNewConfig())</span></div><div class="token-line"><span class="token plain">                cond.Broadcast() // 通知等待着配置已变更</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        go func() {</span></div><div class="token-line"><span class="token plain">            for {</span></div><div class="token-line"><span class="token plain">                cond.L.Lock()</span></div><div class="token-line"><span class="token plain">                cond.Wait()                 // 等待变更信号</span></div><div class="token-line"><span class="token plain">                c := config.Load().(Config) // 读取新的配置</span></div><div class="token-line"><span class="token plain">                fmt.Printf(&quot;new config: %+v\n&quot;, c)</span></div><div class="token-line"><span class="token plain">                cond.L.Unlock()</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        select {}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>好了，关于标准库的atomic提供的方法，到这里我们就学完了。事实上，atomic包提供了非常好的支持各种平台的一致性的API，绝大部分项目都是直接使用它。接下来，我再给你介绍一下第三方库，帮助你稍微开拓一下思维。</p><h1 id="第三方库的扩展"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/03.原子操作/01#第三方库的扩展"><span class="icon icon-link"></span></a>第三方库的扩展</h1><p>其实，atomic的API已经算是很简单的了，它提供了包一级的函数，可以对几种类型的数据执行原子操作。</p><p>不过有一点让人觉得不爽的是，或者是让熟悉面向对象编程的程序员不爽的是，函数调用有一点点麻烦。所以，有些人就对这些函数做了进一步的包装，跟atomic中的Value类型类似，这些类型也提供了面向对象的使用方式，比如关注度比较高的<a target="_blank" rel="noopener noreferrer" href="https://github.com/uber-go/atomic">uber-go/atomic<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，它定义和封装了几种与常见类型相对应的原子操作类型，这些类型提供了原子操作的方法。这些类型包括Bool、Duration、Error、Float64、Int32、Int64、String、Uint32、Uint64等。</p><p>比如Bool类型，提供了CAS、Store、Swap、Toggle等原子方法，还提供String、MarshalJSON、UnmarshalJSON等辅助方法，确实是一个精心设计的atomic扩展库。关于这些方法，你一看名字就能猜出来它们的功能，我就不多说了。</p><p>其它的数据类型也和Bool类型相似，使用起来就像面向对象的编程一样，你可以看下下面的这段代码。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var running atomic.Bool</span></div><div class="token-line"><span class="token plain">        running.Store(true)</span></div><div class="token-line"><span class="token plain">        running.Toggle()</span></div><div class="token-line"><span class="token plain">        fmt.Println(running.Load()) // false</span></div></pre></div><h1 id="使用atomic实现lock-free-queue"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/03.原子操作/01#使用atomic实现lock-free-queue"><span class="icon icon-link"></span></a>使用atomic实现Lock-Free queue</h1><p>atomic常常用来实现Lock-Free的数据结构，这次我会给你展示一个Lock-Free queue的实现。</p><p>Lock-Free queue最出名的就是 Maged M. Michael 和 Michael L. Scott 1996年发表的<a target="_blank" rel="noopener noreferrer" href="https://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf">论文<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中的算法，算法比较简单，容易实现，伪代码的每一行都提供了注释，我就不在这里贴出伪代码了，因为我们使用Go实现这个数据结构的代码几乎和伪代码一样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package queue</span></div><div class="token-line"><span class="token plain">    import (</span></div><div class="token-line"><span class="token plain">    	&quot;sync/atomic&quot;</span></div><div class="token-line"><span class="token plain">    	&quot;unsafe&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    // lock-free的queue</span></div><div class="token-line"><span class="token plain">    type LKQueue struct {</span></div><div class="token-line"><span class="token plain">    	head unsafe.Pointer</span></div><div class="token-line"><span class="token plain">    	tail unsafe.Pointer</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    // 通过链表实现，这个数据结构代表链表中的节点</span></div><div class="token-line"><span class="token plain">    type node struct {</span></div><div class="token-line"><span class="token plain">    	value interface{}</span></div><div class="token-line"><span class="token plain">    	next  unsafe.Pointer</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    func NewLKQueue() *LKQueue {</span></div><div class="token-line"><span class="token plain">    	n := unsafe.Pointer(&amp;node{})</span></div><div class="token-line"><span class="token plain">    	return &amp;LKQueue{head: n, tail: n}</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    // 入队</span></div><div class="token-line"><span class="token plain">    func (q *LKQueue) Enqueue(v interface{}) {</span></div><div class="token-line"><span class="token plain">    	n := &amp;node{value: v}</span></div><div class="token-line"><span class="token plain">    	for {</span></div><div class="token-line"><span class="token plain">    		tail := load(&amp;q.tail)</span></div><div class="token-line"><span class="token plain">    		next := load(&amp;tail.next)</span></div><div class="token-line"><span class="token plain">    		if tail == load(&amp;q.tail) { // 尾还是尾</span></div><div class="token-line"><span class="token plain">    			if next == nil { // 还没有新数据入队</span></div><div class="token-line"><span class="token plain">    				if cas(&amp;tail.next, next, n) { //增加到队尾</span></div><div class="token-line"><span class="token plain">    					cas(&amp;q.tail, tail, n) //入队成功，移动尾巴指针</span></div><div class="token-line"><span class="token plain">    					return</span></div><div class="token-line"><span class="token plain">    				}</span></div><div class="token-line"><span class="token plain">    			} else { // 已有新数据加到队列后面，需要移动尾指针</span></div><div class="token-line"><span class="token plain">    				cas(&amp;q.tail, tail, next)</span></div><div class="token-line"><span class="token plain">    			}</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    // 出队，没有元素则返回nil</span></div><div class="token-line"><span class="token plain">    func (q *LKQueue) Dequeue() interface{} {</span></div><div class="token-line"><span class="token plain">    	for {</span></div><div class="token-line"><span class="token plain">    		head := load(&amp;q.head)</span></div><div class="token-line"><span class="token plain">    		tail := load(&amp;q.tail)</span></div><div class="token-line"><span class="token plain">    		next := load(&amp;head.next)</span></div><div class="token-line"><span class="token plain">    		if head == load(&amp;q.head) { // head还是那个head</span></div><div class="token-line"><span class="token plain">    			if head == tail { // head和tail一样</span></div><div class="token-line"><span class="token plain">    				if next == nil { // 说明是空队列</span></div><div class="token-line"><span class="token plain">    					return nil</span></div><div class="token-line"><span class="token plain">    				}</span></div><div class="token-line"><span class="token plain">    				// 只是尾指针还没有调整，尝试调整它指向下一个</span></div><div class="token-line"><span class="token plain">    				cas(&amp;q.tail, tail, next)</span></div><div class="token-line"><span class="token plain">    			} else {</span></div><div class="token-line"><span class="token plain">    				// 读取出队的数据</span></div><div class="token-line"><span class="token plain">    				v := next.value</span></div><div class="token-line"><span class="token plain">                    // 既然要出队了，头指针移动到下一个</span></div><div class="token-line"><span class="token plain">    				if cas(&amp;q.head, head, next) {</span></div><div class="token-line"><span class="token plain">    					return v // Dequeue is done.  return</span></div><div class="token-line"><span class="token plain">    				}</span></div><div class="token-line"><span class="token plain">    			}</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 将unsafe.Pointer原子加载转换成node</span></div><div class="token-line"><span class="token plain">    func load(p *unsafe.Pointer) (n *node) {</span></div><div class="token-line"><span class="token plain">    	return (*node)(atomic.LoadPointer(p))</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 封装CAS,避免直接将*node转换成unsafe.Pointer</span></div><div class="token-line"><span class="token plain">    func cas(p *unsafe.Pointer, old, new *node) (ok bool) {</span></div><div class="token-line"><span class="token plain">    	return atomic.CompareAndSwapPointer(</span></div><div class="token-line"><span class="token plain">    		p, unsafe.Pointer(old), unsafe.Pointer(new))</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我来给你介绍下这里的主要逻辑。</p><p>这个lock-free的实现使用了一个辅助头指针（head），头指针不包含有意义的数据，只是一个辅助的节点，这样的话，出队入队中的节点会更简单。</p><p>入队的时候，通过CAS操作将一个元素添加到队尾，并且移动尾指针。</p><p>出队的时候移除一个节点，并通过CAS操作移动head指针，同时在必要的时候移动尾指针。</p><h1 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/03.原子操作/01#总结"><span class="icon icon-link"></span></a>总结</h1><p>好了，我们来小结一下。这节课，我们学习了atomic的基本使用方法，以及它提供的几种方法，包括Add、CAS、Swap、Load、Store、Value类型。除此之外，我还介绍了一些第三方库，并且带你实现了Lock-free queue。到这里，相信你已经掌握了atomic提供的各种方法，并且能够应用到实践中了。</p><p>最后，我还想和你讨论一个额外的问题：对一个地址的赋值是原子操作吗？</p><p>这是一个很有趣的问题，如果是原子操作，还要atomic包干什么？官方的文档中并没有特意的介绍，不过，在一些issue或者论坛中，每当有人谈到这个问题时，总是会被建议用atomic包。</p><p><a target="_blank" rel="noopener noreferrer" href="https://dave.cheney.net/2018/01/06/if-aligned-memory-writes-are-atomic-why-do-we-need-the-sync-atomic-package">Dave Cheney<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>就谈到过这个问题，讲得非常好。我来给你总结一下他讲的知识点，这样你就比较容易理解使用atomic和直接内存操作的区别了。</p><p>在现在的系统中，write的地址基本上都是对齐的（aligned）。 比如，32位的操作系统、CPU以及编译器，write的地址总是4的倍数，64位的系统总是8的倍数（还记得WaitGroup针对64位系统和32位系统对state1的字段不同的处理吗）。对齐地址的写，不会导致其他人看到只写了一半的数据，因为它通过一个指令就可以实现对地址的操作。如果地址不是对齐的话，那么，处理器就需要分成两个指令去处理，如果执行了一个指令，其它人就会看到更新了一半的错误的数据，这被称做撕裂写（torn write） 。所以，你可以认为赋值操作是一个原子操作，这个“原子操作”可以认为是保证数据的完整性。</p><p>但是，对于现代的多处理多核的系统来说，由于cache、指令重排，可见性等问题，我们对原子操作的意义有了更多的追求。在多核系统中，一个核对地址的值的更改，在更新到主内存中之前，是在多级缓存中存放的。这时，多个核看到的数据可能是不一样的，其它的核可能还没有看到更新的数据，还在使用旧的数据。</p><p>多处理器多核心系统为了处理这类问题，使用了一种叫做内存屏障（memory fence或memory barrier）的方式。一个写内存屏障会告诉处理器，必须要等到它管道中的未完成的操作（特别是写操作）都被刷新到内存中，再进行操作。此操作还会让相关的处理器的CPU缓存失效，以便让它们从主存中拉取最新的值。</p><p>atomic包提供的方法会提供内存屏障的功能，所以，atomic不仅仅可以保证赋值的数据完整性，还能保证数据的可见性，一旦一个核更新了该地址的值，其它处理器总是能读取到它的最新值。但是，需要注意的是，因为需要处理器之间保证数据的一致性，atomic的操作也是会降低性能的。</p><p><img src="https://static001.geekbang.org/resource/image/53/13/53d55255fe851754659d90cbee814f13.jpg" alt=""/></p><h1 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/03.原子操作/01#思考题"><span class="icon icon-link"></span></a>思考题</h1><p>atomic.Value只有Load/Store方法，你是不是感觉意犹未尽？你可以尝试为Value类型增加 Swap和CompareAndSwap方法（可以参考一下<a target="_blank" rel="noopener noreferrer" href="https://github.com/golang/go/issues/39351">这份资料<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）。</p><p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得有所收获，也欢迎你把今天的内容分享给你的朋友或同事。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/go并发编程实战/03.原子操作/01.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:06</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
