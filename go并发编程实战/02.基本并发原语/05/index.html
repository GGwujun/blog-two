<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>05｜ RWMutex：读写锁的实现原理及避坑指南</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/go并发编程实战/02.基本并发原语/05" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a aria-current="page" class="active" href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a aria-current="page" class="active" href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/go并发编程实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-two/go并发编程实战/01.开篇词/01"><span>开篇词 | 想吃透Go并发编程，你得这样学！</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/go并发编程实战/02.基本并发原语">02.基本并发原语</a><ul><li><a href="/blog-two/go并发编程实战/02.基本并发原语/01"><span>01 | Mutex：如何解决资源并发访问问题？</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/02"><span>02 | Mutex：庖丁解牛看实现</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/03"><span>03｜Mutex：4种易错场景大盘点</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/04"><span>04｜ Mutex：骇客编程，如何拓展额外功能？</span></a></li><li><a aria-current="page" class="active" href="/blog-two/go并发编程实战/02.基本并发原语/05"><span>05｜ RWMutex：读写锁的实现原理及避坑指南</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/06"><span>06 | WaitGroup：协同等待，任务编排利器</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/07"><span>07 | Cond：条件变量的实现机制及避坑指南</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/08"><span>08 | Once：一个简约而不简单的并发原语</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/09"><span>09 | map：如何实现线程安全的map类型？</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/10"><span>10 | Pool：性能提升大杀器</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/11"><span>11 | Context：信息穿透上下文</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/03.原子操作">03.原子操作</a><ul><li><a href="/blog-two/go并发编程实战/03.原子操作/01"><span>12 | atomic：要保证原子操作，一定要使用这几种方法</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/04.channel">04.Channel</a><ul><li><a href="/blog-two/go并发编程实战/04.channel/01"><span>13 | Channel：另辟蹊径，解决并发问题</span></a></li><li><a href="/blog-two/go并发编程实战/04.channel/02"><span>14 | Channel：透过代码看典型的应用模式</span></a></li><li><a href="/blog-two/go并发编程实战/04.channel/03"><span>15 | 内存模型：Go如何保证并发读写的顺序？</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/05.扩展并发原语">05.扩展并发原语</a><ul><li><a href="/blog-two/go并发编程实战/05.扩展并发原语/01"><span>16 | Semaphore：一篇文章搞懂信号量</span></a></li><li><a href="/blog-two/go并发编程实战/05.扩展并发原语/02"><span>17 | SingleFlight 和 CyclicBarrier：请求合并和循环栅栏该怎么用？</span></a></li><li><a href="/blog-two/go并发编程实战/05.扩展并发原语/03"><span>18 | 分组操作：处理一组子任务，该用什么并发原语？</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/06.分布式并发原语">06.分布式并发原语</a><ul><li><a href="/blog-two/go并发编程实战/06.分布式并发原语/01"><span>19 |  在分布式环境中，Leader选举、互斥锁和读写锁该如何实现？</span></a></li><li><a href="/blog-two/go并发编程实战/06.分布式并发原语/02"><span>20 | 在分布式环境中，队列、栅栏和STM该如何实现？</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/07.结束语">07.结束语</a><ul><li><a href="/blog-two/go并发编程实战/07.结束语/01"><span>结束语 | 再聊Go并发编程的价值和精进之路</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/summary">go并发编程实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="RLock/RUnlock的实现" data-depth="2"><a href="/blog-two/go并发编程实战/02.基本并发原语/05#rlockrunlock的实现"><span>RLock/RUnlock的实现</span></a></li><li title="Lock" data-depth="2"><a href="/blog-two/go并发编程实战/02.基本并发原语/05#lock"><span>Lock</span></a></li><li title="Unlock" data-depth="2"><a href="/blog-two/go并发编程实战/02.基本并发原语/05#unlock"><span>Unlock</span></a></li><li title="坑点1：不可复制" data-depth="2"><a href="/blog-two/go并发编程实战/02.基本并发原语/05#坑点1不可复制"><span>坑点1：不可复制</span></a></li><li title="坑点2：重入导致死锁" data-depth="2"><a href="/blog-two/go并发编程实战/02.基本并发原语/05#坑点2重入导致死锁"><span>坑点2：重入导致死锁</span></a></li><li title="坑点3：释放未加锁的RWMutex" data-depth="2"><a href="/blog-two/go并发编程实战/02.基本并发原语/05#坑点3释放未加锁的rwmutex"><span>坑点3：释放未加锁的RWMutex</span></a></li><li title="Docker" data-depth="2"><a href="/blog-two/go并发编程实战/02.基本并发原语/05#docker"><span>Docker</span></a></li><li title="issue 36840" data-depth="3"><a href="/blog-two/go并发编程实战/02.基本并发原语/05#issue-36840"><span>issue 36840</span></a></li><li title="Kubernetes" data-depth="2"><a href="/blog-two/go并发编程实战/02.基本并发原语/05#kubernetes"><span>Kubernetes</span></a></li><li title="issue 62464" data-depth="3"><a href="/blog-two/go并发编程实战/02.基本并发原语/05#issue-62464"><span>issue 62464</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="05-rwmutex读写锁的实现原理及避坑指南"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/05#05-rwmutex读写锁的实现原理及避坑指南"><span class="icon icon-link"></span></a>05｜ RWMutex：读写锁的实现原理及避坑指南</h1><p>你好，我是鸟窝。</p><p>在前面的四节课中，我们学习了第一个同步原语，即Mutex，我们使用它来保证读写共享资源的安全性。不管是读还是写，我们都通过Mutex来保证只有一个goroutine访问共享资源，这在某些情况下有点“浪费”。比如说，在写少读多的情况下，即使一段时间内没有写操作，大量并发的读访问也不得不在Mutex的保护下变成了串行访问，这个时候，使用Mutex，对性能的影响就比较大。</p><p>怎么办呢？你是不是已经有思路了，对，就是区分读写操作。</p><p>我来具体解释一下。如果某个读操作的goroutine持有了锁，在这种情况下，其它读操作的goroutine就不必一直傻傻地等待了，而是可以并发地访问共享变量，这样我们就可以<strong>将串行的读变成并行读</strong>，提高读操作的性能。当写操作的goroutine持有锁的时候，它就是一个排外锁，其它的写操作和读操作的goroutine，需要阻塞等待持有这个锁的goroutine释放锁。</p><p>这一类并发读写问题叫作<a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem">readers-writers问题<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，意思就是，同时可能有多个读或者多个写，但是只要有一个线程在执行写操作，其它的线程都不能执行读写操作。</p><p><strong>Go标准库中的RWMutex（读写锁）就是用来解决这类readers-writers问题的</strong>。所以，这节课，我们就一起来学习RWMutex。我会给你介绍读写锁的使用场景、实现原理以及容易掉入的坑，你一定要记住这些陷阱，避免在实际的开发中犯相同的错误。</p><h1 id="什么是rwmutex"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/05#什么是rwmutex"><span class="icon icon-link"></span></a>什么是RWMutex？</h1><p>我先简单解释一下读写锁RWMutex。标准库中的RWMutex是一个 reader/writer 互斥锁。RWMutex在某一时刻只能由任意数量的reader持有，或者是只被单个的writer持有。</p><p>RWMutex的方法也很少，总共有5个。</p><ul><li><strong>Lock/Unlock：写操作时调用的方法</strong>。如果锁已经被reader或者writer持有，那么，Lock方法会一直阻塞，直到能获取到锁；Unlock则是配对的释放锁的方法。</li><li><strong>RLock/RUnlock：读操作时调用的方法</strong>。如果锁已经被writer持有的话，RLock方法会一直阻塞，直到能获取到锁，否则就直接返回；而RUnlock是reader释放锁的方法。</li><li><strong>RLocker</strong>：这个方法的作用是为读操作返回一个Locker接口的对象。它的Lock方法会调用RWMutex的RLock方法，它的Unlock方法会调用RWMutex的RUnlock方法。</li></ul><p>RWMutex的零值是未加锁的状态，所以，当你使用RWMutex的时候，无论是声明变量，还是嵌入到其它struct中，都不必显式地初始化。</p><p>我以计数器为例，来说明一下，如何使用RWMutex保护共享资源。计数器的<strong>count++<strong>操作是</strong>写</strong>操作，而获取count的值是<strong>读</strong>操作，这个场景非常适合读写锁，因为读操作可以并行执行，写操作时只允许一个线程执行，这正是readers-writers问题。</p><p>在这个例子中，使用10个goroutine进行读操作，每读取一次，sleep 1毫秒，同时，还有一个gorotine进行写操作，每一秒写一次，这是一个 <strong>1</strong> writer-<strong>n</strong> reader 的读写场景，而且写操作还不是很频繁（一秒一次）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func main() {</span></div><div class="token-line"><span class="token plain">        var counter Counter</span></div><div class="token-line"><span class="token plain">        for i := 0; i &lt; 10; i++ { // 10个reader</span></div><div class="token-line"><span class="token plain">            go func() {</span></div><div class="token-line"><span class="token plain">                for {</span></div><div class="token-line"><span class="token plain">                    counter.Count() // 计数器读操作</span></div><div class="token-line"><span class="token plain">                    time.Sleep(time.Millisecond)</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for { // 一个writer</span></div><div class="token-line"><span class="token plain">            counter.Incr() // 计数器写操作</span></div><div class="token-line"><span class="token plain">            time.Sleep(time.Second)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    // 一个线程安全的计数器</span></div><div class="token-line"><span class="token plain">    type Counter struct {</span></div><div class="token-line"><span class="token plain">        mu    sync.RWMutex</span></div><div class="token-line"><span class="token plain">        count uint64</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 使用写锁保护</span></div><div class="token-line"><span class="token plain">    func (c *Counter) Incr() {</span></div><div class="token-line"><span class="token plain">        c.mu.Lock()</span></div><div class="token-line"><span class="token plain">        c.count++</span></div><div class="token-line"><span class="token plain">        c.mu.Unlock()</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 使用读锁保护</span></div><div class="token-line"><span class="token plain">    func (c *Counter) Count() uint64 {</span></div><div class="token-line"><span class="token plain">        c.mu.RLock()</span></div><div class="token-line"><span class="token plain">        defer c.mu.RUnlock()</span></div><div class="token-line"><span class="token plain">        return c.count</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，Incr方法会修改计数器的值，是一个写操作，我们使用Lock/Unlock进行保护。Count方法会读取当前计数器的值，是一个读操作，我们使用RLock/RUnlock方法进行保护。</p><p>Incr方法每秒才调用一次，所以，writer竞争锁的频次是比较低的，而10个goroutine每毫秒都要执行一次查询，通过读写锁，可以极大提升计数器的性能，因为在读取的时候，可以并发进行。如果使用Mutex，性能就不会像读写锁这么好。因为多个reader并发读的时候，使用互斥锁导致了reader要排队读的情况，没有RWMutex并发读的性能好。</p><p><strong>如果你遇到可以明确区分reader和writer goroutine的场景，且有大量的并发读、少量的并发写，并且有强烈的性能需求，你就可以考虑使用读写锁RWMutex替换Mutex。</strong></p><p>在实际使用RWMutex的时候，如果我们在struct中使用RWMutex保护某个字段，一般会把它和这个字段放在一起，用来指示两个字段是一组字段。除此之外，我们还可以采用匿名字段的方式嵌入struct，这样，在使用这个struct时，我们就可以直接调用Lock/Unlock、RLock/RUnlock方法了，这和我们前面在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/294905">01讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中介绍Mutex的使用方法很类似，你可以回去复习一下。</p><h1 id="rwmutex的实现原理"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/05#rwmutex的实现原理"><span class="icon icon-link"></span></a>RWMutex的实现原理</h1><p>RWMutex是很常见的并发原语，很多编程语言的库都提供了类似的并发类型。RWMutex一般都是基于互斥锁、条件变量（condition variables）或者信号量（semaphores）等并发原语来实现。<strong>Go标准库中的RWMutex是基于Mutex实现的。</strong></p><p>readers-writers问题一般有三类，基于对读和写操作的优先级，读写锁的设计和实现也分成三类。</p><ul><li><strong>Read-preferring</strong>：读优先的设计可以提供很高的并发性，但是，在竞争激烈的情况下可能会导致写饥饿。这是因为，如果有大量的读，这种设计会导致只有所有的读都释放了锁之后，写才可能获取到锁。</li><li><strong>Write-preferring</strong>：写优先的设计意味着，如果已经有一个writer在等待请求锁的话，它会阻止新来的请求锁的reader获取到锁，所以优先保障writer。当然，如果有一些reader已经请求了锁的话，新请求的writer也会等待已经存在的reader都释放锁之后才能获取。所以，写优先级设计中的优先权是针对新来的请求而言的。这种设计主要避免了writer的饥饿问题。</li><li><strong>不指定优先级</strong>：这种设计比较简单，不区分reader和writer优先级，某些场景下这种不指定优先级的设计反而更有效，因为第一类优先级会导致写饥饿，第二类优先级可能会导致读饥饿，这种不指定优先级的访问不再区分读写，大家都是同一个优先级，解决了饥饿的问题。</li></ul><p><strong>Go标准库中的RWMutex设计是Write-preferring方案。一个正在阻塞的Lock调用会排除新的reader请求到锁。</strong></p><p>RWMutex包含一个Mutex，以及四个辅助字段writerSem、readerSem、readerCount和readerWait：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type RWMutex struct {</span></div><div class="token-line"><span class="token plain">    	w           Mutex   // 互斥锁解决多个writer的竞争</span></div><div class="token-line"><span class="token plain">    	writerSem   uint32  // writer信号量</span></div><div class="token-line"><span class="token plain">    	readerSem   uint32  // reader信号量</span></div><div class="token-line"><span class="token plain">    	readerCount int32   // reader的数量</span></div><div class="token-line"><span class="token plain">    	readerWait  int32   // writer等待完成的reader的数量</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    const rwmutexMaxReaders = 1 &lt;&lt; 30</span></div></pre></div><p>我来简单解释一下这几个字段。</p><ul><li>字段w：为writer的竞争锁而设计；</li><li>字段readerCount：记录当前reader的数量（以及是否有writer竞争锁）；</li><li>readerWait：记录writer请求锁时需要等待read完成的reader的数量；</li><li>writerSem 和readerSem：都是为了阻塞设计的信号量。</li></ul><p>这里的常量rwmutexMaxReaders，定义了最大的reader数量。</p><p>好了，知道了RWMutex的设计方案和具体字段，下面我来解释一下具体的方法实现。</p><h2 id="rlockrunlock的实现"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/05#rlockrunlock的实现"><span class="icon icon-link"></span></a>RLock/RUnlock的实现</h2><p>首先，我们看一下移除了race等无关紧要的代码后的RLock和RUnlock方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (rw *RWMutex) RLock() {</span></div><div class="token-line"><span class="token plain">        if atomic.AddInt32(&amp;rw.readerCount, 1) &lt; 0 {</span></div><div class="token-line"><span class="token plain">                // rw.readerCount是负值的时候，意味着此时有writer等待请求锁，因为writer优先级高，所以把后来的reader阻塞休眠</span></div><div class="token-line"><span class="token plain">            runtime_SemacquireMutex(&amp;rw.readerSem, false, 0)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    func (rw *RWMutex) RUnlock() {</span></div><div class="token-line"><span class="token plain">        if r := atomic.AddInt32(&amp;rw.readerCount, -1); r &lt; 0 {</span></div><div class="token-line"><span class="token plain">            rw.rUnlockSlow(r) // 有等待的writer</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    func (rw *RWMutex) rUnlockSlow(r int32) {</span></div><div class="token-line"><span class="token plain">        if atomic.AddInt32(&amp;rw.readerWait, -1) == 0 {</span></div><div class="token-line"><span class="token plain">            // 最后一个reader了，writer终于有机会获得锁了</span></div><div class="token-line"><span class="token plain">            runtime_Semrelease(&amp;rw.writerSem, false, 1)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>第2行是对reader计数加1。你可能比较困惑的是，readerCount怎么还可能为负数呢？其实，这是因为，readerCount这个字段有双重含义：</p><ul><li>没有writer竞争或持有锁时，readerCount和我们正常理解的reader的计数是一样的；</li><li>但是，如果有writer竞争锁或者持有锁时，那么，readerCount不仅仅承担着reader的计数功能，还能够标识当前是否有writer竞争或持有锁，在这种情况下，请求锁的reader的处理进入第4行，阻塞等待锁的释放。</li></ul><p>调用RUnlock的时候，我们需要将Reader的计数减去1（第8行），因为reader的数量减少了一个。但是，第8行的AddInt32的返回值还有另外一个含义。如果它是负值，就表示当前有writer竞争锁，在这种情况下，还会调用rUnlockSlow方法，检查是不是reader都释放读锁了，如果读锁都释放了，那么可以唤醒请求写锁的writer了。</p><p>当一个或者多个reader持有锁的时候，竞争锁的writer会等待这些reader释放完，才可能持有这把锁。打个比方，在房地产行业中有条规矩叫做“<strong>买卖不破租赁</strong>”，意思是说，就算房东把房子卖了，新业主也不能把当前的租户赶走，而是要等到租约结束后，才能接管房子。这和RWMutex的设计是一样的。当writer请求锁的时候，是无法改变既有的reader持有锁的现实的，也不会强制这些reader释放锁，它的优先权只是限定后来的reader不要和它抢。</p><p>所以，rUnlockSlow将持有锁的reader计数减少1的时候，会检查既有的reader是不是都已经释放了锁，如果都释放了锁，就会唤醒writer，让writer持有锁。</p><h2 id="lock"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/05#lock"><span class="icon icon-link"></span></a>Lock</h2><p>RWMutex是一个多writer多reader的读写锁，所以同时可能有多个writer和reader。那么，为了避免writer之间的竞争，RWMutex就会使用一个Mutex来保证writer的互斥。</p><p>一旦一个writer获得了内部的互斥锁，就会反转readerCount字段，把它从原来的正整数readerCount(&gt;=0)修改为负数（readerCount-rwmutexMaxReaders），让这个字段保持两个含义（既保存了reader的数量，又表示当前有writer）。</p><p>我们来看下下面的代码。第5行，还会记录当前活跃的reader数量，所谓活跃的reader，就是指持有读锁还没有释放的那些reader。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (rw *RWMutex) Lock() {</span></div><div class="token-line"><span class="token plain">        // 首先解决其他writer竞争问题</span></div><div class="token-line"><span class="token plain">        rw.w.Lock()</span></div><div class="token-line"><span class="token plain">        // 反转readerCount，告诉reader有writer竞争锁</span></div><div class="token-line"><span class="token plain">        r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span></div><div class="token-line"><span class="token plain">        // 如果当前有reader持有锁，那么需要等待</span></div><div class="token-line"><span class="token plain">        if r != 0 &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != 0 {</span></div><div class="token-line"><span class="token plain">            runtime_SemacquireMutex(&amp;rw.writerSem, false, 0)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>如果readerCount不是0，就说明当前有持有读锁的reader，RWMutex需要把这个当前readerCount赋值给readerWait字段保存下来（第7行）， 同时，这个writer进入阻塞等待状态（第8行）。</p><p>每当一个reader释放读锁的时候（调用RUnlock方法时），readerWait字段就减1，直到所有的活跃的reader都释放了读锁，才会唤醒这个writer。</p><h2 id="unlock"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/05#unlock"><span class="icon icon-link"></span></a>Unlock</h2><p>当一个writer释放锁的时候，它会再次反转readerCount字段。可以肯定的是，因为当前锁由writer持有，所以，readerCount字段是反转过的，并且减去了rwmutexMaxReaders这个常数，变成了负数。所以，这里的反转方法就是给它增加rwmutexMaxReaders这个常数值。</p><p>既然writer要释放锁了，那么就需要唤醒之后新来的reader，不必再阻塞它们了，让它们开开心心地继续执行就好了。</p><p>在RWMutex的Unlock返回之前，需要把内部的互斥锁释放。释放完毕后，其他的writer才可以继续竞争这把锁。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (rw *RWMutex) Unlock() {</span></div><div class="token-line"><span class="token plain">        // 告诉reader没有活跃的writer了</span></div><div class="token-line"><span class="token plain">        r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        // 唤醒阻塞的reader们</span></div><div class="token-line"><span class="token plain">        for i := 0; i &lt; int(r); i++ {</span></div><div class="token-line"><span class="token plain">            runtime_Semrelease(&amp;rw.readerSem, false, 0)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        // 释放内部的互斥锁</span></div><div class="token-line"><span class="token plain">        rw.w.Unlock()</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这段代码中，我删除了race的处理和异常情况的检查，总体看来还是比较简单的。这里有几个重点，我要再提醒你一下。首先，你要理解readerCount这个字段的含义以及反转方式。其次，你还要注意字段的更改和内部互斥锁的顺序关系。在Lock方法中，是先获取内部互斥锁，才会修改的其他字段；而在Unlock方法中，是先修改的其他字段，才会释放内部互斥锁，这样才能保证字段的修改也受到互斥锁的保护。</p><p>好了，到这里我们就完整学习了RWMutex的概念和实现原理。RWMutex的应用场景非常明确，就是解决readers-writers问题。学完了今天的内容，之后当你遇到这类问题时，要优先想到RWMutex。另外，Go并发原语代码实现的质量都很高，非常精炼和高效，所以，你可以通过看它们的实现原理，学习一些编程的技巧。当然，还有非常重要的一点就是要知道reader或者writer请求锁的时候，既有的reader/writer和后续请求锁的reader/writer之间的（释放锁/请求锁）顺序关系。</p><p>有个很有意思的事儿，就是官方的文档对RWMutex介绍是错误的，或者说是<a target="_blank" rel="noopener noreferrer" href="https://github.com/golang/go/issues/41555">不明确的<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，在下一个版本（Go 1.16）中，官方会更改对RWMutex的介绍，具体是这样的：</p><blockquote><p>A RWMutex is a reader/writer mutual exclusion lock.</p></blockquote><blockquote><p>The lock can be held by any number of readers or a single writer, and</p></blockquote><blockquote><p>a blocked writer also blocks new readers from acquiring the lock.</p></blockquote><p>这个描述是相当精确的，它指出了RWMutex可以被谁持有，以及writer比后续的reader有获取锁的优先级。</p><p>虽然RWMutex暴露的API也很简单，使用起来也没有复杂的逻辑，但是和Mutex一样，在实际使用的时候，也会很容易踩到一些坑。接下来，我给你重点介绍3个常见的踩坑点。</p><h1 id="rwmutex的3个踩坑点"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/05#rwmutex的3个踩坑点"><span class="icon icon-link"></span></a>RWMutex的3个踩坑点</h1><h2 id="坑点1不可复制"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/05#坑点1不可复制"><span class="icon icon-link"></span></a>坑点1：不可复制</h2><p>前面刚刚说过，RWMutex是由一个互斥锁和四个辅助字段组成的。我们很容易想到，互斥锁是不可复制的，再加上四个有状态的字段，RWMutex就更加不能复制使用了。</p><p>不能复制的原因和互斥锁一样。一旦读写锁被使用，它的字段就会记录它当前的一些状态。这个时候你去复制这把锁，就会把它的状态也给复制过来。但是，原来的锁在释放的时候，并不会修改你复制出来的这个读写锁，这就会导致复制出来的读写锁的状态不对，可能永远无法释放锁。</p><p>那该怎么办呢？其实，解决方案也和互斥锁一样。你可以借助vet工具，在变量赋值、函数传参、函数返回值、遍历数据、struct初始化等时，检查是否有读写锁隐式复制的情景。</p><h2 id="坑点2重入导致死锁"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/05#坑点2重入导致死锁"><span class="icon icon-link"></span></a>坑点2：重入导致死锁</h2><p>读写锁因为重入（或递归调用）导致死锁的情况更多。</p><p>我先介绍第一种情况。因为读写锁内部基于互斥锁实现对writer的并发访问，而互斥锁本身是有重入问题的，所以，writer重入调用Lock的时候，就会出现死锁的现象，这个问题，我们在学习互斥锁的时候已经了解过了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func foo(l *sync.RWMutex) {</span></div><div class="token-line"><span class="token plain">        fmt.Println(&quot;in foo&quot;)</span></div><div class="token-line"><span class="token plain">        l.Lock()</span></div><div class="token-line"><span class="token plain">        bar(l)</span></div><div class="token-line"><span class="token plain">        l.Unlock()</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func bar(l *sync.RWMutex) {</span></div><div class="token-line"><span class="token plain">        l.Lock()</span></div><div class="token-line"><span class="token plain">        fmt.Println(&quot;in bar&quot;)</span></div><div class="token-line"><span class="token plain">        l.Unlock()</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">        l := &amp;sync.RWMutex{}</span></div><div class="token-line"><span class="token plain">        foo(l)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>运行这个程序，你就会得到死锁的错误输出，在Go运行的时候，很容易就能检测出来。</p><p>第二种死锁的场景有点隐蔽。我们知道，有活跃reader的时候，writer会等待，如果我们在reader的读操作时调用writer的写操作（它会调用Lock方法），那么，这个reader和writer就会形成互相依赖的死锁状态。Reader想等待writer完成后再释放锁，而writer需要这个reader释放锁之后，才能不阻塞地继续执行。这是一个读写锁常见的死锁场景。</p><p>第三种死锁的场景更加隐蔽。</p><p>当一个writer请求锁的时候，如果已经有一些活跃的reader，它会等待这些活跃的reader完成，才有可能获取到锁，但是，如果之后活跃的reader再依赖新的reader的话，这些新的reader就会等待writer释放锁之后才能继续执行，这就形成了一个环形依赖： <strong>writer依赖活跃的reader -&gt; 活跃的reader依赖新来的reader -&gt; 新来的reader依赖writer</strong>。</p><p><img src="https://static001.geekbang.org/resource/image/c1/35/c18e897967d29e2d5273b88afe626035.jpg" alt=""/></p><p>这个死锁相当隐蔽，原因在于它和RWMutex的设计和实现有关。啥意思呢？我们来看一个计算阶乘(n!)的例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func main() {</span></div><div class="token-line"><span class="token plain">        var mu sync.RWMutex</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // writer,稍微等待，然后制造一个调用Lock的场景</span></div><div class="token-line"><span class="token plain">        go func() {</span></div><div class="token-line"><span class="token plain">            time.Sleep(200 * time.Millisecond)</span></div><div class="token-line"><span class="token plain">            mu.Lock()</span></div><div class="token-line"><span class="token plain">            fmt.Println(&quot;Lock&quot;)</span></div><div class="token-line"><span class="token plain">            time.Sleep(100 * time.Millisecond)</span></div><div class="token-line"><span class="token plain">            mu.Unlock()</span></div><div class="token-line"><span class="token plain">            fmt.Println(&quot;Unlock&quot;)</span></div><div class="token-line"><span class="token plain">        }()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        go func() {</span></div><div class="token-line"><span class="token plain">            factorial(&amp;mu, 10) // 计算10的阶乘, 10!</span></div><div class="token-line"><span class="token plain">        }()</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        select {}</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 递归调用计算阶乘</span></div><div class="token-line"><span class="token plain">    func factorial(m *sync.RWMutex, n int) int {</span></div><div class="token-line"><span class="token plain">        if n &lt; 1 { // 阶乘退出条件 </span></div><div class="token-line"><span class="token plain">            return 0</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        fmt.Println(&quot;RLock&quot;)</span></div><div class="token-line"><span class="token plain">        m.RLock()</span></div><div class="token-line"><span class="token plain">        defer func() {</span></div><div class="token-line"><span class="token plain">            fmt.Println(&quot;RUnlock&quot;)</span></div><div class="token-line"><span class="token plain">            m.RUnlock()</span></div><div class="token-line"><span class="token plain">        }()</span></div><div class="token-line"><span class="token plain">        time.Sleep(100 * time.Millisecond)</span></div><div class="token-line"><span class="token plain">        return factorial(m, n-1) * n // 递归调用</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>factoria方法是一个递归计算阶乘的方法，我们用它来模拟reader。为了更容易地制造出死锁场景，我在这里加上了sleep的调用，延缓逻辑的执行。这个方法会调用读锁（第27行），在第33行递归地调用此方法，每次调用都会产生一次读锁的调用，所以可以不断地产生读锁的调用，而且必须等到新请求的读锁释放，这个读锁才能释放。</p><p>同时，我们使用另一个goroutine去调用Lock方法，来实现writer，这个writer会等待200毫秒后才会调用Lock，这样在调用Lock的时候，factoria方法还在执行中不断调用RLock。</p><p>这两个goroutine互相持有锁并等待，谁也不会退让一步，满足了“writer依赖活跃的reader -&gt; 活跃的reader依赖新来的reader -&gt; 新来的reader依赖writer”的死锁条件，所以就导致了死锁的产生。</p><p>所以，使用读写锁最需要注意的一点就是尽量避免重入，重入带来的死锁非常隐蔽，而且难以诊断。</p><h2 id="坑点3释放未加锁的rwmutex"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/05#坑点3释放未加锁的rwmutex"><span class="icon icon-link"></span></a>坑点3：释放未加锁的RWMutex</h2><p>和互斥锁一样，Lock和Unlock的调用总是成对出现的，RLock和RUnlock的调用也必须成对出现。Lock和RLock多余的调用会导致锁没有被释放，可能会出现死锁，而Unlock和RUnlock多余的调用会导致panic。在生产环境中出现panic是大忌，你总不希望半夜爬起来处理生产环境程序崩溃的问题吧？所以，在使用读写锁的时候，一定要注意，<strong>不遗漏不多余</strong>。</p><h1 id="流行的go开发项目中的坑"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/05#流行的go开发项目中的坑"><span class="icon icon-link"></span></a>流行的Go开发项目中的坑</h1><p>好了，又到了泡一杯宁夏枸杞加新疆大滩枣的养生茶，静静地欣赏知名项目出现Bug的时候了，这次被拉出来的是RWMutex的Bug。</p><h2 id="docker"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/05#docker"><span class="icon icon-link"></span></a>Docker</h2><h3 id="issue-36840"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/05#issue-36840"><span class="icon icon-link"></span></a>issue 36840</h3><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/moby/moby/pull/36840/files">issue 36840<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>修复的是错误地把writer当成reader的Bug。 这个地方本来需要修改数据，需要调用的是写锁，结果用的却是读锁。或许是被它紧挨着的findNode方法调用迷惑了，认为这只是一个读操作。可实际上，代码后面还会有changeNodeState方法的调用，这是一个写操作。修复办法也很简单，只需要改成Lock/Unlock即可。</p><p><img src="https://static001.geekbang.org/resource/image/e4/4b/e4d153cb5f81873a726b09bc436b8a4b.png" alt=""/></p><h2 id="kubernetes"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/05#kubernetes"><span class="icon icon-link"></span></a>Kubernetes</h2><h3 id="issue-62464"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/05#issue-62464"><span class="icon icon-link"></span></a>issue 62464</h3><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/kubernetes/kubernetes/pull/62464">issue 62464<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>就是读写锁第二种死锁的场景，这是一个典型的reader导致的死锁的例子。知道墨菲定律吧？“凡是可能出错的事，必定会出错”。你可能觉得我前面讲的RWMutex的坑绝对不会被人踩的，因为道理大家都懂，但是你看，Kubernetes就踩了这个重入的坑。</p><p>这个issue在移除pod的时候可能会发生，原因就在于，GetCPUSetOrDefault方法会请求读锁，同时，它还会调用GetCPUSet或GetDefaultCPUSet方法。当这两个方法都请求写锁时，是获取不到的，因为GetCPUSetOrDefault方法还没有执行完，不会释放读锁，这就形成了死锁。</p><p><img src="https://static001.geekbang.org/resource/image/06/c2/062ae5d2a6190f86cb7bf57db643d8c2.png" alt=""/></p><h1 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/05#总结"><span class="icon icon-link"></span></a>总结</h1><p>在开发过程中，一开始考虑共享资源并发访问问题的时候，我们就会想到互斥锁Mutex。因为刚开始的时候，我们还并不太了解并发的情况，所以，就会使用最简单的同步原语来解决问题。等到系统成熟，真正到了需要性能优化的时候，我们就能静下心来分析并发场景的可能性，这个时候，我们就要考虑将Mutex修改为RWMutex，来压榨系统的性能。</p><p>当然，如果一开始你的场景就非常明确了，比如我就要实现一个线程安全的map，那么，一开始你就可以考虑使用读写锁。</p><p>正如我在前面提到的，如果你能意识到你要解决的问题是一个readers-writers问题，那么你就可以毫不犹豫地选择RWMutex，不用考虑其它选择。那在使用RWMutex时，最需要注意的一点就是尽量避免重入，重入带来的死锁非常隐蔽，而且难以诊断。</p><p>另外我们也可以扩展RWMutex，不过实现方法和互斥锁Mutex差不多，在技术上是一样的，都是通过unsafe来实现，我就不再具体讲了。课下你可以参照我们<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/296793">上节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>学习的方法，实现一个扩展的RWMutex。</p><p>这一讲我们系统学习了读写锁的相关知识，这里提供给你一个知识地图，帮助你复习本节课的知识。</p><p><img src="https://static001.geekbang.org/resource/image/69/42/695b9aa6027b5d3a61e92cbcbba10042.jpg" alt=""/></p><h1 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/05#思考题"><span class="icon icon-link"></span></a>思考题</h1><p>请你写一个扩展的读写锁，比如提供TryLock，查询当前是否有writer、reader的数量等方法。</p><p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得有所收获，也欢迎你把今天的内容分享给你的朋友或同事。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/go并发编程实战/02.基本并发原语/05.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:06</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
