<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>09 | map：如何实现线程安全的map类型？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/go并发编程实战/02.基本并发原语/09" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a aria-current="page" class="active" href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a aria-current="page" class="active" href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/go并发编程实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-two/go并发编程实战/01.开篇词/01"><span>开篇词 | 想吃透Go并发编程，你得这样学！</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/go并发编程实战/02.基本并发原语">02.基本并发原语</a><ul><li><a href="/blog-two/go并发编程实战/02.基本并发原语/01"><span>01 | Mutex：如何解决资源并发访问问题？</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/02"><span>02 | Mutex：庖丁解牛看实现</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/03"><span>03｜Mutex：4种易错场景大盘点</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/04"><span>04｜ Mutex：骇客编程，如何拓展额外功能？</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/05"><span>05｜ RWMutex：读写锁的实现原理及避坑指南</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/06"><span>06 | WaitGroup：协同等待，任务编排利器</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/07"><span>07 | Cond：条件变量的实现机制及避坑指南</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/08"><span>08 | Once：一个简约而不简单的并发原语</span></a></li><li><a aria-current="page" class="active" href="/blog-two/go并发编程实战/02.基本并发原语/09"><span>09 | map：如何实现线程安全的map类型？</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/10"><span>10 | Pool：性能提升大杀器</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/11"><span>11 | Context：信息穿透上下文</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/03.原子操作">03.原子操作</a><ul><li><a href="/blog-two/go并发编程实战/03.原子操作/01"><span>12 | atomic：要保证原子操作，一定要使用这几种方法</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/04.channel">04.Channel</a><ul><li><a href="/blog-two/go并发编程实战/04.channel/01"><span>13 | Channel：另辟蹊径，解决并发问题</span></a></li><li><a href="/blog-two/go并发编程实战/04.channel/02"><span>14 | Channel：透过代码看典型的应用模式</span></a></li><li><a href="/blog-two/go并发编程实战/04.channel/03"><span>15 | 内存模型：Go如何保证并发读写的顺序？</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/05.扩展并发原语">05.扩展并发原语</a><ul><li><a href="/blog-two/go并发编程实战/05.扩展并发原语/01"><span>16 | Semaphore：一篇文章搞懂信号量</span></a></li><li><a href="/blog-two/go并发编程实战/05.扩展并发原语/02"><span>17 | SingleFlight 和 CyclicBarrier：请求合并和循环栅栏该怎么用？</span></a></li><li><a href="/blog-two/go并发编程实战/05.扩展并发原语/03"><span>18 | 分组操作：处理一组子任务，该用什么并发原语？</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/06.分布式并发原语">06.分布式并发原语</a><ul><li><a href="/blog-two/go并发编程实战/06.分布式并发原语/01"><span>19 |  在分布式环境中，Leader选举、互斥锁和读写锁该如何实现？</span></a></li><li><a href="/blog-two/go并发编程实战/06.分布式并发原语/02"><span>20 | 在分布式环境中，队列、栅栏和STM该如何实现？</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/07.结束语">07.结束语</a><ul><li><a href="/blog-two/go并发编程实战/07.结束语/01"><span>结束语 | 再聊Go并发编程的价值和精进之路</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/summary">go并发编程实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="map的基本使用方法" data-depth="2"><a href="/blog-two/go并发编程实战/02.基本并发原语/09#map的基本使用方法"><span>map的基本使用方法</span></a></li><li title="使用map的2种常见错误" data-depth="2"><a href="/blog-two/go并发编程实战/02.基本并发原语/09#使用map的2种常见错误"><span>使用map的2种常见错误</span></a></li><li title="常见错误一：未初始化" data-depth="3"><a href="/blog-two/go并发编程实战/02.基本并发原语/09#常见错误一未初始化"><span>常见错误一：未初始化</span></a></li><li title="常见错误二：并发读写" data-depth="3"><a href="/blog-two/go并发编程实战/02.基本并发原语/09#常见错误二并发读写"><span>常见错误二：并发读写</span></a></li><li title="如何实现线程安全的map类型？" data-depth="2"><a href="/blog-two/go并发编程实战/02.基本并发原语/09#如何实现线程安全的map类型"><span>如何实现线程安全的map类型？</span></a></li><li title="加读写锁：扩展map，支持并发读写" data-depth="3"><a href="/blog-two/go并发编程实战/02.基本并发原语/09#加读写锁扩展map支持并发读写"><span>加读写锁：扩展map，支持并发读写</span></a></li><li title="分片加锁：更高效的并发map" data-depth="3"><a href="/blog-two/go并发编程实战/02.基本并发原语/09#分片加锁更高效的并发map"><span>分片加锁：更高效的并发map</span></a></li><li title="应对特殊场景的sync.Map" data-depth="2"><a href="/blog-two/go并发编程实战/02.基本并发原语/09#应对特殊场景的syncmap"><span>应对特殊场景的sync.Map</span></a></li><li title="sync.Map的实现" data-depth="3"><a href="/blog-two/go并发编程实战/02.基本并发原语/09#syncmap的实现"><span>sync.Map的实现</span></a></li><li title="总结" data-depth="2"><a href="/blog-two/go并发编程实战/02.基本并发原语/09#总结"><span>总结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-two/go并发编程实战/02.基本并发原语/09#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="09--map如何实现线程安全的map类型"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/09#09--map如何实现线程安全的map类型"><span class="icon icon-link"></span></a>09 | map：如何实现线程安全的map类型？</h1><p>你好，我是鸟窝。</p><p>哈希表（Hash Table）这个数据结构，我们已经非常熟悉了。它实现的就是key-value之间的映射关系，主要提供的方法包括Add、Lookup、Delete等。因为这种数据结构是一个基础的数据结构，每个key都会有一个唯一的索引值，通过索引可以很快地找到对应的值，所以使用哈希表进行数据的插入和读取都是很快的。Go语言本身就内建了这样一个数据结构，也就是<strong>map数据类型</strong>。</p><p>今天呢，我们就先来学习Go语言内建的这个map类型，了解它的基本使用方法和使用陷阱，然后再学习如何实现线程安全的map类型，最后我还会给你介绍Go标准库中线程安全的sync.Map类型。学完了这节课，你可以学会几种可以并发访问的map类型。</p><h2 id="map的基本使用方法"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/09#map的基本使用方法"><span class="icon icon-link"></span></a>map的基本使用方法</h2><p>Go内建的map类型如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">map[K]V</span></div></pre></div><p>其中，<strong>key类型的K必须是可比较的</strong>（comparable），也就是可以通过 == 和 !=操作符进行比较；value的值和类型无所谓，可以是任意的类型，或者为nil。</p><p>在Go语言中，bool、整数、浮点数、复数、字符串、指针、Channel、接口都是可比较的，包含可比较元素的struct和数组，这俩也是可比较的，而slice、map、函数值都是不可比较的。</p><p>那么，上面这些可比较的数据类型都可以作为map的key吗？显然不是。通常情况下，我们会选择内建的基本类型，比如整数、字符串做key的类型，因为这样最方便。</p><p>这里有一点需要注意，如果使用struct类型做key其实是有坑的，因为如果struct的某个字段值修改了，查询map时无法获取它add进去的值，如下面的例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type mapKey struct {</span></div><div class="token-line"><span class="token plain">        key int</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">        var m = make(map[mapKey]string)</span></div><div class="token-line"><span class="token plain">        var key = mapKey{10}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        m[key] = &quot;hello&quot;</span></div><div class="token-line"><span class="token plain">        fmt.Printf(&quot;m[key]=%s\n&quot;, m[key])</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 修改key的字段的值后再次查询map，无法获取刚才add进去的值</span></div><div class="token-line"><span class="token plain">        key.key = 100</span></div><div class="token-line"><span class="token plain">        fmt.Printf(&quot;再次查询m[key]=%s\n&quot;, m[key])</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>那该怎么办呢？如果要使用struct作为key，我们要保证struct对象在逻辑上是不可变的，这样才会保证map的逻辑没有问题。</p><p>以上就是选取key类型的注意点了。接下来，我们看一下使用map[key]函数时需要注意的一个知识点。<strong>在Go中，map[key]函数返回结果可以是一个值，也可以是两个值</strong>，这是容易让人迷惑的地方。原因在于，如果获取一个不存在的key对应的值时，会返回零值。为了区分真正的零值和key不存在这两种情况，可以根据第二个返回值来区分，如下面的代码的第6行、第7行：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func main() {</span></div><div class="token-line"><span class="token plain">        var m = make(map[string]int)</span></div><div class="token-line"><span class="token plain">        m[&quot;a&quot;] = 0</span></div><div class="token-line"><span class="token plain">        fmt.Printf(&quot;a=%d; b=%d\n&quot;, m[&quot;a&quot;], m[&quot;b&quot;])</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        av, aexisted := m[&quot;a&quot;]</span></div><div class="token-line"><span class="token plain">        bv, bexisted := m[&quot;b&quot;]</span></div><div class="token-line"><span class="token plain">        fmt.Printf(&quot;a=%d, existed: %t; b=%d, existed: %t\n&quot;, av, aexisted, bv, bexisted)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>map是无序的，所以当遍历一个map对象的时候，迭代的元素的顺序是不确定的，无法保证两次遍历的顺序是一样的，也不能保证和插入的顺序一致。那怎么办呢？如果我们想要按照key的顺序获取map的值，需要先取出所有的key进行排序，然后按照这个排序的key依次获取对应的值。而如果我们想要保证元素有序，比如按照元素插入的顺序进行遍历，可以使用辅助的数据结构，比如<a target="_blank" rel="noopener noreferrer" href="https://github.com/elliotchance/orderedmap">orderedmap<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，来记录插入顺序。</p><p>好了，总结下关于map我们需要掌握的内容：map的类型是map[key]，key类型的K必须是可比较的，通常情况下，我们会选择内建的基本类型，比如整数、字符串做key的类型。如果要使用struct作为key，我们要保证struct对象在逻辑上是不可变的。在Go中，map[key]函数返回结果可以是一个值，也可以是两个值。map是无序的，如果我们想要保证遍历map时元素有序，可以使用辅助的数据结构，比如<a target="_blank" rel="noopener noreferrer" href="https://github.com/elliotchance/orderedmap">orderedmap<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><h2 id="使用map的2种常见错误"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/09#使用map的2种常见错误"><span class="icon icon-link"></span></a>使用map的2种常见错误</h2><p>那接下来，我们来看使用map最常犯的两个错误，就是<strong>未初始化</strong>和<strong>并发读写</strong>。</p><h3 id="常见错误一未初始化"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/09#常见错误一未初始化"><span class="icon icon-link"></span></a>常见错误一：未初始化</h3><p>和slice或者Mutex、RWmutex等struct类型不同，map对象必须在使用之前初始化。如果不初始化就直接赋值的话，会出现panic异常，比如下面的例子，m实例还没有初始化就直接进行操作会导致panic（第3行）:</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func main() {</span></div><div class="token-line"><span class="token plain">        var m map[int]int</span></div><div class="token-line"><span class="token plain">        m[100] = 100</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>解决办法就是在第2行初始化这个实例（m := make(map[int]int)）。</p><p>从一个nil的map对象中获取值不会panic，而是会得到零值，所以下面的代码不会报错:</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func main() {</span></div><div class="token-line"><span class="token plain">        var m map[int]int</span></div><div class="token-line"><span class="token plain">        fmt.Println(m[100])</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个例子很简单，我们可以意识到map的初始化问题。但有时候map作为一个struct字段的时候，就很容易忘记初始化了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type Counter struct {</span></div><div class="token-line"><span class="token plain">        Website      string</span></div><div class="token-line"><span class="token plain">        Start        time.Time</span></div><div class="token-line"><span class="token plain">        PageCounters map[string]int</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">        var c Counter</span></div><div class="token-line"><span class="token plain">        c.Website = &quot;baidu.com&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        c.PageCounters[&quot;/&quot;]++</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>所以，关于初始化这一点，我再强调一下，目前还没有工具可以检查，我们只能记住“<strong>别忘记初始化</strong>”这一条规则。</p><h3 id="常见错误二并发读写"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/09#常见错误二并发读写"><span class="icon icon-link"></span></a>常见错误二：并发读写</h3><p>对于map类型，另一个很容易犯的错误就是并发访问问题。这个易错点，相当令人讨厌，如果没有注意到并发问题，程序在运行的时候就有可能出现并发读写导致的panic。</p><p>Go内建的map对象不是线程（goroutine）安全的，并发读写的时候运行时会有检查，遇到并发问题就会导致panic。</p><p>我们一起看一个并发访问map实例导致panic的例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func main() {</span></div><div class="token-line"><span class="token plain">        var m = make(map[int]int,10) // 初始化一个map</span></div><div class="token-line"><span class="token plain">        go func() {</span></div><div class="token-line"><span class="token plain">            for {</span></div><div class="token-line"><span class="token plain">                m[1] = 1 //设置key</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        go func() {</span></div><div class="token-line"><span class="token plain">            for {</span></div><div class="token-line"><span class="token plain">                _ = m[2] //访问这个map</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }()</span></div><div class="token-line"><span class="token plain">        select {}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>虽然这段代码看起来是读写goroutine各自操作不同的元素，貌似map也没有扩容的问题，但是运行时检测到同时对map对象有并发访问，就会直接panic。panic信息会告诉我们代码中哪一行有读写问题，根据这个错误信息你就能快速定位出来是哪一个map对象在哪里出的问题了。</p><p><img src="https://static001.geekbang.org/resource/image/82/62/82fb958bb73128cf8afc438de4acc862.png" alt=""/></p><p>这个错误非常常见，是几乎每个人都会踩到的坑。其实，不只是我们写代码时容易犯这个错，一些知名的项目中也是屡次出现这个问题，比如Docker issue 40772，在删除map对象的元素时忘记了加锁：</p><p><img src="https://static001.geekbang.org/resource/image/60/ce/60642481f9707520045991030d0f00ce.png" alt=""/></p><p>Docker issue 40772，Docker issue 35588、34540、39643等等，也都有并发读写map的问题。</p><p>除了Docker中，Kubernetes的issue 84431、72464、68647、64484、48045、45593、37560等，以及TiDB的issue 14960和17494等，也出现了这个错误。</p><p>这么多人都会踩的坑，有啥解决方案吗？肯定有，那接下来，我们就继续来看如何解决内建map的并发读写问题。</p><h2 id="如何实现线程安全的map类型"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/09#如何实现线程安全的map类型"><span class="icon icon-link"></span></a>如何实现线程安全的map类型？</h2><p>避免map并发读写panic的方式之一就是加锁，考虑到读写性能，可以使用读写锁提供性能。</p><h3 id="加读写锁扩展map支持并发读写"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/09#加读写锁扩展map支持并发读写"><span class="icon icon-link"></span></a>加读写锁：扩展map，支持并发读写</h3><p>比较遗憾的是，目前Go还没有正式发布泛型特性，我们还不能实现一个通用的支持泛型的加锁map。但是，将要发布的泛型方案已经可以验证测试了，离发布也不远了，也许发布之后sync.Map就支持泛型了。</p><p>当然了，如果没有泛型支持，我们也能解决这个问题。我们可以通过interface<!-- -->{<!-- -->}<!-- -->来模拟泛型，但还是要涉及接口和具体类型的转换，比较复杂，还不如将要发布的泛型方案更直接、性能更好。</p><p>这里我以一个具体的map类型为例，来演示利用读写锁实现线程安全的map[int]int类型：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type RWMap struct { // 一个读写锁保护的线程安全的map</span></div><div class="token-line"><span class="token plain">        sync.RWMutex // 读写锁保护下面的map字段</span></div><div class="token-line"><span class="token plain">        m map[int]int</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    // 新建一个RWMap</span></div><div class="token-line"><span class="token plain">    func NewRWMap(n int) *RWMap {</span></div><div class="token-line"><span class="token plain">        return &amp;RWMap{</span></div><div class="token-line"><span class="token plain">            m: make(map[int]int, n),</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    func (m *RWMap) Get(k int) (int, bool) { //从map中读取一个值</span></div><div class="token-line"><span class="token plain">        m.RLock()</span></div><div class="token-line"><span class="token plain">        defer m.RUnlock()</span></div><div class="token-line"><span class="token plain">        v, existed := m.m[k] // 在锁的保护下从map中读取</span></div><div class="token-line"><span class="token plain">        return v, existed</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func (m *RWMap) Set(k int, v int) { // 设置一个键值对</span></div><div class="token-line"><span class="token plain">        m.Lock()              // 锁保护</span></div><div class="token-line"><span class="token plain">        defer m.Unlock()</span></div><div class="token-line"><span class="token plain">        m.m[k] = v</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func (m *RWMap) Delete(k int) { //删除一个键</span></div><div class="token-line"><span class="token plain">        m.Lock()                   // 锁保护</span></div><div class="token-line"><span class="token plain">        defer m.Unlock()</span></div><div class="token-line"><span class="token plain">        delete(m.m, k)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func (m *RWMap) Len() int { // map的长度</span></div><div class="token-line"><span class="token plain">        m.RLock()   // 锁保护</span></div><div class="token-line"><span class="token plain">        defer m.RUnlock()</span></div><div class="token-line"><span class="token plain">        return len(m.m)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func (m *RWMap) Each(f func(k, v int) bool) { // 遍历map</span></div><div class="token-line"><span class="token plain">        m.RLock()             //遍历期间一直持有读锁</span></div><div class="token-line"><span class="token plain">        defer m.RUnlock()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for k, v := range m.m {</span></div><div class="token-line"><span class="token plain">            if !f(k, v) {</span></div><div class="token-line"><span class="token plain">                return</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>正如这段代码所示，对map对象的操作，无非就是增删改查和遍历等几种常见操作。我们可以把这些操作分为读和写两类，其中，查询和遍历可以看做读操作，增加、修改和删除可以看做写操作。如例子所示，我们可以通过读写锁对相应的操作进行保护。</p><h3 id="分片加锁更高效的并发map"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/09#分片加锁更高效的并发map"><span class="icon icon-link"></span></a>分片加锁：更高效的并发map</h3><p>虽然使用读写锁可以提供线程安全的map，但是在大量并发读写的情况下，锁的竞争会非常激烈。我在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/296793">第4讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中提到过，锁是性能下降的万恶之源之一。</p><p>在并发编程中，我们的一条原则就是尽量减少锁的使用。一些单线程单进程的应用（比如Redis等），基本上不需要使用锁去解决并发线程访问的问题，所以可以取得很高的性能。但是对于Go开发的应用程序来说，并发是常用的一个特性，在这种情况下，我们能做的就是，<strong>尽量减少锁的粒度和锁的持有时间</strong>。</p><p>你可以优化业务处理的代码，以此来减少锁的持有时间，比如将串行的操作变成并行的子任务执行。不过，这就是另外的故事了，今天我们还是主要讲对同步原语的优化，所以这里我重点讲如何减少锁的粒度。</p><p><strong>减少锁的粒度常用的方法就是分片</strong>（Shard），将一把锁分成几把锁，每个锁控制一个分片。Go比较知名的分片并发map的实现是<a target="_blank" rel="noopener noreferrer" href="https://github.com/orcaman/concurrent-map">orcaman/concurrent-map<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>它默认采用32个分片，<strong>GetShard是一个关键的方法，能够根据key计算出分片索引</strong>。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var SHARD_COUNT = 32</span></div><div class="token-line"><span class="token plain">    	</span></div><div class="token-line"><span class="token plain">        // 分成SHARD_COUNT个分片的map</span></div><div class="token-line"><span class="token plain">    	type ConcurrentMap []*ConcurrentMapShared</span></div><div class="token-line"><span class="token plain">    	</span></div><div class="token-line"><span class="token plain">    	// 通过RWMutex保护的线程安全的分片，包含一个map</span></div><div class="token-line"><span class="token plain">    	type ConcurrentMapShared struct {</span></div><div class="token-line"><span class="token plain">    		items        map[string]interface{}</span></div><div class="token-line"><span class="token plain">    		sync.RWMutex // Read Write mutex, guards access to internal map.</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	</span></div><div class="token-line"><span class="token plain">    	// 创建并发map</span></div><div class="token-line"><span class="token plain">    	func New() ConcurrentMap {</span></div><div class="token-line"><span class="token plain">    		m := make(ConcurrentMap, SHARD_COUNT)</span></div><div class="token-line"><span class="token plain">    		for i := 0; i &lt; SHARD_COUNT; i++ {</span></div><div class="token-line"><span class="token plain">    			m[i] = &amp;ConcurrentMapShared{items: make(map[string]interface{})}</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    		return m</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// 根据key计算分片索引</span></div><div class="token-line"><span class="token plain">    	func (m ConcurrentMap) GetShard(key string) *ConcurrentMapShared {</span></div><div class="token-line"><span class="token plain">    		return m[uint(fnv32(key))%uint(SHARD_COUNT)]</span></div><div class="token-line"><span class="token plain">    	}</span></div></pre></div><p>增加或者查询的时候，首先根据分片索引得到分片对象，然后对分片对象加锁进行操作：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (m ConcurrentMap) Set(key string, value interface{}) {</span></div><div class="token-line"><span class="token plain">    		// 根据key计算出对应的分片</span></div><div class="token-line"><span class="token plain">    		shard := m.GetShard(key)</span></div><div class="token-line"><span class="token plain">    		shard.Lock() //对这个分片加锁，执行业务操作</span></div><div class="token-line"><span class="token plain">    		shard.items[key] = value</span></div><div class="token-line"><span class="token plain">    		shard.Unlock()</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func (m ConcurrentMap) Get(key string) (interface{}, bool) {</span></div><div class="token-line"><span class="token plain">    		// 根据key计算出对应的分片</span></div><div class="token-line"><span class="token plain">    		shard := m.GetShard(key)</span></div><div class="token-line"><span class="token plain">    		shard.RLock()</span></div><div class="token-line"><span class="token plain">    		// 从这个分片读取key的值</span></div><div class="token-line"><span class="token plain">    		val, ok := shard.items[key]</span></div><div class="token-line"><span class="token plain">    		shard.RUnlock()</span></div><div class="token-line"><span class="token plain">    		return val, ok</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>当然，除了GetShard方法，ConcurrentMap还提供了很多其他的方法。这些方法都是通过计算相应的分片实现的，目的是保证把锁的粒度限制在分片上。</p><p>好了，到这里我们就学会了解决map并发panic的两个方法：加锁和分片。</p><p><strong>在我个人使用并发map的过程中，加锁和分片加锁这两种方案都比较常用，如果是追求更高的性能，显然是分片加锁更好，因为它可以降低锁的粒度，进而提高访问此map对象的吞吐。如果并发性能要求不是那么高的场景，简单加锁方式更简单。</strong></p><p>接下来，我会继续给你介绍sync.Map，这是Go官方线程安全map的标准实现。虽然是官方标准，反而是不常用的，为什么呢？一句话来说就是map要解决的场景很难描述，很多时候在做抉择时根本就不知道该不该用它。但是呢，确实有一些特定的场景，我们需要用到sync.Map来实现，所以还是很有必要学习这个知识点。具体什么场景呢，我慢慢给你道来。</p><h2 id="应对特殊场景的syncmap"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/09#应对特殊场景的syncmap"><span class="icon icon-link"></span></a>应对特殊场景的sync.Map</h2><p>Go内建的map类型不是线程安全的，所以Go 1.9中增加了一个线程安全的map，也就是sync.Map。但是，我们一定要记住，这个sync.Map并不是用来替换内建的map类型的，它只能被应用在一些特殊的场景里。</p><p>那这些特殊的场景是啥呢？<a target="_blank" rel="noopener noreferrer" href="https://golang.org/pkg/sync/#Map">官方的文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中指出，在以下两个场景中使用sync.Map，会比使用map+RWMutex的方式，性能要好得多：</p><ol><li>只会增长的缓存系统中，一个key只写入一次而被读很多次；</li><li>多个goroutine为不相交的键集读、写和重写键值对。</li></ol><p>这两个场景说得都比较笼统，而且，这些场景中还包含了一些特殊的情况。所以，官方建议你针对自己的场景做性能评测，如果确实能够显著提高性能，再使用sync.Map。</p><p>这么来看，我们能用到sync.Map的场景确实不多。即使是sync.Map的作者Bryan C. Mills，也很少使用sync.Map，即便是在使用sync.Map的时候，也是需要临时查询它的API，才能清楚记住它的功能。所以，我们可以把sync.Map看成一个生产环境中很少使用的同步原语。</p><h3 id="syncmap的实现"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/09#syncmap的实现"><span class="icon icon-link"></span></a>sync.Map的实现</h3><p>那sync.Map是怎么实现的呢？它是如何解决并发问题提升性能的呢？其实sync.Map的实现有几个优化点，这里先列出来，我们后面慢慢分析。</p><ul><li>空间换时间。通过冗余的两个数据结构（只读的read字段、可写的dirty），来减少加锁对性能的影响。对只读字段（read）的操作不需要加锁。</li><li>优先从read字段读取、更新、删除，因为对read字段的读取不需要锁。</li><li>动态调整。miss次数多了之后，将dirty数据提升为read，避免总是从dirty中加锁读取。</li><li>double-checking。加锁之后先还要再检查read字段，确定真的不存在才操作dirty字段。</li><li>延迟删除。删除一个键值只是打标记，只有在提升dirty字段为read字段的时候才清理删除的数据。</li></ul><p>要理解sync.Map这些优化点，我们还是得深入到它的设计和实现上，去学习它的处理方式。</p><p>我们先看一下map的数据结构：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type Map struct {</span></div><div class="token-line"><span class="token plain">        mu Mutex</span></div><div class="token-line"><span class="token plain">        // 基本上你可以把它看成一个安全的只读的map</span></div><div class="token-line"><span class="token plain">        // 它包含的元素其实也是通过原子操作更新的，但是已删除的entry就需要加锁操作了</span></div><div class="token-line"><span class="token plain">        read atomic.Value // readOnly</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 包含需要加锁才能访问的元素</span></div><div class="token-line"><span class="token plain">        // 包括所有在read字段中但未被expunged（删除）的元素以及新加的元素</span></div><div class="token-line"><span class="token plain">        dirty map[interface{}]*entry</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 记录从read中读取miss的次数，一旦miss数和dirty长度一样了，就会把dirty提升为read，并把dirty置空</span></div><div class="token-line"><span class="token plain">        misses int</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    type readOnly struct {</span></div><div class="token-line"><span class="token plain">        m       map[interface{}]*entry</span></div><div class="token-line"><span class="token plain">        amended bool // 当dirty中包含read没有的数据时为true，比如新增一条数据</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // expunged是用来标识此项已经删掉的指针</span></div><div class="token-line"><span class="token plain">    // 当map中的一个项目被删除了，只是把它的值标记为expunged，以后才有机会真正删除此项</span></div><div class="token-line"><span class="token plain">    var expunged = unsafe.Pointer(new(interface{}))</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // entry代表一个值</span></div><div class="token-line"><span class="token plain">    type entry struct {</span></div><div class="token-line"><span class="token plain">        p unsafe.Pointer // *interface{}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>如果dirty字段非nil的话，map的read字段和dirty字段会包含相同的非expunged的项，所以如果通过read字段更改了这个项的值，从dirty字段中也会读取到这个项的新值，因为本来它们指向的就是同一个地址。</p><p>dirty包含重复项目的好处就是，一旦miss数达到阈值需要将dirty提升为read的话，只需简单地把dirty设置为read对象即可。不好的一点就是，当创建新的dirty对象的时候，需要逐条遍历read，把非expunged的项复制到dirty对象中。</p><p>接下来，我们就深入到源码去看看sync.map的实现。在看这部分源码的过程中，我们只要重点关注Store、Load和Delete这3个核心的方法就可以了。</p><p>Store、Load和Delete这三个核心函数的操作都是先从read字段中处理的，因为读取read字段的时候不用加锁。</p><h4 id="store方法"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/09#store方法"><span class="icon icon-link"></span></a>Store方法</h4><p>我们先来看Store方法，它是用来设置一个键值对，或者更新一个键值对的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (m *Map) Store(key, value interface{}) {</span></div><div class="token-line"><span class="token plain">        read, _ := m.read.Load().(readOnly)</span></div><div class="token-line"><span class="token plain">        // 如果read字段包含这个项，说明是更新，cas更新项目的值即可</span></div><div class="token-line"><span class="token plain">        if e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) {</span></div><div class="token-line"><span class="token plain">            return</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // read中不存在，或者cas更新失败，就需要加锁访问dirty了</span></div><div class="token-line"><span class="token plain">        m.mu.Lock()</span></div><div class="token-line"><span class="token plain">        read, _ = m.read.Load().(readOnly)</span></div><div class="token-line"><span class="token plain">        if e, ok := read.m[key]; ok { // 双检查，看看read是否已经存在了</span></div><div class="token-line"><span class="token plain">            if e.unexpungeLocked() {</span></div><div class="token-line"><span class="token plain">                // 此项目先前已经被删除了，通过将它的值设置为nil，标记为unexpunged</span></div><div class="token-line"><span class="token plain">                m.dirty[key] = e</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            e.storeLocked(&amp;value) // 更新</span></div><div class="token-line"><span class="token plain">        } else if e, ok := m.dirty[key]; ok { // 如果dirty中有此项</span></div><div class="token-line"><span class="token plain">            e.storeLocked(&amp;value) // 直接更新</span></div><div class="token-line"><span class="token plain">        } else { // 否则就是一个新的key</span></div><div class="token-line"><span class="token plain">            if !read.amended { //如果dirty为nil</span></div><div class="token-line"><span class="token plain">                // 需要创建dirty对象，并且标记read的amended为true,</span></div><div class="token-line"><span class="token plain">                // 说明有元素它不包含而dirty包含</span></div><div class="token-line"><span class="token plain">                m.dirtyLocked()</span></div><div class="token-line"><span class="token plain">                m.read.Store(readOnly{m: read.m, amended: true})</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            m.dirty[key] = newEntry(value) //将新值增加到dirty对象中</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        m.mu.Unlock()</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看出，Store既可以是新增元素，也可以是更新元素。如果运气好的话，更新的是已存在的未被删除的元素，直接更新即可，不会用到锁。如果运气不好，需要更新（重用）删除的对象、更新还未提升的dirty中的对象，或者新增加元素的时候就会使用到了锁，这个时候，性能就会下降。</p><p>所以从这一点来看，sync.Map适合那些只会增长的缓存系统，可以进行更新，但是不要删除，并且不要频繁地增加新元素。</p><p>新加的元素需要放入到dirty中，如果dirty为nil，那么需要从read字段中复制出来一个dirty对象：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (m *Map) dirtyLocked() {</span></div><div class="token-line"><span class="token plain">        if m.dirty != nil { // 如果dirty字段已经存在，不需要创建了</span></div><div class="token-line"><span class="token plain">            return</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        read, _ := m.read.Load().(readOnly) // 获取read字段</span></div><div class="token-line"><span class="token plain">        m.dirty = make(map[interface{}]*entry, len(read.m))</span></div><div class="token-line"><span class="token plain">        for k, e := range read.m { // 遍历read字段</span></div><div class="token-line"><span class="token plain">            if !e.tryExpungeLocked() { // 把非punged的键值对复制到dirty中</span></div><div class="token-line"><span class="token plain">                m.dirty[k] = e</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h4 id="load方法"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/09#load方法"><span class="icon icon-link"></span></a>Load方法</h4><p>Load方法用来读取一个key对应的值。它也是从read开始处理，一开始并不需要锁。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (m *Map) Load(key interface{}) (value interface{}, ok bool) {</span></div><div class="token-line"><span class="token plain">        // 首先从read处理</span></div><div class="token-line"><span class="token plain">        read, _ := m.read.Load().(readOnly)</span></div><div class="token-line"><span class="token plain">        e, ok := read.m[key]</span></div><div class="token-line"><span class="token plain">        if !ok &amp;&amp; read.amended { // 如果不存在并且dirty不为nil(有新的元素)</span></div><div class="token-line"><span class="token plain">            m.mu.Lock()</span></div><div class="token-line"><span class="token plain">            // 双检查，看看read中现在是否存在此key</span></div><div class="token-line"><span class="token plain">            read, _ = m.read.Load().(readOnly)</span></div><div class="token-line"><span class="token plain">            e, ok = read.m[key]</span></div><div class="token-line"><span class="token plain">            if !ok &amp;&amp; read.amended {//依然不存在，并且dirty不为nil</span></div><div class="token-line"><span class="token plain">                e, ok = m.dirty[key]// 从dirty中读取</span></div><div class="token-line"><span class="token plain">                // 不管dirty中存不存在，miss数都加1</span></div><div class="token-line"><span class="token plain">                m.missLocked()</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            m.mu.Unlock()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if !ok {</span></div><div class="token-line"><span class="token plain">            return nil, false</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return e.load() //返回读取的对象，e既可能是从read中获得的，也可能是从dirty中获得的</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>如果幸运的话，我们从read中读取到了这个key对应的值，那么就不需要加锁了，性能会非常好。但是，如果请求的key不存在或者是新加的，就需要加锁从dirty中读取。所以，读取不存在的key会因为加锁而导致性能下降，读取还没有提升的新值的情况下也会因为加锁性能下降。</p><p>其中，missLocked增加miss的时候，如果miss数等于dirty长度，会将dirty提升为read，并将dirty置空。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (m *Map) missLocked() {</span></div><div class="token-line"><span class="token plain">        m.misses++ // misses计数加一</span></div><div class="token-line"><span class="token plain">        if m.misses &lt; len(m.dirty) { // 如果没达到阈值(dirty字段的长度),返回</span></div><div class="token-line"><span class="token plain">            return</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        m.read.Store(readOnly{m: m.dirty}) //把dirty字段的内存提升为read字段</span></div><div class="token-line"><span class="token plain">        m.dirty = nil // 清空dirty</span></div><div class="token-line"><span class="token plain">        m.misses = 0  // misses数重置为0</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h4 id="delete方法"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/09#delete方法"><span class="icon icon-link"></span></a>Delete方法</h4><p>sync.map的第3个核心方法是Delete方法。在Go 1.15中欧长坤提供了一个LoadAndDelete的实现（<a target="_blank" rel="noopener noreferrer" href="https://github.com/golang/go/issues/33762">go#issue 33762<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），所以Delete方法的核心改在了对LoadAndDelete中实现了。</p><p>同样地，Delete方法是先从read操作开始，原因我们已经知道了，因为不需要锁。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (m *Map) LoadAndDelete(key interface{}) (value interface{}, loaded bool) {</span></div><div class="token-line"><span class="token plain">        read, _ := m.read.Load().(readOnly)</span></div><div class="token-line"><span class="token plain">        e, ok := read.m[key]</span></div><div class="token-line"><span class="token plain">        if !ok &amp;&amp; read.amended {</span></div><div class="token-line"><span class="token plain">            m.mu.Lock()</span></div><div class="token-line"><span class="token plain">            // 双检查</span></div><div class="token-line"><span class="token plain">            read, _ = m.read.Load().(readOnly)</span></div><div class="token-line"><span class="token plain">            e, ok = read.m[key]</span></div><div class="token-line"><span class="token plain">            if !ok &amp;&amp; read.amended {</span></div><div class="token-line"><span class="token plain">                e, ok = m.dirty[key]</span></div><div class="token-line"><span class="token plain">                // 这一行长坤在1.15中实现的时候忘记加上了，导致在特殊的场景下有些key总是没有被回收</span></div><div class="token-line"><span class="token plain">                delete(m.dirty, key)</span></div><div class="token-line"><span class="token plain">                // miss数加1</span></div><div class="token-line"><span class="token plain">                m.missLocked()</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            m.mu.Unlock()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if ok {</span></div><div class="token-line"><span class="token plain">            return e.delete()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return nil, false</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func (m *Map) Delete(key interface{}) {</span></div><div class="token-line"><span class="token plain">        m.LoadAndDelete(key)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    func (e *entry) delete() (value interface{}, ok bool) {</span></div><div class="token-line"><span class="token plain">        for {</span></div><div class="token-line"><span class="token plain">            p := atomic.LoadPointer(&amp;e.p)</span></div><div class="token-line"><span class="token plain">            if p == nil || p == expunged {</span></div><div class="token-line"><span class="token plain">                return nil, false</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            if atomic.CompareAndSwapPointer(&amp;e.p, p, nil) {</span></div><div class="token-line"><span class="token plain">                return *(*interface{})(p), true</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>如果read中不存在，那么就需要从dirty中寻找这个项目。最终，如果项目存在就删除（将它的值标记为nil）。如果项目不为nil或者没有被标记为expunged，那么还可以把它的值返回。</p><p>最后，我补充一点，sync.map还有一些LoadAndDelete、LoadOrStore、Range等辅助方法，但是没有Len这样查询sync.Map的包含项目数量的方法，并且官方也不准备提供。如果你想得到sync.Map的项目数量的话，你可能不得不通过Range逐个计数。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/09#总结"><span class="icon icon-link"></span></a>总结</h2><p>Go内置的map类型使用起来很方便，但是它有一个非常致命的缺陷，那就是它存在着并发问题，所以如果有多个goroutine同时并发访问这个map，就会导致程序崩溃。所以Go官方Blog很早就提供了一种加锁的<a target="_blank" rel="noopener noreferrer" href="https://blog.golang.org/maps#TOC_6.">方法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，还有后来提供了适用特定场景的线程安全的sync.Map，还有第三方实现的分片式的map，这些方法都可以应用于并发访问的场景。</p><p>这里我给你的建议，也是Go开发者给的建议，就是通过性能测试，看看某种线程安全的map实现是否满足你的需求。</p><p>当然还有一些扩展其它功能的map实现，比如带有过期功能的<a target="_blank" rel="noopener noreferrer" href="https://github.com/zekroTJA/timedmap">timedmap<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、使用红黑树实现的key有序的<a target="_blank" rel="noopener noreferrer" href="https://godoc.org/github.com/emirpasic/gods/maps/treemap">treemap<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>等，因为和并发问题没有关系，就不详细介绍了。这里我给你提供了链接，你可以自己探索。</p><p><img src="https://static001.geekbang.org/resource/image/a8/03/a80408a137b13f934b0dd6f2b6c5cc03.jpg" alt=""/></p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/02.基本并发原语/09#思考题"><span class="icon icon-link"></span></a>思考题</h2><ol><li><p>为什么sync.Map中的集合核心方法的实现中，如果read中项目不存在，加锁后还要双检查，再检查一次read？</p></li><li><p>你看到sync.map元素删除的时候只是把它的值设置为nil，那么什么时候这个key才会真正从map对象中删除？</p></li></ol><p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得有所收获，也欢迎你把今天的内容分享给你的朋友或同事。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/go并发编程实战/02.基本并发原语/09.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:06</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
