<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>16 | Semaphore：一篇文章搞懂信号量</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/go并发编程实战/05.扩展并发原语/01" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a aria-current="page" class="active" href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a aria-current="page" class="active" href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/go并发编程实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-two/go并发编程实战/01.开篇词/01"><span>开篇词 | 想吃透Go并发编程，你得这样学！</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语">02.基本并发原语</a><ul><li><a href="/blog-two/go并发编程实战/02.基本并发原语/01"><span>01 | Mutex：如何解决资源并发访问问题？</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/02"><span>02 | Mutex：庖丁解牛看实现</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/03"><span>03｜Mutex：4种易错场景大盘点</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/04"><span>04｜ Mutex：骇客编程，如何拓展额外功能？</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/05"><span>05｜ RWMutex：读写锁的实现原理及避坑指南</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/06"><span>06 | WaitGroup：协同等待，任务编排利器</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/07"><span>07 | Cond：条件变量的实现机制及避坑指南</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/08"><span>08 | Once：一个简约而不简单的并发原语</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/09"><span>09 | map：如何实现线程安全的map类型？</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/10"><span>10 | Pool：性能提升大杀器</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/11"><span>11 | Context：信息穿透上下文</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/03.原子操作">03.原子操作</a><ul><li><a href="/blog-two/go并发编程实战/03.原子操作/01"><span>12 | atomic：要保证原子操作，一定要使用这几种方法</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/04.channel">04.Channel</a><ul><li><a href="/blog-two/go并发编程实战/04.channel/01"><span>13 | Channel：另辟蹊径，解决并发问题</span></a></li><li><a href="/blog-two/go并发编程实战/04.channel/02"><span>14 | Channel：透过代码看典型的应用模式</span></a></li><li><a href="/blog-two/go并发编程实战/04.channel/03"><span>15 | 内存模型：Go如何保证并发读写的顺序？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/go并发编程实战/05.扩展并发原语">05.扩展并发原语</a><ul><li><a aria-current="page" class="active" href="/blog-two/go并发编程实战/05.扩展并发原语/01"><span>16 | Semaphore：一篇文章搞懂信号量</span></a></li><li><a href="/blog-two/go并发编程实战/05.扩展并发原语/02"><span>17 | SingleFlight 和 CyclicBarrier：请求合并和循环栅栏该怎么用？</span></a></li><li><a href="/blog-two/go并发编程实战/05.扩展并发原语/03"><span>18 | 分组操作：处理一组子任务，该用什么并发原语？</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/06.分布式并发原语">06.分布式并发原语</a><ul><li><a href="/blog-two/go并发编程实战/06.分布式并发原语/01"><span>19 |  在分布式环境中，Leader选举、互斥锁和读写锁该如何实现？</span></a></li><li><a href="/blog-two/go并发编程实战/06.分布式并发原语/02"><span>20 | 在分布式环境中，队列、栅栏和STM该如何实现？</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/07.结束语">07.结束语</a><ul><li><a href="/blog-two/go并发编程实战/07.结束语/01"><span>结束语 | 再聊Go并发编程的价值和精进之路</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/summary">go并发编程实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="P/V操作" data-depth="2"><a href="/blog-two/go并发编程实战/05.扩展并发原语/01#pv操作"><span>P/V操作</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="16--semaphore一篇文章搞懂信号量"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/05.扩展并发原语/01#16--semaphore一篇文章搞懂信号量"><span class="icon icon-link"></span></a>16 | Semaphore：一篇文章搞懂信号量</h1><p>你好，我是鸟窝。</p><p>在前面的课程里，我们学习了标准库的并发原语、原子操作和Channel，掌握了这些，你就可以解决80%的并发编程问题了。但是，如果你要想进一步提升你的并发编程能力，就需要学习一些第三方库。</p><p>所以，在接下来的几节课里，我会给你分享Go官方或者其他人提供的第三方库，这节课我们先来学习信号量，信号量（Semaphore）是用来控制多个goroutine同时访问多个资源的并发原语。</p><h1 id="信号量是什么都有什么操作"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/05.扩展并发原语/01#信号量是什么都有什么操作"><span class="icon icon-link"></span></a>信号量是什么？都有什么操作？</h1><p>信号量的概念是荷兰计算机科学家Edsger Dijkstra在1963年左右提出来的，广泛应用在不同的操作系统中。在系统中，会给每一个进程一个信号量，代表每个进程目前的状态。未得到控制权的进程，会在特定的地方被迫停下来，等待可以继续进行的信号到来。</p><p>最简单的信号量就是一个变量加一些并发控制的能力，这个变量是0到n之间的一个数值。当goroutine完成对此信号量的等待（wait）时，该计数值就减1，当goroutine完成对此信号量的释放（release）时，该计数值就加1。当计数值为0的时候，goroutine调用wait等待该信号量是不会成功的，除非计数器又大于0，等待的goroutine才有可能成功返回。</p><p>更复杂的信号量类型，就是使用抽象数据类型代替变量，用来代表复杂的资源类型。实际上，大部分的信号量都使用一个整型变量来表示一组资源，并没有实现太复杂的抽象数据类型，所以你只要知道有更复杂的信号量就行了，我们这节课主要是学习最简单的信号量。</p><p>说到这儿呢，我想借助一个生活中的例子，来帮你进一步理解信号量。</p><p>举个例子，图书馆新购买了10本《Go并发编程的独家秘籍》，有1万个学生都想读这本书，“僧多粥少”。所以，图书馆管理员先会让这1万个同学进行登记，按照登记的顺序，借阅此书。如果书全部被借走，那么，其他想看此书的同学就需要等待，如果有人还书了，图书馆管理员就会通知下一位同学来借阅这本书。这里的资源是《Go并发编程的独家秘籍》这十本书，想读此书的同学就是goroutine，图书管理员就是信号量。</p><p>怎么样，现在是不是很好理解了？那么，接下来，我们来学习下信号量的P/V操作。</p><h2 id="pv操作"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/05.扩展并发原语/01#pv操作"><span class="icon icon-link"></span></a>P/V操作</h2><p>Dijkstra在他的论文中为信号量定义了两个操作P和V。P操作（descrease、wait、acquire）是减少信号量的计数值，而V操作（increase、signal、release）是增加信号量的计数值。</p><p>使用伪代码表示如下（中括号代表原子操作）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function V(semaphore S, integer I):</span></div><div class="token-line"><span class="token plain">        [S ← S + I]</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    function P(semaphore S, integer I):</span></div><div class="token-line"><span class="token plain">        repeat:</span></div><div class="token-line"><span class="token plain">            [if S ≥ I:</span></div><div class="token-line"><span class="token plain">            S ← S − I</span></div><div class="token-line"><span class="token plain">            break]</span></div></pre></div><p>可以看到，初始化信号量S有一个指定数量（<strong>n</strong>）的资源，它就像是一个有n个资源的池子。P操作相当于请求资源，如果资源可用，就立即返回；如果没有资源或者不够，那么，它可以不断尝试或者阻塞等待。V操作会释放自己持有的资源，把资源返还给信号量。信号量的值除了初始化的操作以外，只能由P/V操作改变。</p><p>现在，我们来总结下信号量的实现。</p><ul><li>初始化信号量：设定初始的资源的数量。</li><li>P操作：将信号量的计数值减去1，如果新值已经为负，那么调用者会被阻塞并加入到等待队列中。否则，调用者会继续执行，并且获得一个资源。</li><li>V操作：将信号量的计数值加1，如果先前的计数值为负，就说明有等待的P操作的调用者。它会从等待队列中取出一个等待的调用者，唤醒它，让它继续执行。</li></ul><p>讲到这里，我想再稍微说一个题外话，我们在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/295850">第2讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>提到过饥饿，就是说在高并发的极端场景下，会有些goroutine始终抢不到锁。为了处理饥饿的问题，你可以在等待队列中做一些“文章”。比如实现一个优先级的队列，或者先入先出的队列，等等，保持公平性，并且照顾到优先级。</p><p>在正式进入实现信号量的具体实现原理之前，我想先讲一个知识点，就是信号量和互斥锁的区别与联系，这有助于我们掌握接下来的内容。</p><p>其实，信号量可以分为计数信号量（counting semaphore）和二进位信号量（binary semaphore）。刚刚所说的图书馆借书的例子就是一个计数信号量，它的计数可以是任意一个整数。在特殊的情况下，如果计数值只能是0或者1，那么，这个信号量就是二进位信号量，提供了互斥的功能（要么是0，要么是1），所以，有时候互斥锁也会使用二进位信号量来实现。</p><p>我们一般用信号量保护一组资源，比如数据库连接池、一组客户端的连接、几个打印机资源，等等。如果信号量蜕变成二进位信号量，那么，它的P/V就和互斥锁的Lock/Unlock一样了。</p><p>有人会很细致地区分二进位信号量和互斥锁。比如说，有人提出，在Windows系统中，互斥锁只能由持有锁的线程释放锁，而二进位信号量则没有这个限制（<a target="_blank" rel="noopener noreferrer" href="https://stackoverflow.com/questions/62814/difference-between-binary-semaphore-and-mutex">Stack Overflow<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>上也有相关的讨论）。实际上，虽然在Windows系统中，它们的确有些区别，但是对Go语言来说，互斥锁也可以由非持有的goroutine来释放，所以，从行为上来说，它们并没有严格的区别。</p><p>我个人认为，没必要进行细致的区分，因为互斥锁并不是一个很严格的定义。实际在遇到互斥并发的问题时，我们一般选用互斥锁。</p><p>好了，言归正传，刚刚我们掌握了信号量的含义和具体操作方式，下面，我们就来具体了解下官方扩展库的实现。</p><h1 id="go官方扩展库的实现"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/05.扩展并发原语/01#go官方扩展库的实现"><span class="icon icon-link"></span></a>Go官方扩展库的实现</h1><p>在运行时，Go内部使用信号量来控制goroutine的阻塞和唤醒。我们在学习基本并发原语的实现时也看到了，比如互斥锁的第二个字段：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type Mutex struct {</span></div><div class="token-line"><span class="token plain">    		state int32</span></div><div class="token-line"><span class="token plain">    		sema  uint32</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>信号量的P/V操作是通过函数实现的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func runtime_Semacquire(s *uint32)</span></div><div class="token-line"><span class="token plain">    func runtime_SemacquireMutex(s *uint32, lifo bool, skipframes int)</span></div><div class="token-line"><span class="token plain">    func runtime_Semrelease(s *uint32, handoff bool, skipframes int)</span></div></pre></div><p>遗憾的是，它是Go运行时内部使用的，并没有封装暴露成一个对外的信号量并发原语，原则上我们没有办法使用。不过没关系，Go在它的扩展包中提供了信号量<a target="_blank" rel="noopener noreferrer" href="https://godoc.org/golang.org/x/sync/semaphore">semaphore<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，不过这个信号量的类型名并不叫Semaphore，而是叫Weighted。</p><p>之所以叫做Weighted，我想，应该是因为可以在初始化创建这个信号量的时候设置权重（初始化的资源数），其实我觉得叫Semaphore或许会更好。</p><p><img src="https://static001.geekbang.org/resource/image/1a/b0/1a13a551346cd6b910f38f5ed2bfc6b0.png?wh=702*174" alt=""/></p><p>我们来分析下这个信号量的几个实现方法。</p><ol><li><strong>Acquire方法</strong>：相当于P操作，你可以一次获取多个资源，如果没有足够多的资源，调用者就会被阻塞。它的第一个参数是Context，这就意味着，你可以通过Context增加超时或者cancel的机制。如果是正常获取了资源，就返回nil；否则，就返回ctx.Err()，信号量不改变。</li><li><strong>Release方法</strong>：相当于V操作，可以将n个资源释放，返还给信号量。</li><li><strong>TryAcquire方法</strong>：尝试获取n个资源，但是它不会阻塞，要么成功获取n个资源，返回true，要么一个也不获取，返回false。</li></ol><p>知道了信号量的实现方法，在实际的场景中，我们应该怎么用呢？我来举个Worker Pool的例子，来帮助你理解。</p><p>我们创建和CPU核数一样多的Worker，让它们去处理一个4倍数量的整数slice。每个Worker一次只能处理一个整数，处理完之后，才能处理下一个。</p><p>当然，这个问题的解决方案有很多种，这一次我们使用信号量，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var (</span></div><div class="token-line"><span class="token plain">        maxWorkers = runtime.GOMAXPROCS(0)                    // worker数量</span></div><div class="token-line"><span class="token plain">        sema       = semaphore.NewWeighted(int64(maxWorkers)) //信号量</span></div><div class="token-line"><span class="token plain">        task       = make([]int, maxWorkers*4)                // 任务数，是worker的四倍</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">        ctx := context.Background()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for i := range task {</span></div><div class="token-line"><span class="token plain">            // 如果没有worker可用，会阻塞在这里，直到某个worker被释放</span></div><div class="token-line"><span class="token plain">            if err := sema.Acquire(ctx, 1); err != nil {</span></div><div class="token-line"><span class="token plain">                break</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 启动worker goroutine</span></div><div class="token-line"><span class="token plain">            go func(i int) {</span></div><div class="token-line"><span class="token plain">                defer sema.Release(1)</span></div><div class="token-line"><span class="token plain">                time.Sleep(100 * time.Millisecond) // 模拟一个耗时操作</span></div><div class="token-line"><span class="token plain">                task[i] = i + 1</span></div><div class="token-line"><span class="token plain">            }(i)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 请求所有的worker,这样能确保前面的worker都执行完</span></div><div class="token-line"><span class="token plain">        if err := sema.Acquire(ctx, int64(maxWorkers)); err != nil {</span></div><div class="token-line"><span class="token plain">            log.Printf(&quot;获取所有的worker失败: %v&quot;, err)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        fmt.Println(task)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这段代码中，main goroutine相当于一个dispatcher，负责任务的分发。它先请求信号量，如果获取成功，就会启动一个goroutine去处理计算，然后，这个goroutine会释放这个信号量（有意思的是，信号量的获取是在main goroutine，信号量的释放是在worker goroutine中），如果获取不成功，就等到有信号量可以使用的时候，再去获取。</p><p>需要提醒你的是，其实，在这个例子中，还有一个值得我们学习的知识点，就是最后的那一段处理（第25行）。<strong>如果在实际应用中，你想等所有的Worker都执行完，就可以获取最大计数值的信号量</strong>。</p><p>Go扩展库中的信号量是使用互斥锁+List实现的。互斥锁实现其它字段的保护，而List实现了一个等待队列，等待者的通知是通过Channel的通知机制实现的。</p><p>我们来看一下信号量Weighted的数据结构：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type Weighted struct {</span></div><div class="token-line"><span class="token plain">    		size    int64         // 最大资源数</span></div><div class="token-line"><span class="token plain">    		cur     int64         // 当前已被使用的资源</span></div><div class="token-line"><span class="token plain">    		mu      sync.Mutex    // 互斥锁，对字段的保护</span></div><div class="token-line"><span class="token plain">    		waiters list.List     // 等待队列</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在信号量的几个实现方法里，Acquire是代码最复杂的一个方法，它不仅仅要监控资源是否可用，而且还要检测Context的Done是否已关闭。我们来看下它的实现代码。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (s *Weighted) Acquire(ctx context.Context, n int64) error {</span></div><div class="token-line"><span class="token plain">    		s.mu.Lock()</span></div><div class="token-line"><span class="token plain">            // fast path, 如果有足够的资源，都不考虑ctx.Done的状态，将cur加上n就返回</span></div><div class="token-line"><span class="token plain">    		if s.size-s.cur &gt;= n &amp;&amp; s.waiters.Len() == 0 {</span></div><div class="token-line"><span class="token plain">    			s.cur += n</span></div><div class="token-line"><span class="token plain">    			s.mu.Unlock()</span></div><div class="token-line"><span class="token plain">    			return nil</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    	</span></div><div class="token-line"><span class="token plain">            // 如果是不可能完成的任务，请求的资源数大于能提供的最大的资源数</span></div><div class="token-line"><span class="token plain">    		if n &gt; s.size {</span></div><div class="token-line"><span class="token plain">    			s.mu.Unlock()</span></div><div class="token-line"><span class="token plain">                // 依赖ctx的状态返回，否则一直等待</span></div><div class="token-line"><span class="token plain">    			&lt;-ctx.Done()</span></div><div class="token-line"><span class="token plain">    			return ctx.Err()</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    	</span></div><div class="token-line"><span class="token plain">            // 否则就需要把调用者加入到等待队列中</span></div><div class="token-line"><span class="token plain">            // 创建了一个ready chan,以便被通知唤醒</span></div><div class="token-line"><span class="token plain">    		ready := make(chan struct{})</span></div><div class="token-line"><span class="token plain">    		w := waiter{n: n, ready: ready}</span></div><div class="token-line"><span class="token plain">    		elem := s.waiters.PushBack(w)</span></div><div class="token-line"><span class="token plain">    		s.mu.Unlock()</span></div><div class="token-line"><span class="token plain">    	</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 等待</span></div><div class="token-line"><span class="token plain">    		select {</span></div><div class="token-line"><span class="token plain">    		case &lt;-ctx.Done(): // context的Done被关闭</span></div><div class="token-line"><span class="token plain">    			err := ctx.Err()</span></div><div class="token-line"><span class="token plain">    			s.mu.Lock()</span></div><div class="token-line"><span class="token plain">    			select {</span></div><div class="token-line"><span class="token plain">    			case &lt;-ready: // 如果被唤醒了，忽略ctx的状态</span></div><div class="token-line"><span class="token plain">    				err = nil</span></div><div class="token-line"><span class="token plain">    			default: 通知waiter</span></div><div class="token-line"><span class="token plain">    				isFront := s.waiters.Front() == elem</span></div><div class="token-line"><span class="token plain">    				s.waiters.Remove(elem)</span></div><div class="token-line"><span class="token plain">    				// 通知其它的waiters,检查是否有足够的资源</span></div><div class="token-line"><span class="token plain">    				if isFront &amp;&amp; s.size &gt; s.cur {</span></div><div class="token-line"><span class="token plain">    					s.notifyWaiters()</span></div><div class="token-line"><span class="token plain">    				}</span></div><div class="token-line"><span class="token plain">    			}</span></div><div class="token-line"><span class="token plain">    			s.mu.Unlock()</span></div><div class="token-line"><span class="token plain">    			return err</span></div><div class="token-line"><span class="token plain">    		case &lt;-ready: // 被唤醒了</span></div><div class="token-line"><span class="token plain">    			return nil</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    	}</span></div></pre></div><p>其实，为了提高性能，这个方法中的fast path之外的代码，可以抽取成acquireSlow方法，以便其它Acquire被内联。</p><p>Release方法将当前计数值减去释放的资源数n，并唤醒等待队列中的调用者，看是否有足够的资源被获取。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (s *Weighted) Release(n int64) {</span></div><div class="token-line"><span class="token plain">    		s.mu.Lock()</span></div><div class="token-line"><span class="token plain">    		s.cur -= n</span></div><div class="token-line"><span class="token plain">    		if s.cur &lt; 0 {</span></div><div class="token-line"><span class="token plain">    			s.mu.Unlock()</span></div><div class="token-line"><span class="token plain">    			panic(&quot;semaphore: released more than held&quot;)</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    		s.notifyWaiters()</span></div><div class="token-line"><span class="token plain">    		s.mu.Unlock()</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>notifyWaiters方法就是逐个检查等待的调用者，如果资源不够，或者是没有等待者了，就返回：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (s *Weighted) notifyWaiters() {</span></div><div class="token-line"><span class="token plain">    		for {</span></div><div class="token-line"><span class="token plain">    			next := s.waiters.Front()</span></div><div class="token-line"><span class="token plain">    			if next == nil {</span></div><div class="token-line"><span class="token plain">    				break // No more waiters blocked.</span></div><div class="token-line"><span class="token plain">    			}</span></div><div class="token-line"><span class="token plain">    	</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    			w := next.Value.(waiter)</span></div><div class="token-line"><span class="token plain">    			if s.size-s.cur &lt; w.n {</span></div><div class="token-line"><span class="token plain">    				//避免饥饿，这里还是按照先入先出的方式处理</span></div><div class="token-line"><span class="token plain">    				break</span></div><div class="token-line"><span class="token plain">    			}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    			s.cur += w.n</span></div><div class="token-line"><span class="token plain">    			s.waiters.Remove(next)</span></div><div class="token-line"><span class="token plain">    			close(w.ready)</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    	}</span></div></pre></div><p>notifyWaiters方法是按照先入先出的方式唤醒调用者。当释放100个资源的时候，如果第一个等待者需要101个资源，那么，队列中的所有等待者都会继续等待，即使有的等待者只需要1个资源。这样做的目的是避免饥饿，否则的话，资源可能总是被那些请求资源数小的调用者获取，这样一来，请求资源数巨大的调用者，就没有机会获得资源了。</p><p>好了，到这里，你就知道了官方扩展库的信号量实现方法，接下来你就可以使用信号量了。不过，在此之前呢，我想给你讲几个使用时的常见错误。这部分内容可是帮助你避坑的，我建议你好好学习。</p><h1 id="使用信号量的常见错误"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/05.扩展并发原语/01#使用信号量的常见错误"><span class="icon icon-link"></span></a>使用信号量的常见错误</h1><p>保证信号量不出错的前提是正确地使用它，否则，公平性和安全性就会受到损害，导致程序panic。</p><p>在使用信号量时，最常见的几个错误如下：</p><ul><li>请求了资源，但是忘记释放它；</li><li>释放了从未请求的资源；</li><li>长时间持有一个资源，即使不需要它；</li><li>不持有一个资源，却直接使用它。</li></ul><p>不过，即使你规避了这些坑，在同时使用多种资源，不同的信号量控制不同的资源的时候，也可能会出现死锁现象，比如<a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Dining_philosophers_problem">哲学家就餐问题<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>就Go扩展库实现的信号量来说，在调用Release方法的时候，你可以传递任意的整数。但是，如果你传递一个比请求到的数量大的错误的数值，程序就会panic。如果传递一个负数，会导致资源永久被持有。如果你请求的资源数比最大的资源数还大，那么，调用者可能永远被阻塞。</p><p>所以，<strong>使用信号量遵循的原则就是请求多少资源，就释放多少资源</strong>。你一定要注意，必须使用正确的方法传递整数，不要“耍小聪明”，而且，请求的资源数一定不要超过最大资源数。</p><h1 id="其它信号量的实现"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/05.扩展并发原语/01#其它信号量的实现"><span class="icon icon-link"></span></a>其它信号量的实现</h1><p>除了官方扩展库的实现，实际上，我们还有很多方法实现信号量，比较典型的就是使用Channel来实现。</p><p>根据之前的Channel类型的介绍以及Go内存模型的定义，你应该能想到，使用一个buffer为n的Channel很容易实现信号量，比如下面的代码，我们就是使用chan struct<!-- -->{<!-- -->}<!-- -->类型来实现的。</p><p>在初始化这个信号量的时候，我们设置它的初始容量，代表有多少个资源可以使用。它使用Lock和Unlock方法实现请求资源和释放资源，正好实现了Locker接口。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Semaphore 数据结构，并且还实现了Locker接口</span></div><div class="token-line"><span class="token plain">    	type semaphore struct {</span></div><div class="token-line"><span class="token plain">    		sync.Locker</span></div><div class="token-line"><span class="token plain">    		ch chan struct{}</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	</span></div><div class="token-line"><span class="token plain">    	// 创建一个新的信号量</span></div><div class="token-line"><span class="token plain">    	func NewSemaphore(capacity int) sync.Locker {</span></div><div class="token-line"><span class="token plain">    		if capacity &lt;= 0 {</span></div><div class="token-line"><span class="token plain">    			capacity = 1 // 容量为1就变成了一个互斥锁</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    		return &amp;semaphore{ch: make(chan struct{}, capacity)}</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	</span></div><div class="token-line"><span class="token plain">    	// 请求一个资源</span></div><div class="token-line"><span class="token plain">    	func (s *semaphore) Lock() {</span></div><div class="token-line"><span class="token plain">    		s.ch &lt;- struct{}{}</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	</span></div><div class="token-line"><span class="token plain">    	// 释放资源</span></div><div class="token-line"><span class="token plain">    	func (s *semaphore) Unlock() {</span></div><div class="token-line"><span class="token plain">    		&lt;-s.ch</span></div><div class="token-line"><span class="token plain">    	}</span></div></pre></div><p>当然，你还可以自己扩展一些方法，比如在请求资源的时候使用Context参数（Acquire(ctx)）、实现TryLock等功能。</p><p>看到这里，你可能会问，这个信号量的实现看起来非常简单，而且也能应对大部分的信号量的场景，为什么官方扩展库的信号量的实现不采用这种方法呢？其实，具体是什么原因，我也不知道，但是我必须要强调的是，官方的实现方式有这样一个功能：<strong>它可以一次请求多个资源，这是通过Channel实现的信号量所不具备的</strong>。</p><p>除了Channel，<a target="_blank" rel="noopener noreferrer" href="https://github.com/marusama/semaphore">marusama/semaphore<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>也实现了一个可以动态更改资源容量的信号量，也是一个非常有特色的实现。如果你的资源数量并不是固定的，而是动态变化的，我建议你考虑一下这个信号量库。</p><h1 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/05.扩展并发原语/01#总结"><span class="icon icon-link"></span></a>总结</h1><p>这是一个很奇怪的现象：标准库中实现基本并发原语（比如Mutex）的时候，强烈依赖信号量实现等待队列和通知唤醒，但是，标准库中却没有把这个实现直接暴露出来放到标准库，而是通过第三库提供。</p><p>不管怎样，信号量这个并发原语在多资源共享的并发控制的场景中被广泛使用，有时候也会被Channel类型所取代，因为一个buffered chan也可以代表n个资源。</p><p>但是，官方扩展的信号量也有它的优势，就是可以一次获取多个资源。<strong>在批量获取资源的场景中，我建议你尝试使用官方扩展的信号量</strong>。</p><p><img src="https://static001.geekbang.org/resource/image/67/73/674bc464d4e3d11c96fa1ac71d317e73.jpg?wh=2250*1413" alt=""/></p><h1 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/05.扩展并发原语/01#思考题"><span class="icon icon-link"></span></a>思考题</h1><ol><li>你能用Channel实现信号量并发原语吗？你能想到几种实现方式？</li><li>为什么信号量的资源数设计成int64而不是uint64呢？</li></ol><p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得有所收获，也欢迎你把今天的内容分享给你的朋友或同事。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/go并发编程实战/05.扩展并发原语/01.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:07</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
