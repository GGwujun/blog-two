<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>18 | 分组操作：处理一组子任务，该用什么并发原语？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/go并发编程实战/05.扩展并发原语/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a aria-current="page" class="active" href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a aria-current="page" class="active" href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/go并发编程实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-two/go并发编程实战/01.开篇词/01"><span>开篇词 | 想吃透Go并发编程，你得这样学！</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语">02.基本并发原语</a><ul><li><a href="/blog-two/go并发编程实战/02.基本并发原语/01"><span>01 | Mutex：如何解决资源并发访问问题？</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/02"><span>02 | Mutex：庖丁解牛看实现</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/03"><span>03｜Mutex：4种易错场景大盘点</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/04"><span>04｜ Mutex：骇客编程，如何拓展额外功能？</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/05"><span>05｜ RWMutex：读写锁的实现原理及避坑指南</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/06"><span>06 | WaitGroup：协同等待，任务编排利器</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/07"><span>07 | Cond：条件变量的实现机制及避坑指南</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/08"><span>08 | Once：一个简约而不简单的并发原语</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/09"><span>09 | map：如何实现线程安全的map类型？</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/10"><span>10 | Pool：性能提升大杀器</span></a></li><li><a href="/blog-two/go并发编程实战/02.基本并发原语/11"><span>11 | Context：信息穿透上下文</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/03.原子操作">03.原子操作</a><ul><li><a href="/blog-two/go并发编程实战/03.原子操作/01"><span>12 | atomic：要保证原子操作，一定要使用这几种方法</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/04.channel">04.Channel</a><ul><li><a href="/blog-two/go并发编程实战/04.channel/01"><span>13 | Channel：另辟蹊径，解决并发问题</span></a></li><li><a href="/blog-two/go并发编程实战/04.channel/02"><span>14 | Channel：透过代码看典型的应用模式</span></a></li><li><a href="/blog-two/go并发编程实战/04.channel/03"><span>15 | 内存模型：Go如何保证并发读写的顺序？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/go并发编程实战/05.扩展并发原语">05.扩展并发原语</a><ul><li><a href="/blog-two/go并发编程实战/05.扩展并发原语/01"><span>16 | Semaphore：一篇文章搞懂信号量</span></a></li><li><a href="/blog-two/go并发编程实战/05.扩展并发原语/02"><span>17 | SingleFlight 和 CyclicBarrier：请求合并和循环栅栏该怎么用？</span></a></li><li><a aria-current="page" class="active" href="/blog-two/go并发编程实战/05.扩展并发原语/03"><span>18 | 分组操作：处理一组子任务，该用什么并发原语？</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/06.分布式并发原语">06.分布式并发原语</a><ul><li><a href="/blog-two/go并发编程实战/06.分布式并发原语/01"><span>19 |  在分布式环境中，Leader选举、互斥锁和读写锁该如何实现？</span></a></li><li><a href="/blog-two/go并发编程实战/06.分布式并发原语/02"><span>20 | 在分布式环境中，队列、栅栏和STM该如何实现？</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/07.结束语">07.结束语</a><ul><li><a href="/blog-two/go并发编程实战/07.结束语/01"><span>结束语 | 再聊Go并发编程的价值和精进之路</span></a></li></ul></li><li><a href="/blog-two/go并发编程实战/summary">go并发编程实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="基本用法" data-depth="2"><a href="/blog-two/go并发编程实战/05.扩展并发原语/03#基本用法"><span>基本用法</span></a></li><li title="ErrGroup使用例子" data-depth="2"><a href="/blog-two/go并发编程实战/05.扩展并发原语/03#errgroup使用例子"><span>ErrGroup使用例子</span></a></li><li title="简单例子：返回第一个错误" data-depth="3"><a href="/blog-two/go并发编程实战/05.扩展并发原语/03#简单例子返回第一个错误"><span>简单例子：返回第一个错误</span></a></li><li title="更进一步，返回所有子任务的错误" data-depth="3"><a href="/blog-two/go并发编程实战/05.扩展并发原语/03#更进一步返回所有子任务的错误"><span>更进一步，返回所有子任务的错误</span></a></li><li title="任务执行流水线Pipeline" data-depth="3"><a href="/blog-two/go并发编程实战/05.扩展并发原语/03#任务执行流水线pipeline"><span>任务执行流水线Pipeline</span></a></li><li title="扩展库" data-depth="2"><a href="/blog-two/go并发编程实战/05.扩展并发原语/03#扩展库"><span>扩展库</span></a></li><li title="bilibili/errgroup" data-depth="3"><a href="/blog-two/go并发编程实战/05.扩展并发原语/03#bilibilierrgroup"><span>bilibili/errgroup</span></a></li><li title="neilotoole/errgroup" data-depth="3"><a href="/blog-two/go并发编程实战/05.扩展并发原语/03#neilotooleerrgroup"><span>neilotoole/errgroup</span></a></li><li title="facebookgo/errgroup" data-depth="3"><a href="/blog-two/go并发编程实战/05.扩展并发原语/03#facebookgoerrgroup"><span>facebookgo/errgroup</span></a></li><li title="其它实用的Group并发原语" data-depth="2"><a href="/blog-two/go并发编程实战/05.扩展并发原语/03#其它实用的group并发原语"><span>其它实用的Group并发原语</span></a></li><li title="SizedGroup/ErrSizedGroup" data-depth="3"><a href="/blog-two/go并发编程实战/05.扩展并发原语/03#sizedgrouperrsizedgroup"><span>SizedGroup/ErrSizedGroup</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="18--分组操作处理一组子任务该用什么并发原语"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/05.扩展并发原语/03#18--分组操作处理一组子任务该用什么并发原语"><span class="icon icon-link"></span></a>18 | 分组操作：处理一组子任务，该用什么并发原语？</h1><p>你好，我是鸟窝。</p><p>共享资源保护、任务编排和消息传递是Go并发编程中常见的场景，而<strong>分组执行一批相同的或类似的任务则是任务编排中一类情形</strong>，所以，这节课，我专门来介绍一下分组编排的一些常用场景和并发原语，包括ErrGroup、gollback、Hunch和schedgroup。</p><p>我们先来学习一类非常常用的并发原语，那就是ErrGroup。</p><h1 id="errgroup"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/05.扩展并发原语/03#errgroup"><span class="icon icon-link"></span></a>ErrGroup</h1><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/golang/sync/tree/master/errgroup">ErrGroup<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>是Go官方提供的一个同步扩展库。我们经常会碰到需要将一个通用的父任务拆成几个小任务并发执行的场景，其实，将一个大的任务拆成几个小任务并发执行，可以有效地提高程序的并发度。就像你在厨房做饭一样，你可以在蒸米饭的同时炒几个小菜，米饭蒸好了，菜同时也做好了，很快就能吃到可口的饭菜。</p><p>ErrGroup就是用来应对这种场景的。它和WaitGroup有些类似，但是它提供功能更加丰富：</p><ul><li>和Context集成；</li><li>error向上传播，可以把子任务的错误传递给Wait的调用者。</li></ul><p>接下来，我来给你介绍一下ErrGroup的基本用法和几种应用场景。</p><h2 id="基本用法"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/05.扩展并发原语/03#基本用法"><span class="icon icon-link"></span></a>基本用法</h2><p>golang.org/x/sync/errgroup包下定义了一个Group struct，它就是我们要介绍的ErrGroup并发原语，底层也是基于WaitGroup实现的。</p><p>在使用ErrGroup时，我们要用到三个方法，分别是WithContext、Go和Wait。</p><p><strong>1.WithContext</strong></p><p>在创建一个Group对象时，需要使用WithContext方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func WithContext(ctx context.Context) (*Group, context.Context)</span></div></pre></div><p>这个方法返回一个Group实例，同时还会返回一个使用context.WithCancel(ctx)生成的新Context。一旦有一个子任务返回错误，或者是Wait调用返回，这个新Context就会被cancel。</p><p>Group的零值也是合法的，只不过，你就没有一个可以监控是否cancel的Context了。</p><p>注意，如果传递给WithContext的ctx参数，是一个可以cancel的Context的话，那么，它被cancel的时候，并不会终止正在执行的子任务。</p><p><strong>2.Go</strong></p><p>我们再来学习下执行子任务的Go方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (g *Group) Go(f func() error)</span></div></pre></div><p>传入的子任务函数f是类型为func() error的函数，如果任务执行成功，就返回nil，否则就返回error，并且会cancel 那个新的Context。</p><p>一个任务可以分成好多个子任务，而且，可能有多个子任务执行失败返回error，不过，Wait方法只会返回第一个错误，所以，如果想返回所有的错误，需要特别的处理，我先留个小悬念，一会儿再讲。</p><p><strong>3.Wait</strong></p><p>类似WaitGroup，Group也有Wait方法，等所有的子任务都完成后，它才会返回，否则只会阻塞等待。如果有多个子任务返回错误，它只会返回第一个出现的错误，如果所有的子任务都执行成功，就返回nil：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func (g *Group) Wait() error</span></div></pre></div><h2 id="errgroup使用例子"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/05.扩展并发原语/03#errgroup使用例子"><span class="icon icon-link"></span></a>ErrGroup使用例子</h2><p>好了，知道了基本用法，下面我来给你介绍几个例子，帮助你全面地掌握ErrGroup的使用方法和应用场景。</p><h3 id="简单例子返回第一个错误"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/05.扩展并发原语/03#简单例子返回第一个错误"><span class="icon icon-link"></span></a>简单例子：返回第一个错误</h3><p>先来看一个简单的例子。在这个例子中，启动了三个子任务，其中，子任务2会返回执行失败，其它两个执行成功。在三个子任务都执行后，group.Wait才会返回第2个子任务的错误。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package main</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import (</span></div><div class="token-line"><span class="token plain">        &quot;errors&quot;</span></div><div class="token-line"><span class="token plain">        &quot;fmt&quot;</span></div><div class="token-line"><span class="token plain">        &quot;time&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        &quot;golang.org/x/sync/errgroup&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">        var g errgroup.Group</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 启动第一个子任务,它执行成功</span></div><div class="token-line"><span class="token plain">        g.Go(func() error {</span></div><div class="token-line"><span class="token plain">            time.Sleep(5 * time.Second)</span></div><div class="token-line"><span class="token plain">            fmt.Println(&quot;exec #1&quot;)</span></div><div class="token-line"><span class="token plain">            return nil</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">        // 启动第二个子任务，它执行失败</span></div><div class="token-line"><span class="token plain">        g.Go(func() error {</span></div><div class="token-line"><span class="token plain">            time.Sleep(10 * time.Second)</span></div><div class="token-line"><span class="token plain">            fmt.Println(&quot;exec #2&quot;)</span></div><div class="token-line"><span class="token plain">            return errors.New(&quot;failed to exec #2&quot;)</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 启动第三个子任务，它执行成功</span></div><div class="token-line"><span class="token plain">        g.Go(func() error {</span></div><div class="token-line"><span class="token plain">            time.Sleep(15 * time.Second)</span></div><div class="token-line"><span class="token plain">            fmt.Println(&quot;exec #3&quot;)</span></div><div class="token-line"><span class="token plain">            return nil</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">        // 等待三个任务都完成</span></div><div class="token-line"><span class="token plain">        if err := g.Wait(); err == nil {</span></div><div class="token-line"><span class="token plain">            fmt.Println(&quot;Successfully exec all&quot;)</span></div><div class="token-line"><span class="token plain">        } else {</span></div><div class="token-line"><span class="token plain">            fmt.Println(&quot;failed:&quot;, err)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>如果执行下面的这个程序，会显示三个任务都执行了，而Wait返回了子任务2的错误：</p><p><img src="https://static001.geekbang.org/resource/image/92/11/92d746f7a1ab943e73b83796fb436a11.png" alt=""/></p><h3 id="更进一步返回所有子任务的错误"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/05.扩展并发原语/03#更进一步返回所有子任务的错误"><span class="icon icon-link"></span></a>更进一步，返回所有子任务的错误</h3><p>Group只能返回子任务的第一个错误，后续的错误都会被丢弃。但是，有时候我们需要知道每个任务的执行情况。怎么办呢？这个时候，我们就可以用稍微有点曲折的方式去实现。我们使用一个result slice保存子任务的执行结果，这样，通过查询result，就可以知道每一个子任务的结果了。</p><p>下面的这个例子，就是使用result记录每个子任务成功或失败的结果。其实，你不仅可以使用result记录error信息，还可以用它记录计算结果。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package main</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import (</span></div><div class="token-line"><span class="token plain">        &quot;errors&quot;</span></div><div class="token-line"><span class="token plain">        &quot;fmt&quot;</span></div><div class="token-line"><span class="token plain">        &quot;time&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        &quot;golang.org/x/sync/errgroup&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">        var g errgroup.Group</span></div><div class="token-line"><span class="token plain">        var result = make([]error, 3)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 启动第一个子任务,它执行成功</span></div><div class="token-line"><span class="token plain">        g.Go(func() error {</span></div><div class="token-line"><span class="token plain">            time.Sleep(5 * time.Second)</span></div><div class="token-line"><span class="token plain">            fmt.Println(&quot;exec #1&quot;)</span></div><div class="token-line"><span class="token plain">            result[0] = nil // 保存成功或者失败的结果</span></div><div class="token-line"><span class="token plain">            return nil</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 启动第二个子任务，它执行失败</span></div><div class="token-line"><span class="token plain">        g.Go(func() error {</span></div><div class="token-line"><span class="token plain">            time.Sleep(10 * time.Second)</span></div><div class="token-line"><span class="token plain">            fmt.Println(&quot;exec #2&quot;)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            result[1] = errors.New(&quot;failed to exec #2&quot;) // 保存成功或者失败的结果</span></div><div class="token-line"><span class="token plain">            return result[1]</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 启动第三个子任务，它执行成功</span></div><div class="token-line"><span class="token plain">        g.Go(func() error {</span></div><div class="token-line"><span class="token plain">            time.Sleep(15 * time.Second)</span></div><div class="token-line"><span class="token plain">            fmt.Println(&quot;exec #3&quot;)</span></div><div class="token-line"><span class="token plain">            result[2] = nil // 保存成功或者失败的结果</span></div><div class="token-line"><span class="token plain">            return nil</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        if err := g.Wait(); err == nil {</span></div><div class="token-line"><span class="token plain">            fmt.Printf(&quot;Successfully exec all. result: %v\n&quot;, result)</span></div><div class="token-line"><span class="token plain">        } else {</span></div><div class="token-line"><span class="token plain">            fmt.Printf(&quot;failed: %v\n&quot;, result)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="任务执行流水线pipeline"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/05.扩展并发原语/03#任务执行流水线pipeline"><span class="icon icon-link"></span></a>任务执行流水线Pipeline</h3><p>Go官方文档中还提供了一个pipeline的例子。这个例子是说，由一个子任务遍历文件夹下的文件，然后把遍历出的文件交给20个goroutine，让这些goroutine并行计算文件的md5。</p><p>这个例子中的计算逻辑你不需要重点掌握，我来把这个例子简化一下（如果你想看原始的代码，可以看<a target="_blank" rel="noopener noreferrer" href="https://godoc.org/golang.org/x/sync/errgroup#example-Group--Pipeline">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package main</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import (</span></div><div class="token-line"><span class="token plain">       ......</span></div><div class="token-line"><span class="token plain">        &quot;golang.org/x/sync/errgroup&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 一个多阶段的pipeline.使用有限的goroutine计算每个文件的md5值.</span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">        m, err := MD5All(context.Background(), &quot;.&quot;)</span></div><div class="token-line"><span class="token plain">        if err != nil {</span></div><div class="token-line"><span class="token plain">            log.Fatal(err)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for k, sum := range m {</span></div><div class="token-line"><span class="token plain">            fmt.Printf(&quot;%s:\t%x\n&quot;, k, sum)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    type result struct {</span></div><div class="token-line"><span class="token plain">        path string</span></div><div class="token-line"><span class="token plain">        sum  [md5.Size]byte</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 遍历根目录下所有的文件和子文件夹,计算它们的md5的值.</span></div><div class="token-line"><span class="token plain">    func MD5All(ctx context.Context, root string) (map[string][md5.Size]byte, error) {</span></div><div class="token-line"><span class="token plain">        g, ctx := errgroup.WithContext(ctx)</span></div><div class="token-line"><span class="token plain">        paths := make(chan string) // 文件路径channel</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        g.Go(func() error {</span></div><div class="token-line"><span class="token plain">            defer close(paths) // 遍历完关闭paths chan</span></div><div class="token-line"><span class="token plain">            return filepath.Walk(root, func(path string, info os.FileInfo, err error) error {</span></div><div class="token-line"><span class="token plain">                ...... //将文件路径放入到paths</span></div><div class="token-line"><span class="token plain">                return nil</span></div><div class="token-line"><span class="token plain">            })</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 启动20个goroutine执行计算md5的任务，计算的文件由上一阶段的文件遍历子任务生成.</span></div><div class="token-line"><span class="token plain">        c := make(chan result)</span></div><div class="token-line"><span class="token plain">        const numDigesters = 20</span></div><div class="token-line"><span class="token plain">        for i := 0; i &lt; numDigesters; i++ {</span></div><div class="token-line"><span class="token plain">            g.Go(func() error {</span></div><div class="token-line"><span class="token plain">                for path := range paths { // 遍历直到paths chan被关闭</span></div><div class="token-line"><span class="token plain">                    ...... // 计算path的md5值，放入到c中</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">                return nil</span></div><div class="token-line"><span class="token plain">            })</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        go func() {</span></div><div class="token-line"><span class="token plain">            g.Wait() // 20个goroutine以及遍历文件的goroutine都执行完</span></div><div class="token-line"><span class="token plain">            close(c) // 关闭收集结果的chan</span></div><div class="token-line"><span class="token plain">        }()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        m := make(map[string][md5.Size]byte)</span></div><div class="token-line"><span class="token plain">        for r := range c { // 将md5结果从chan中读取到map中,直到c被关闭才退出</span></div><div class="token-line"><span class="token plain">            m[r.path] = r.sum</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 再次调用Wait，依然可以得到group的error信息</span></div><div class="token-line"><span class="token plain">        if err := g.Wait(); err != nil {</span></div><div class="token-line"><span class="token plain">            return nil, err</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return m, nil</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>通过这个例子，你可以学习到多阶段pipeline的实现（这个例子是遍历文件夹和计算md5两个阶段），还可以学习到如何控制执行子任务的goroutine数量。</p><p>很多公司都在使用ErrGroup处理并发子任务，比如Facebook、bilibili等公司的一些项目，但是，这些公司在使用的时候，发现了一些不方便的地方，或者说，官方的ErrGroup的功能还不够丰富。所以，他们都对ErrGroup进行了扩展。接下来呢，我就带你看看几个扩展库。</p><h2 id="扩展库"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/05.扩展并发原语/03#扩展库"><span class="icon icon-link"></span></a>扩展库</h2><h3 id="bilibilierrgroup"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/05.扩展并发原语/03#bilibilierrgroup"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://godoc.org/github.com/bilibili/kratos/pkg/sync/errgroup">bilibili/errgroup<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>如果我们无限制地直接调用ErrGroup的Go方法，就可能会创建出非常多的goroutine，太多的goroutine会带来调度和GC的压力，而且也会占用更多的内存资源。就像<a target="_blank" rel="noopener noreferrer" href="https://github.com/golang/go/issues/34457">go#34457<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>指出的那样，当前Go运行时创建的g对象只会增长和重用，不会回收，所以在高并发的情况下，也要尽可能减少goroutine的使用。</p><p>常用的一个手段就是使用worker pool(goroutine pool)，或者是类似<a target="_blank" rel="noopener noreferrer" href="https://github.com/containerd/stargz-snapshotter/pull/157">containerd/stargz-snapshotter<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的方案，使用前面我们讲的信号量，信号量的资源的数量就是可以并行的goroutine的数量。但是在这一讲，我来介绍一些其它的手段，比如下面介绍的bilibili实现的errgroup。</p><p>bilibili实现了一个扩展的ErrGroup，可以使用一个固定数量的goroutine处理子任务。如果不设置goroutine的数量，那么每个子任务都会比较“放肆地”创建一个goroutine并发执行。</p><p>这个链接里的文档已经很详细地介绍了它的几个扩展功能，所以我就不通过示例的方式来进行讲解了。</p><p>除了可以控制并发goroutine的数量，它还提供了2个功能：</p><ol><li>cancel，失败的子任务可以cancel所有正在执行任务；</li><li>recover，而且会把panic的堆栈信息放到error中，避免子任务panic导致的程序崩溃。</li></ol><p>但是，有一点不太好的地方就是，一旦你设置了并发数，超过并发数的子任务需要等到调用者调用Wait之后才会执行，而不是只要goroutine空闲下来，就去执行。如果不注意这一点的话，可能会出现子任务不能及时处理的情况，这是这个库可以优化的一点。</p><p>另外，这个库其实是有一个并发问题的。在高并发的情况下，如果任务数大于设定的goroutine的数量，并且这些任务被集中加入到Group中，这个库的处理方式是把子任务加入到一个数组中，但是，这个数组不是线程安全的，有并发问题，问题就在于，下面图片中的标记为96行的那一行，这一行对slice的append操作不是线程安全的：</p><p><img src="https://static001.geekbang.org/resource/image/ef/5b/ef65c08c041f7b98c71e461f1497bc5b.png" alt=""/></p><p>我们可以写一个简单的程序来测试这个问题：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package main</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import (</span></div><div class="token-line"><span class="token plain">        &quot;context&quot;</span></div><div class="token-line"><span class="token plain">        &quot;fmt&quot;</span></div><div class="token-line"><span class="token plain">        &quot;sync/atomic&quot;</span></div><div class="token-line"><span class="token plain">        &quot;time&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        &quot;github.com/bilibili/kratos/pkg/sync/errgroup&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">        var g errgroup.Group</span></div><div class="token-line"><span class="token plain">        g.GOMAXPROCS(1) // 只使用一个goroutine处理子任务</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        var count int64</span></div><div class="token-line"><span class="token plain">        g.Go(func(ctx context.Context) error {</span></div><div class="token-line"><span class="token plain">            time.Sleep(time.Second) //睡眠5秒，把这个goroutine占住</span></div><div class="token-line"><span class="token plain">            return nil</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        total := 10000</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for i := 0; i &lt; total; i++ { // 并发一万个goroutine执行子任务，理论上这些子任务都会加入到Group的待处理列表中</span></div><div class="token-line"><span class="token plain">            go func() {</span></div><div class="token-line"><span class="token plain">                g.Go(func(ctx context.Context) error {</span></div><div class="token-line"><span class="token plain">                    atomic.AddInt64(&amp;count, 1)</span></div><div class="token-line"><span class="token plain">                    return nil</span></div><div class="token-line"><span class="token plain">                })</span></div><div class="token-line"><span class="token plain">            }()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 等待所有的子任务完成。理论上10001个子任务都会被完成</span></div><div class="token-line"><span class="token plain">        if err := g.Wait(); err != nil {</span></div><div class="token-line"><span class="token plain">            panic(err)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        got := atomic.LoadInt64(&amp;count)</span></div><div class="token-line"><span class="token plain">        if got != int64(total) {</span></div><div class="token-line"><span class="token plain">            panic(fmt.Sprintf(&quot;expect %d but got %d&quot;, total, got))</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>运行这个程序的话，你就会发现死锁问题，因为我们的测试程序是一个简单的命令行工具，程序退出的时候，Go runtime能检测到死锁问题。如果是一直运行的服务器程序，死锁问题有可能是检测不出来的，程序一直会hang在Wait的调用上。</p><h3 id="neilotooleerrgroup"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/05.扩展并发原语/03#neilotooleerrgroup"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://github.com/neilotoole/errgroup">neilotoole/errgroup<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>neilotoole/errgroup是今年年中新出现的一个ErrGroup扩展库，它可以直接替换官方的ErrGroup，方法都一样，原有功能也一样，只不过<strong>增加了可以控制并发goroutine的功能</strong>。它的方法集如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type Group</span></div><div class="token-line"><span class="token plain">      func WithContext(ctx context.Context) (*Group, context.Context)</span></div><div class="token-line"><span class="token plain">      func WithContextN(ctx context.Context, numG, qSize int) (*Group, context.Context)</span></div><div class="token-line"><span class="token plain">      func (g *Group) Go(f func() error)</span></div><div class="token-line"><span class="token plain">      func (g *Group) Wait() error</span></div></pre></div><p>新增加的方法WithContextN，可以设置并发的goroutine数，以及等待处理的子任务队列的大小。当队列满的时候，如果调用Go方法，就会被阻塞，直到子任务可以放入到队列中才返回。如果你传给这两个参数的值不是正整数，它就会使用runtime.NumCPU代替你传入的参数。</p><p>当然，你也可以把bilibili的recover功能扩展到这个库中，以避免子任务的panic导致程序崩溃。</p><h3 id="facebookgoerrgroup"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/05.扩展并发原语/03#facebookgoerrgroup"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://github.com/facebookarchive/errgroup">facebookgo/errgroup<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Facebook提供的这个ErrGroup，其实并不是对Go扩展库ErrGroup的扩展，而是对标准库WaitGroup的扩展。不过，因为它们的名字一样，处理的场景也类似，所以我把它也列在了这里。</p><p>标准库的WaitGroup只提供了Add、Done、Wait方法，而且Wait方法也没有返回子goroutine的error。而Facebook提供的ErrGroup提供的Wait方法可以返回error，而且可以包含多个error。子任务在调用Done之前，可以把自己的error信息设置给ErrGroup。接着，Wait在返回的时候，就会把这些error信息返回给调用者。</p><p>我们来看下Group的方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type Group</span></div><div class="token-line"><span class="token plain">      func (g *Group) Add(delta int)</span></div><div class="token-line"><span class="token plain">      func (g *Group) Done()</span></div><div class="token-line"><span class="token plain">      func (g *Group) Error(e error)</span></div><div class="token-line"><span class="token plain">      func (g *Group) Wait() error</span></div></pre></div><p>关于Wait方法，我刚刚已经介绍了它和标准库WaitGroup的不同，我就不多说了。这里还有一个不同的方法，就是Error方法，</p><p>我举个例子演示一下Error的使用方法。</p><p>在下面的这个例子中，第26行的子goroutine设置了error信息，第39行会把这个error信息输出出来。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package main</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import (</span></div><div class="token-line"><span class="token plain">        &quot;errors&quot;</span></div><div class="token-line"><span class="token plain">        &quot;fmt&quot;</span></div><div class="token-line"><span class="token plain">        &quot;time&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        &quot;github.com/facebookgo/errgroup&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">        var g errgroup.Group</span></div><div class="token-line"><span class="token plain">        g.Add(3)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 启动第一个子任务,它执行成功</span></div><div class="token-line"><span class="token plain">        go func() {</span></div><div class="token-line"><span class="token plain">            time.Sleep(5 * time.Second)</span></div><div class="token-line"><span class="token plain">            fmt.Println(&quot;exec #1&quot;)</span></div><div class="token-line"><span class="token plain">            g.Done()</span></div><div class="token-line"><span class="token plain">        }()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 启动第二个子任务，它执行失败</span></div><div class="token-line"><span class="token plain">        go func() {</span></div><div class="token-line"><span class="token plain">            time.Sleep(10 * time.Second)</span></div><div class="token-line"><span class="token plain">            fmt.Println(&quot;exec #2&quot;)</span></div><div class="token-line"><span class="token plain">            g.Error(errors.New(&quot;failed to exec #2&quot;))</span></div><div class="token-line"><span class="token plain">            g.Done()</span></div><div class="token-line"><span class="token plain">        }()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 启动第三个子任务，它执行成功</span></div><div class="token-line"><span class="token plain">        go func() {</span></div><div class="token-line"><span class="token plain">            time.Sleep(15 * time.Second)</span></div><div class="token-line"><span class="token plain">            fmt.Println(&quot;exec #3&quot;)</span></div><div class="token-line"><span class="token plain">            g.Done()</span></div><div class="token-line"><span class="token plain">        }()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 等待所有的goroutine完成，并检查error</span></div><div class="token-line"><span class="token plain">        if err := g.Wait(); err == nil {</span></div><div class="token-line"><span class="token plain">            fmt.Println(&quot;Successfully exec all&quot;)</span></div><div class="token-line"><span class="token plain">        } else {</span></div><div class="token-line"><span class="token plain">            fmt.Println(&quot;failed:&quot;, err)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>关于ErrGroup，你掌握这些就足够了，接下来，我再介绍几种有趣而实用的Group并发原语。这些并发原语都是控制一组子goroutine执行的面向特定场景的并发原语，当你遇见这些特定场景时，就可以参考这些库。</p><h2 id="其它实用的group并发原语"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/05.扩展并发原语/03#其它实用的group并发原语"><span class="icon icon-link"></span></a>其它实用的Group并发原语</h2><h3 id="sizedgrouperrsizedgroup"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/05.扩展并发原语/03#sizedgrouperrsizedgroup"><span class="icon icon-link"></span></a>SizedGroup/ErrSizedGroup</h3><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/go-pkgz/syncs">go-pkgz/syncs<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>提供了两个Group并发原语，分别是SizedGroup和ErrSizedGroup。</p><p>SizedGroup内部是使用信号量和WaitGroup实现的，它通过信号量控制并发的goroutine数量，或者是不控制goroutine数量，只控制子任务并发执行时候的数量（通过）。</p><p>它的代码实现非常简洁，你可以到它的代码库中了解它的具体实现，你一看就明白了，我就不多说了。下面我重点说说它的功能。</p><p><strong>默认情况下，SizedGroup控制的是子任务的并发数量，而不是goroutine的数量</strong>。在这种方式下，每次调用Go方法都不会被阻塞，而是新建一个goroutine去执行。</p><p>如果想控制goroutine的数量，你可以使用syncs.Preemptive设置这个并发原语的可选项。如果设置了这个可选项，但在调用Go方法的时候没有可用的goroutine，那么调用者就会等待，直到有goroutine可以处理这个子任务才返回，这个控制在内部是使用信号量实现的。</p><p>我们来看一个使用SizedGroup的例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package main</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import (</span></div><div class="token-line"><span class="token plain">        &quot;context&quot;</span></div><div class="token-line"><span class="token plain">        &quot;fmt&quot;</span></div><div class="token-line"><span class="token plain">        &quot;sync/atomic&quot;</span></div><div class="token-line"><span class="token plain">        &quot;time&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        &quot;github.com/go-pkgz/syncs&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">        // 设置goroutine数是10</span></div><div class="token-line"><span class="token plain">        swg := syncs.NewSizedGroup(10)</span></div><div class="token-line"><span class="token plain">        // swg := syncs.NewSizedGroup(10, syncs.Preemptive)</span></div><div class="token-line"><span class="token plain">        var c uint32</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 执行1000个子任务，只会有10个goroutine去执行</span></div><div class="token-line"><span class="token plain">        for i := 0; i &lt; 1000; i++ {</span></div><div class="token-line"><span class="token plain">            swg.Go(func(ctx context.Context) {</span></div><div class="token-line"><span class="token plain">                time.Sleep(5 * time.Millisecond)</span></div><div class="token-line"><span class="token plain">                atomic.AddUint32(&amp;c, 1)</span></div><div class="token-line"><span class="token plain">            })</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 等待任务完成</span></div><div class="token-line"><span class="token plain">        swg.Wait()</span></div><div class="token-line"><span class="token plain">        // 输出结果</span></div><div class="token-line"><span class="token plain">        fmt.Println(c)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>ErrSizedGroup为SizedGroup提供了error处理的功能，它的功能和Go官方扩展库的功能一样，就是等待子任务完成并返回第一个出现的error。不过，它还提供了额外的功能，我来介绍一下。</p><p>第一个额外的功能，就是可以控制并发的goroutine数量，这和SizedGroup的功能一样。</p><p>第二个功能是，如果设置了termOnError，子任务出现第一个错误的时候会cancel Context，而且后续的Go调用会直接返回，Wait调用者会得到这个错误，这相当于是遇到错误快速返回。如果没有设置termOnError，Wait会返回所有的子任务的错误。</p><p>不过，ErrSizedGroup和SizedGroup设计得不太一致的地方是，<strong>SizedGroup可以把Context传递给子任务，这样可以通过cancel让子任务中断执行，但是ErrSizedGroup却没有实现。我认为，这是一个值得加强的地方</strong>。</p><p>总体来说，syncs包提供的并发原语的质量和功能还是非常赞的。不过，目前的star只有十几个，这和它的功能严重不匹配，我建议你star这个项目，支持一下作者。</p><p>好了，关于ErrGroup，你掌握这些就足够了，下面我再来给你介绍一些非ErrGroup的并发原语，它们用来编排子任务。</p><h1 id="gollback"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/05.扩展并发原语/03#gollback"><span class="icon icon-link"></span></a>gollback</h1><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/vardius/gollback">gollback<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>也是用来处理一组子任务的执行的，不过它解决了ErrGroup收集子任务返回结果的痛点。使用ErrGroup时，如果你要收到子任务的结果和错误，你需要定义额外的变量收集执行结果和错误，但是这个库可以提供更便利的方式。</p><p>我刚刚在说官方扩展库ErrGroup的时候，举了一些例子（返回第一个错误的例子和返回所有子任务错误的例子），在例子中，如果想得到每一个子任务的结果或者error，我们需要额外提供一个result slice进行收集。使用gollback的话，就不需要这些额外的处理了，因为它的方法会把结果和error信息都返回。</p><p>接下来，我们看一下它提供的三个方法，分别是<strong>All、Race和Retry</strong>。</p><p><strong>All方法</strong></p><p>All方法的签名如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func All(ctx context.Context, fns ...AsyncFunc) ([]interface{}, []error)</span></div></pre></div><p>它会等待所有的异步函数（AsyncFunc）都执行完才返回，而且返回结果的顺序和传入的函数的顺序保持一致。第一个返回参数是子任务的执行结果，第二个参数是子任务执行时的错误信息。</p><p>其中，异步函数的定义如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type AsyncFunc func(ctx context.Context) (interface{}, error)</span></div></pre></div><p>可以看到，ctx会被传递给子任务。如果你cancel这个ctx，可以取消子任务。</p><p>我们来看一个使用All方法的例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package main</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import (</span></div><div class="token-line"><span class="token plain">    	&quot;context&quot;</span></div><div class="token-line"><span class="token plain">    	&quot;errors&quot;</span></div><div class="token-line"><span class="token plain">    	&quot;fmt&quot;</span></div><div class="token-line"><span class="token plain">    	&quot;github.com/vardius/gollback&quot;</span></div><div class="token-line"><span class="token plain">    	&quot;time&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">    	rs, errs := gollback.All( // 调用All方法</span></div><div class="token-line"><span class="token plain">    		context.Background(),</span></div><div class="token-line"><span class="token plain">    		func(ctx context.Context) (interface{}, error) { </span></div><div class="token-line"><span class="token plain">    			time.Sleep(3 * time.Second)</span></div><div class="token-line"><span class="token plain">    			return 1, nil // 第一个任务没有错误，返回1</span></div><div class="token-line"><span class="token plain">    		},</span></div><div class="token-line"><span class="token plain">    		func(ctx context.Context) (interface{}, error) {</span></div><div class="token-line"><span class="token plain">    			return nil, errors.New(&quot;failed&quot;) // 第二个任务返回一个错误</span></div><div class="token-line"><span class="token plain">    		},</span></div><div class="token-line"><span class="token plain">    		func(ctx context.Context) (interface{}, error) {</span></div><div class="token-line"><span class="token plain">    			return 3, nil // 第三个任务没有错误，返回3</span></div><div class="token-line"><span class="token plain">    		},</span></div><div class="token-line"><span class="token plain">    	)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	fmt.Println(rs) // 输出子任务的结果</span></div><div class="token-line"><span class="token plain">    	fmt.Println(errs) // 输出子任务的错误信息</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p><strong>Race方法</strong></p><p>Race方法跟All方法类似，只不过，在使用Race方法的时候，只要一个异步函数执行没有错误，就立马返回，而不会返回所有的子任务信息。如果所有的子任务都没有成功，就会返回最后一个error信息。</p><p>Race方法签名如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func Race(ctx context.Context, fns ...AsyncFunc) (interface{}, error)</span></div></pre></div><p>如果有一个正常的子任务的结果返回，Race会把传入到其它子任务的Context cancel掉，这样子任务就可以中断自己的执行。</p><p>Race的使用方法也跟All方法类似，我就不再举例子了，你可以把All方法的例子中的All替换成Race方式测试下。</p><p><strong>Retry方法</strong></p><p><strong>Retry不是执行一组子任务，而是执行一个子任务</strong>。如果子任务执行失败，它会尝试一定的次数，如果一直不成功 ，就会返回失败错误 ，如果执行成功，它会立即返回。如果retires等于0，它会永远尝试，直到成功。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func Retry(ctx context.Context, retires int, fn AsyncFunc) (interface{}, error)</span></div></pre></div><p>再来看一个使用Retry的例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package main</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import (</span></div><div class="token-line"><span class="token plain">    	&quot;context&quot;</span></div><div class="token-line"><span class="token plain">    	&quot;errors&quot;</span></div><div class="token-line"><span class="token plain">    	&quot;fmt&quot;</span></div><div class="token-line"><span class="token plain">    	&quot;github.com/vardius/gollback&quot;</span></div><div class="token-line"><span class="token plain">    	&quot;time&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">    	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)</span></div><div class="token-line"><span class="token plain">    	defer cancel()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	// 尝试5次，或者超时返回</span></div><div class="token-line"><span class="token plain">    	res, err := gollback.Retry(ctx, 5, func(ctx context.Context) (interface{}, error) {</span></div><div class="token-line"><span class="token plain">    		return nil, errors.New(&quot;failed&quot;)</span></div><div class="token-line"><span class="token plain">    	})</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	fmt.Println(res) // 输出结果</span></div><div class="token-line"><span class="token plain">    	fmt.Println(err) // 输出错误信息</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h1 id="hunch"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/05.扩展并发原语/03#hunch"><span class="icon icon-link"></span></a>Hunch</h1><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/AaronJan/Hunch">Hunch<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>提供的功能和gollback类似，不过它提供的方法更多，而且它提供的和gollback相应的方法，也有一些不同。我来一一介绍下。</p><p>它定义了执行子任务的函数，这和gollback的AyncFunc是一样的，它的定义如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type Executable func(context.Context) (interface{}, error)</span></div></pre></div><p><strong>All方法</strong></p><p>All方法的签名如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func All(parentCtx context.Context, execs ...Executable) ([]interface{}, error)</span></div></pre></div><p>它会传入一组可执行的函数（子任务），返回子任务的执行结果。和gollback的All方法不一样的是，一旦一个子任务出现错误，它就会返回错误信息，执行结果（第一个返回参数）为nil。</p><p><strong>Take方法</strong></p><p>Take方法的签名如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func Take(parentCtx context.Context, num int, execs ...Executable) ([]interface{}, error)</span></div></pre></div><p>你可以指定num参数，只要有num个子任务正常执行完没有错误，这个方法就会返回这几个子任务的结果。一旦一个子任务出现错误，它就会返回错误信息，执行结果（第一个返回参数）为nil。</p><p><strong>Last方法</strong></p><p>Last方法的签名如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func Last(parentCtx context.Context, num int, execs ...Executable) ([]interface{}, error)</span></div></pre></div><p>它只返回最后num个正常执行的、没有错误的子任务的结果。一旦一个子任务出现错误，它就会返回错误信息，执行结果（第一个返回参数）为nil。</p><p>比如num等于1，那么，它只会返回最后一个无错的子任务的结果。</p><p><strong>Retry方法</strong></p><p>Retry方法的签名如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func Retry(parentCtx context.Context, retries int, fn Executable) (interface{}, error)</span></div></pre></div><p>它的功能和gollback的Retry方法的功能一样，如果子任务执行出错，就会不断尝试，直到成功或者是达到重试上限。如果达到重试上限，就会返回错误。如果retries等于0，它会不断尝试。</p><p><strong>Waterfall方法</strong></p><p>Waterfall方法签名如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func Waterfall(parentCtx context.Context, execs ...ExecutableInSequence) (interface{}, error)</span></div></pre></div><p>它其实是一个pipeline的处理方式，所有的子任务都是串行执行的，前一个子任务的执行结果会被当作参数传给下一个子任务，直到所有的任务都完成，返回最后的执行结果。一旦一个子任务出现错误，它就会返回错误信息，执行结果（第一个返回参数）为nil。</p><p>gollback和Hunch是属于同一类的并发原语，对一组子任务的执行结果，可以选择一个结果或者多个结果，这也是现在热门的微服务常用的服务治理的方法。</p><h1 id="schedgroup"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/05.扩展并发原语/03#schedgroup"><span class="icon icon-link"></span></a>schedgroup</h1><p>接下来，我再介绍一个<strong>和时间相关的处理一组goroutine的并发原语schedgroup</strong>。</p><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/mdlayher/schedgroup">schedgroup<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>是Matt Layher开发的worker pool，可以指定任务在某个时间或者某个时间之后执行。Matt Layher也是一个知名的Gopher，经常在一些会议上分享一些他的Go开发经验，他在GopherCon Europe 2020大会上专门介绍了这个并发原语：<a target="_blank" rel="noopener noreferrer" href="https://talks.godoc.org/github.com/mdlayher/talks/conferences/2020/gopherconeu/schedgroup.slide">schedgroup: a timer-based goroutine concurrency primitive<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ，课下你可以点开这个链接看一下，下面我来给你介绍一些重点。</p><p>这个并发原语包含的方法如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type Group</span></div><div class="token-line"><span class="token plain">      func New(ctx context.Context) *Group</span></div><div class="token-line"><span class="token plain">      func (g *Group) Delay(delay time.Duration, fn func())</span></div><div class="token-line"><span class="token plain">      func (g *Group) Schedule(when time.Time, fn func())</span></div><div class="token-line"><span class="token plain">      func (g *Group) Wait() error</span></div></pre></div><p>我来介绍下这些方法。</p><p>先说Delay和Schedule。</p><p>它们的功能其实是一样的，都是用来指定在某个时间或者之后执行一个函数。只不过，Delay传入的是一个time.Duration参数，它会在time.Now()+delay之后执行函数，而Schedule可以指定明确的某个时间执行。</p><p>再来说说Wait方法。</p><p>这个方法调用会阻塞调用者，直到之前安排的所有子任务都执行完才返回。如果Context被取消，那么，Wait方法会返回这个cancel error。</p><p>在使用Wait方法的时候，有2点需要注意一下。</p><p><strong>第一点是，如果调用了Wait方法，你就不能再调用它的Delay和Schedule方法，否则会panic。</strong></p><p><strong>第二点是，Wait方法只能调用一次，如果多次调用的话，就会panic。</strong></p><p>你可能认为，简单地使用timer就可以实现这个功能。其实，如果只有几个子任务，使用timer不是问题，但一旦有大量的子任务，而且还要能够cancel，那么，使用timer的话，CPU资源消耗就比较大了。所以，schedgroup在实现的时候，就使用container/heap，按照子任务的执行时间进行排序，这样可以避免使用大量的timer，从而提高性能。</p><p>我们来看一个使用schedgroup的例子，下面代码会依次输出1、2、3：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">sg := schedgroup.New(context.Background())</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 设置子任务分别在100、200、300之后执行</span></div><div class="token-line"><span class="token plain">    for i := 0; i &lt; 3; i++ {</span></div><div class="token-line"><span class="token plain">        n := i + 1</span></div><div class="token-line"><span class="token plain">        sg.Delay(time.Duration(n)*100*time.Millisecond, func() {</span></div><div class="token-line"><span class="token plain">            log.Println(n) //输出任务编号</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 等待所有的子任务都完成</span></div><div class="token-line"><span class="token plain">    if err := sg.Wait(); err != nil {</span></div><div class="token-line"><span class="token plain">        log.Fatalf(&quot;failed to wait: %v&quot;, err)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h1 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/05.扩展并发原语/03#总结"><span class="icon icon-link"></span></a>总结</h1><p>这节课，我给你介绍了几种常见的处理一组子任务的并发原语，包括ErrGroup、gollback、Hunch、schedgroup，等等。这些常见的业务场景共性处理方式的总结，你可以把它们加入到你的知识库中，等以后遇到相同的业务场景时，你就可以考虑使用这些并发原语。</p><p>当然，类似的并发原语还有别的，比如<a target="_blank" rel="noopener noreferrer" href="https://github.com/pieterclaerhout/go-waitgroup">go-waitgroup<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>等，而且，我相信还会有新的并发原语不断出现。所以，你不仅仅要掌握这些并发原语，而且还要通过学习这些并发原语，学会构造新的并发原语来处理应对你的特有场景，实现代码重用和业务逻辑简化。</p><p><img src="https://static001.geekbang.org/resource/image/ee/9c/ee46d1dbed154a24063d3b0795fb5d9c.jpg" alt=""/></p><h1 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-two/go并发编程实战/05.扩展并发原语/03#思考题"><span class="icon icon-link"></span></a>思考题</h1><p>这节课，我讲的官方扩展库ErrGroup没有实现可以取消子任务的功能，请你课下可以自己去实现一个子任务可取消的ErrGroup。</p><p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得有所收获，也欢迎你把今天的内容分享给你的朋友或同事。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/go并发编程实战/05.扩展并发原语/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:07</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
