exports.category = "architect";
exports.title = "遗留系统现代化实战";
exports.data = [
  {
    chapterTitle: "开篇词",
    children: [
      {
        title: "开篇词｜你现在所写的每一行代码，都是未来的遗留系统",
        id: 505735,
        content:
          '<p>你好，我是姚琪琳，来自Thoughtworks，很高兴在极客时间与你相遇。</p><p>先做个自我介绍，我做过程序员、架构师、技术负责人、技术教练、咨询师，角色一直在变化，但幸运的是始终可以有机会写写代码。业余时间也喜欢翻译，曾经翻译过大大小小十来本技术书籍。</p><p>这15年的职业生涯，虽然我尝试了种种工作，但总结起来我大部分的时间都在和遗留系统打交道。既有开发历史已经接近20年的系统，也有刚上线没几年的系统，当然也有开发了十来年，但看上去十分美好的、所谓的“遗留”系统。</p><p>在这个深坑中摸爬滚打了多年之后，我在遗留系统开发、治理和改造的过程中积累了大量的一手经验，现在我决定把我和团队的经验分享出来，帮助深陷在遗留系统的泥潭中无法自拔的你。</p><p>你可能会说，你当前所在的项目上并没有遗留系统，所有的系统都生机勃勃、一片祥和。不过，根据这些年和遗留系统打交道的经验，我基本可以告诉你，表面的祥和之下，可能暗藏波涛。</p><h2>你现在所写的每一行代码，都是未来的遗留系统</h2><p>我的同事，重构和微服务的缔造者，软件开发领域的泰斗，Martin Fowler曾经说过<a href="https://martinfowler.com/bliki/StranglerFigApplication.html">这样一句话</a>：</p><blockquote>\n<p>Let’s face it, all we are doing is writing tomorrow’s legacy software today.</p>\n</blockquote><!-- [[[read_end]]] --><p>是的，可以毫不夸张地说，<strong>你现在所写的每一行代码，都是未来的遗留系统</strong>。</p><p>这听上去有点让人沮丧，但却是血淋淋的事实。每一种技术的诞生和流行，都有它的时代背景，当这个背景不存在时，也就失去了它生存的土壤。因此你现在所纠结的每一项技术选型，到五年以后都会过时成为遗留产物。</p><p>曾经作为行业标准的IOE，现在人人唯恐避之不及；风靡一时的SOA，也最终被微服务所取代；而如果以后云服务进一步发展，大型服务的部署和演进不再是瓶颈，单体会不会重新流行？谁知道呢。</p><p>看到这里，你还会觉得遗留系统跟自己没关系吗？即使你现在没有工作在遗留系统上，你也很快就要工作在它上面了。</p><p>而随着技术的发展，被遗留系统左右的可不仅仅是开发者个人，还有你所在的企业。我想你一定听说过数字化转型！那些曾经为企业立下汗马功劳的IT系统（也就是遗留系统），此刻反而成为了数字化转型的绊脚石。这是为什么呢？</p><p>概括来说就是，IT能力支撑不了企业的市场需求，技术跟不上业务。一个简单的流程更改，都需要很久才能上线；新的数字渠道来临时，系统更是无法支持。不仅如此，有些系统甚至连最基本的可用性都无法满足，动不动就打不开、报错，甚至无法完成业务，用户体验也非常差。面对这样的痛点，系统现代化势在必行。</p><p>有太多在遗留系统上折腾的案例，改造的过程声势浩大，结果却令人扼腕。有的开启专项，抽调精英，大刀阔斧地进行整改；有的则干脆重写，企图替换原有系统。但这些行动大多都以失败而告终：有的改造完了仍然无法满足业务，新写的系统也好不到哪去，只不过是又一个遗留系统罢了。</p><p>在亲眼目睹了这些惨案之后，我愈发觉得有必要把我的经验分享给你和你的组织了。</p><h2>你的系统真的不是遗留系统吗？</h2><p>也许看到这里你还是感觉遗留系统和你无关。要么觉得我手上的系统才两三年，算不上遗留系统，要么立志“让我维护遗留系统就辞职”。</p><p>对于第一种想法，你敢打包票自己的系统不是遗留系统吗？很多人以为存在时间很长的就是遗留系统，但这其实是个误区。</p><p>时间长短并不能作为衡量遗留系统的标准。有些系统虽然刚开发不久，但你工作起来还是有各种不爽，比如：</p><ul>\n<li>代码质量一言难尽，改个需求或做维护经常加班，让你恨不得推翻重写；</li>\n<li>架构混乱，模块之间职责不明，一个需求需要修改四五个服务；</li>\n<li>CI/CD运转不畅，经常莫名其妙地挂掉，每次升级、上线都一拖再拖；</li>\n<li>团队结构不稳定，人员变动频繁；大家都在拼命开发新需求，没人关心技术债；</li>\n<li>……</li>\n</ul><p>如果以上问题你都自信满满，那我就要拿出杀手锏了。</p><p>你的代码有测试吗？你平时开发新需求时会写测试吗？你在修改bug时会补测试吗？经过这样的灵魂三问，你还有自信坚持说自己的系统不是遗留系统吗？</p><p>《修改代码的艺术》一书的作者Michael Feathers说过，“没有测试的代码都是遗留代码”。在我们越来越强调软件系统质量内建的今天，仍然有很多系统甚至很多刚刚开发的新系统，由于各种原因不写测试。有的说工期太紧，没时间写；有的说系统原来就没测试，我新加的这么几行代码没必要写。其实每种借口都禁不起推敲，都是在为自己不会写测试来打马虎眼。</p><p>软件系统本身就是一个不断熵增的过程，代码逐渐从有序变得无序。如果没有测试的严防死守，熵增的过程就会慢慢加快，代码很快就会变得混乱不堪。</p><p>前段时间在硅谷有个新闻，一位华裔开发人员受不了同事不写单元测试，所以愤然离开了这家在国内赫赫有名的大厂。这家大厂的做法和国内的很多互联网公司一样，用大量的昂贵的人工测试，去替代廉价的自动化测试。不是说这样不可行，但问题是它的投入产出比非常低，并且十分低效的。而且是把软件开发这个智力劳动，当成了体力劳动密集型的工作。在我看来，这不但是对软件工作者的嘲讽和亵渎，而且无视了熵增定律，迟早要付出代价。</p><p>至于第二种想法“让我维护遗留系统就辞职”。如果你是公司的CTO或者架构师，你还会这么想吗？</p><p>技术之路走到后来，你需要更深的技术与业务洞察，更丰富的理论和实战经验。</p><p>比如我在代码现代化部分介绍的代码重构，难道你平时写代码不重构吗？显然不是，重构已经成为了开发人员必备的甚至是融入血液的技能。不会重构，怎么好意思跟人打招呼。</p><p>再比如在架构现代化部分介绍的抽象分支模式，不也正是我们在日常开发时会频繁使用的模式吗？每当我们提取一个接口来隔离某个变化方向，其实就是一个抽象分支。想想看，你是不是早就习惯了一个接口加一个Impl类的结构了呢（当然，我并不推荐盲目使用接口 + Impl类的结构）？</p><p>我的这些经验之谈，并不仅适用于遗留系统开发。像三个原则和四个现代化中的各种模式，其实都是开发新系统常常要用到的。</p><h2>课程安排</h2><p>谈了这么多，无非就是表达一个观点：作为工程师，我们比想象中距离遗留系统更近。与其逃避躲闪，不如把它作为我们技术进阶的磨刀石和垫脚石。</p><p>在这个专栏里，我会先给你介绍一下我心中的遗留系统现代化的定义。然后按照我最喜欢的技术书籍之一《敏捷软件开发：原则、模式和实践》那样，将遗留系统现代化的各种知识总结为原则、模式和实践。</p><p>你一定会好奇为什么叫遗留系统“现代化”，而不是业界常说的“改造”。我其实是有意回避了这个词，因为这个词“重过程”、“轻结果”。我见过太多遗留系统改造之后并没有什么变化，甚至越改越糟。这也是我总结遗留系统现代化三原则的原因。只有遵循这些原则，才能有的放矢，才不会偏离方向。</p><p>这三个原则分别是<strong>以降低认知负载为前提、以假设驱动为指引、以增量演进为手段</strong>。</p><p>它们是大多数遗留系统改造项目中容易忽视的部分。很多系统的改造都只针对局部问题，缺乏全局的认知和系统的视角。</p><p>比如重构代码是为了什么？只是为了提升可读性吗？拆分模块是为了什么？只是为了架构整洁吗？为什么耗时一年的改造上线之后因为bug太多而不得不被叫停，最后不了了之？相信在学完原则篇后，你能找到答案。</p><p>而模式则包含很多了，它们有的来源于网络上或书上，我在实际工作中使用之后感觉受益匪浅，于是拿出来夹带着我自己的理解展示给你。像Michael Feathers提出的<strong>接缝</strong>模式、Martin Fowler提出的<strong>扩张-收缩</strong>模式、Eric Evans提出的<strong>气泡上下文</strong>模式等等。这些大师总结的模式，我用起来的感觉就是两个字：真香。</p><p>这些模式，有的则来自于我和同事在实战一线处理完各种疑难杂症后，总结出来的套路，它们适合去解决不同种类的问题。比如为遗留代码添加测试的<strong>决策表</strong>模式，以及为了更好地持续集成而使用的<strong>七步提交法</strong>。即使你不在遗留系统上工作，这些知识也能丰富你的工具箱，使你成为解决问题的高手。</p><p><img src="https://static001.geekbang.org/resource/image/21/ef/216d75abcd69352fec044138befd9bef.jpg?wh=11533x6020" alt=""></p><p>而最后的实践部分，我将带着你一起对一个典型的遗留系统进行现代化。这期间会遇到种种问题，我们一起把前面提到的原则和模式使用起来，武装我们的双手，并且还会对各种模式进行变体，以使其更加适配我们要解决的问题。相信我们一定可以兵来将挡、水来土掩。</p><p><img src="https://static001.geekbang.org/resource/image/3e/6e/3e5f39d0b9a91f9cd858d7d2830f2b6e.jpg?wh=1920x876" alt="图片"></p><h2>写在最后</h2><p>技术可以流行一时，但终将被淘汰，而方法论却可以像陈年老酒一样愈久弥香。我也曾经像你一样，对于新技术趋之若鹜，但最后发现，只有掌握了解决问题的方法，才能不惧任何问题。那些不同的技术，只不过是同一种方法下的不同思路罢了。</p><p>总之，我把我解决遗留系统难题的方法总结了出来，尽管它有些地方与你现在所使用的技术并不完全一致，但学会了这些知识，对平时的开发和设计都是非常有帮助的。毕竟，虽然要解决的问题不同，但方法却殊途同归。</p><p>我们的遗留系统现代化列车即将启程，希望你和我一起学习进步！</p>',
        article_title: "开篇词｜你现在所写的每一行代码，都是未来的遗留系统",
      },
    ],
  },
  {
    chapterTitle: "基础篇",
    children: [
      {
        title: "01｜遗留系统之殇：为什么要对遗留系统进行现代化？",
        id: 505740,
        content:
          '<p>你好，我是姚琪琳。</p><p>不知道你是否跟曾经的我一样，身处一个遗留系统的漩涡之中，每天为毫无头绪的代码和混乱不堪的架构发愁。一个新的需求来了，都不知道从哪儿开始改起，即便看似简单的需求都要很久才能上线。</p><p>假如你也如此，请不要悲伤，也不要心急，其中有很多妥善的应对之法，我会在这个专栏中一一交付给你。</p><p>但在此之前啊，我想我们是不是得先明确一下，到底什么样的系统才能称之为遗留系统呢？它存在哪些问题，复杂在哪里？</p><p>这节课我们就来一探究竟，好为我们后面深入学习遗留系统奠定一个良好的基础。同时，我们也可以看看在高成本的现代化改造之下，为什么遗留系统还要迎难而上？</p><h2>关于遗留系统的误区</h2><p>请你先思考这样一个问题：假如一个系统七八年了，它是不是个遗留系统？</p><p>系统的时间长等同于就是遗留系统，这是很多人的一个误区。虽然大多数遗留系统确实是存在的时间很长，但并不等于时间长的都是遗留系统。</p><p>这里分享一个我的项目经历。我之前曾在一个项目上工作6年多，这是一个有着12年历史的老项目。</p><p>它的技术栈最初是.NET Framework，现在已经有部分迁移到了.NET Core；它最初是单体架构，现在是一个小单体加多个微服务；它从第一行代码开始就使用TDD的方式开发，至今已经有30000多个不同类型的测试；它一开始使用SVN来管理源代码，不过早在十年前就被迁移到了Git；它从第一天就有CI/CD相伴，并且一直坚持基于主干开发的分支策略，每个月都有稳定的版本发布；它没有一行注释，但是任何开发人员都能通过阅读源代码快速了解系统的实现，也就是说代码质量相当高……</p><!-- [[[read_end]]] --><p>这个系统历时12年之久，比很多公司活的时间都长。那它是遗留系统吗？答案是否定的。因为它的代码质量高、架构合理、自动化测试丰富、DevOps成熟度也高，各种技术、工具都是相对先进的，怎么能说是遗留系统呢？</p><p>这里我还想请你进一步思考一下：存在时间短的系统就不是遗留系统吗？</p><p>仍然拿我个人经历过的一个项目来举例。它是07年左右开发完成的，当我10年加入项目组的时候发现，它仍旧是基于JDK 1.4的（那个时候Java 6已经发布4年了），很多Java的新特性都无法使用。它是一个C/S结构的软件，前端基于Java富客户端，后端是一个大单体向前端提供RPC服务；它没有一行测试，每改一行代码都提心吊胆，有时为了不影响别的功能，只好把代码复制一份，加入自己的逻辑，这就导致了大量的重复代码；每次发布日期都是一拖再拖，而部署到生产环境上的war包，甚至在是开发机器上打包的……</p><p>别看这个系统只开发完3年，但毫不客气地说，它从刚开发完毕的那一刻起，恐怕就是个遗留系统。它的代码质量差、架构不可演进、没有自动化测试、缺乏DevOps，各种技术、工具也十分落后、老旧，这样的系统，即使刚开发完，也是遗留系统。</p><p>那么从上面的描述看，你大概已经发现了我判断遗留系统的几个维度：<strong>代码、架构、测试、DevOps以及技术和工具</strong>。</p><p>所以说啊，时间长短并不是衡量遗留系统的标准。代码质量差、架构混乱、没有测试、纯手工的DevOps（或运维）、老旧的技术和工具，才是遗留系统的真正特点。</p><p>接下来我们就从这些特点出发，逐一分析一下它们都造成了哪些问题。</p><h2>遗留系统的特点和问题</h2><p>首先就是代码质量差。我们说优秀的代码都是相似的，而糟糕的代码则各有各的糟糕之处。</p><p>我曾治理过一个有着6000行代码的单个方法，至今印象深刻。其中包含6个大的if/else块，每个块中大概有1000行左右的代码，这6个1000行的代码只有十分细小的差别。显然是开发人员为了偷懒，不敢在原代码上改动，于是复制出来加入自己的逻辑。他倒是图省事儿了，但是对于维护人员来说简直是噩梦。正所谓编码一时爽，维护火葬场。</p><p>其次是架构，这也是遗留系统的重灾区。一个软件架构的作用，是要解决多个业务模块之间的协作问题。但如果架构混乱，多个模块之间往复调用，数据也是随意访问，模块之间的边界就会变得模糊，数据所有权也会变得含糊。试想一下，如果一张表被10个模块访问，谁能说得清这张表到底属于哪个模块呢？</p><p>下图是一家银行的核心应用系统模块之间的交互图，我想没有一个人愿意工作在这样的系统上吧？</p><p><img src="https://static001.geekbang.org/resource/image/24/ae/240594a8fb368884641cc981beed27ae.png?wh=1200x688" alt="图片"></p><p>综合来看，代码和架构的质量差会导致遗留系统的维护成本相当高昂。这里的维护就包括：新需求的添加、线上Bug的修改，以及为了维护系统运行所需投入的软硬件和人力等。</p><p>我说这些可不是空穴来风，IEEE就曾报道过，2010年以来，全世界在IT产品和服务上的支出达到了35万亿美元。其中四分之三用于运营和维护现有的IT系统，至少有2.5万亿用于尝试替换旧系统，其中差不多三分之一的资金都打了水漂（这个报道详情你感兴趣的话，可以看<a href="https://spectrum.ieee.org/computing/it/inside-hidden-world-legacy-it-systems">这里</a>）。</p><p>企业在遗留系统上的投入巨大，却没能得到相称的回报。很多资金只是用来维持系统的现状，却不能让它们变得更好。</p><p>更严重的是，代码和架构的落后还会导致系统在合规和安全方面的问题。</p><p>随着我国法律法规的健全，软件系统的合规性越来越重要，而一个面对任何需求都难以实现的遗留系统，要想进行修改以符合新的法律法规，是难上加难的事情。去年我国正式施行了《中华人民共和国数据安全法》（即中国的GDPR），明确规定了软件系统的数据安全规范。如果不能依法进行系统的整改，将面临法律的制裁。</p><p>而在遗留系统开始构建的时候，可能就没有考虑太多的安全性。随着新的攻击手段越来越丰富，遗留系统的安全性越来越脆弱，企业也很难对此投资去专门改善安全性。</p><p>然后我们接着看缺乏甚至没有测试所造成的问题。在一个遗留系统上添加新需求简直如履薄冰，当你好不容易找到要修改的位置，敲了几行代码感觉可以了的时候，系统的另一个功能可能会因为你的这几行代码而崩溃。</p><p>而一个线上Bug想要找到元凶，可能会难如登天，一方面缺乏有效的日志难以定位（很多遗留系统的日志是打在命令行里的），另一方面修复了一个Bug也可能会导致更多的Bug。</p><p>这时就体现出自动化测试的重要性了。我不知道你的系统里有没有或者有多少测试，总之我在那个有着30000多个自动化测试的项目上修复一个Bug的过程是这样的：</p><p>1.先在本地复现Bug，找到产生这个Bug的业务场景；<br>\n2.为这个业务场景添加一个自动化测试并运行，发现这个测试是失败的；<br>\n3.修改代码，让这个新增的测试通过；<br>\n4.运行所有的测试，确保所有的测试通过。</p><p>经过这一系列操作，我就可以有十分有信心地宣布，这个Bug被我修复了，而且在目前测试覆盖的场景下没有引入新的Bug。但对于没有测试的遗留系统，在测试人员告知测试通过之前，我简直是胆战心惊。</p><p>那遗留系统落后的DevOps手段会造成哪些问题呢？</p><p>这会造成重大的安全隐患。像我前面举的那个例子，部署到生产环境的安装包是本地打出来的，就是非常严重的安全问题。不知你是否记得几年前著名的XCodeGhost事件，开发人员使用非官方渠道下载的注入了恶意代码的XCode，并用这样的XCode打包App，上传到了App Store上。结果下载了这种App的手机信息就被窃取了。</p><p>这里多说两句，这次事件延伸到我们的日常工作中也是有值得深思之处的。</p><p>一是不要从非官方渠道下载开发工具，但这个教训直到现在仍然没有引起足够的重视，仍然有很多团队使用的付费开发工具不是从官方渠道下载的。二是不要在开发机器上打包部署到非开发环境（特别是生产环境）上，要通过CI/CD来编译、打包和部署（当然CI/CD上的工具也必须是从官方渠道下载）。这就是DevOps的作用之一。</p><p>最后，技术和工具也可能存在很大的安全漏洞（比如前段时间爆雷的log4j）。新的系统虽然也存在这样的风险，但是非常容易补救。反观遗留系统的工具升级，那就举步维艰了，原因也很简单，投入产出比合不来。</p><p>另外，落后的技术和工具也使得遗留系统难以与新系统集成。基于Delphi、PowerBuilder、VB或Lotus Notes那一代的桌面应用，就是很好的例子。新的开发团队在面临遗留系统集成的时候，往往都是唯恐避之不及。这样的系统也使得自己所拥有的企业核心数据成为孤岛，难以与其他系统互联。</p><h2>什么是遗留系统？</h2><p>说了这么多，我们似乎已经有了一个很具体的关于遗留系统的画像了，参考如下：</p><p><img src="https://static001.geekbang.org/resource/image/29/e5/2956b29efbd201cf8ecabab096fe0ae5.jpg?wh=1920x840" alt="图片"></p><p>那是不是可以进一步抽象一下概念了呢？</p><p>很简单，不妨直接看看维基百科是如何定义的吧：</p><blockquote>\n<p>在计算机领域，遗留系统是一种使用旧的方法和技术的、过时的，却仍旧在使用的计算机系统。</p>\n</blockquote><p>而Gartner给出的定义是：</p><blockquote>\n<p>基于过时技术但对日常运营至关重要的信息系统。</p>\n</blockquote><p>嗯，有信息重合，我们找找关键字：<strong>旧的、过时的、重要的、仍在使用的</strong>……</p><p>这里找找对应的例子，辅助下理解。不知道你是否看过一些医疗类型的美剧，还记得发生危急情况时，医院是如何通知医生们的吗？是使用寻呼机——一个在现实生活中已经寿终正寝了快20年的古老的通信设备。</p><p>难道美国的通信设施如此落后吗？当然不是，诞生了iPhone和Android的美国怎么可能通信落后呢？真正落后的是医院的急救寻呼系统。这些系统往往有着六七十年的历史，很难被替换。它就完美符合上面的所有关键字：旧、过时、重要、仍在使用。</p><p>还有Windows XP系统，尽管它很经典，但微软在2014年就已宣布不再维护了。不过直到现在，我们仍然能在很多ATM机上看到它的踪影。</p><p>到这，我们已经完全明确了遗留系统的定义以及它所带来的问题，所以你觉得一个遗留系统还有保留的价值吗？为什么我们没有替换甚至丢弃，还要继续维护，并为其打上重要的标签呢？</p><h2>遗留系统的现代化价值</h2><p>原因有很多。首先，<strong>可能是成本太高了，企业不愿意投入资源去改进；也可能是因为积重难返，根本改不动。</strong>而遗留系统往往都是企业的核心业务系统，支撑着整个企业的业务运营，这样的系统就算问题再多，也是不可替代的。</p><p><strong>其次，遗留系统蕴含了大量的数据资产。</strong>遗留系统中的数据虽然很难与其他系统进行集成，但这部分数据的价值又是巨大的。企业的新系统常常不得不在这些数据的基础之上去构建，其他系统要想获得遗留系统中的数据，就必须对遗留系统进行修改，所以很多团队为了避免修改代码就会去寻求数据库层面的复制和同步，这也是一个选择。</p><p><strong>另外，遗留系统中还藏匿着丰富的业务知识。</strong>由于业务人员长期使用并且养成了习惯，很多软件系统已经与业务融为一体，很难区分哪些是真正的业务，哪些是系统的设计。而由于系统历时太久，已经失去了能够正确描述系统现状的文档，所以到最后只有遗留系统的代码才能够准确表达系统的行为，以及与之对应的业务知识。</p><p>系统改造，有可为有可不为，而对于遗留系统来说，结合其现代化价值，看上去更像是一种不得不为。所谓现代化，其实就是从代码、架构、DevOps和团队结构这四个方面来对遗留系统进行治理。</p><p>既然不能对遗留系统听之任之，我们就要下决心迎难而上，掌握主动权，否则当问题真正出现时就为时已晚了。</p><p>举个例子，疫情期间，美国大量人口失业，但上世纪80年代建造的失业系统无法及时发放失业福利，他们的国税局系统则更加老旧，是60年代建造的，总共需要20个星期的时间才能为符合条件的纳税人发放疫情补贴。</p><p>我们看到的是，在全球疫情这种黑天鹅事件发生时，一方面，高响应力的公司能够快速推出像疫情地图、行程码这种全新的服务，以造福社会服务大众；而一方面，陈旧的遗留系统却在拖着整个时代的后腿。</p><p>用巴菲特的话说就是，当潮水退去之后，你才知道谁在裸泳。</p><p>如果说不得不为，那怎么为之更好呢？</p><p>在数字化时代，每家企业都应该意识到科技是核心竞争力，要依赖科技去重塑业务、创造新的商业模式，创造数字化收益。也就是我们常说的Tech@Core。</p><p>很多互联网公司的数字化基因是与生俱来的，它们能够根据当前的形式和热点迅速地开启一个全新的商业模式并站稳脚跟。比如在疫情下买菜难的问题，很多公司就迅速推出了买菜App。</p><p>然而与此同时，对于传统企业来说，与上下游客户和供应商合作的数字化需求其实也是在不断增多的。以汽车保险这个行业为例，与车主、4S店、汽车制造商、交管系统等等合作方之间，存在着大量的互联需求，这里面有很多商机。一个有雄心的企业是不可能用一个落后的遗留系统去应对这些挑战的。</p><p><img src="https://static001.geekbang.org/resource/image/16/0b/165f49aa7fd90fdaa8133c72c120ea0b.jpg?wh=1920x1253" alt="图片" title="图片来源网络"></p><p>所以，迎难而上是必须的，让老旧、过时的遗留系统变得现代化也是必须的，这样才能更好地为企业的战略和运营服务。</p><h2>总结</h2><p>总结一下今天的内容。</p><p>我们从业界对遗留系统的定义中总结出了4个关键字：<strong>旧、过时、重要、仍在使用</strong>。然而人们对于遗留系统的认识存在一个普遍的误区，即时间长的系统就是遗留系统。</p><p>事实并非如此。有些系统时间虽长，但如果一直坚持现代化的开发方式，在代码质量、架构合理性、测试策略、DevOps等方面都保持先进性，这样的系统就像陈年的老酒一样，历久弥香。而有些系统虽然刚刚开发完成，但如果在上述几个方面都做得不好，我们也可以把它叫做遗留系统。</p><p>遗留系统在维护成本、合规性、安全性、集成性等方面都会给企业造成巨大的负担，但同时也蕴含着丰富的数据和业务资产。我们应该对遗留系统进行现代化，让它重新焕发青春。</p><p>那么遗留系统的现代化都包含哪些方面呢，<a href="https://time.geekbang.org/column/article/506570">下节课</a>我们就揭晓谜题。</p><h2>思考题</h2><p>如果你现在正工作在遗留系统上，你或你的团队最大的痛点是什么？你们又是如何解决这些痛点的？</p><p>期待你的分享，我们可以在留言区进行互动交流！如果今天的学习让你有所收获，也欢迎把课程分享给有需要的朋友，我们下节课再见！</p>',
        article_title: "01｜遗留系统之殇：为什么要对遗留系统进行现代化？",
      },
      {
        title: "02 | 遗留系统现代化：遗留系统的四化建设",
        id: 506570,
        content:
          '<p>你好，我是姚琪琳。</p><p>上节课，我们学习了什么是遗留系统，对于老旧、过时，但又十分重要、不可替代的遗留系统，听之任之只会埋下隐患，真正出现问题就为时已晚了。</p><p>不过在动手改造遗留系统之前，我们先要找准方向。其实相比遗留系统“治理”、“改造”，我们更强调的是“现代化（Modernization）”，也就是把遗留系统变为现代化的系统。这也是国际上更通用的提法。用“Legacy System Modernization”这个关键词，在Google上能搜到1380万条结果。</p><p>很多团队在对遗留系统进行“改造”或者“现代化”的时候，往往会陷入一个误区，就是盲目引入各种时髦的新技术，仿佛“新”就代表着“好”，就代表着方向正确。</p><p>比如我们耳熟能详、近年来愈发流行的微服务架构，有些团队也不管自己的项目适不适合，上来就把一个“大泥球”式的遗留系统肢解成了几十个微服务。更有甚者，一个遗留系统拆成了几百个微服务，有些甚至一张表的“增、删、查、改”居然被拆成了四个服务。架构似乎“现代化”了，运维人员却“哭”了。</p><p>那遗留系统现代化的正确方向到底是什么呢？结合上节课的分析，遗留系统在代码、架构、测试、DevOps方面存在诸多问题，我们在此基础上，将代码和测试合并（因为它们说的都是代码的质量），并引入开发团队这个维度，就得到了遗留系统现代化的四个方向：<strong>代码现代化、架构现代化、DevOps现代化和团队结构现代化</strong>。</p><!-- [[[read_end]]] --><h2>代码现代化</h2><p>代码现代化顾名思义，就是把遗留系统中丑陋的“祖传”代码重构成职责清晰、结构良好的优质代码。</p><p>之所以说遗留系统中的代码是“祖传”的，是因为它和其他祖传的东西类似，都是历史悠久、且不敢轻举妄动的。而之所以不敢轻举妄动，就是因为缺乏测试，无法快速验证修改的正确性。而大多数情况下，之所以没有测试，又是因为代码写得不可测。可测试的代码和代码的测试是相互依存的，其中一个做到了，另一个也很容易做到，而如果其中一个没有做到，另一个也必然无法做到。</p><p><strong>因此代码现代化的首要任务，就是对遗留系统的代码进行安全的可测试化重构</strong>。</p><p>在正常情况下，重构应该是在充分的自动化测试的保护下进行的。但对于没有测试的代码，我们只能“硬着头皮”去做一些相对来说比较安全的重构，将代码重构成可以写测试的程度，然后再补上大量的测试，进而在有充分测试覆盖的情况下，进行更广泛更深入的重构。</p><p>后面的课程我还会详细讲解如何进行可测试化重构，但在这里我想先举一个小例子，来让你有个感性认识。比如下面的代码，我想测试if的逻辑，当Dao的方法返回一个null时，这段代码会抛出一个异常。</p><pre><code class="language-java">public class EmployeeService {\n  public EmployeeDto getEmployeeDto(long employeeId) {\n    EmployeeDao employeeDao = new EmployeeDao();\n    // 访问数据库获取一个Employee\n    Employee employee = employeeDao.getEmployeeById(employeeId);\n    if (employee == null) {\n      throw new EmployeeNotFoundException(employeeId);\n    }\n    return convertToEmployeeDto(employee);\n  }\n}\n</code></pre><p>看到这样的代码，你可能会说，这质量还行啊，可读性不错，职责也比较清晰。的确是这样，但这样的代码却是不可测的。因为EmployeeDao内部会访问数据库，从中读取出一个Employee对象。而这个EmployeeDao是在方法内通过new的方式直接构造的，就意味着这个方法对EmployeeDao的依赖是固定的，无法解耦的。</p><p>要知道在单元测试中，我们是不可能直接访问真实的数据库的，因此要想测试这样的方法，只能先对它进行可测试化重构，也就是先将它重构为可测试的代码。</p><p>什么样的代码叫可测试的呢？比如下面这样：</p><pre><code class="language-java">public class EmployeeService {\n  private EmployeeDao employeeDao;\n  public EmployeeService(EmployeeDao employeeDao) {\n    this.employeeDao = employeeDao;\n  }\n\n  public EmployeeDto getEmployeeDto(long employeeId) {\n    Employee employee = employeeDao.getEmployeeById(employeeId);\n    if (employee == null) {\n      throw new EmployeeNotFoundException(employeeId);\n    }\n    return convertToEmployeeDto(employee);\n  }\n}\n</code></pre><p>通过这次重构，我们把会访问数据库的EmployeeDao提取成类的私有字段，通过构造函数传入到EmployeeService中来，在getEmployeeDto方法中，就可以直接使用这个EmployeeDao实例，不用再去构造了。由于传入的EmployeeDao并不是EmployeeService构造的，所以后者对前者的依赖就不是固定的，是可以解耦的。</p><p>如果我们传入EmployeeService的是一个new出来的EmployeeDao，那和原来的方法一样，仍然会去访问数据库；如果传入的是一个EmployeeDao的子类，而这个子类不会去访问数据库，那么getEmployeeDto这个方法就不会直接访问数据库，它就变成可测试的了。比如我们传入这样的一个子类：</p><pre><code class="language-java">public class InMemoryEmployeeDao extends EmployeeDao {\n  @Override\n  public Employee getEmployeeById(long employeeId) {\n    return null;\n  }\n}\n</code></pre><p>这样，想测试原方法中if的代码逻辑就非常方便了。</p><p>这里我们使用的重构手法叫做<strong>提取接缝（Extract Seem）</strong>，至于什么是接缝，以及还有哪些可测试化重构的手法先按下不表，后面课里我会细说，你先有个初步印象就好。</p><p>当代码可测了，我们就可以为它们添加足够的测试，提供质量保障。然后，在测试的保障下进行安全的重构。接下来要做的就是将“祖传”代码重构得让人耳目一新。当代码结构良好了，再实现下一个代码现代化的目标，也就是良好的分层结构。</p><h2>架构现代化</h2><p>遗留系统现代化的第二个方向是架构现代化。看到“架构现代化”这几个字，有些同学很自然地就想到了微服务架构或云原生架构。然而我们前面说过，新不代表正确。在团队的开发能力、DevOps能力和运维能力不足的时候，引入微服务，反而会将团队推向更痛苦的深渊。</p><p>有时候我们常常把软件系统比作一个城市，把系统架构和城市建设做类比。随着城市的发展和扩张，以前处于城市边缘的农村，反而会被周围新建的高楼大厦包裹成为一个城中村。治理这些城中村，就叫“改造老城区”。</p><p>有时候老城区的设计和规划会暴露出一些问题，不足以满足城市的发展。比如市政府通过一些集中的招商引资后，很多企业都要来这里建厂，但老城区显然没有足够的空间。这时候很多城市都会新建一个城区，有些地方叫开发区，有些地方干脆直接就叫新区。我们将这称之为“建设新城区”。</p><p>同样，遗留系统的架构现代化，我们也可以分成“改造老城区”和“建设新城区”两类模式。</p><p><strong>改造老城区模式是指对遗留系统内部的模块进行治理、让模块内部结构合理、模块之间职责清晰的一系列模式。</strong>前端方面包括单页应用注入、微前端等，后端包括抽象分支、扩张与收缩等，数据库端包括变更数据所有权、将数据库作为契约等。</p><p><img src="https://static001.geekbang.org/resource/image/03/41/038a1616b382744261c92ed7945e0c41.jpg?wh=3840x1859" alt=""></p><p><strong>建设新城区模式是指将遗留系统内部的某个模块拆分到外面，或将新需求实现在遗留系统外部的一系列模式。</strong>包括绞杀植物、冒泡上下文等。为了对新建立的新城区予以各种支持，老城区还可以通过提供API、变动数据捕获、事件拦截等各种模式，与新城区进行集成。</p><p><img src="https://static001.geekbang.org/resource/image/63/21/63015b42d785dd8328ef1a618624d521.jpg?wh=1920x992" alt="图片"></p><p>看到这么多专业名词，你可能应接不暇，别担心，后面课里这些内容都会详细展开。总之，只有“改造老城区”和“建设新城区”齐头并进，遗留系统架构的现代化版图才算完整。</p><h2>DevOps现代化</h2><p>代码和架构现代化了，DevOps的现代化也不能落后。它对项目的重要性不言而喻，如果没有现代化的DevOps平台，代码和架构现代化所带来的优势，就无法淋漓尽致地体现出来。</p><p>假如在代码和架构优化后，需求的开发时间缩短了一倍，那么大家对于新需求上线的时间点自然也有新的期待。然而落后的DevOps水平反而会让这个时间变得更长，因为单体架构变成微服务了，DevOps的难度增加了。</p><p>DevOps的历史虽然只有短短十几年，但最近几年的发展势头却很足。大大小小的公司都开始了DevOps转型，很多项目都声称自己建立了持续集成流水线，但实际上很多都是只见其形不见其神，只学其表不学其里。</p><p>而遗留系统的状况就更惨不忍睹了，它们几乎没有任何的自动化，或仅仅是一两句简单的构建命令。像我在第一节课里举的例子那样，在开发机上打包、靠人工用移动硬盘部署的项目还比比皆是。因此，遗留系统的DevOps现代化与其说是一种改进，不如说是从0到1的建设。这一部分可以和代码、架构的治理并行，甚至可以更早。先把平台搭起来，再逐步往上添加内容。对于大多数遗留系统来说，有一个可以对代码进行构建、打包的流水线，就已经是极大的进步了。</p><p>要从头开始搭建一个DevOps平台，包括代码、构建、测试、打包、发布、配置、监控等多个方面。这其中的代码和测试有一部分是和代码现代化重叠的，代码现代化的课里我会一并说给你听。剩下的几个部分再专门用一节课来详细讲述。</p><h2>团队结构现代化</h2><p>如果说代码、架构和DevOps的现代化还好理解的话，那这个团队结构现代化是个什么东西？其实很多时候，一个开发团队的结构是否合理，决定了这个团队的交付效率、产品质量，甚至项目成败，而很多人还没有对此产生足够的重视。</p><p>近年来有一本新书，叫做Team Topologies，中文直译就是团队拓扑。一上市便引起了不小的轰动。它将团队放到了软件开发的第一位，提出了四种团队拓扑结构和三种团队交互模式。四种团队拓扑包括业务流团队、复杂子系统团队、平台团队和赋能团队。三种团队交互模式包括协作、服务和促进。我们在进行开发团队的组织结构规划时，应该参考这四种团队拓扑。去年这本书的中文版——《高效能团队模式》也已经上市了。</p><p>我们对于团队结构的现代化，基本上是围绕这本书的内容展开的。因为我发现，遗留系统中团队的问题，有时比遗留系统本身更大。比如很多遗留系统可能只有一两个人在维护，在他们遇到困难的时候根本得不到团队的支持；再比如一些遗留系统的“老人”对系统比较熟悉，因此任何新启动的专项治理小组都会邀请他们加入，导致这些人的变动十分频繁，上下文切换的成本极其高昂。</p><p>团队拓扑不仅对遗留系统至关重要，对一个新系统如何组建开发团队、团队之间如何沟通协作也是至关重要的，后面我专门用一节课为你详细展开。</p><h2>小结</h2><p>今天我们学习了遗留系统的四个现代化。</p><p>也许你已经发现了，这样做本质上就是<strong>将先进的、现代化的软件开发方法应用到遗留系统上</strong>，让遗留系统重获新生、保持活力。是的，日光之下并无新事。遗留系统之所以成为遗留的，就是因为既缺乏现代化的软件开发方法，又没有随着潮流的发展而不断演进。<br>\n<img src="https://static001.geekbang.org/resource/image/c2/e4/c2c9b09b10109abec6189df04a8b5ee4.jpg?wh=9470x7437" alt="" title="遗留系统的四个现代化"></p><p>遗憾的是，这里还应该引入一个“需求现代化”，但是在权衡之后我将它删除了。因为一个企业里的需求方与开发方是不同的部门，要想进行需求的现代化，必然要让需求部门参与进来。然而国内很多企业的需求部门和开发部门，还无法亲密无间地展开合作。我们甚至有信心对开发部门内部的团队结构进行重组，但却没信心让需求人员改变工作习惯。</p><p>无论如何，在做到代码、架构、DevOps、团队结构四个现代化之后，遗留系统的现代化之路就算基本成功了。不过，在着手对这四个方面进行治理之前，我们还需要先掌握遗留系统现代化的三个原则。即：</p><p>1.以降低认知负载为前提<br>\n2.以假设驱动为指引<br>\n3.以增量演进为手段</p><p>这是我在工作中总结出来的，我们在遗留系统现代化中的许多举措，都符合这三个原则。忽视了它们，四个现代化之路很可能背道而驰。<a href="https://time.geekbang.org/column/article/507513">下节课</a>我们就从修改需求的场景出发，聊一聊为啥要遵循“以降低认知负载为前提”这个原则。</p><h2>思考题</h2><p>感谢你学完了这节课的内容，今天的思考题是这样的：</p><p>你所在的遗留系统架构是什么样的？如果是单体架构，是否打算将其拆分为微服务？打算怎么拆？如果是分布式架构（不一定是微服务），是如何运维的？</p><p>欢迎你在留言区留下你的思考，我们一起交流讨论。</p>',
        article_title: "02 | 遗留系统现代化：遗留系统的四化建设",
      },
    ],
  },
  {
    chapterTitle: "原则篇",
    children: [
      {
        title: "03｜以降低认知负载为前提：为什么遗留系统这么难搞？",
        id: 507513,
        content:
          '<p>你好，我是姚琪琳。</p><p>前两节课，我们分别介绍了为什么要对遗留系统进行现代化，以及遗留系统现代化的四个方向和三个原则。从这节课开始，我们将逐一讲解这三个原则。今天先来看看第一个原则：以降低认知负载为前提。</p><p>你可能会问，认知负载对改造遗留系统有什么帮助呢？别着急，学完这节课的内容，你自然就明白了。</p><h2>怎样理解认知负载？</h2><p>作为开发人员，不管是不是工作在遗留系统上，我想你都一定面临过来自业务方或项目经理的灵魂拷问：为什么这个需求这么简单，不过是多一项在下拉菜单，你们却开发这么长时间，要我做绝对不超过半天！言语中透露出一丝对于你工作能力的质疑，或是上班摸鱼的揣度。</p><p>然而实际情况真的如此吗？你恨不得翻出代码逐行展示给他看。来来来，你以为只是下拉框多了一项，实际上前后端都要加上；后端还要改五个服务，有两个我本地从未部署；搭环境调服务就用了一天，改代码修bug又是两天半；别问我为什么修了两天bug，因为实际上服务要改六个；我已经连续加班三个晚上，你要觉得你行下次你上……</p><p>玩笑归玩笑，但类似的battle我相信每个同学都经历过。你在面对这样的质疑时，内心肯定是很委屈的。但是你是否思考过这里面的真正原因？</p><p>你可能会说，是架构不合理，新增一个下拉项要改五六个服务；是DevOps工具不好用或根本没有，在本地部署新服务搭环境要很长时间；是系统知识严重缺失，不知道要改哪些地方以至于漏掉了一个服务……</p><!-- [[[read_end]]] --><p>虽然这些问题确实增加了工作难度，但是对于项目上的老人不是这样啊，他们改起来仍然游刃有余，没部署过的服务也能轻松调通。你可能会辩驳，这是系统太复杂，对新人不友好，而老人都已经熟悉了。</p><p>是的，没错，你说对了。但这里面有个更专业的术语，叫做认知负载。认知负载（Cognitive Load）是认知心理学家John Sweller在上世纪80年代所创建的理论，是指从事一件工作所要使用的脑力劳动的总和。简单来说，就是你可以用认知负载衡量你牺牲了多少脑细胞。</p><p>认知负载一共分为三种类型，内在认知负载、外在认知负载和相关认知负载。对于它们的定义和对比，我汇总了一张表。</p><p><img src="https://static001.geekbang.org/resource/image/6a/9b/6a9fdcc5da58e60c384d12ccd57e819b.jpg?wh=4000x1820" alt=""></p><p>从表中我们可以看到，内在认知负载是你掌握一门技能所必须要付出的努力，虽然不同的技能难度不同，但只要选择了一个，它的大小就固定了，掌握得不够必然就无法胜任工作。外在认知负载是信息的呈现方式，是我们着重要降低的，信息的呈现自然应该越简单越好。而相关认知负载是在构建概念时要了解的知识，是要尽可能增加的，因为这些知识越多越有利于我们的工作。</p><p>也就是说，<strong>我们要完成一项工作，就要在内在认知负载一定的前提下，尽量减少外在认知负载，增加相关认知负载</strong>。以软件开发为例，要完成这项工作，就要在掌握开发技能的前提下，尽量简化与开发需求本身无关的细节，而去了解尽可能多的业务知识。</p><p>看到这里，你就能充分理解为啥架构不合理、DevOps工具不好用以及系统知识匮乏，都会导致你改个“芝麻大”的需求都要加班加点，没错，罪魁祸首就是外在认知负载。</p><p>结合前面的例子，我们逐一分析：一个小需求都要改很多地方，说明模块划分时，可能一起发生变化的部分没有内聚在一起，而是分离到了不同模块和层级，架构向开发者呈现系统的方式过于复杂，增加了外在认知负载；DevOps工具不好用，意味着工具向开发者呈现的部署任务方式太复杂；同理，没人能把一个需求要改哪些地方都说清楚，说明系统知识早已藏身代码深处，不陪葬一把头发深入研究代码，别想拿到这些知识。</p><p>而项目里的“老人们”早已经消化掉了这些外在认知负载。我相信他们在刚加入项目时，也一定经历过你的这些崩溃时刻。</p><p>还有一点就是，有些时候一些知识或实践，看上去在当下增加了外在认知负载，但实际上长远来看，是可以大大降低外在认知负载的。</p><p>比如测试驱动开发，一开始上手的时候，绝大多数开发人员可能都不会写代码了，软件开发的外在认知负载一下子大了很多。但如果你把它当做一项技能（也就是内在认知负载）去不断学习、刻意练习的话，熟能生巧之后，就会大大降低写代码的整体认知负载，而且还提升了软件的质量（因为有很多自动化测试），降低了业务知识获取的难度（测试可以看成是有效的文档）。</p><h2>遗留系统中的认知负载</h2><p>那么遗留系统中的外在认知负载都有哪些呢？第一节课我们介绍过遗留系统的特点，代码质量差、架构不合理、测试不充分、DevOps水平低，其实都会导致外在认知负载增加。</p><p><strong>不过，留系统最大的认知负载其实是无处可寻的业务知识。</strong>我们第一节课介绍过，遗留系统中的蕴含着丰富的业务资产，但由于种种原因，导致这个资产并不那么容易获得。</p><p>遗留系统在构建的时候，往往会有成百上千页的需求、设计文档，这些的确能准确描述当时的系统状态。然而随着时间的更迭、需求的演化，当前的系统已经和构建时不可同日而语，且不同阶段的文档往往无法很好地保留下来，这就造成了业务知识的缺失。</p><p>即使所有文档都保存完好，也很难有人能完完整整地阅读下来。而且，也没有人能保证系统的实现和文档的描述是完全吻合的。</p><p>你可能会问，不是还有人吗？去问问需求人员或者业务分析人员啊。遗憾的是，对于时间不太长的遗留系统，也许还能找到人，但稍长一点的，可能人影都找不到了。有的离职了，有的升职了，有的可能是第三方供应商开发的，现在已经不合作了。即使有些知识可以在开发人员之间口口相传下来，但是也是严重失真的，没人能确保它的正确性。</p><p>下图是事件风暴的发明者Alberto Brandolini在讲述知识的分布时用到的图，我想它也同样适合描述知识传递过程。结合图片可以看到，有些知识只有曾经工作在它上面的某一个人知道，有些知识得去问Bob，而有些知识就像一个谜。</p><p><img src="https://static001.geekbang.org/resource/image/eb/21/eb807c20f9bb7b0d25dd9b23ab0bf521.jpg?wh=1920x1016" alt="图片"></p><p>如果系统中包含自动化测试，尤其是那种描述一个端到端业务的自动化测试，某种意义上是可以被看作有效文档的。但对于遗留系统来说，这样的测试太罕见了，不提也罢。</p><p>很明显，想通过历史文档、咨询相关者，以及自动化测试等手段理清业务，都不靠谱。其实，要想捋清一个遗留系统的业务，唯一有效的方式就是“扒代码”。</p><p>把代码掰开揉碎了仔细阅读，弄清楚每一行的意图，直到搞清楚这一块代码所要表达的业务逻辑。但这种方法同时又是非常低效的，因为遗留系统的代码质量往往惨不忍睹，想靠人工的方式来梳理代码理清业务，是几乎不可能完成的任务。</p><p>经过这一番描述，你应该弄清楚了遗留系统中业务知识难以获取的原因。因为它们是以“质量很差的代码”这种形式向人呈现出来的，因此有着非常高的外在认知负载。</p><p>这里你可能会有疑问，前面不是还说业务知识是相关认知负载，需要增加吗？这里为什么又说业务知识是遗留系统最大的认知负载，需要降低呢？其实这里说的，隐藏在遗留系统隐秘角落的业务知识，是指它们呈现的方式不友好，提高了外在认知负载，而这恰恰是我们需要降低的。</p><p><strong>遗留系统的第二大认知负载，是同样难以获取的系统知识</strong>。这里的系统知识是指系统的具体实现细节，包括模块的划分、架构的取舍，以及每一个技术决策的原因。这些知识也同样很难有文档可以一窥究竟，更遗憾的是，连代码都无法体现出每一个细节。</p><p>给我印象深刻的是我曾经治理的一段代码，有一行用Thread.sleep(5000)等待了5秒钟。我问遍团队的每一个人，都不知道这行代码的用意，于是就当做无用代码删掉了。没想到几天之后系统崩溃了，原来这行代码的前面几百行，有一处调用链很深的代码触发了一个后台任务，等待5秒钟的目的就是等这个后台任务跑完，然后后面的代码就可以用这个后台任务所生成的数据了。删掉这行等待代码，后续的代码就失败了。</p><p>还记得我第一节课的吐槽吗？糟糕的代码各有各的糟糕之处。但这段代码的问题并不在于它有多糟糕，而是在于没有人知道它为什么糟糕。这种代码存在于系统之中，就带来了非常高的外在认知负载。</p><p>这些高认知负载的系统知识，会导致我们的需求开发走向“魔改”。所谓“魔改”，就是魔幻般地修改，这种情况下，没人能说清楚一个新需求应该改哪里，更没法保证改了这些，是否就覆盖了全部要改的内容。</p><p>至此，我们已经知道了遗留系统之所以这么“难搞”，就是因为过高的外在认知负载。人们在遗留系统上工作的时候，所付出的脑力劳动比正常系统要多得多，因此只要能大致测试通过，就会凑合着上线，而没有精力去偿还欠下的债务、改善外在认知负载。如此恶性循环，导致遗留系统的外在认知负载越来越高，修改起来越来越难。</p><p>我们进行遗留系统的整治，其实就是要尽力降低遗留系统的外在认知负载。外在认知负载降低了，开发起来容易了，痛点自然就解决了。</p><h2>以降低认知负载为前提</h2><p><strong>以降低外在认知负载为前提的意思就是，我们进行遗留系统现代化时，所做的任何举措都应该是能够降低外在认知负载的</strong>。</p><p>现在回顾<a href="https://xn--yfr16a528c0pp4fap15gjp7o">第二节课</a>的“四化建设”——代码现代化、架构现代化、DevOps现代化和团队结构现代化，你会发现这四大方向其实都有利于降低团队外在认知负载。</p><p>比如对代码进行重构、改善代码的可读性，可以降低阅读代码的难度，实际上就是降低代码的认知负载；对单体架构进行拆分，分解成多个小的、更加内聚的微服务，每个服务可以独立部署和演进，实际上就是在降低业务和系统的认知负载；还有优化持续集成流水线，让开发人员提交代码之后就不必随时关注后续的步骤，轻装上阵；再比如对团队结构进行优化，让每个团队只关注少量大小适中的业务模块，以降低认知负载。</p><p>没错，降低认知负载这一原则不光能作为方向指引，落到微观操作层，同样能帮助你科学预判改造过程中的每个决策。</p><p>比如在进行微服务拆分时，是应该先对代码进行模块化分解，再进而拆分出独立的服务，还是应该直接拆分出服务，再对耦合的部分进行解耦呢？代码分层改造时，是应该改造成分层架构，还是六边形架构或整洁架构呢？优化分支策略时，是应该基于主干开发，还是应该使用特性分支呢？前端应该改造成React还是Vue？改造过程如何回退？</p><p>在遗留系统现代化的过程中，如果以常规的技术视角去看待上述问题，可能很多类似的技术决策都很难找到具有说服力的依据，最后只好拍拍脑袋，随便决定一个，或者看架构师自己的喜好。实际上只要我们掌握了“降低外在认知负载”这个原则，我们就可以把技术性的问题轻松转换成人的问题，然后去分析看看，到底哪个选项更有利于降低团队的认知负载，更容易被团队所接受，更容易实现。</p><p>很多时候，遗留系统的现代化项目以失败告终，或举步维艰，都是因为很多决定和举措非但不能降低认知负载，反倒增加了认知负载。以高认知负载的方案去解决高认知负载的问题，最终必将导致项目做不下去，人也疲惫不堪。</p><p>其实<strong>不止是遗留系统现代化，我们所有的工作都应该尽量去降低外在认知负载，从而简化工作本身</strong>。</p><p>比如敏捷开发方法就是一套很好的可以降低外在认知负载的方法。几个月甚至几年的交付周期，所承载的内容会让人不堪重负；而只有两周的迭代，则能让人轻装上阵。一份动辄几百页的需求文档，会让人不知所措；而只有一两页的故事卡，则能让人更轻松地聚焦于眼前的工作。</p><p>领域驱动开发（DDD）也是行之有效的降低外在认知负载的方法论。形成统一语言、拆分限界上下文，都是为了使沟通更加容易、工作更加聚焦。还有目前大厂比较流行的研发工程效能，其本质说白了也是为了降低外在认知负载。</p><p>从这个角度出发，灵活应用这个原则，以前很多悬而未决的疑难杂症，很多靠“视情况而定”、“具体问题具体分析”等“托词”搪塞过去的问题，是不是一下子就豁然开朗了？</p><h2>总结</h2><p>总结一下今天的内容。我们介绍了认知负载的三个分类：内在认知负载、外在认知负载和相关认知负载。我把它们的特点以及和软件开发特别是遗留系统的关系总结一下，方便你复习：</p><ul>\n<li>内在认知负载是指从事一项工作必须付出的努力，比如学习Java知识、前端知识等；</li>\n<li>外在认知负载是指知识呈现的形式，代码越糟糕、越难读，外在认知负载越高；</li>\n<li>相关认知负载是指人们要学习一个知识所要付出的努力，在软件开发领域就特指业务知识。<br>\n<img src="https://static001.geekbang.org/resource/image/ce/8e/ce4b36145ce6ca0f6f5da1e139a3208e.jpg?wh=1920x991" alt="图片"></li>\n</ul><p>其中，外在认知负载是我们最痛恨的，一定要尽可能地降低。我们在做遗留系统现代化的时候，所有的决策在制定之前都要思考一下，是否有利于降低当前的外在认知负载。可以说，将遗留系统的外在认知负载降到最低，遗留系统的现代化工作也就完成了。</p><p>为了方便后面课程的讲述，我将统一用“认知负载”来代替具体的分类。至于到底是哪一种类型的认知负载，就不是那么特别重要了。你只需要判断一下，<strong>当前这个事物、活动、决策所增加的认知负载是否更有利于我们完成当前和以后的工作</strong>。如果有利（比如学习更多的业务知识），就增加这种认知负载；如果不利（比如读一篇晦涩难懂的需求文档），就减少这种认知负载。</p><p><a href="https://time.geekbang.org/column/article/508559">下一节课</a>我们就来看看在遗留系统中，如何来降低业务知识和系统知识难以获取的认知负载。</p><h2>思考题</h2><p>感谢你认真学完了这节课的内容，今天的思考题是两道开放式的问题：</p><p>1.你项目上的分支策略是什么样的？是基于主干开发，还是特性分支，或者其他分支策略？你认为哪种方式更能降低外在认知负载？</p><p>2.你项目上的哪些实践是有意无意地降低了外在认知负载的？又有哪些实践增加了外在认知负载？</p><p>欢迎你在留言区留下你的思考，我们一起交流讨论。也欢迎你把这节课分享给其他工作在遗留系统上的朋友，让我们一起帮助他们走出泥潭。</p>',
        article_title: "03｜以降低认知负载为前提：为什么遗留系统这么难搞？",
      },
      {
        title: "04 | 如何降低认知负载：活的文档能救命",
        id: 508559,
        content:
          '<p>你好，我是姚琪琳。</p><p>在第三节课，我带你了解了认知心理学中的一个概念——认知负载。这个看似与软件开发毫无瓜葛的知识，实际上却决定了软件系统的成败。因此在遗留系统现代化中，我们把“以降低认知负载为前提”作为首要原则。</p><p>有些同学这时就会问了，你总说认知负载如何如何，降低认知负载又是多么重要，那怎么才能真正降低认知负载呢？别着急，我们今天就来看看有哪些方法能降低认知负载。其中最重要的工具，就是活文档。</p><h2>什么是活文档</h2><p>活文档（living document），顾名思义，就是指活着的文档，也就是<strong>在持续编辑和更新的文档，有时候也叫长青文档或动态文档。</strong>比如维基百科中的一个词条，随时都有人更新和维护，这就是一个活文档。与之相对的是静态文档，也就是一旦产生就不会更新的文档，比如大英百科全书中的一个条目。</p><p>你可以想象一下，在软件开发过程中，无论是瀑布模式还是敏捷，我们拿到的需求文档或故事卡是“维基百科”还是“大英百科”呢？我想大多数情况可能是，在最终需求还没有敲定时还是“维基百科”，也就是还会随时更新，而一旦敲定开始开发后，就变成了“大英百科”，再也不会更新了吧。</p><p>然而随着需求的不断叠加，“大英百科”作为当时系统的一个“快照”，早就已经失去了时效性。只有将不同时段、不同模块的文档片段合并在一起，才能得到当前系统的快照。但这个合并放在现实中是很难操作的。</p><!-- [[[read_end]]] --><p>正是因为发现了这样的问题，《实例化需求》一书的作者Gojko Adzic将活文档的概念引入到了软件开发当中；而去年出版的《活文档——与代码共同演进》一书，又在此基础上对活文档如何落地做了系统指导。我强烈建议你读一下这两本书，虽然它们的出版相隔近10年，但讲述的内容却一样非常有帮助。</p><p><img src="https://static001.geekbang.org/resource/image/bf/3f/bff365a6ea8e9f2207acdb03cd25123f.jpg?wh=1920x1168" alt="图片"></p><h2>如何用活文档挖掘业务知识</h2><p>了解了活文档的概念，我们来看一下它是如何降低遗留系统的认知负载的。</p><h3>为遗留代码添加注解</h3><p>先来看看下面这段虚构的遗留代码（抱歉我实在编不出更糟糕的代码了……），在没有任何文档的情况下，我们如何理解这段代码的意思呢？</p><pre><code class="language-java">public class EmployeeService {\n  public void createEmployee(long employeeId) { /*...*/ }\n  public void updateEmployee(long employeeId) { /*...*/ }\n  public void deleteEmployee(long employeeId) { /*...*/ }\n  public EmployeeDto queryEmployee(long employeeId) { /*...*/ }\n  public void assignWork(long employeeId, long ticketId) {\n    // 获取员工\n    EmployeeDao employeeDao = new EmployeeDao();\n    EmployeeModel employee = employeeDao.getEmployeeById(employeeId);\n    if (employee == null) {\n      throw new RuntimeException("员工不存在");\n    }\n    // 获取工单\n    WorkTicketDao workTicketDao = new EmployeeDao();\n    WorkTicketModel workTicket = workTicketDao.getWorkTicketById(ticketId);\n    if (workTicket == null) {\n      throw new RuntimeException("工单不存在");\n    }\n\n    // 校验是否可以将员工分配到工单上\n    if ((employee.getEmployeeType() != 6 &amp;&amp; employee.getEmployeeStatus() == 3)\n          || (employee.getEmployeeType() == 5 &amp;&amp; workTicket.getTicketType() == "2")) {\n      throw new RuntimeException("员工类型与工单不匹配，不能将员工分配到工单上");\n    }\n\n    if (!isWorkTicketLocked(workTicket)) {\n      if (!isWorkTicketInitialized(workTicket)) {\n        throw new RuntimeException("工单尚未初始化");\n      }\n    }\n    \n    // ...\n  }\n\n  public void cancelWork(long employeeId, long ticketId) { /*...*/ }\n}\n</code></pre><p>如果每个方法都很长，这样一个类就会愈发不可读，从中理解业务知识的难度也越来越大，这就是我们上节课提到的认知负载过高。</p><p>如果把这种代码转化为下面的脑图，是不是一下子就清晰许多了呢？</p><p><img src="https://static001.geekbang.org/resource/image/7f/c0/7f5908e2cef28e5063d855207648f4c0.jpg?wh=1920x1371" alt="图片"></p><p>阅读代码时，我们是以线性的方式逐行阅读的，这样的信息进入大脑后，就会处理成上面这样的树状信息，方便理解和记忆。但当代码过于复杂的时候，这个处理过程就会需要更多的脑力劳动，导致过高的认知负载。</p><p>我们可以通过在代码中加入活文档的方式，来降低认知负载。其实要得到上面的脑图，只需要在代码中加入一些简单的注解：</p><pre><code class="language-java">@Chapter("员工服务")\npublic class EmployeeService {\n  @Doc("员工创建")\n  public void createEmployee(long employeeId) { /*...*/ }\n  @Doc("员工修改")\n  public void updateEmployee(long employeeId) { /*...*/ }\n  @Doc("员工删除")\n  public void deleteEmployee(long employeeId) { /*...*/ }\n  @Doc("获取员工信息")\n  public EmployeeDto queryEmployee(long employeeId) { /*...*/ }\n  @Doc("给员工分配工单")\n  public void assignWork(long employeeId, long ticketId) { /*...*/}\n  @Doc("撤销工单分配")\n  public void cancelWork(long employeeId, long ticketId) { /*...*/ }\n}\n</code></pre><p>然后，我们编写一个工具，它可以基于这些注解来生成根节点和二级节点，并将方法中抛出的异常作为叶子节点。</p><p>这么做的原因是，虽然遗留系统中的很多文档和代码注释已经不是最新的了，但这些异常信息往往会直接抛出去展示给用户看，是为数不多的、可以从代码中直接提取的有效信息。</p><p>当然这样做也有一定局限性，因为异常信息中可能包含一些运行时数据。比如“ID为12345的员工不存在”这样的异常信息，是由“ID为 + employeeId + 的员工不存在”这样的字符串拼接而成，静态扫描字节码，是无法得出这些运行时数据的。但即使只在叶子节点中显示“ID为 %s 的员工不存在”这样的信息，也已经非常有用了。</p><p>通过这样的工具，我们可以把一个非常复杂的业务代码，转化为下面这样的脑图（为了过滤掉敏感信息，我故意将图片做了模糊处理）。</p><p><img src="https://static001.geekbang.org/resource/image/3f/28/3fa116f8091ed99234edc4f2ef21bb28.jpg?wh=574x506" alt="图片"></p><p>这段业务代码总共有5000多行，一行一行地去阅读代码会让人抓狂，但有了这样的脑图，认知负载简直降低了一个数量级。</p><p>看到这里，你一定对这个工具十分感兴趣了。但是很遗憾，这个自研的工具目前还没有开源。一旦开源，我将在专栏写一篇加餐，详细介绍这个可以解救你于水火的工具。</p><p>不过它的原理其实十分简单，想必你也已经猜到了，就是扫描Java字节码，获取到用注解标记的代码，然后再进一步分析得到异常信息，组织成树形结构，再生成一些中间文档，并通过一些绘图引擎绘制出来。</p><p>在实际操作过程中，只需要有一个人通读一次代码，哪怕花上几个礼拜的时间，但只要能理出一个业务模块的基本逻辑，添加上注解，就可以通过图形化的方式来展示代码结构。其他人不需要再次这么痛苦地阅读代码了，可谓一劳永逸，效率会大大提升。</p><p>这么做还有一个好处是，当新的需求来临时，开发人员可以迅速定位到要修改的地方，不需要再去扒一遍代码了。传统的代码和文档最大的问题是，代码是代码，文档是文档，彼此分离。</p><p>代码和文档的关联关系储存在开发人员脑子里，这样认知负载比较高。当开发人员看到一份新的需求文档时，需要搜索一下脑子里的记忆，才能想起来这部分内容是在代码的什么位置。</p><p>然而人脑不是电脑，这种记忆是十分不靠谱的，搜索定位的过程也十分低效。而上面这样的脑图就和代码很好地结合了起来，可以说找到文档，就找到了代码，非常有效地降低了认知负载。</p><p>这么做的第三个好处是有利于团队协作。业务分析师、开发人员、测试人员都可以围绕这样一份文档来讨论需求、设计测试用例。</p><h3>实例化需求最好的工件就是活文档</h3><p>除了在代码中添加注解，并分析代码生成各种可视化的图表之外，用实例化需求的方式编写的测试也是一种活文档。所谓实例化需求，实际上指的是<strong>以现实中的例子来描述需求，而不是抽象的描述</strong>。</p><p>怎么理解呢？在生活中我们会遇到很多文字描述，比如产品说明书、合同文本、法律法规等。这些描述大多数时候都是抽象的，普通人读起来很难理解，甚至引起歧义。如果抽象的说明能够配几个具体的示例，认知负载就会大大降低。软件开发中的需求描述也是如此。</p><p>让我印象非常深刻的是，在刚加入Thoughtworks没几天的时候，曾经跟着BA和其他开发人员找客户对一个关于用户权限的需求，大概是不同的用户在不同的场景下，能看到一个页面中的哪些字段。</p><p>那位BA没有像我之前见过的BA那样，写一大篇文档，而是简单地把界面打印了出来了好几张，每张纸上注明场景，用马克笔把不能看到的字段打个大叉划掉。</p><p>就这样，他用最简单的方式，在5分钟内就快速确认了所有的需求，客户也对这种直观的方式非常满意。这些纸随后就给了我们开发人员，我们根本没必要再去看需求文档了，因为需求已经以如此实例化的方式展示给我们了。</p><p>这就是典型的实例化需求。我们在开发时，可以将这种需求转换为测试，这种以实例化方式描述的测试，也是一种活文档。它们不但很好地展示了业务知识，而且是随代码更新的。</p><p>比如上面的给员工分配工单的例子，按实例化需求的方式，可以写出一系列组织良好的测试，如下所示：</p><pre><code class="language-java">@Test\npublic void should_be_able_to_assign_work_to_an_employee() {}\n@Test\npublic void should_not_assign_work_to_when_employee_not_exist() {}\n@Test\npublic void should_not_assign_work_when_ticket_not_exist() {}\n@Test\npublic void should_not_assign_work_when_employee_type_and_ticket_type_not_match() {}\n@Test\npublic void should_not_assign_work_when_ticket_is_not_initialized() {}\n</code></pre><p>怎么样？是不是一目了然？其实我们就是将需求文档的描述转换成了测试的方法名。</p><p>读到测试，就相当于读到了需求文档；测试通过，就相当于需求完成了。以后如果需求有了变更，只需要同步修改测试的名称即可。这时候，测试是和代码共同演进的，也就是活文档。</p><p>在某些框架下运行上面的测试，还能帮我们去掉中间的下划线，这就更像是文档了。如果愿意，你还可以用中文去写方法名，阅读起来会更友好，尽管我强烈建议不要这样做。我们在后面讲到代码现代化的时候，再来详细讨论单元测试如何编写和组织。</p><p>如果一个遗留系统的每个功能都具有这样的测试，那么业务知识也就不再难以获得了，整个系统的认知负载也没有那么高了。</p><h2>用依赖分析工具展示系统知识</h2><p>工具除了能挖掘业务知识，还能揭示系统知识。我们在<a href="https://time.geekbang.org/column/article/507513">上一节课</a>讲过，遗留系统的两大认知负载，是无处可寻的业务知识和难以获取的系统知识。经过多年的腐化，类与类之间、包与包之间、模块与模块之间、服务与服务之间分别是什么样的依赖关系呢？</p><p>这就好像我们来到一个陌生的城市时，对这个城市的行政区域、大街小巷都不了解。如果我们想从一个地方到另一个地方，应该怎么办呢？最好的办法就是搞一张当地的地图（当然你也可以用地图App），有了地图的指引，就不会迷路了。</p><p>同样，我们可以通过<strong>依赖分析工具</strong>，建立一张遗留系统的地图，这样就可以快速知道一个业务是由哪些模块组成的。市面上存在很多做系统依赖分析的工具，如Backstage、Aplas、Honeycom、Systems、Coca等等。感兴趣的同学可以去了解一下。</p><p><img src="https://static001.geekbang.org/resource/image/f3/19/f3dc7f21a847c81fd95dc335751dbc19.jpg?wh=1920x1263" alt="图片" title="图片来自Aplas官网"></p><p>但我们也会发现，有时这些工具并不能解决我们的全部问题。比如在做系统的数据拆分时，我希望知道一个API调用都访问了哪些表，从而评估工作量。这种定制化的需求很多工具都无法满足，不过不要灰心，发挥我们开发人员优势的时候又到了。没有轮子，我们就造一个出来。</p><p>其实这种根据入口点获取表名的逻辑并不复杂，只需要遍历语法树，把所有执行SQL语句的点都找出来，然后分析它的语句中包含哪些表就可以了。</p><p>对于<strong>存储过程或函数</strong>，我们也可以找到执行它们的点，获得存储过程或函数的名称，然后再根据名称找到对应的SQL文件，再做类似的分析。当然，这要求我们首先要治理好编写在数据库中的存储过程和函数治理，将DDL（Data Definition Language）迁移到代码库中，进行版本化。这样分析工具定位起来才方便。</p><p>对于<strong>复杂的入口方法</strong>，你可能会得到一幅相当大的列表或脑图，它虽然能列出全部内容，但读起来仍然很费劲。这时候我们有两个办法。一是重构复杂的入口方法，抽取出若干小的方法，再以小方法为入口点做分析。二是修改分析工具，直接分析存储过程或函数。如果存储过程或函数过大，也可以进一步拆分。</p><p>除此之外，我们还可以提出很多有用的需求，继续改进分析工具。比如分析不同模块之间所依赖的对方的表有哪些，这对于数据拆分也是非常有帮助的。</p><h2>总结</h2><p>今天我们学习了降低认知负载的一种非常有用的方法：活文档。很多同学可能是第一次听说这个概念，但如果你的项目里用实例化需求的方式去组织单元测试，你其实已经在使用活文档了。</p><p>虽然遗留系统中可能没有太多的测试，但我们仍然可以通过向代码中添加注解的方式来编写活文档，并通过工具来实现图形化展示，将遗留系统中无处可寻的业务知识暴露在你面前。</p><p>除此之外，我们还可以使用依赖分析工具来挖掘系统知识，同样也可以用图形化的方式来帮助我们理清系统内的依赖关系。这对我们开发新需求或推动代码和架构的现代化都非常有帮助。</p><p>能够降低认知负载的方法、工具和实践还有很多，我们后面的课再慢慢介绍吧。</p><p>《活文档》这本书在介绍遗留系统的“文档破产”时，是这样描述遗留系统的，我也想把这段话分享给你：</p><blockquote>\n<p>遗留系统里充满了知识，但通常是加密的，而且我们已经丢失了秘钥。没有测试，我们就无法对遗留系统的预期行为做出清晰的定义。没有一致的结构，我们就必须猜测它是如何设计的、为什么这么设计以及应该如何演进。没有谨慎的命名，我们就必须猜测和推断变量、方法和类的含义，以及每段代码负责的任务。</p>\n</blockquote><p>虽然遗留系统是“文档破产”的，是“加密”的，但是只要我们掌握了活文档这个“破译工具”，就可以一步一步破解出那些隐匿在系统深处的知识。</p><h2>思考题</h2><p>感谢你学完了这节课的内容。我想此刻的你，一定会对课程中提到的活文档工具十分感兴趣。今天的思考题就请你来分享一下，如果是你，会如何设计和开发这样的一个工具呢？</p><p>欢迎你在评论区留下你的观点，我会尽量回复你们的问题。也欢迎你把文章分享你的朋友和同事，让我们一起来降低认知负载。</p>',
        article_title: "04 | 如何降低认知负载：活的文档能救命",
      },
      {
        title: "05 | 以假设驱动为指引：如何评价遗留系统的现代化成果？",
        id: 509535,
        content:
          '<p>你好，我是姚琪琳。</p><p>前两节课，我们学习了遗留系统现代化的第一个原则：以降低认知负载为前提，以及能够显著降低认知负载的利器——活文档。今天我们就来看看遗留系统现代化的第二个原则：<strong>以假设驱动为指引</strong>。</p><p>我们很多人在做遗留系统现代化的时候呢，总觉得它是一个十分复杂的技术问题。本来嘛，无论是代码的重构、架构的拆分，还是DevOps平台的搭建或技术栈的升级，无一不是技术活动。</p><p>下面我来分享一个我早年间的经历，看看能不能颠覆你的想法。</p><h2>脱离业务的技术改进都是耍流氓</h2><p>十年前，我曾经试图去主导一次技术改进，希望将一个遗留系统上的JDK从1.4升级到5。你可以想象一下，使用Java 1.4开发是一个什么样的情形，没有stream、没有泛型，甚至没有枚举，实现一个简单的功能都需要好几行代码（当然现在的Java也没好到哪去……），在这样的项目上工作简直痛不欲生。</p><p>我当时做了充分的调研，制定了详细的计划，以确保升级过程的平滑。然而这样一个看起来很“正常”的改进却被部门领导叫停了。</p><p>他的理由是，系统刚刚上线不久，一两年内不会有很多的新需求，旧JDK导致的开发痛点并不明显。而业务方也没有明确提出，未来要提升开发效率以支撑更多的需求。所以，这样的改进，虽然看上去在技术上十分必要，但在业务上优先级却没那么高。</p><!-- [[[read_end]]] --><p>这番话一语点醒梦中人。在“怎么改”这件事儿上，我当时的确做了不少功课，但偏偏“要不要改”这个关键问题脱离了业务，所以成了单方面的“技术自嗨”。这种改进虽说从技术上看十分必要，但业务上优先级却没那么高。</p><p>这个翻车案例告诉我们，<strong>技术要为业务服务。</strong>业务不需要的话，技术升级没有任何意义。做好了，业务方面也感知不到；做不好，很有可能导致项目失败，可谓费力不讨好。</p><p>那么，到底如何做，才能让技术更好地为业务服务呢？</p><p>如果一个遗留系统平时用的人不多，需求也不多，一两个开发人员完全能够应付得来，这种情况还需要技术的更新换代吗？其实对于这样的系统，最好的方案就是保持原样，根本不需要做什么升级和优化，因为它所带来的业务价值太小，投入产出比过低。</p><p>但面对使用人数众多、需求纷至沓来的遗留系统，想要让业务方充分感知到技术迭代带来的好处，又该怎么办呢？这时候假设驱动的方法就派上用场了。我们先说说假设驱动是什么，又该怎样应用。</p><h2>什么是假设驱动？</h2><p>假设驱动实际上是一种科学的研究方法，在面对一个问题时，我们先要分析问题，然后试着提出一种阐述或者假设，去解释我们的发现。接着就到了实验环节，如果实验结果满足假设，就证明我们的理论是正确的。</p><p>假设驱动的思想在数学、物理、生物等科学领域都是十分常见的方法，比如哥德巴赫猜想、量子力学等，最初都是通过假设的方式提出来，并在后期通过实验加以证明或验证的。</p><p>实验是科学研究的基础，但并不是只有在实验室里才能做。在软件开发领域，我们同样可以做实验，这就是<strong>假设驱动开发（Hypothesis-Driven Development，简称HDD）</strong>。</p><p>《持续交付》的作者Jez Humble曾经说过：</p><blockquote>\n<p>“验证业务模式或产品理念的最低效的方法，是构建完整的产品以查看设想中的需求是否真实存在”。</p>\n</blockquote><p>我们在构建一个产品或功能之前，应该先扪心自问：“我们应该构建它吗？理由是什么？”然后开展最廉价、最快速的实验，通过用户研究，验证设想的功能是否会产生预想的业务成果。</p><p>在一个产品处于探索、复杂和不确定的阶段时，我们更需要的是假设，而不是传统的需求。也就是说，我们假设一个功能上线之后会得到一个什么样的结果，然后等功能上线后，再去验证是否得到了这样的结果，从而得出结论和提取知识。</p><p><img src="https://static001.geekbang.org/resource/image/bf/60/bf108d0f6034379c385e884c3ee06160.png?wh=1400x761" alt="图片"></p><p>我们可以看到，以假设驱动的方式去构建产品，可以将用户的反馈纳入到开发过程中来，让每一个需求的效果都可以度量。</p><p>比如对于一个电子商城的App，我们假设如果在商品的展示页面中加入视频功能，商品的销量就会增加10%。之后我们就开始开发视频功能，上线之后通过A/B测试做实验对比，看看是否加入了视频功能的商品，销量真的会增加10%。</p><p><img src="https://static001.geekbang.org/resource/image/12/46/121e2d8f47d3ac3d118968b5f1a22a46.jpg?wh=1920x1457" alt="图片"></p><p>你可能会说，我公司的商品展示页面也有视频功能，但就是按照普通需求去开发的，这跟假设驱动开发的方式有什么区别吗？其实区别是很明显的。</p><p>一个需求总是要解决一个业务问题的，电商平台不会平白无故开发一个视频功能，背后要解决的问题，就是提升商品销量。但以普通需求的方式提出来，我们就不会特意做度量，等到上线后发现没达成这个目标，也就不了了之了。</p><p>你可以回忆一下，你所在的系统中，有多少费时费力开发完但却没人用的功能？它们中大多数都是因为没达成预想的假设。这是巨大的浪费。</p><p>而<strong>如果以假设驱动的方式进行开发，我可以在某个方向上快速验证，如果假设不成立，就立即止损，不再追加投资。这样整个过程就显得十分精益了</strong>。</p><p>还拿商品页的视频功能为例，我可以先开发一个极其简单的版本快速上线，在对比发现真的对销量有提升效果后，再来逐步优化整个方案，比如延长视频时间、提高视频清晰度，甚至把直播带货时该商品的介绍剪辑下来，放到商品页等等。这样不断迭代，每一步都通过假设驱动，并不断验证假设，得到能带来最多客户价值的方案。</p><h2>在遗留系统中应用假设驱动开发</h2><p>既然新功能开发上，我们可以借助假设驱动实现“多快好省”，那遗留系统现代化是不是同样适用呢？答案是肯定的。</p><p>在遗留系统现代化的过程中，我们接收到的任务，呈现形式往往也是需求或者故事卡，得到的也都是一个技术结果而不是业务结果。比如重构某段代码来提升可读性，或者添加测试来提高某个模块的单元测试覆盖率。这样的技术任务是很难验收的，而且上线之后，业务方无法很容易地感知它所带来的价值。</p><p>这时我们可以将假设驱动开发引入到遗留系统现代化中来，将那些以“As…I want…So that…”或“Given…When…Then…”编写的故事卡和验收条件，改为下面这种形式：</p><blockquote>\n<p>我们相信&lt;某个功能&gt;<br>\n将&lt;产生某种结果&gt;<br>\n当&lt;我们看到某种可度量的信号&gt;时，我们就有信心沿着这个方向继续下去</p>\n</blockquote><p>举个例子来说就是：</p><blockquote>\n<p>我们相信，为&lt;库存模块添加单元测试&gt;<br>\n将&lt;提升库存模块的内建质量&gt;<br>\n当&lt;我们看到库存模块新需求的bug数量连续三个月降低&gt;时，我们就有信心沿着这个方向继续下去</p>\n</blockquote><p>你看，如果只添加单元测试，而不拿出添加完测试后的数据，业务方就无法直观看到这样做的好处，这样的改进也很难获得他们认可。但如果我拿着一份图表，向业务方展示连续三个月降低的bug数，他们一定会非常开心，并支持我们的下一步计划。</p><p>在开发软件时，我们主张<a href="https://time.geekbang.org/column/article/268129">关注成效而非产出</a>，在遗留系统现代化过程中，同样也应该关注成效，而不仅仅是做了哪些改进。在上面的例子中，添加完测试后的测试数量和覆盖率就是产出，而bug数降低就是成效。</p><p>如果只注重产出，我们就会更关注团队都完成了哪些技术改进，考核维度是工作量。这样能快速完成的工作优先级会更高，改进带来的业务价值反而被忽视；但如果注重成效，我们更关注改进如何服务于业务，考核维度变成某项改进，在多大程度上能<strong>提高用户效率</strong>，并在上线后关注相关指标的变化。</p><p>关注成效，不但可以激励我们去找出可以衡量业务价值的指标，也能帮助我们避免一些价值不大的技术改进。</p><p>还拿添加单元测试举例，如果只是为了产出，那我们关注的就是提高测试数量和测试覆盖率，当这样的度量指标，落到团队头上去真正执行时，他们就会想出一些匪夷所思的方式。</p><p>比如给Java类的getter/setter添加测试，那产出的测试数量是惊人的，但却对降低bug数量完全没有任何帮助，是毫无价值的。这就像如果用代码行数去评价开发人员的工作，就会多出很多无用代码一样。</p><p>说到这，我们明确了关注成效的必要性，下一步就是把“成效”转化成更明确的指标，这样才能更好地建立假设。</p><h2>明确目标和度量指标</h2><p>在以假设驱动的方式推动遗留系统现代化时，首要工作就是确定目标。没有目标的工作会让我们变成无头苍蝇，到处乱撞。以下图为例，我们通常可以制定这样四个维度的目标。</p><p><img src="https://static001.geekbang.org/resource/image/b4/63/b48084a4f769af2973c271f24b751063.jpg?wh=1920x979" alt="图片"></p><p>1.业务敏捷：系统快速响应市场变化和新兴机会的能力，比如一个需求从提出到上线的时间；</p><p>2.运营效率：系统提升价值流效率的能力，比如一个业务从开始办理到办理完成的时间；</p><p>3.客户洞见：系统理解和解释客户数据、行为和反馈的能力，比如前面提到的，客户对于商品视频和直播等特性的敏感程度，我们应该如何去解释；</p><p>4.系统韧性与弹性：云时代对于系统的基本要求。</p><p>确定好目标，接下来就是制定各个目标的度量指标了。软件度量是很多项目都欠缺的一环，缺少了度量，就没有办法对我们的系统做出有效的评价。因此有必要在这里重点讲一讲。</p><p>以业务敏捷为例，我们可以进一步细化成3个维度、6个指标。然后再讨论出某项遗留系统现代化的举措实施之后，能带来怎样的数据变化。等交付之后，再收集度量数据，并把数据可视化。</p><p><img src="https://static001.geekbang.org/resource/image/f8/fa/f87eb8467a6e180503047fc417b5e6fa.jpg?wh=1920x807" alt="图片"></p><p>对于其他维度的指标，我在这里举一些例子。你可以根据自己项目的实际情况，定制更适合的指标。</p><p>运营效率主要看某个业务条线的技术改进，会对该业务带来哪些效率提升。比如银行贷款业务，从借贷申请到发放贷款的间隔时间，就是一个不错的指标；而对于保险公司的投保业务，可以选择从投保申请到核保完成的时间。</p><p>客户洞见，主要看技术改进能否帮助系统更好地理解客户行为。这一点乍听上去有点虚，我来举个例子你就明白了。</p><p>很多电商系统都有秒杀功能，在客户秒杀时会造成大量的并发请求，有时甚至会拖垮服务器。这种把客户秒杀行为与系统吞吐量做关联的能力，就是客户洞见。那么给系统“上云”，或者引入缓存，都是可以提升吞吐量的方案，最终服务于优化秒杀体验这个目的。</p><p>你可能觉得，这个例子这么简单，哪算得上什么“洞见”嘛！</p><p>其实，所谓客户洞见，就是要求我们站在客户视角去理解客户。有些可能很好理解，有些却不是那么直观。比如以地图的形式显示订单的运送路线和状态，可以显著地降低客户的投诉率。这里面隐含的一个客户洞见就是，客户非常关注包裹的物流信息，而地图的形式比文字列表的形式更能让客户安心。</p><p><img src="https://static001.geekbang.org/resource/image/4a/d5/4aea0be02082d5bce447197d57b29fd5.jpg?wh=1148x780" alt="图片"></p><p>系统韧性和弹性的指标就很多了，比如平均恢复时间、平均故障时间等、每秒请求数、每秒事务数等。</p><p>在确定这些指标时，我们可以通过正推的方式（即某项技术改进可以改善哪些指标）推导指标，也可以通过逆推的方式来寻找解决方案（即想要改善某个指标，都可以通过哪些技术改进来实现）。</p><p>举个例子，我们希望优化DevOps平台，就可以用部署频率这个指标来评价优化的结果；我们希望减少线上bug数量，也可以逆推出提高测试覆盖率、加强代码评审、拆分模块以降低认知负载等质量内建的手段。</p><p>不同目标维度的指标可以是重合的，比如服务恢复时长，既可作为业务敏捷维度的指标，也可作为系统韧性与弹性的指标；一项技术改进也可能带来多个指标的变化。</p><p>在制定度量指标时，还要注意的一点是，<strong>要尽量使用相对的数据，避免使用绝对的数据</strong>。比如一次交付周期内的bug数就是一个绝对的数字，它在有些情况下有意义，但在某些情况下可能就没有意义。</p><p>比如某个需求特别大，需要横跨几个交付周期，在前几个交付周期时不会上线，这时bug数自然就少。等最后一个交付周期上线时，可能一下子就会多出不少bug。通过这样绝对的数据，就不能推出“前几个交付周期质量高，最后一个交付周期质量差”的结论。我们把指标换成bug数和上线需求数的比值，就可以避免这种偏差。</p><p>实际上，bug数与需求数的比值也并不十全十美的，因为bug的严重程度、修复难度都不相同，需求的大小、紧急程度和难易程度也不相同。这时可以用“行bug数”来代替“需求bug数”，但不同代码行的难度显然也是不同的，但扩大代码行的数量就可以拉平这种差别，比如“每千行代码的bug数”。</p><p>你还可以将bug的特点和需求的特点作为权重，引入到整个评价体系中来。不过如果你的项目上还没有任何度量，我建议你先把简单的度量体系搭建起来，等想要更精准度量的时候，再引入具体系数也不迟。</p><p>想要了解更多关于软件指标和度量的内容，推荐你看看《精益软件度量》这本书。</p><p>指标制定好之后，等各项改进任务以增量（下节课再讲什么是增量）上线之后，我们就可以开始收集数据，持续度量了。需要牢记的是，<strong>一定要把度量结果用各种图表可视化出来</strong>。</p><p>一方面，这可以向开发团队展示改造的成果以及给公司带来的价值，以前开发人员可能只知道我在哪里添加了什么代码，但并不知道这几行代码给公司带来了什么样的价值。另一方面也把改造的过程向业务部门、运营部门、市场部门透明，让他们了解并支持我们的工作。</p><p>有了可度量的指标，遗留系统的假设驱动开发就成为了可能。我们在开始一项改进任务时，首先要对相关指标的变化做一个假设，等改进任务的部分交付之后，再收集相应的指标数据，以验证假设。</p><p>如果数据是朝着假设的方向变动的，我们就有理由继续投资后续的改进；如果数据变化不明显或是向相反的方向变化，就要停下来仔细研究一下原因了。</p><p><strong>以假设驱动为指引的遗留系统现代化，就是说我们所做的所有现代化任务，都应该能够提升这些指标</strong>。这些指标就像灯塔一样，引领着我们朝着正确的方向前行。</p><h2>小结</h2><p>今天我们介绍了遗留系统现代化的第二个原则：以假设驱动为指引。假设驱动开发是精益里的一个概念，不过迁移到遗留系统现代化中也完全适用。Thoughtworks的技术雷达中有一个条目就是<a href="https://www.thoughtworks.com/radar/techniques/hypothesis-driven-legacy-renovation">假设驱动的遗留系统改造</a>，讲的就是类似的技术。</p><p>假设驱动开发与传统的需求式开发不同，它先对要达成的目标做一个假设，这个目标其实才是我们真正要解决的问题。然后根据假设制定解决方案，也就是我们平时开发时所面对的需求。</p><p>不同于传统需求式开发，并不是功能验收上线之后就算完成了，而是还要验证假设，看看所收集到的数据是否支持我们的假设，从而帮助我们更好地演进产品。</p><p>不以假设驱动，遗留系统现代化的很多技术改进就会盲目开展，最后忘了初心，走错了方向。</p><p>在应用假设驱动开发时，你首先要根据自己的项目制定一些目标，然后再根据目标建立度量体系。这样，所有的技术改进都可以围绕这些指标展开了。</p><p>在建立度量指标时要尽量避免绝对的数值，而要尽量用数据的比值。比值更能体现数据的相对性，比绝对的数值更能减少误差。</p><p>最后，要记得把数据可视化出来，可以打印出来贴在墙上，也可以用一个大显示器立在团队旁边。它们一方面可以激励团队成员，另一方面也是向业务方展示工作的成果，让他们相信，一个看上去很技术向的改进任务，也能给业务带来巨大的价值。</p><p><a href="https://time.geekbang.org/column/article/510594">下节课</a>，我们会讲<strong>以增量演进为手段</strong>这个原则，它能有效指导我们在确定完指标之后，在行动上如何一步一步实现这些目标，敬请期待。</p><h2>思考题</h2><p>感谢你学完了这节课的内容，今天的思考题是：你的项目是否存在盲目做技术改进的情况？你们的改进在上线之后是否在用指标来度量呢？都有哪些指标？</p><p>欢迎把你项目上遗留系统现代化的心得和经验分享出来，也希望你把这节课分享给你的朋友，我们一起进步。</p>',
        article_title: "05 | 以假设驱动为指引：如何评价遗留系统的现代化成果？",
      },
      {
        title: "06 | 以增量演进为手段：为什么历时一年的改造到头来是一场空？",
        id: 510594,
        content:
          '<p>你好，我是姚琪琳。</p><p>今天我们来聊聊遗留系统现代化中的HOW，也就是第三个原则，以增量演进为手段。</p><p>很多团队在一阵大张旗鼓的遗留系统改造后，终于迎来了最终的“梭哈”时刻。尽管事先可能在各种测试环境测过无数遍了，但上线生产环境仍然如履薄冰。</p><p>和遗留系统项目“相爱相杀”十几年，我可以肯定地告诉你，这种一次性交付的大规模遗留系统改造，几乎不可能一上线就成功，必然会有各种或大或小的问题，甚至导致不得不全量回滚，交付日期一拖再拖。哪怕你的“战前准备”历时一年，甚至更久，到头还是一地鸡毛。</p><p>你可能会有疑问，你见过很多大厂的案例，都是一次性上线的。没错，的确是这样，但大厂之所以有勇气这么做，是因为他们有很强的人力、物力支撑，客观条件允许这么做。对于资源有限的小公司、小项目，还是应该衡量一下改造的难度和运维的能力，以控制风险为主。</p><p>怎么控制风险呢？我的答案是增量演进。这节课，我带你把这个概念搞通透，顺便演示下代码和架构的增量演进怎么做。</p><h2>什么是增量演进？</h2><p>什么是增量？什么又是演进呢？这要从演进式架构开始说起。</p><p>我在北美的同事Neal Ford和Rebecca Parsons，在《演进式架构》这本书中给演进式架构下了精准的定义：<strong>支持跨多个维度的引导性增量变更的架构</strong>。</p><!-- [[[read_end]]] --><p>这么多的限定词，你乍一听挺懵，别急，我给你解释一下就清楚了。其中，多维度是指技术、数据、安全、运维等不同的看待架构的视角；引导性是指在<strong>适应度函数</strong>的引导下，向着正确的方向演进架构；而增量变更是指以小步快跑的方式，细粒度地构建和部署软件，同时在一定程度上允许新旧两种实现并行运行。</p><p>我这里说的遗留系统中的增量演进，借鉴了演进式架构中“增量”的概念。我们可以把已有的遗留系统作为“存量”，而每一次的优化、改进作为“增量”。“演进”则要求我们将这些增量划分成非常小的粒度。这些小的增量也可以随时部署到各种环境来进行验证，每次验证的最小单元都是这些小的增量，而不是整个的改造结果。</p><p>同时，新改进的实现和老的实现是并存的，一旦在验证时发现问题，可以随时回退到老实现。</p><p>因此，<strong>增量演进是指，以增量的方式，不断向明确的目标前进的过程</strong>。</p><p>虽然理论上，可演进的架构才更容易实现小的增量变更，但大多数遗留系统的架构显然不是可演进的。这时候我们怎么实现相对细粒度的增量交付呢？我们从代码和架构两个维度为例，具体分析一下。</p><h2>代码的增量演进</h2><p>在代码现代化方面，我们的主要目标包括三类：修补测试、代码重构、代码分层。接下来我将以代码重构为例，向你演示如何实现增量演进。</p><p>下面的代码来自《代码整洁之道》第2章“有意义的命名”，Bob大叔举了这样一个例子来吐槽糟糕的命名。这段代码来自一个扫雷游戏，想实现获取所有被标记过的单元格的目的。</p><pre><code class="language-java">public List&lt;int[]&gt; getThem() {\n　List&lt;int[]&gt; list1 = new ArrayList&lt;int[]&gt;();\n　for (int[] x : theList)\n　　 if (x[0] == 4)\n　　　 list1.add(x);\n　return list1;\n}\n</code></pre><p>然而你不难发现，这段代码的坏味道远不止getThem、theList这种<strong>晦涩的命名</strong>，还包括<strong>魔法数字</strong>、<strong>基本类型偏执</strong>等。</p><p>面对如此多的坏味道，我相信对代码有洁癖的你，已经摩拳擦掌准备重构了吧？但是请别急，如果你直接改代码，在没有测试的情况下，有信心保证正百分之百正确吗？</p><p>在遗留系统中，到处充斥着这样的糟糕代码，而且没有测试覆盖。我们可以选择先补测试，然后再开始重构。这也是我强烈推荐的方式，因为这样的步子迈得更稳、更扎实。</p><p>但有时代码本身并不可测，还要先完成可测试化改造。我的初衷就是单纯地重构这段代码，现在又要可测试化，又要加测试，似乎外延越来越广了，工作量也随之越来越大。有没有办法不用加测试，也能安全地重构呢，并且完成增量式交付呢？答案是肯定的。</p><p>这种方法其实很简单，就是<strong>先把代码复制出来一份</strong>，<strong>在复制的代码处进行重构</strong>。等重构完毕，再通过某种开关，来控制新旧代码的切换。在测试时，可以通过开关来做A/B测试，从而确保重构的正确性。</p><p>除了复制代码的方式外，还有一种更巧妙的方法来实现无测试的安全重构，并完成增量交付。这里我先卖个关子，等到后面的模式篇再来介绍这种方法。</p><p>重构完的代码可以像下面这样，只有一行，十分精练：</p><pre><code class="language-java">public List&lt;Cell&gt; getFlaggedCells()  {\n  return gameBoard.stream().filter(c -&gt; c.isFlagged()).collect(toList());\n}\n</code></pre><p>在这里我就不介绍具体的重构过程了，<strong>毕竟我们的重点是增量交付。</strong>重构代码的方法，我们后面模式篇再展开讲，这里也顺便推荐郑晔的《<a href="https://time.geekbang.org/column/intro/100068401?tab=catalog">代码之丑</a>》专栏。</p><p>在原方法的调用端，我们可以像这样引入开关，来实现这个增量：</p><pre><code class="language-java">List&lt;int[]&gt; cells;\nList&lt;Cell&gt; cellsRefactored;\nif (toggleOff) {\n  cells = getThem();\n  // 其他代码\n}\nelse {\n  cellsRefactored = getFlaggedCells();\n  // 其他代码\n}\n</code></pre><p>开关的值通常都写到配置文件，或存储在数据库里。我们可以通过修改这个配置，不断验证新代码的行为是否和旧代码完全一致。直到经过了充分的测试，我们有了十足的信心，再来删掉开关，将旧代码完全删除。</p><p>我的同事，《<a href="https://time.geekbang.org/column/intro/100036501?tab=catalog">说透中台</a>》专栏的作者王健，曾经把这种重构手法总结为“<strong>十六字心法</strong>”，非常形象、贴切：</p><blockquote>\n<p>旧的不变，新的创建。一步切换，旧的再见。</p>\n</blockquote><p>“旧的不变”是指先不动旧方法；“新的创建”是指创建一个跟原来方法功能相同的新方法，你可以通过先复制再重构的方式，来得到这个新方法，也就是整个系统的一个增量；“一步切换”是指，在充分测试之后，新的方法可以完全替代旧方法了，就将开关切换到新方法上；“旧的再见”则意味着删除旧方法以及相应的开关，一个演进到此也就结束了。</p><p>你会发现，这十六字心法不光适用于代码重构，也可以推广、复用，用在架构、安全、性能等其他维度，作为增量演进的指导方针。</p><h2>架构的增量演进</h2><p>如果说代码的重构还可以在短时间内完成并上线，那架构的重新设计就很难一蹴而就了。这其实就更加需要小步上线，随时验证了。</p><p>你可能会说：“骗人的吧？你要是说代码的改动可以小步前进，我还相信，但是架构调整这么大的动作，怎么可能增量演进呢？”这其实就是我们一直想要强调的，越是大的改进，越要频繁上线去验证，不要等到最后来个“大惊喜”。</p><p>对于架构或系统的替换，Martin Fowler提出了<strong>绞杀植物模式</strong>。这源于他一次在澳大利亚旅行时发现的奇观，一棵巨大的古树被榕树的藤蔓缠绕，许多年以后最终被榕树所取代。</p><p>“老马”（国内对于Martin Fowler的昵称）想到了一种与之类似的系统替换的方式，也就是新建一个系统，让它与旧系统并存且缓慢增长，直到某一天完全取代旧的系统。于是，老马就给这种方法起了一个名字，叫绞杀植物模式。</p><p>这里稍微说个题外话，这个模式一开始的名字是Strangler，国内通常的翻译是“绞杀者模式”。2019年老马在个人网站上修订了这篇博客，将模式重新命名为Strangler Fig。原因是这个模式虽然越来越流行，但是名字太血腥太暴力。Strangler Fig直译成中文是绞杀无花果，听上去有点莫名其妙。其实Strangler本身就有绞杀植物的含义，因此我个人倾向于把这个模式翻译为绞杀植物模式。</p><p>使用绞杀植物模式最主要的好处，就是降低风险。作为绞杀植物的新系统可以稳定提供价值，并且频繁发布。你还可以很好地监控它的状态和进度。</p><p>这种新旧系统或架构同时存在、同时运行、逐渐替换的方式，就是我们的增量演进所追求的目标。</p><p>假设我们有这样一个单体系统，包含员工、财务和薪酬三个模块，其中员工和薪酬模块都会调用通知模块来发送邮件或短信。上游服务或前端页面通过HTTP API来访问不同的模块。</p><p><img src="https://static001.geekbang.org/resource/image/cb/6c/cbda599236da28ff9a9a35763bed276c.jpg?wh=1920x1110" alt="图片"></p><p>如果我们希望将薪酬模块迁移到独立的服务中，应该如何使用绞杀植物模式，以增量演进的方式做拆分呢？</p><p>我们可以分四步完成拆分。</p><p>第一步，<strong>建立开关</strong>。要实现增量演进，开关是必不可少的。一方面可以通过开关来控制A/B测试，以验证功能不被破坏，另一方面一旦新实现有问题，也能迅速回退到旧实现。</p><p>你可以将这个开关实现在API调用薪酬模块的地方，当开关打开的时候，调用新的薪酬服务，当开关关闭的时候，仍然调用已有的薪酬模块。这个开关可以是粗粒度的一个开关，也可以是细粒度的每个功能点一个开关。我建议你把开关尽可能设小一些，在实战中这种方式可以获得更小的增量演进和回滚。</p><p><img src="https://static001.geekbang.org/resource/image/9e/c7/9e6c3ecee98743aebe30a142e3c559c7.jpg?wh=1920x995" alt="图片"></p><p>现在的薪酬服务还是一个空壳，没有任何实现。如果打开开关，应该得到一个501 Not Implemented错误。</p><p>第二步，<strong>增量迁移</strong>。按迭代逐步将薪酬模块的功能迁移到薪酬服务中。假设我们需要4个迭代来完成全部的迁移工作，迭代0的工作主要是为开发开关和搭建新服务的脚手架，其余迭代就可以按计划来迁移不同的功能了。</p><p><img src="https://static001.geekbang.org/resource/image/dc/b8/dcdcee412c348eb0bc3f495782e26ab8.jpg?wh=1920x1116" alt="图片"></p><p>在这一步，我建议你从迭代0开始，就把薪酬服务部署到生产环境中。虽然迭代0中的薪酬服务还没有任何功能，但这可以让你先测试整个部署的过程，以及服务的连通性。否则你就要在迭代1交付的时候既测试部署，又测试功能了。</p><p>你可能会注意到，我们虽然在迭代0<strong>部署</strong>了薪酬服务，但是开关并不会打开，因此并不意味着<strong>交付</strong>了薪酬服务的功能。我们将软件部署和软件交付（或软件发布）的概念做了区分，相信你能体会到它们之间的差别。</p><p>从迭代1开始，就会有迁移完成的增量发布到薪酬服务中了，你可以打开开关来测试这一部分的功能。</p><p>第三步，<strong>并行运行</strong>。对于有一定规模的架构演进，我强烈建议你将开关和旧代码保留一段时间，让新旧代码并行运行几个迭代。</p><p>对于遗留系统来说，这样做好处是利用新旧实现并行的这段时间，让隐藏的坑逐步浮现出来，直到我们对新实现有十足信心。这里说的“隐藏的坑”意思是指，隐藏在代码和架构深处的，那些任何人都不曾知道的问题。它们随时可能会暴露出来。多并行一段时间，可以让“子弹飞一会儿”，看看是否能够暴露出这些问题。</p><p><strong>并行运行</strong>和绞杀植物模式一样，也是一种常用的架构现代化模式，我们会在模式篇里详细介绍。</p><p>第四步，<strong>代码清理</strong>。删除旧代码和开关，切记不要忘了这一步。很多遗留系统的架构演进都没有完成这一步，导致很多无用的代码留在系统中。它们除了给人带来迷惑之外没有任何用处。</p><p>完成这四步之后，我们就实现了架构的增量演进过程。你会发现，架构的增量演进与代码的增量演进一样，也完美契合了“旧的不变，新的创建，一步切换，旧的再见”这十六字心法。</p><h2>小结</h2><p>又到了总结的时候。为什么历时很久的遗留系统改造会以失败而告终呢？一是因为直到最后一刻才上线，失去了持续验证的机会；二是上线后发现有问题，只能硬着头皮热修复，或者整体回滚，缺乏细粒度的回退机制。</p><p>而增量演进原则可以有效解决这个问题。它一方面鼓励我们持续交付改造的功能或新的实现，不断在生产环境验证；另一方面拥有细粒度的开关，也使得回退变得十分灵活，一旦发现问题，我们只需要关闭引起问题的那个开关即可。</p><p>在<strong>以增量演进为手段</strong>这个原则的指导下，我对代码和架构的演进步骤做了比较详细的演示。此外，在软件系统的其他维度，如数据、安全、性能、运维等，也可以用同样的方式完成改进。</p><p>增量演进的思想不仅体现在遗留系统现代化之中，我们平时做设计的时候，也应该遵循增量演进的思想。一方面给予回退的可能，小步地上线，另一方面，也可以先上线一个简单的方案，然后再随着遇到的问题去不断演进这个方案。</p><p>我发现很多架构师在设计一个方案时喜欢一步到位，但这其实是错误的。这个世界上根本不存在完美的架构，所有的架构都应该是通过不断演进而浮现出来的，在演进的过程中我们应该根据当前上下文和约束的改变而不断调整，最终得到一个“差不多的”或者“刚刚好”的架构。</p><p>而一步到位的思想，轻则导致过度设计，重则完全走错了方向，因为没能尽早上线去收集反馈。虽然很多一步到位的决策，最后结果是走对了方向，那也不能说明你有眼光，只能说明你运气好。</p><p>另外，我还剧透了绞杀植物模式、并行运行模式等遗留系统现代化模式。想要了解更多的模式，欢迎你继续学习接下来的模式篇。</p><p>到此为止，我讲完了遗留系统现代化的三大原则。从<a href="https://time.geekbang.org/column/article/511924">下节课</a>开始，我们将进入模式篇的学习，你将在这一部分看到很多似曾相识的模式，它们是进行遗留系统现代化强有力的工具和方法。</p><h2>思考题</h2><p>感谢你学完了今天的内容，我给你留了三道思考题，你可以任选一个或者多个说说想法：</p><p>1.在你的项目中，是如何做代码和架构的重构的？是否曾经使用过类似增量演进的方式呢？期待你分享一下自己团队经验。</p><p>2.除了复制代码并重构之外，我在文中还提到了另外一种方法，用来在无测试的情况下完成安全重构，你想到是什么了吗？</p><p>3.在架构的增量演进一节中，单体系统中的薪酬模块对通知模块是有依赖的，那么新的薪酬服务拆分出去之后，应该如何实现对外发通知的功能呢？</p><p>欢迎你在评论区留下你的思考，也欢迎你把这节课分享给你的同事和朋友，我们一起讨论、进步。</p>',
        article_title:
          "06 | 以增量演进为手段：为什么历时一年的改造到头来是一场空？",
      },
    ],
  },
  {
    chapterTitle: "模式篇",
    children: [
      {
        title: "07 | 遗留系统现代化的五种策略：重构还是重写？这是一个问题",
        id: 511924,
        content:
          '<p>你好，我是姚琪琳。</p><p>从今天开始，我们正式进入模式篇的学习。这一部分我会带你学习代码、架构、DevOps、团队结构四个现代化中的各种模式，这些模式是我们实战的理论基础，希望你能牢牢掌握。</p><p>不过深入学习这些模式前，今天我们先从重构和重写的“两难”问题说起。到底是重构，还是重写？这是一个困扰着很多团队的问题。</p><p>重构吧，遗留系统积重难返，重构之路遥遥无期，三年、五年时间，可能也只是刚开了个头，还不如重写。</p><p>但重写就真的比重构好吗？遗留系统中最难获取的就是业务知识。当你问起一块业务时，得到的回答往往是：“没有文档”、“没人知道”或者“只能看代码”……没有业务，或者说没有需求，怎么可能构建出来一个新的系统呢？</p><p>那我们到底应该如何应对呢？除了重构和重写，还有没有其他方式呢？</p><h2>遗留系统现代化的五种策略</h2><p>Gartner在19年曾经有<a href="https://www.gartner.com/smarterwithgartner/7-options-to-modernize-legacy-systems">一篇报道</a>，提出了遗留系统现代化的七种方案。我把这七种方案做了整合，把它们整理成后面这五种策略。它们各有各的特点，而且分别对应不同场景，你要根据项目自身情况选择不同的策略或组合。然后，再应用后面要讲的模式来落地。</p><h3>Encapsulate</h3><p>第一种策略是<strong>Encapsulate</strong>，也就是<strong>将遗留系统中的数据或者功能封装成API，供外部调用</strong>。</p><!-- [[[read_end]]] --><p>我们在<a href="https://time.geekbang.org/column/article/505740">第一节课</a>里提到过，遗留系统中蕴含着丰富的数据资产，但是因为技术和工具落后，导致它难以与新系统集成，这些数据被封印在遗漏系统中，成了数据孤岛。比如早期的银行或民航软件，很多都是部署在大型机上的。企业非常希望开发手机App，这样才能更好地为客户服务，但却很难访问到主机上的这些数据。</p><p>同样地，遗留系统中还有一些功能十分重要，其他外部系统需要这些能力来构建业务。比如一些公文流转的工作流，可能构建在基于Lotus Notes的办公系统中，但如果企业想要开发移动办公App，并在App中复用这套工作流，也是困难重重。</p><p>问题虽然棘手，但事到临头，工程师们总要想办法应对。结合刚才说的情况，我们可以封装这些数据和功能，形成API，供这些移动App或其他外部系统使用。如果遗留系统本身就是基于Web的，可以在Web系统上直接构建API；如果不是，可以选择构建一个全新的Web API来部署并提供服务。</p><p>这样做的好处是，以较低的成本和风险，尽可能满足外部系统的需求。你无需对遗留系统做较大的修改，只是增加一些API而已。遗留系统本身不会被优化，但它可以通过这些API对外提供能力。</p><p>还有一种情况，我也建议你使用封装的策略，那就是当你有一个第三方系统，希望扩展它的功能，但只能访问它的数据库，却无法修改代码的时候。</p><p>这时有些团队采用的方式就是直接连它的数据库，并在已有的系统中基于这些数据构建新的功能。我不建议你这么做，直接连数据库固然简单，但由于你可以访问它所有的表和列，距离混乱也就剩一步之遥了。</p><p>我建议你基于这个第三方系统的数据库构建一个Web API，来向其他的系统提供你想提供的数据和功能，而不是暴露全部的数据。</p><p>我这里也稍微剧透下，封装的策略落到具体应用的时候，衍生出了很多相关模式，比如<strong>数据API模式</strong>、<strong>功能API模式</strong>等等。我会在后面的课里再详细展开。</p><h3>Replatform</h3><p>第二种策略是<strong>Replatform</strong>，也就是<strong>替换运行时平台</strong>。这种策略不需要对代码大动干戈，只需要改动很小一部分。到了新的平台后，软件的功能和特性仍然保持不变。</p><p>比如，很多银行或民航软件还是基于COBOL的主机系统，把它们从大型机上迁移到Linux或Windows环境，就会甩掉昂贵的主机成本。</p><p>再比如，早年间开始构建的系统，由于种种原因，很多是基于商业软件的，想升级，就要花一大笔预算。很多企业为了节省这部分开支，会尽量避免升级，也导致系统最终变成了遗留系统。你可以通过Replatform策略来解除对商业软件的依赖，例如用Tomcat来替换WebLogic。</p><p>或者像.NET这种技术栈，也十分有必要从.NET Framework迁移到.NET Core或者.NET 5。而Python从2升级到3、JDK的大版本升级等等，也都属于Replatform。</p><p>在使用Replatform时，你只需要对代码做少量更改，以适配新的平台。这样，只通过较小的成本就可以降低基础设施的成本，并提高性能。</p><p>还有一种迁移我认为也可以看做是Replatform，虽然它并不是替换运行时平台。那就是迁移代码版本管理工具。比如你把代码从SVN迁移到Git中，不需要修改任何功能代码，但却可以享受新的代码管理平台带来的好处。</p><h3>Rehost</h3><p>第三种策略是<strong>Rehost</strong>，也就是<strong>将应用程序或组件部署到其他基础设施中</strong>，如虚拟主机、容器或云。这种策略完全不需要修改代码，而只需要迁移部署的环境，甚至都不需要重新编译，因此这种迁移方法也有个很形象的别名，叫做“lift and shift”，就是原封不动地拎起来，转移到别的地方去。</p><p>我举个例子来说明，如果你的公司有一个SAP的ERP系统，可以将它从本地的数据中心迁移到AWS或GCP中。</p><p>Rehost可以让你在完全不修改已有系统的情况下，快速上云，体验云环境带来的弹性、安全性和高性能，并且迁移过程也能做到很平滑。然而由于没有任何适配，也就无法充分利用云原生的优势，因此还需要对系统内部的代码和架构做进一步调整，比如将单体架构拆分为可以独立运维的微服务。</p><h3>Refactor/Rearchitect</h3><p>第四种策略是<strong>Refactor和Rearchitect</strong>，它们是指<strong>在不改变系统外部行为的前提下，对代码或架构进行调整、优化，以偿还拖欠已久的技术债务、改善非功能需求、提升系统健康度</strong>。</p><p><strong>Refactor主要是指代码级别的重构</strong>，比如你可能用Sonar等代码扫描工具，扫描出了很多代码坏味道、缺陷或隐患，修复这些问题的过程就属于Refactor。这和我们平时说的代码重构基本上是一个意思。</p><p><strong>Rearchitect是指架构级别的重构</strong>，它包含两层意思。第一层比较好理解，就是指从单体架构到分布式架构的这种架构调整。第二层是指不改变部署单元之间的关系，而是对单个或多个部署单元内部进行模块化或分层重构。由于这种模块化和分层也会涉及很多代码的调整，所以这种Rearchitect往往会和Refactor同时进行。</p><p>后面你学到代码和架构现代化的内容时，会看到很多Refactor/Rearchitect相关的模式。这些也往往是遗留系统现代化中最有挑战，也最有意思的部分。</p><h3>Rebuild/Replace</h3><p>第五种策略是<strong>Rebuild和Replace</strong>，都是指<strong>对遗留系统进行替换</strong>。它们两个替换的范围和程度不同。<strong>Rebuild</strong>可能是<strong>对应用程序的某个组件或某个服务的重新设计或重写</strong>，但会保留其原有的业务范围和业务规则。而<strong>Replace</strong>是指<strong>彻底淘汰应用程序的所有组件，去构建或购买新的软件</strong>，同时会考虑添加新的业务需求或移除某些旧的业务需求。</p><p>我在<a href="https://time.geekbang.org/column/article/505740">第一节课</a>提到过，遗留系统中的业务知识是严重缺失的，不仅没有遗留下来的文档供我们查阅，也没有任何一个人能说清楚全部的业务细节。在这样的基础上实施Rebuild或Replace，风险和成本都是相当高的，但相对来说，收益也是最高的，一旦替换成功，就可以彻底摆脱原来的遗留系统了。</p><p>下图是对上面五种策略的一个总结，你可以从中看出它们的收益、风险和成本（用面积表示）：</p><p><img src="https://static001.geekbang.org/resource/image/73/bf/735968254f34d2eecbe73f5f0bed34bf.jpg?wh=3122x1870" alt=""></p><h3>其他策略</h3><p>除了上面的几种策略以外，对于遗留系统来说还有一些应对策略可以选择。不过由于不涉及到代码、架构或运行环境的变更，我没有把它们作为遗留系统现代化的策略。</p><p>其中一种是Retain，即保持系统当前的状态不做任何修改或更新。对于尚可满足使用的遗留系统来说，这无疑是风险和成本最低的策略。我在<a href="https://time.geekbang.org/column/article/509535">第五节课</a>说过，使用人数不多、需求很少、只需要一两个人维护的遗留系统，就可以使用这种策略。</p><p>还有一种是Retire，就是评估完工作量、使用情况和业务价值之后，选择完全停止使用的一种策略。有的时候系统已经没有什么人用了，或者类似的功能在其他系统中可以替代，你就可以选择让这个旧系统彻底退休了。</p><h2>你应该选择什么样的策略？</h2><p>面对如此眼花缭乱的策略，你恐怕更加无所适从了吧？别担心，接下来我就来帮你梳理一下如何选择。</p><p>到底是Replatform还是Rehost？是Refactor还是Rebuild？是Rearchitect还是Replace？其实，我们还是要依据目标和系统现状做判断。</p><p>先看最终目标，第五节课我列出了企业遗留系统现代化的四个目标，即业务敏捷、运营效率、客户洞见、系统韧性与弹性。</p><p>对于业务敏捷来说，Replatform和Rehost通过替换运行时环境和上云可以提升部署频率，特别是Rehost可以显著提升系统在遇到故障时的恢复时间；Refactor/Rearchitect通过改善代码和架构的质量，可以缩短需求交付周期，减少线上问题数量；而Rebuild/Replace由于在某种程度上做了替换，也可以大幅度提升业务的响应力和交付质量。</p><p>对于运营效率来说，Refactor/Rearchitect和Rebuild/Replace都可以提升价值流效率。而要想改善客户洞见，最有效的方式还是Rebuild/Replace。在系统韧性与弹性方面，Rehost显然是不二之选。</p><p>我们要结合当前遗留系统的现状和想要提升的目标，做综合判断，对于不同的模块，也可以选择不同的策略组合，来实现一个完整的业务目标。</p><p>比如遗留系统中的有些业务，需要提供7x24小时的高可用服务，类似银行转账、保险报案等模块。但这些模块很有可能还位于单体的“大泥球”中，和其他模块有着剪不断、理还乱的关系。</p><p>为了支撑这些需求，我们可以先采用Rearchitect的模块化策略，结解耦模块之间的关系；然后再用Rearchitect的服务化策略，将这些模块拆分成独立的服务；最后再用Rehost策略将这些服务部署到云上，以提升系统的可用性。</p><p>当然，如果由于系统耦合严重，模块化改造很难实施，你也可以选择用Rebuild策略重写这一部分模块。</p><p>再比如一个部署在WAS v6上的Java Web遗留系统，由于只支持Java EE 1.4，技术栈严重落后，已经很难在市场上招到人来维护了。</p><p>这时，可以先选择Replatform策略，将WAS替换为较新版本的Tomcat，以摆脱昂贵的商业软件；然后再次使用Replatform升级Java的版本，包括所依赖的第三方工具，这样就完成了整个技术栈的升级。</p><p>如果企业认为当前遗留系统已经彻底无法满足业务的需要，且具备足够的资源来构建新的系统，就可以使用Replace策略来彻底替换旧系统。同时，在遗留系统并不是很大，但重要性又相对很高的情况下，也可以考虑Rebuild/Replace。</p><p>这里我一直没有提Encapsulate这种策略，是因为它有自己独特的适用场景，也就是与其他外部系统集成的时候。</p><h2>小结</h2><p>又到了总结的时刻。今天我们学习了遗留系统现代化的几种策略，不同的策略有不同的适用场景，我把它们总结到了一张表中。</p><p><img src="https://static001.geekbang.org/resource/image/ec/d6/ecd8ff1b982116d6ff91e4f5bebb5cd6.jpg?wh=1920x1135" alt="图片"></p><p>你要记住的是，一定要根据项目的情况来选择不同的策略组合。不要上来就大张旗鼓地重构或重写，一定要弄清楚想要的是什么。除了重构和重写，你其实还有很多选择。</p><p>从下节课开始，我们马上进入各种模式的学习了，你准备好了吗？</p><h2>思考题</h2><p>感谢你学完了今天的内容。我给你留的作业是这样的：</p><p>假设你是一个项目的技术负责人，你的项目基于.NET Framework 4.6.1，而该版本即将在这个月（2022年4月）“寿终正寝”。为了避免潜在的安全风险，你不得不将.NET版本进行升级（假设系统当前部署在Windows虚拟机上）。</p><p>这时你有以下三个选择：</p><p>1.升级到.NET Framework 4.6.2版本，几乎不用对代码做任何修改，只需要升级一下各个部署环境的虚拟机即可，保守估计三天之内也能完成升级并上线。</p><p>2.升级到最新的.NET Fremework 4.8版本，可以获得更长的技术支持，还能使用新版语言的特性，以提升开发效率。但有些旧的第三方库并不支持4.8，需要升级或替换。你可能需要两周到一个月的时间来完成全部升级。</p><p>3.升级到.NET 5，以充分享受跨平台和容器化的优势，系统也将彻底摆脱Windows的束缚。但代码需要改动的地方很多，几乎所有第三方依赖也都需要升级。预计需要五到六个月的时间才能搞定。</p><p>你会做出什么样的选择呢？补充一句，如果你不熟悉.NET的版本和特性，可以自行搜索一下。</p><p>本次作业没有正确答案，在我看来，任何一个选择都是可以接受的。你可以根据自己的思考给出答案，并说明理由。必要的时候，也可以自己添加一些约束条件，来支持自己的选择。</p><p>期待你的分享。如果你觉得今天这节课对你有帮助，别忘了分享给你的同事和朋友，说不定就能帮他解决一个难题。</p>',
        article_title:
          "07 | 遗留系统现代化的五种策略：重构还是重写？这是一个问题",
      },
      {
        title: "08 | 代码现代化：你的代码可测吗？",
        id: 512658,
        content:
          '<p>你好，我是姚琪琳。</p><p>从今天开始，我将用三讲来介绍代码现代化的主要模式。它们大体的脉络是这样的：</p><p>1.先对代码做可测试化重构，并添加测试；<br>\n2.在测试的保护下，安全地重构；<br>\n3.在测试的保护下，将代码分层。</p><p>我们今天先来看看如何让代码变得可测，这是遗留系统现代化的基本功，希望你重视起来。</p><p>一个软件的自动化测试，可以从内部表达这个软件的质量，我们通常管它叫做<strong>内建质量（Build Quality In）</strong>。</p><p>然而国内的开发人员普遍缺乏编写自动化测试的能力，一方面是认为没什么技术含量，另一方面是觉得质量是测试人员的工作，与自己无关。然而你有没有想过，正是因为这样的误区，才导致软件的质量越来越差，系统也一步步沦为了遗留系统。</p><p>我虽然在第六节课分享了可以不加测试就重构代码的方法，但添加测试再重构的方法更加扎实，一步一个脚印。</p><h2>你的代码可测吗？</h2><p>我们先来看看不可测的代码都长什么样，分析出它们不可测的原因，再“按方抓药”。</p><p>可测的代码很相似，而不可测的代码各有各的不可测之处。我在<a href="https://time.geekbang.org/column/article/506570">第二节课</a>举过一个不可测代码的例子，现在我们来一起复习一下：</p><pre><code class="language-java">public class EmployeeService {\n  public EmployeeDto getEmployeeDto(long employeeId) {\n    EmployeeDao employeeDao = new EmployeeDao();\n    // 访问数据库获取一个Employee\n    Employee employee = employeeDao.getEmployeeById(employeeId);\n    // 其他代码  \n  }\n}\n</code></pre><!-- [[[read_end]]] --><p>这段代码之所以不可测，是因为在方法内部直接初始化了一个可以访问数据库的Dao类，要想测试这个方法，就必须访问数据库了。倒不是说所有测试都不能连接数据库，但大多数直连数据库的测试跑起来都太慢了，而且数据的准备也会相当麻烦。</p><p>这属于不可测代码的第一种类型：<strong>在方法中构造了不可测的对象</strong>。</p><p>我们再来看一个例子，与上面的代码非常类似：</p><pre><code class="language-java">public class EmployeeService {\n  public EmployeeDto getEmployeeDto(long employeeId) {\n    // 访问数据库获取一个Employee\n    Employee employee = EmploeeDBHelper.getEmployeeById(employeeId);\n    // 其他代码\n  }\n}\n</code></pre><p>这段代码同样是不可测的，它<strong>在方法中调用了不可测的静态方法</strong>，因为这个静态方法跟前面的实例方法一样，也访问了数据库。</p><p>除了不能在测试中访问真实数据库以外，也不要在测试中访问其他需要部署的中间件、服务等，它们也会给测试带来极大的不便。</p><p>在测试中，我们通常把被测的元素（可能是组件、类、方法等）叫做SUT（System Under Test），把SUT所依赖的组件叫做DOC（Depended-on Component）。导致<strong>SUT无法测试的原因</strong>，通常都是<strong>DOC在当前的测试上下文中不可用</strong>。</p><p>DOC不可用的原因通常有三种：</p><p>1.不能访问。比如DOC访问了数据库或其他需要部署的中间件、服务等，而本地环境没有这些组件，也很难部署这些组件。</p><p>2.不是当前测试期望的返回值。即使本地能够访问这些组件，但它们却无法返回我们想要的值。比如我们想要获取ID为1的员工信息，但数据库中却并没有这条数据。</p><p>3.执行这些DOC的方法会引发不想要的副作用。比如更新数据库，会破坏已有数据，影响其他测试。另外连接数据库，还会导致测试执行时间变长，这也是一种副作用。</p><p>要让SUT可测，就得让DOC可用，有哪些办法呢？</p><h2>如何让代码变得可测？</h2><p>其实很简单，就是要让DOC的行为可变。这种变化可以让DOC在测试时不再直接访问数据库或其他组件，从而变得“可以访问”、“能返回期望的值”以及“不会产生副作用”。</p><p>如何才能让DOC的行为可变呢？如果DOC是静态的或是在SUT内构造的，那自然不可改变。所以，我们要让DOC的构造和SUT本身分离，SUT只需使用外部构造好的DOC的实例，而不用关心它的构造。</p><p>这种<strong>可以让DOC的行为发生改变的位置</strong>，叫做<strong>接缝（seam）</strong>，这是Michael Feathers在《修改代码的艺术》这本书里提出来的。</p><p>接缝这个隐喻非常形象，如果是一整块没有接缝的布料，你就无法做任何改动，它始终就是一块平面的布料。有了接缝，你不但可以连接不同的布料，还可以改变一块布的方向，从平面变得立体。有了接缝，身为“裁缝”的我们才可以充分发挥想象力，制作出各种丰富多彩的成品。</p><p>我把这种在<strong>SUT中创建接缝从而使SUT变得可测的方式</strong>，叫做<strong>提取接缝模式</strong>。</p><p>想要用好这个模式，我们需要了解何处下剪子，针法选什么合适。也就是接缝的位置和类型，下面我们就结合代码例子分别看看。</p><h3>接缝的位置</h3><p>我在第二节课介绍了一种提取接缝模式的应用，也就是把EmployeeDao提取成EmployeeService的字段，并通过EmployeeService的<strong>构造函数注入</strong>进来。</p><pre><code class="language-java">public class EmployeeService {\n  private EmployeeDao employeeDao;\n  public EmployeeService(EmployeeDao employeeDao) {\n    this.employeeDao = employeeDao;\n  }\n\n  public EmployeeDto getEmployeeDto(long employeeId) {\n    Employee employee = employeeDao.getEmployeeById(employeeId);\n    // 其他代码\n  }\n}\n</code></pre><p>除了构造函数，接缝也可以位于<strong>方法参数</strong>中，即：</p><pre><code class="language-java">public class EmployeeService {\n  public EmployeeDto getEmployeeDto(long employeeId, EmployeeDao employeeDao) {\n    Employee employee = employeeDao.getEmployeeById(employeeId);\n    // 其他代码\n  }\n}\n</code></pre><p>如果你使用了依赖注入工具（比如Spring），也可以给字段加@Autowired注解，这样接缝的位置就成了<strong>字段</strong>。对于这三种接缝位置，我更倾向于构造函数，因为它更方便，而且与具体的工具无关。</p><p>学习完接缝的位置，我们再来看看接缝的类型。</p><h3>接缝的类型</h3><p><strong>接缝的类型</strong>是指，<strong>通过什么样的方式来改变DOC的行为</strong>。第二节课中，提取完接缝后，我创建了一个EmployeeDao的子类，这个子类重写了getEmployeeById的默认行为，从而让这个DOC返回了我们“期望的值”。</p><pre><code class="language-java">public class InMemoryEmployeeDao extends EmployeeDao {\n  @Override\n  public Employee getEmployeeById(long employeeId) {\n    return null;\n  }\n}\n</code></pre><p>我把这种<strong>通过继承DOC来改变默认行为</strong>的接缝类型叫做<strong>对象接缝</strong>。</p><p>除此之外，还可以将原来的EmployeeDao类重命名为DatabaseEmployeeDao，并提取出一个EmployeeDao接口。然后再让InMemoryEmployeeDao类实现EmployeeDao接口。</p><pre><code class="language-java">public interface EmployeeDao {\n    Employee getEmployeeById(long employeeId);\n}\n</code></pre><p>在EmployeeService中，我们仍然通过构造函数来提供这个接缝，代码基本上可以保持不变。这样，我们和对象接缝一样，只需要在构造EmployeeService的时候传入InMemoryEmployeeDao就可以改变默认的行为，之后的测试也更方便。</p><p>这种<strong>通过将DOC提取为接口，并用其他实现类来改变默认行为</strong>的接缝类型，就叫做<strong>接口接缝</strong>。</p><p>如果你的代码依赖的是一个接口，那么这种依赖或者说耦合就是很松散的。在接口本身不发生改变的前提下，不管是修改实现了该接口的类，还是添加了新的实现类，使用接口的代码都不会受到影响。</p><h3>新生和外覆</h3><p>提取了接缝，你就可以对遗留代码添加测试了。但这时你可能会说，虽然接缝很好，但是很多复杂的代码依赖了太多东西，一个个都提取接缝的话，需要很长时间，但无奈工期太紧，不允许这么做啊。</p><p>不要紧，《修改代码的艺术》中还介绍了两种不用提取接缝就能编写可测代码的模式，也就是<strong>新生（sprout）<strong>和</strong>外覆（wrap）</strong>。</p><p>假设我们有这样一段代码，根据传入的开始和结束时间，计算这段时间内所有员工的工作时间：</p><pre><code class="language-java">public class EmployeeService {\n    public Map&lt;Long, Integer&gt; getWorkTime(LocalDate startDate, LocalDate endDate) {\n        EmployeeDao employeeDao = new EmployeeDao();\n        List&lt;Employee&gt; employees = employeeDao.getAllEmployees();\n        Map&lt;Long, Integer&gt; workTimes = new HashMap&lt;&gt;();\n        for(Employee employee : employees) {\n            WorkTimeDao workTimeDao = new WorkTimeDao();\n            int workTime = workTimeDao.getWorkTimeByEmployeeId(employee.getEmployeeId(), startDate, endDate);\n            workTimes.put(employee.getEmployeeId(), workTime);\n        }\n        return workTimes;\n    }\n}\n</code></pre><p>我知道这段代码有很多槽点，但更痛的现实状况是：你根本没有时间去优化，因为新的需求已经来了，并且明天就要提测。</p><p>需求是这样的，业务人员拿到工时的报表后发现，有很多员工的工时都是0，原来他们早就离职了。现在要求你修改一下代码，过滤掉那些离职的员工。</p><p>如果不需要写测试，这样的需求对你来说就是小事一桩，你一定轻车熟路。</p><p>你可以在EmployeeDao中添加一个新的查询数据库的方法getAllActiveEmployees，只返回在职的Employee。也可以仍然使用getAllEmployees，并在内存中进行过滤。</p><pre><code class="language-java">public class EmployeeService {\n    public Map&lt;Long, Integer&gt; getWorkTime(LocalDate startDate, LocalDate endDate) {\n        EmployeeDao employeeDao = new EmployeeDao();\n        List&lt;Employee&gt; employees = employeeDao.getAllEmployees()\n                .stream()\n                .filter(e -&gt; e.isActive())\n                .collect(toList());\n        // 其他代码\n    }\n}\n</code></pre><p>这样的修改不仅在遗留系统中，即使在所谓的新系统中，也是十分常见的。需求要求加一个过滤条件，那我就加一个过滤条件就好了。</p><p>然而，这样的代码仍然是不可测的，你加了几行代码，但你加的代码也是不可测的，系统没有因你的代码而变得更好，反而更糟了。</p><p>更好的做法是添加一个<strong>新生方法</strong>，去执行过滤操作，而不是在原来的方法内去过滤。</p><pre><code class="language-java">public class EmployeeService {\n    public Map&lt;Long, Integer&gt; getWorkTime(LocalDate startDate, LocalDate endDate) {\n        EmployeeDao employeeDao = new EmployeeDao();\n        List&lt;Employee&gt; employees = filterInactiveEmployees(employeeDao.getAllEmployees());\n        // 其他代码\n    }\n    public List&lt;Employee&gt; filterInactiveEmployees(List&lt;Employee&gt; employees) {\n        return employees.stream().filter(e -&gt; e.isActive()).collect(toList());\n    }\n}\n</code></pre><p>这样一来，新生方法是可测的，你可以对它添加测试，以验证过滤逻辑的正确性。原来的方法虽然仍然不可测，但我们也没有让它变得更糟。</p><p>除了<strong>新生</strong>，你还可以使用<strong>外覆</strong>的方式来让新增加的功能可测。比如下面这段计算员工薪水的代码。</p><pre><code class="language-java">public class EmployeeService {\n    public BigDecimal calculateSalary(long employeeId) {\n        EmployeeDao employeeDao = new EmployeeDao();\n        Employee employee = employeeDao.getEmployeeById();\n        return SalaryEngine.calculateSalaryForEmployee(employee);\n    }\n}\n</code></pre><p>如果我们现在要添加一个新的功能，有些调用端在计算完薪水后，需要立即给员工发短信提醒，而且其他调用端则保持不变。你脑子里可能有无数种实现方式，但最简单的还是直接在这段代码里添加一个<strong>新生</strong>方法，用来通知员工。</p><pre><code class="language-java">public class EmployeeService {\n    public BigDecimal calculateSalary(long employeeId, bool needToNotify) {\n        EmployeeDao employeeDao = new EmployeeDao();\n        Employee employee = employeeDao.getEmployeeById();\n        BigDecimal salary = SalaryEngine.calculateSalaryForEmployee(employee);\n        notifyEmployee(employee, salary, needToNotify);\n        return salary;\n    }\n}\n</code></pre><p>这的确非常方便，但将needToNotify这种标志位一层层地传递下去，是典型的代码坏味道<a href="https://martinfowler.com/bliki/FlagArgument.html">FlagArgument</a>。你也可以在调用端根据情况去通知员工，但那样对调用端的修改又太多太重，是典型的霰弹式修改。</p><p>最好的方式是在原有方法的基础上<strong>外覆</strong>一个新的方法calculateSalaryAndNotify，它会先调用原有方法，然后再调用通知方法。</p><pre><code class="language-java">public BigDecimal calculateSalary(long employeeId) {\n    // ...\n}\npublic BigDecimal calculateSalaryAndNotify(long employeeId) {\n    BigDecimal salary = calculateSalary(employeeId);\n    notifyEmployee(employeeId, salary);\n    return salary;\n}\npublic void notifyEmployee(long employeeId, BigDecimal salary) {\n    // 通知员工\n}\n</code></pre><p>通过这样的修改，调用端只需要根据情况选择调用哪个方法即可，这样的改动量最少。同时你还可以单独测试notifyEmployee，以确保这部分逻辑是正确的。</p><p>通过新生和外覆两种模式，我们新编写的代码就是可测的了。而通过提取接缝，旧代码的可测试化重构也可以基本搞定。接下来，我将通过构造函数注入和接口接缝演示一下，如何为这个EmployeeService编写测试。</p><h2>为代码添加测试</h2><p>我们先来回顾一下现在EmployeeService的完整代码：</p><pre><code class="language-java">public class EmployeeService {\n    private EmployeeDao employeeDao;\n    public EmployeeService(EmployeeDao employeeDao) {\n        this.employeeDao = employeeDao;\n    }\n    public EmployeeDto getEmployeeDto(long employeeId) {\n        Employee employee = employeeDao.getEmployeeById(employeeId);\n        if (employee == null) {\n            throw new EmployeeNotFoundException(employeeId);\n        }\n        return convertToEmployeeDto(employee);\n    }\n}\n</code></pre><p>我们要添加的测试是当EmployeeDao的getEmployeeById方法返回一个null的时候，EmployeeService的getEmployeeDto方法会抛出一个异常。</p><pre><code class="language-java">public class EmployeeServiceTest {\n    @Test\n    public void should_throw_employee_not_found_exception_when_employee_not_exists() {\n        EmployeeService employeeService = new EmployeeService(new InMemoryEmployeeDao());\n        EmployeeNotFoundException exception = assertThrows(EmployeeNotFoundException.class,\n            () -&gt; employeeService.getEmployeeDto(1L));\n        assertEquals(exception.getEmployeeId(), 1L);\n    }\n}\n</code></pre><p>我们在测试中使用的InMemoryEmployeeDao，实际上就是一种<strong>测试替身（Test Double）</strong>。但是它只返回了null，有点单一，想测试正常的情况就没法用了。如果想让这个方法返回不同的值，再添加一个EmployeeDao的实现着实有点麻烦。这时可以使用Mock框架，让它可以针对不同的测试场景返回不同的值。</p><pre><code class="language-java">@Test\npublic void should_return_correct_employee_when_employee_exists() {\n    EmployeeDao mockEmployeeDao = Mockito.mock(EmployeeDao.class);\n    when(mockEmployeeDao.getEmployeeById(1L)).thenReturn(givenEmployee("John Smith"));\n    EmployeeService employeeService = new EmployeeService(mockEmployeeDao);\n    EmployeeDto employeeDto = employeeService.getEmployeeDto(1L);\n    \n    assertEquals(1L, employeeDto.getEmployeeId());\n    assertEquals("John Smith", employeeDto.getName());\n}\n</code></pre><p>这里我们使用了Mockito这个Java中最流行的Mock框架。想了解更多关于测试替身和Mock框架的知识，可以参考郑晔老师的<a href="https://time.geekbang.org/column/article/408762">专栏文章</a>。</p><p>好了，代码也可测了，我们也知道怎么写测试了，那么应该按什么样的思路去添加测试呢？上面这种简单的例子，我相信你肯定是知道要怎么加测试，但是遗留系统中的那些“祖传”代码真的是什么样的都有，对于这种复杂代码，应该怎么去添加测试呢？</p><h3>决策表模式</h3><p>我们以著名的<a href="https://github.com/emilybache/GildedRose-Refactoring-Kata">镶金玫瑰重构道场</a>的代码为例，来说明如何为复杂遗留代码添加测试。</p><pre><code class="language-java">public void updateQuality() {\n   for (int i = 0; i &lt; items.length; i++) {\n       if (!items[i].name.equals("Aged Brie")\n               &amp;&amp; !items[i].name.equals("Backstage passes to a TAFKAL80ETC concert")) {\n           if (items[i].quality &gt; 0) {\n               if (!items[i].name.equals("Sulfuras, Hand of Ragnaros")) {\n                   items[i].quality = items[i].quality - 1;\n               }\n           }\n       } else {\n           if (items[i].quality &lt; 50) {\n               items[i].quality = items[i].quality + 1;\n\n               if (items[i].name.equals("Backstage passes to a TAFKAL80ETC concert")) {\n                   if (items[i].sellIn &lt; 11) {\n                       if (items[i].quality &lt; 50) {\n                           items[i].quality = items[i].quality + 1;\n                       }\n                   }\n\n                   if (items[i].sellIn &lt; 6) {\n                       if (items[i].quality &lt; 50) {\n                           items[i].quality = items[i].quality + 1;\n                       }\n                   }\n               }\n           }\n       }\n\n       if (!items[i].name.equals("Sulfuras, Hand of Ragnaros")) {\n           items[i].sellIn = items[i].sellIn - 1;\n       }\n\n       if (items[i].sellIn &lt; 0) {\n           if (!items[i].name.equals("Aged Brie")) {\n               if (!items[i].name.equals("Backstage passes to a TAFKAL80ETC concert")) {\n                   if (items[i].quality &gt; 0) {\n                       if (!items[i].name.equals("Sulfuras, Hand of Ragnaros")) {\n                           items[i].quality = items[i].quality - 1;\n                       }\n                   }\n               } else {\n                   items[i].quality = items[i].quality - items[i].quality;\n               }\n           } else {\n               if (items[i].quality &lt; 50) {\n                   items[i].quality = items[i].quality + 1;\n               }\n           }\n       }\n   }\n}\n</code></pre><p>这是非常典型的遗留代码，if/else满天飞，可谓眼花缭乱；而且分支的规则不统一，有的按名字去判断，有的按数量去判断。</p><p>对于这种分支条件较多的代码，我们可以梳理需求文档（如果有的话）和代码，找出所有的路径，根据每个路径下各个字段的数据和最终的值，制定一张决策表，如下图所示。</p><p><img src="https://static001.geekbang.org/resource/image/63/d1/6357f689162820db3d22623e38aacbd1.jpg?wh=1920x1667" alt="图片"></p><p>比如第一行，我们要测的是，系统每天会自动给所有商品的保质期和品质都减1，那么给出的条件是商品类型为normal，保质期为4天，品质为1，所期望的行为是保质期和品质都减少1。而第二行则是测试，当保质期减为0之后，品质会双倍地减少。以此类推，我们一共梳理出18个测试场景。</p><p>你会看到，这种决策表不但清晰地提供了所有测试用例，而且给出了相应的数据，你可以很轻松地基于它来构建整个方法的测试。</p><h2>测试的类型和组织</h2><p>说完了如何添加测试，我们接下来看看可以添加哪些类型的测试。</p><p>Mike Cohn在十几年前曾经提出过著名的“<a href="https://martinfowler.com/bliki/TestPyramid.html">测试金字塔</a>”理论，将测试划分为三个层次。从上到下分别是：UI测试、服务测试和单元测试。它们累加在一起，就像一个金字塔一样。需要指出的是，遗留系统很难应用测试金字塔，但我们还是有必要先来看看这三层测试都包含哪些内容。</p><p><img src="https://static001.geekbang.org/resource/image/4d/48/4da7cb2739ac48ff731184f91c728f48.jpg?wh=1920x1106" alt="图片"></p><p>其中，最顶层的UI测试是指从页面点击到数据库访问的端到端测试，用自动化的方式去模拟用户或测试人员的行为。</p><p>早年间的所谓自动化测试大多都属于这种。但这样的测试十分不稳定，一个简单的页面调整就可能导致测试失败。</p><p>尽管现在很多工具推出了headless的方式，可以绕开页面，但它们仍然运行得很慢。而且还需要与很多服务、工具集成起来，环境的搭建也是个问题。所以UI测试位于测试金字塔的顶端，即只需要少量的这种测试，来验证服务和中间件等相互之间的访问是正常的。</p><p>需要指出的是，UI测试并不是针对前端元素或组件的测试。后者其实是前端的单元测试。</p><p>中间这层的服务测试也是某种意义的端到端测试，但它避开了UI的复杂性，而是直接去测试UI会访问的API。也有人管这种测试叫集成测试。它可以直接访问数据库，也可以用H2或SQLite等文件或内存数据库代替；它也可以直接访问其他服务，也可以用<a href="https://github.com/dreamhead/moco">Moco</a>等工具来模拟服务的行为。</p><p>这种测试的好处是，可以测试API级别的端到端行为，不管内部的代码如何重构，只要API的契约保持不变，测试就不需要修改。</p><p>最底层的单元测试就是对某个方法的测试，平时开发同学写的大多是这方面的测试。测试金字塔的建议是，尽可能多地写单元测试，它编写成本低、运行速度快，是整个测试金字塔的基座。</p><p>对于方法内用到的DOC，你可以用测试替身来替换。对于在多大程度上使用测试替身，有两种不同的观点。</p><p>一种观点认为不管任何依赖都应该使用测试替身来代替；一种观点则认为只要DOC不访问数据库、不访问文件系统、不访问进程外的服务或中间件，就可以不用测试替身。前者的学名叫solitary unit test，我管它叫“<strong>社恐症单元测试</strong>”；后者学名叫做sociable unit test，我管它叫“<strong>交际花单元测试</strong>”。</p><p>到底应该使用哪种类型的单元测试呢？这一点并没有定论，支持每种类型的人都不少。我个人更倾向于交际花单测，因为这样写起来更容易，而且对重构很友好。</p><h2>遗留系统中的测试策略</h2><p>学完了测试金字塔，你是不是已经准备按照由少到多的关系，在遗留系统中补测试了呢？先别急，遗留代码有很多特点，导致它们并不适合完全应用测试金字塔来组织测试。</p><p>首先，遗留系统的很多业务逻辑位于数据库的存储过程或函数中，代码只是用来传递参数而已。这样一来单元测试根本测不到什么东西。你也不能在服务测试（或API测试）中使用内存数据库，因为要在这些数据库中复制原数据库中的存储过程或函数，可能会有很多语法不兼容。</p><p>其次，遗留系统的很多业务还位于前端页面中，位于JSP、PHP、ASP的标签之中。这部分逻辑也是没法用单元测试来覆盖的。而服务测试脱离了页面，显然也无法覆盖。</p><p>因此，如果你的遗留系统在前端和数据库中都有不少业务逻辑，就可以多写一些UI测试，它们可以端到端地覆盖这些业务逻辑。你可以从系统中最重要的业务开始编写UI测试。</p><p>然而，UI测试毕竟十分不稳定，运行起来也很慢，当数量上来后这些缺点就会被放大。这时候你可以多编写一些服务测试。</p><p>对于数据库中的业务逻辑，你可以搭建一些基础设施，让开发人员可以在测试中直连数据库，并方便地编写集成测试。这些基础设施包括：</p><ul>\n<li>一个数据库镜像，可以快速在本地或远端做初始化；需要将数据库容器化，满足开发和测试人员使用个人数据库的需求。</li>\n<li>一个数据复制工具，可以方便地从其他测试环境拉取数据到这个镜像，以方便数据的准备；可以考虑通过CI/CD来实现数据的复制。</li>\n</ul><p>除此之外，你可能还需要一个数据对比工具，用来帮你在重构完代码后，比较数据库的状态。比如将一个存储过程或函数中的逻辑迁移到Java代码中的时候，要验证迁移的正确性，只跑通集成测试是远远不够的，还要全方位地比较数据库中相关表的数据，以防漏掉一些不起眼的地方。</p><p>对于前端中的业务逻辑，你可以先重构这些逻辑，将它们迁移到后端中（我将在第十三节课详细讲解如何迁移），然后再编写单元测试或服务测试。</p><p>这时的测试策略有点像一个钻石的形状。</p><p><img src="https://static001.geekbang.org/resource/image/5e/c5/5ea17f429b5b6f1a3397238448b49ac5.jpg?wh=1920x1066" alt="图片"></p><p>确定好了测试的类型，还有一些测试编写方面的小细节我想跟你分享。</p><p>第一个细节是测试的命名。关于测试命名，不同书籍中都有不同的推荐，但我更倾向于像<a href="https://time.geekbang.org/column/article/508559">第四节课</a>中介绍的那样，用“实例化需求”的方式，从业务角度来命名测试，使得测试可以和代码一起演进，成为活文档。</p><p>第二个细节是测试的组织。当测试变多时，如果不好好对测试进行分组，很快就会变得杂乱无章。这样的测试即使是活文档，也会增加认知负载。</p><p>最好的方法是，将单个类的测试都放在同一个包中，将不同方法的测试放在单独的测试类里。而对于同一个方法，要先写它Happy path的测试，再写Sad path。记住一个口诀：<strong>先简单，再复杂；先正常，再异常</strong>。也就是测试的场景要先从简单的开始，逐步递进到复杂的情况；而测试的用例要先写正常的Case，再逐步递进到异常的Case。</p><h2>小结</h2><p>今天学习的知识比较密集，需要好好总结一下。</p><p>我们首先学习了<strong>接缝的位置</strong>和<strong>接缝的类型</strong>。接缝的位置是指那些可以让DOC的行为发生改变的位置，有构造函数、方法参数、字段三种；而接缝的类型则是说改变DOC行为的方式，包括对象接缝和接口接缝。</p><p>遗留代码中有了接缝，就可以着手写测试了。然而复杂的遗留代码很难去梳理清楚头绪，我想你推荐用<strong>决策表</strong>的方式，将测试用例一一列出来。</p><p>在遗留系统中，如果存储过程中包含大量的业务逻辑，传统的金字塔型的测试策略可能并不适合，你可以多写一些端到端的UI测试，以及与数据库交互的集成测试（服务测试）。这时的测试策略呈现一个钻石的形状。</p><p><img src="https://static001.geekbang.org/resource/image/5e/c5/5ea17f429b5b6f1a3397238448b49ac5.jpg?wh=1920x1066" alt="图片"></p><p>最后我想说的是，自动化测试是代码不可或缺的一部分，忽视了测试，即使是新系统，也在向着遗留系统的不归路上冲刺。然而技术社区对于测试的态度总是十分漠视，多年来不曾改观。</p><p>有一次我的同事在某语言群里询问，是否有人愿意给一个开源框架添加测试，然而大家想的却是什么“技术进步性”。</p><p><img src="https://static001.geekbang.org/resource/image/9d/2f/9dbed940418bc71d3ebc11fbc0a3d02f.jpg?wh=1920x1351" alt="图片"></p><p>开发人员如果忽视编写自动化测试，就放弃了将质量内建到软件（也就是自己证明自己质量）的机会，把质量的控制完全托付给了测试人员。这种靠人力去保证质量的方式，永远也不可能代表“技术先进性”。</p><p>有的时候你可能觉得，我就是写了一行代码，加不加测试无所谓吧？反正原来也没有测试。但是，希望你不要这么想，更不要这么做。犯罪心理学中有一个“破窗效应”，意思是说如果一栋楼有几扇窗户是破的，用不了几天所有的窗户都会破掉。这是一个加速熵增的过程，没有测试的系统，就是那座破了窗户的大楼。</p><p>你要记住的是“童子军原则”，也就是当露营结束离开的时候，要打扫营地，让它比你来的时候更干净。你写了一行代码，并把这一行代码的测试加上，你就没有去打破一扇新的窗户，而是让系统比你写代码之前变得更好了。这便是引入了一个负熵，让你的系统从无序向着有序迈出了一步。</p><p>莫以恶小而为之，莫以善小而不为。</p><h2>思考题</h2><p>感谢你听完我的絮絮叨叨，希望今天的课程能唤醒你写测试的意愿。今天的思考题请你分享一段你项目中的代码，并聊一聊你准备如何给它添加测试，别忘了给代码脱敏。</p><p>如果你觉得今天的课程对你有帮助，请把它分享给你的同事和朋友，我们一起来写测试吧。</p>',
        article_title: "08 | 代码现代化：你的代码可测吗？",
      },
      {
        title: "09 | 代码现代化：如何将一个300行的方法重构为3行？",
        id: 513599,
        content:
          '<p>你好，我是姚琪琳。</p><p>在上节课里，我们学习了如何对遗留代码做可测试化重构，并添加测试。有了测试的保障，接下来就可以大胆地开始重构“烂代码”了。</p><p>在重构了大量遗留代码后，我终于找到了两个最实用的方法，这节课我就带你认识这两种重构遗留代码的利器，我把它们称为“倚天剑”和“屠龙刀”，可以帮你劈开一团乱麻式的代码。</p><p>我曾经用这两种模式将一个300行代码重构为3行。是不是感觉很神奇？</p><h2>基于坏味道的重构</h2><p>在此之前，我先来简单絮叨两句我们重构代码的原则，就是<strong>基于坏味道来重构</strong>。也就是说，我们在重构时，要尽量先去识别《重构》中总结的二十几种坏味道，再用书中对应的重构手法去重构。</p><p>你可能会质疑，要不要这么教条啊？这其实并不是教条。Martin Fowler已经“阅码无数”，甚至可能比我吃的饭都多。他总结出来的坏味道已经足够典型，对应的重构手法也足够好用。我也承认我的智商远不如他，那为什么不能拿来主义呢？</p><p>和第六节课学习代码增量演进时一样，在重构代码之前，我还是先带你识别坏味道，然后再重构。遗留系统的代码，简直是最具代表性的“代码坏味道大观园”。</p><p>尽管重构起来挑战重重，但攻克它们又令人上瘾、着迷、欲罢不能。我这样安排，是为了授之以渔（即重构的方法），而不光是授之以鱼（即重构好的方法）。</p><!-- [[[read_end]]] --><p>准备好了吗？我们开始。</p><h2>倚天剑：拆分阶段</h2><p>我们先来见识见识重构遗留代码的倚天剑，<strong>拆分阶段（Split Phase）</strong>。这是Martin Fowler在《重构（第2版）》中新提出的一种重构手法。当我第一次看到这个手法的介绍时，简直茅塞顿开（当然，我第一次看到《重构》中的很多内容时，都是这个状态）。它解决了我在面临遗留代码时最头疼的问题。</p><p><img src="https://static001.geekbang.org/resource/image/03/76/034d1bcaef664422de2971ed7af8a076.png?wh=1920x1088" alt="图片"></p><p>遗留代码最大的问题就是方法过长。方法长了之后，前后几代开发人员不停往里塞东西，有的加在这里，有的加在那里，导致最后谁都无法分清到底方法做了几件事情。我们都说，方法长了就不是<strong>单一职责（SRP）</strong>了，但更要命的是，由于代码过于混乱，你甚至说不清楚到底有哪些职责。</p><p>拆分阶段就像倚天剑一样，轻巧地把方法到底做了几件事情给拎清楚，把相关的代码组织到一起。</p><p>比如，大多数情况下，一个方法都在处理这样的三个阶段：第一，校验、转换传入的数据；第二，根据传入或转换后的数据，完成业务处理；第三，准备要返回的数据并返回。其中第二个阶段如果过于复杂，还可以拆分成更多的小步骤。</p><p>现在我们来举一个例子。以下代码来自一个拆分阶段的重构Kata，它出自《重构（第2版）》的第1章，作者对原来的代码做了一些简化，使之更适合拆分阶段的重构练习。你可以在<a href="https://github.com/gregorriegler/refactoring-split-phase">GitHub</a>上找到完整的代码。</p><pre><code class="language-java">public class TheatricalPlayers {\n   public String print(Invoice invoice) {\n       var totalAmount = 0;\n       var volumeCredits = 0;\n       var result = String.format("Statement for %s\\n", invoice.customer);\n\n       NumberFormat format = NumberFormat.getCurrencyInstance(Locale.US);\n\n       for (var perf : invoice.performances) {\n           var play = perf.play;\n           var thisAmount = 40000;\n           if (perf.audience &gt; 30) {\n               thisAmount += 1000 * (perf.audience - 30);\n           }\n\n           var thisCredits = Math.max(perf.audience - 30, 0);\n           if ("comedy".equals(play.type)) thisCredits += Math.floor((double) perf.audience / 5);\n\n           totalAmount += thisAmount;\n           volumeCredits += thisCredits;\n       }\n       \n       result += String.format("Amount owed is %s\\n", format.format(totalAmount / 100));\n       result += String.format("You earned %s credits\\n", volumeCredits);\n       return result;\n   }\n}\n</code></pre><p>我们一起来看看它有哪些坏味道。</p><p>它计算了演出的总费用以及观众量积分（volume credits，根据到场的观众数量来计算的积分，下次客户再请剧团演出的时候，可以用这个积分获得折扣），并且对这两项数据进行格式化并返回。</p><p>看到这样的描述，估计你的第一反应就是，它违反了<strong>单一职责原则（SRP）</strong>。没错，一个方法承担了计算总费用、计算观众量积分和格式化信息这三个职责。然而我更喜欢用《重构》中介绍的坏味道<strong>发散式变化（divergent change）</strong>来评价它。</p><p><strong>一个类或方法应该只有一个引起它变化的原因</strong>，而对于这个方法来说，显然有三个。如果计算费用的逻辑发生变化，比如观众的基数从30改成了50；如果计算积分的逻辑发生变化，比如演出悲剧也有相应的积分；如果格式化的逻辑发生变化，比如用HTML来输出清单，你都需要修改这个方法。引起它变化的原因，不是一个，而是三个。</p><p>对于这个坏味道，《重构》的建议是，如果不同的变化方向形成了先后顺序，就用<strong>拆分阶段</strong>手法将它们分开。我们来看看该怎么操作。</p><p>首先，在开始正式重构之前，我建议你先运行一下所有的测试，确保通过。</p><p>再仔细观察这段代码，你会发现，很多变量的声明和使用的位置离得非常远。这是遗留代码的典型特点。一方面，一些古老的编程语言或编程风格，以及某些大学课程，要求你把方法内的所有变量都声明在方法开头。另一方面，由于代码经手的人太多，很多人会有意无意将自己的代码插入到变量的声明和使用之间。</p><p>但你应该清楚的是，我们更倾向于<strong>给局部变量更小的作用域</strong>，也就是在使用它之前再声明。</p><p>我们先把result和format两个变量的声明往下挪，挪到result使用之前。仅此一步，你其实已经完成了拆分阶段的部分内容，把格式化部分的逻辑择了出来。</p><p>别忘了运行测试。虽然只有这一步，你几乎可以100%确认没有问题，但你仍然需要运行一下测试，养成好习惯。</p><pre><code class="language-java">public class TheatricalPlayers {\n   public String print(Invoice invoice) {\n       var totalAmount = 0;\n       var volumeCredits = 0;\n       \n       for (var perf : invoice.performances) {\n           var play = perf.play;\n           var thisAmount = 40000;\n           if (perf.audience &gt; 30) {\n               thisAmount += 1000 * (perf.audience - 30);\n           }\n\n           var thisCredits = Math.max(perf.audience - 30, 0);\n           if ("comedy".equals(play.type)) thisCredits += Math.floor((double) perf.audience / 5);\n\n           totalAmount += thisAmount;\n           volumeCredits += thisCredits;\n       }\n       \n       var result = String.format("Statement for %s\\n", invoice.customer);\n       NumberFormat format = NumberFormat.getCurrencyInstance(Locale.US);\n       result += String.format("Amount owed is %s\\n", format.format(totalAmount / 100));\n       result += String.format("You earned %s credits\\n", volumeCredits);\n       return result;\n   }\n}\n</code></pre><p>第二步，来看看for循环里面吧。play变量也和使用它的地方差了6行的距离，你一定二话不说，也往下移。但是等等，再仔细观察一下，其实只有一个地方在使用这个play，干脆不用移动了，直接内联（inline）吧。</p><p>注意，我说的移动一行代码和内联，包括后面的提取方法和移动方法，在大多数IDE中都是有快捷键的。我强烈建议你<strong>记住并熟练运用这些快捷键</strong>，它们可以使你事半功倍。后面讲解“屠龙刀”时会专门说说快捷键。</p><p>第三步，计算thisAmount的代码已经集中在了一起，这也是拆分阶段的阶段性成果。不要迟疑，把它们提取成一个方法，彻底和下面的代码划清界限。我们来看看，现在的代码变成了什么样子：</p><pre><code class="language-java">public String print(Invoice invoice) {\n    var totalAmount = 0;\n    var volumeCredits = 0;\n\n    for (var perf : invoice.performances) {\n        int thisAmount = getThisAmount(perf);\n        \n        var thisCredits = Math.max(perf.audience - 30, 0);\n        if ("comedy".equals(perf.play.type)) thisCredits += Math.floor((double) perf.audience / 5);\n        \n        totalAmount += thisAmount;\n        volumeCredits += thisCredits;\n    }\n    \n    // format代码\n}\n</code></pre><p>第四步，把totalAmount的累加代码上移，让使用thisAmount和声明thisAmount的代码挨在一起。这时你会发现，thisAmount也只有这一处调用，完全可以内联。你可能正发愁这个变量名不知道怎么改好，这样一内联，它就不见了，真是一了百了。</p><p>第五步，重复上面的第三、四步，把计算thisCredits的方法提取出来，并内联thisCredits。这时for循环内部，只剩短短的两行代码了。</p><pre><code class="language-java">for (var perf : invoice.performances) {\n    totalAmount += getThisAmount(perf);\n    volumeCredits += getThisCredits(perf);\n}\n</code></pre><p>是不是已经很清爽了？但其实还有改进空间，不要停止脚步，我们继续。变量totalAmount和valumeCredits的声明和使用还是分离的，而且它们在循环内部赋值，在循环后面使用，这样的变量似乎只能在循环前面声明。</p><p>第六步，复制一下这个for循环，分别删掉两个for中的volumeCredits和totalAmount的赋值语句，用两个for循环分别计算totalAmount和volumeCredits。对这一步你可能有异议，本来一个循环变为了两个，性能变差了呀。的确，性能是变差了那么一点点，但这一点点性能损失与它所带来的可读性提升相比，根本不值一提。</p><p>第七步，把totalAmount和volumeCredits的声明和各自的for循环移到一起，形成下面这样的形式：</p><pre><code class="language-java">public String print(Invoice invoice) {\n    var totalAmount = 0;\n    for (var perf : invoice.performances) {\n        totalAmount += getThisAmount(perf);\n    }\n    \n    var volumeCredits = 0;\n    for (var perf : invoice.performances) {\n        volumeCredits += getThisCredits(perf);\n    }\n    \n    var result = String.format("Statement for %s\\n", invoice.customer);\n    var format = NumberFormat.getCurrencyInstance(Locale.US);\n    result += String.format("Amount owed is %s\\n", format.format(totalAmount / 100));\n    result += String.format("You earned %s credits\\n", volumeCredits);\n    return result;\n}\n</code></pre><p>到这一步，我们基本完成了拆分阶段的重构。代码本来是一团乱麻，被倚天剑劈成了三段，分别负责计算totalAmount、计算volumeCredits和格式化输出结果。代码已经相当清爽了。</p><p>讲到这，其实你会发现，拆分阶段不过就是重新组织代码，把跟某个逻辑相关的语句，从原先分散的各处拎出来，统统合并在一起。你可以用空行隔开不同阶段，也可以抽取出方法，这样就能让原方法显得更简洁一些。</p><p>因此，第八步，把各个阶段提取成单独的方法，彻底完成重构。</p><pre><code class="language-java">public String print(Invoice invoice) {\n    int totalAmount = getTotalAmount(invoice);\n    int volumeCredits = getVolumeCredits(invoice);\n    return getResult(invoice, totalAmount, volumeCredits);\n}\n</code></pre><p>总结一下我们重构这段代码的八个步骤，如下图：</p><p><img src="https://static001.geekbang.org/resource/image/ef/5a/efa27a11abf8f6112c5cfc130841765a.jpg?wh=6580x4220" alt="" title="拆分阶段"></p><p>把一个长方法拆分成多个阶段，并抽取成小的方法，这样做不但能使代码异常整洁，而且在你需要修改的时候，只需找到相关的小方法，而完全不需要去关心其他小方法内的细节，从而降低了<strong>认知负载</strong>。</p><p>拆分阶段不仅适用于代码拆分，而且也可以用于存储过程和函数的拆分，我们后面在实战篇里还会看到这个模式。</p><p>展示了倚天剑，是时候掏出屠龙刀了，它可以将职责不相关的代码彻底斩断关系。</p><h2>屠龙刀：方法对象</h2><p><strong>方法对象（Method Object）</strong>是极限编程和TDD之父Kent Beck在《实现模式》中提出的一种模式。Kent Beck甚至直言，这是他最喜爱的模式之一。</p><p>所谓方法对象，就是指<strong>只包含一个方法的对象</strong>，这个方法就是该对象主要的业务逻辑。如果你不知道如何隔离不同的职责，就可以“无脑”地使用方法对象模式，将不同职责都提取到不同的方法对象中。</p><p>我们仍然以上面介绍的代码为例来介绍方法对象。拆分阶段完成之后的完整代码如下：</p><pre><code class="language-java">public class TheatricalPlayers {\n    public String print(Invoice invoice) {\n        int totalAmount = getTotalAmount(invoice);\n        int volumeCredits = getVolumeCredits(invoice);\n        return getResult(invoice, totalAmount, volumeCredits);\n    }\n    \n    private int getTotalAmount(Invoice invoice) {\n        var totalAmount = 0;\n        for (var perf : invoice.performances) {\n            totalAmount += getThisAmount(perf);\n        }\n        return totalAmount;\n    }\n    \n    private int getThisAmount(Performance perf) {\n        var thisAmount = 40000;\n        if (perf.audience &gt; 30) {\n            thisAmount += 1000 * (perf.audience - 30);\n        }\n        return thisAmount;\n    }\n    private int getVolumeCredits(Invoice invoice) {\n        var volumeCredits = 0;\n        for (var perf : invoice.performances) {\n            volumeCredits += getThisCredits(perf);\n        }\n        return volumeCredits;\n    }\n    \n    private int getThisCredits(Performance perf) {\n        var thisCredits = Math.max(perf.audience - 30, 0);\n        if ("comedy".equals(perf.play.type)) thisCredits += Math.floor((double) perf.audience / 5);\n        return thisCredits;\n    }\n    \n    private String getResult(Invoice invoice, int totalAmount, int volumeCredits) {\n        var result = String.format("Statement for %s\\n", invoice.customer);\n        var format = NumberFormat.getCurrencyInstance(Locale.US);\n        result += String.format("Amount owed is %s\\n", format.format(totalAmount / 100));\n        result += String.format("You earned %s credits\\n", volumeCredits);\n        return result;\n    }\n}\n</code></pre><p>代码的坏味道仍然是<strong>发散式变化</strong>，只不过从方法级别变成了类级别，当三个阶段的任何一个逻辑发生变化的时候，你都需要修改这个类。</p><p>我们要做的就是把getTotalAmount、getVolumeCredits和getResult三个方法都移动到不同的方法对象中。</p><p>你可能会说，这有何难？我最擅长的就是Copy&amp;Paste了。先别急着按Ctrl（Cmd）+ C，IDE普遍提供了强大的重构工具支持，如果不能物尽其用，简直就是暴殄天物了。你完全可以全都使用重构工具来自动完成这些重构，甚至都不需要碰鼠标。</p><p>我在这里就以Mac版的IntelliJ IDEA来演示一下，如何只用键盘就安全地实现移动方法的重构。仔细看好，不要眨眼。</p><p>我们先来移动getTotalAmount这个方法。由于它还调用了getThisAmount，所以必须连带着把它也移走。为了避免这个麻烦，你可以选择先把getThisAmount内联，这样就只需要移动一个方法了。</p><p>你可以把光标放到getThisAmount的方法定义处或者调用处，然后按Cmd+Opt+N，在弹出的对话框中选择“Inline all and remove the method”。</p><p>下一步，按下Opt+F1，唤出选择视图的菜单，再按回车选择第一个Project View，这时焦点正好在TheatricalPlayers类上。你可以按Cmd+N在相同的包内创建一个新类，名字就叫TotalAmountCalculator吧。</p><p>Kent Beck在书中介绍方法对象时说，<strong>可以用方法名的变形作为类名</strong>。如果方法名叫complexCalculation，那么类名就可以叫ComplexCalculator。我们这里的方法叫做getTotalAmount，按同样的思路应该叫TotalAmountGetter，但这个名字并不好，因为getTotalAmount这个名字本身就不好，其实应该叫calculateTotalAmount。</p><p>创建完类之后，IDE会帮我们打开这个类，然而我现在并不打算对这个类做修改。你可以按Ctrl+Tab跳回到TheatricalPlayers类中，把光标放到getTotalAmount方法签名上，按Cmd+F6来修改它的签名，将刚刚创建的TotalAmountCalculator作为方法的参数，在参数默认值的文本框中，可以填new TotalAmountCalculator()。</p><p>按下回车，方法的签名就改好了。你可能会问，为什么要把新建的类作为方法参数呢？方法内又没有用到，这不是多此一举吗？不用急，你很快就会发现原因了。</p><p>接下来就是见证奇迹的时刻。把光标放到getTotalAmount的方法名上，按下F6，会弹出移动方法的对话框，你要选择一个对象来移动你的方法。由于我们想把方法移动到新建的TotalAmountCalculator中，所以当然要选这个。按下回车，getTotalAmount方法就被神奇地移动到了TotalAmountCalculator中。</p><p>现在你应该明白了为什么要把TotalAmountCalculator放到方法参数中了吧？因为要移动方法时，需要选择一个位置，这个位置就是这个方法所依赖的类。放到方法参数中就相当于让它依赖了TotalAmountCalculator，这样你才能在后续移动方法时，选择TotalAmountCalculator作为移动的目标。</p><p>接下来，你可以用同样的方式来移动getVolumeCredits和getResult方法，这里就不一一演示了。完成之后的代码如下：</p><pre><code class="language-java">public String print(Invoice invoice) {\n    int totalAmount = new TotalAmountCalculator().getTotalAmount(invoice);\n    int volumeCredits = new VolumeCreditsCalculator().getVolumeCredits(invoice);\n    return new ResultFormatter().getResult(invoice, totalAmount, volumeCredits);\n}\n</code></pre><p>由于我们是在方法中直接构造的这些DOC，你可以把它们<strong>提取成接缝</strong>，通过构造函数进行注入。我们再做一些重命名，把看着不爽的方法名通通改掉。</p><pre><code class="language-java">public class TheatricalPlayers {\n    private TotalAmountCalculator totalAmountCalculator;\n    private VolumeCreditsCalculator volumeCreditsCalculator;\n    private ResultFormatter resultFormatter;\n    \n    public TheatricalPlayers(TotalAmountCalculator totalAmountCalculator, VolumeCreditsCalculator volumeCreditsCalculator, ResultFormatter resultFormatter) {\n        this.totalAmountCalculator = totalAmountCalculator;\n        this.volumeCreditsCalculator = volumeCreditsCalculator;\n        this.resultFormatter = resultFormatter;\n    }\n    \n    public String print(Invoice invoice) {\n        int totalAmount = totalAmountCalculator.calculate(invoice);\n        int volumeCredits = volumeCreditsCalculator.calculate(invoice);\n        return resultFormatter.format(invoice, totalAmount, volumeCredits);\n    }\n}\n\n</code></pre><p>到这里，方法对象的重构就全部完成了。它就像屠龙刀一样，彻底劈开了不同职责之间的联系，让它们各自位于自己的方法对象里。</p><p>我在重构了大量遗留代码之后发现，虽然不同代码最终的样子不尽相同，但过程中似乎都包含了方法对象。有些可能会进一步重构成行为型的设计模式，有些就干脆以方法对象为终点。可以说，方法对象，是设计模式的中间步骤。</p><p><img src="https://static001.geekbang.org/resource/image/1a/51/1a49223e13ac1e0b399216d7110d4451.jpg?wh=7369x4737" alt="" title="方法对象"></p><p>我们用快捷键秀操作的过程就到此为止了。我强烈建议你跟着文稿，实际操练一遍，体会快捷键编程带来的快感。</p><p><img src="https://static001.geekbang.org/resource/image/19/11/198f254a1bd8537bedf2f5347b0fb311.jpg?wh=1920x1178" alt="图片" title="IntelliJ IDEA常用快捷键速记表"></p><p>我创建了两个关于快捷键的小测验，一个是<a href="https://jinshuju.net/f/RD0T8r">Mac版</a>，一个是<a href="https://jinshuju.net/f/KHJfng">Windows版</a>，你可以刻意练习一下。</p><p>这样做的好处是，每一个步骤都是IDE自动完成的，是比较安全的。即使在没有测试的情况下，也能相对安全地完成重构。当然，我这可不是鼓励你在没有测试的情况下就去重构，这只是万不得已的情况。</p><p>用快捷键来操作，也是IntelliJ IDEA的正确打开方式，它可以大大提高你的开发效率，让你的手速能够跟上你的思维。如果你熟练的话，整个重构过程不超过1分钟就能完成，省去了各种上下文切换的成本，比如键鼠切换、Tab页切换等。</p><h2>重构结束了吗？</h2><p>有人可能认为重构已经结束了，但如果你对代码有洁癖，就不能容忍坏味道的存在。我们虽然提取出了三个方法对象，但代码仍然有问题。</p><p>下面我再提供两种不同的重构方向。你可以来比较一下。</p><h3>重构到策略模式</h3><p>仔细观察TotalAmountCalculator和VolumeCreditsCalculator，你会发现，它们的方法签名非常类似，都是接受一个Invoice参数，返回一个int。这种坏味道叫做<strong>异曲同工的类（Alternative Classes with Different Interfaces）</strong>，我们可以提取接口，让这两个类实现同一个接口：</p><pre><code class="language-java">public interface InvoiceCalculator {\n    int calculate(Invoice invoice);\n}\n</code></pre><p>TheatricalPlayers将变成：</p><pre><code class="language-java">public class TheatricalPlayers {\n    private InvoiceCalculator totalAmountCalculator;\n    private InvoiceCalculator volumeCreditsCalculator;\n    private ResultFormatter resultFormatter;\n    \n    public TheatricalPlayers(InvoiceCalculator totalAmountCalculator, InvoiceCalculator volumeCreditsCalculator, ResultFormatter resultFormatter) {\n        this.totalAmountCalculator = totalAmountCalculator;\n        this.volumeCreditsCalculator = volumeCreditsCalculator;\n        this.resultFormatter = resultFormatter;\n    }\n    \n    // print方法\n}\n\n</code></pre><p>现在，不同的calculator都实现了同一个接口，我们貌似重构到了策略模式。看过《重构与模式》的人可能会暗喜，重构到设计模式可是重构的最高境界啊，我的代码貌似向着“整洁”的方向又迈进了一大步。然而真的是这样吗？我们先来看看另一种重构思路。</p><h3>重构到领域模型</h3><p>我们看看TotalAmountCalculator这个方法对象，它只依赖Invoice类，并且本身没有任何数据。这种大量依赖外部数据，而不依赖自己内部数据的坏味道，叫做<strong>依恋情结（Feature Envy）</strong>。我们可以直接将方法移动到Invoice内部。用上面学到的快捷键，按一下F6就可以搞定。</p><p>移动之后的Invoice类如下所示：</p><pre><code class="language-java">public class Invoice {\n    // 其他代码\n    \n    int calculate() {\n        var totalAmount = 0;\n        for (var perf : performances) {\n            var thisAmount = 40000;\n            if (perf.audience &gt; 30) {\n                thisAmount += 1000 * (perf.audience - 30);\n            }\n            totalAmount += thisAmount;\n        }\n        return totalAmount;\n    }\n}\n</code></pre><p>这时这个方法再叫calculate就不合适了，我们把它改回getTotalAmount，如果你不喜欢get为前缀的名字，也可以叫calculateTotalAmount。</p><p>你还会发现，移动到Invoice中来之后，这个方法就只依赖Performance了，Invoice不过是遍历了多个Performance而已。你可以提取计算单个Performance的Amount的方法，看看会发生什么。</p><pre><code class="language-java">int calculateTotalAmount() {\n    var totalAmount = 0;\n    for (var perf : performances) {\n        int thisAmount = getThisAmount(perf);\n        totalAmount += thisAmount;\n    }\n    return totalAmount;\n}\nprivate int getThisAmount(Performance perf) {\n    var thisAmount = 40000;\n    if (perf.audience &gt; 30) {\n        thisAmount += 1000 * (perf.audience - 30);\n    }\n    return thisAmount;\n}\n</code></pre><p>你会发现getThisAmount方法只依赖Performance，这又是<strong>依恋情结</strong>坏味道。同样的，可以把方法移动到Performance内来消除。移动完之后，calculateTotalAmount变为：</p><pre><code class="language-java">int calculateTotalAmount() {\n    var totalAmount = 0;\n    for (var perf : performances) {\n        int thisAmount = perf.calculateAmount();\n        totalAmount += thisAmount;\n    }\n    return totalAmount;\n}\n</code></pre><p>这时你还可以充分发挥Java stream的语法特性，将for循环也消除掉：</p><pre><code class="language-java">int calculateTotalAmount() {\n    return performances.stream().mapToInt(Performance::calculateAmount).sum();\n}\n</code></pre><p>同样的，VolumeCreditsCalculator方法也存在依恋情结坏味道，可以用同样的方式来重构。都完成后，TheatricalPlayers类的print方法将如下所示：</p><pre><code class="language-java">public String print(Invoice invoice) {\n    int totalAmount = invoice.calculateTotalAmount();\n    int volumeCredits = invoice.calculateVolumeCredits();\n    return resultFormatter.getResult(invoice, totalAmount, volumeCredits);\n}\n</code></pre><p>这时，你可以将totalAmount和volumeCredits内联，这样方法就剩下了一行。它的职责就只剩下了格式化结果，因为计算totalAmount和volumeCredits的逻辑已经被隔离在了Invoice中。那么当前方法和ResultFormatter的职责也重叠了，我们可以把这个getResult方法也内联掉。</p><pre><code class="language-java">public String print(Invoice invoice) {\n    var format = NumberFormat.getCurrencyInstance(Locale.US);\n    var result = String.format("Statement for %s\\n", invoice.customer);\n    result += String.format("Amount owed is %s\\n", format.format(invoice.calculateTotalAmount() / 100));\n    result += String.format("You earned %s credits\\n", invoice.calculateVolumeCredits());\n    return result;\n}\n</code></pre><p>我们把重构出来的三个方法对象，居然又全部消除掉了！</p><p>为什么产生了“消消乐”一样的效果呢？这是因为我们把计算的逻辑都放到了Invoice和Performance对象中，就没有必要引入其他的算法类（方法对象）了。这种<strong>把数据行为都放在对象中</strong>的模式，叫做<strong>领域模型模式</strong>。我们将在下节课详细介绍。</p><p>比较一下上面提到的两种重构方向，你觉得哪种更适合当前的代码呢？我的答案是第二种。</p><p>第一种重构虽然看上去像是“策略模式”，但实际上策略接口的两个实现类并不是相互替换的关系，而是“毫无关系”。所有行为型模式的共同特点是，不同的行为可以根据某些条件相互替换，直白点说就是，要有if/else，才能体现出这些替换。而代码中的TotalAmountCalculator和VolumeCreditsCalculator虽然都叫calculator，但没有if/else，它们在原方法中是顺序执行的，不能相互替换。</p><p>你必须对所有代码坏味道和模式非常熟悉，才能找到正确的重构方向。重构到设计模式固然美好，但并不一定就是最终目标，有时候你可能会用错设计模式，有时候会过度设计。重构到一个刚刚好的状态，没有明显的坏味道，就足够了。</p><h2>小结</h2><p>终于学完了今天的课程，希望你学完的感受是“大呼过瘾”。有时候重构的感觉就是这样，比实际写代码更让人身心愉悦。</p><p>我今天为你展示了重构遗留代码的倚天剑和屠龙刀，希望它们能助你在遗留系统的荆棘之中，杀出一条血路。其实重构手法和模式还有很多很多，我之所以认为这两个特别实用，是因为在重构了大量遗留代码后，我发现<strong>拆分阶段</strong>和<strong>方法对象</strong>是必不可少的中间步骤。</p><p>当你通过这两种方式完成了初步重构之后，还要审视一下代码，根据坏味道实现下一步的重构。</p><p>我还在介绍方法对象的时候，穿插了如何使用快捷键来完成重构。你可能会觉得记住额外的快捷键属于外在认知负载，其实不然。它们能够提高你的工作效率，而且一旦记住并且熟练掌握，就能一劳永逸。这种知识属于内在认知负载，是我们完成工作必须具备的技能。</p><p>重构手法也好，快捷键也罢，都不是什么奇技淫巧，而是像玄铁重剑一样，重剑无锋，大巧不工。它们应该融化在每一个开发人员的血液里。如果你还不熟悉，就抓紧练起来吧。</p><p>无他，唯手熟尔。</p><h2>思考题</h2><p>感谢你学完了今天的内容，希望你能通过书籍和博客去学习一下其他的重构手法和模式。今天的课后作业，还是请你来贴一段项目中的实际代码，我们一起来分析一下其中的坏味道，并通过坏味道来驱动我们重构。</p><p>如果你觉得今天的课程对你有帮助，请把它分享给你的同事和朋友，我们一起来重构吧。下节课，我们继续挑战代码的分层重构，敬请期待。</p>',
        article_title: "09 | 代码现代化：如何将一个300行的方法重构为3行？",
      },
      {
        title: "10 | 代码现代化 ：代码的分层重构",
        id: 514479,
        content:
          '<p>你好，我是姚琪琳。</p><p>上节课，我带你学习了重构遗留代码的倚天剑和屠龙刀，也就是<strong>拆分阶段</strong>和<strong>方法对象。</strong>面对遗留代码，它们是披荆斩棘的利器。</p><p>不过，单块逻辑的代码重构好了之后，我们还要迎接新的挑战。今天我们就来看看如何重构整体的代码，也就是如何对代码分层。</p><h2>遗留系统中常见的模式</h2><p>我还记得大学时做的编程作业，用VB6做一个学校图书馆的借书系统。当时的做法十分“朴素”，在点击“借阅”按钮的事件处理器中，我直接读取借书列表中的书籍ID，然后连接数据库，执行一条update语句，把这些书籍的借阅者字段改成当前的学生ID。</p><p>后来，我看到了Eric Evans的《领域驱动设计》这本书，才发现这种做法就是书中介绍的<strong>Smart UI模式</strong>。它虽然简单好理解，但归根结底还是一种面向过程的编程思想。一旦逻辑变得更复杂，这种模式的问题就会凸显出来。</p><p>举个最简单的例子，比如借书前需要校验学生的类型，本科生最多可以借3本，而研究生最多可以借10本。如果本科生借阅了5本书，在点击按钮的时候就会弹出错误消息。我们用伪代码来表示就是：</p><pre><code class="language-java">var bookCount = bookDataTable.count\nvar studentType = DB.query("SELECT TYPE FROM STUDENTS WHERE ID = " + studentId)\nif (studentType = "本科生" &amp;&amp; bookCount &gt; 3)\n  MessageBox.error("本科生一次最多借阅3本图书")\nif (studentType = "研究生" &amp;&amp; bookCount &gt; 10)\n  MessageBox.error("研究生一次最多借阅10本图书")\n\nfor(var book in bookDataTable.values)\n  DB.update("UPDATE BOOKS SET BORROWER_ID = " + studentId + " WHERE BOOK_ID = " + book.id)\n</code></pre><!-- [[[read_end]]] --><p>也许只是添加这几行代码，你并不觉是什么大问题，但紧接着教师的借阅数量也需要校验，讲师和教授的借阅数量也会有不同的限制。当逻辑越来越复杂，这种过程式的代码就只能向一个地方堆代码。即使可以抽一些函数出来，也只能是杯水车薪。</p><p>其实还有更严重的问题：由于将界面展示、业务逻辑、数据库访问都放在一个文件中，<strong>发散式变化</strong>的坏味道十分严重。调整界面布局要改这个文件，修改业务逻辑要改这个文件，甚至修改表名、列名也要修改这个文件。</p><p>除了早期的桌面客户端应用，还有在JSP和ASP中直接写业务逻辑并访问数据库的，也属于Smart UI。除此之外，Martin Fowler在《企业应用架构模式》还提出了<strong>事务脚本（Transaction Script）模式</strong>。该模式分离了用户界面和业务逻辑，但仍然还是按数据的方式去组织业务，没有建立对象模型。</p><p>为了改善这种状况，人们开始重构这种模式。将界面逻辑、业务逻辑和数据库访问分离开来，形成了UI、Service、Dao这样的三层结构。</p><p><img src="https://static001.geekbang.org/resource/image/d3/c3/d39636411e3263c192453a7c5495c8c3.jpg?wh=1920x1256" alt="图片"></p><p>上面的代码也就变成了下面这样（让我们从伪代码切换回Java）。</p><pre><code class="language-java">// UI层\nBookService bookService = new BookService();\nbookService.borrowBook(userData, bookDataList);\n\n// Service层\nif ("教师".equals(userData.getType())) {\n  if ("讲师".equals(userData.getLevel()) || "助教".equals(userData.getLevel())) {\n    if (bookDataList.count() &gt; 20) {\n      throw new BookBorrowException("讲师和助教一次最多借阅20本图书");\n    }\n  }\n  else if ("教授".equals(userData.getLevel()) || "副教授".equals(userData.getLevel())) {\n    if (bookDataList.count() &gt; 50) {\n      throw new BookBorrowException("教授和副教授一次最多借阅50本图书");\n    }\n  }\n}\nelse if ("学生".equals(userData.getType())) {\n  if ("本科生".equals(userData.getLevel())) {\n    if (bookDataList.count() &gt; 3) {\n      throw new BookBorrowException("本科生一次最多借阅3本图书");\n    }\n  }\n  else if ("研究生".equals(userData.getLevel())) {\n    if (bookDataList.count() &gt; 10) {\n      throw new BookBorrowException("研究生一次最多借阅50本图书");\n    }\n  }\n}\nBookDao bookDao = new BookDao();\nbookDao.borrowBook(userData.getUserId(), bookDataList)\n\n// Dao层\nfor(var book in bookDataList)\n  DB.update("UPDATE BOOKS SET BORROWER_ID = " + userId + " WHERE BOOK_ID = " + book.getId())\n</code></pre><p>感觉是不是跟你平时编写的代码十分类似？</p><p>然而在我看来，这样的分层仍然是过程式的，和事务脚本相比，并没有本质区别。它虽然在Service层向Dao层传递数据时使用了对象，但这种不含任何行为的<strong>贫血模型</strong>也只是起了数据传递的作用。</p><p>而且，像代码中的UserData和BookData所定义的位置往往都是很随意的，有时定义在UI层，有时定义在Service层，有时定义在Dao层。上面图中所画的箭头只是代表了数据流动的方向，而不是对象依赖的方向。</p><p>这种模式最大的问题在于，当逻辑变得复杂时，服务层的代码会变得越来越臃肿，不同的服务之间也很难相互调用和复用逻辑，每一个服务类都将变成上帝类（God Class）。</p><h2>领域模型</h2><p>随着面向对象编程范式的流行，越来越多的人倾向于<strong>用对象为要解决的问题建立模型（Domain Model）</strong>，<strong>用对象来描述问题中的不同元素</strong>。<strong>元素中所有的数据和行为都将在对象中有所体现</strong>。也就是说，我们不再用过程来控制逻辑，而是将逻辑分别放入不同的对象中。</p><p>对于上面借书的例子，如果我们把各种判断借书数量是否合规的逻辑，放到不同的User对象中去，将书籍借阅的逻辑，也就是设置书籍借阅状态的逻辑，放到Book中去，就会得到这样的代码：</p><pre><code class="language-java">public abstract class User {\n    public abstract void borrow(Book[] books);\n}\n\npublic class UndergraduateStudent extends User {\n    @Override\n    public void borrow(Book[] books) {\n        if (books.length &gt; 3) {\n            throw new BookBorrowException("本科生一次最多借阅3本图书");\n        }\n        for(Book book : books) {\n          book.lendTo(this);\n        }\n    }\n}\n\npublic class Book {\n    public void lendTo(User user) {\n        status = BookStatus.LEND_OUT;\n        borrowerId = user.getId();\n    }\n}\n</code></pre><p>可以看到，这段代码充分利用了面向对象继承和封装的优势，分解了原来的复杂逻辑，将其分散到不同的对象中去。</p><p>乍一看你也许有点困惑，因为逻辑十分分散，而且想看懂一个业务场景，要在不同的对象之间来回跳转，远不如过程式代码那样直观。而且还会有各种纠结的地方，比如到底是“人借阅书”，还是“书借给人”。</p><p>但这其实就是面向对象的优雅之处，它对客观世界进行了建模，但是并不需要完全去照搬客观世界。</p><p>“人借阅书”还是“书借给人”并不重要，重要的是如何更顺畅地编写代码。比如在我的例子中，既有“人借阅书”，又有“书借给人”。“人借阅书”是为了解决在借阅时的校验问题，“书借给人”是为了将人的信息标记在书上。</p><p>在了解了领域模型模式后，你一定迫不及待地想把事务脚本模式的代码都重构成领域模型了吧？这个重构过程中，你可能分辨不出自己的代码到底属于哪种模式。我可以教你一个小技巧，就是看你要获取一个值的时候，是<strong>从对象中获取</strong>，还是<strong>直接从数据库中查询</strong>。</p><p>比如你想查询一本书是否被借出了，你查询数据库BOOKS表，如果BORROWER_ID这个字段为空，就返回1，那这就是事务脚本模式：</p><pre><code class="language-java">String sql = "SELECT COUNT(*) FROM BOOKS WHERE BOOK_ID = :bookId AND BORROWER_ID IS NULL";"\n\nboolean isBorrowed = DB.query(sql) == 0;\n</code></pre><p>这种处理方式把数据和模型割裂开了，而且IS NULL和==0大概率会把人搞晕，认知负载非常高。</p><p>如果你用SQL去获取一个模型，然后在代码中判断getBorrowerId方法的返回值是否为空，那就是贫血模型模式：</p><pre><code class="language-java">String sql = "SELECT * FROM BOOKS WHERE BOOK_ID = :bookId";\nBook book = DB.query(sql);\nif (book.getBorrowerId() != null) { }\n</code></pre><p>这种处理方式把模型当做数据的载体，比单纯的事务脚本要好很多。但是所有判断逻辑都会落在客户端代码处。</p><p>如果你用SQL去获取一个模型，然后调用模型的isBorrowed方法来判断书籍是否被借出，就是领域模型模式：</p><pre><code class="language-java">String sql = "SELECT * FROM BOOKS WHERE BOOK_ID = :bookId";\nBook book = DB.query(sql);\nif (book.isBorrowed()) { }\n</code></pre><p>这种处理方式把模型当做数据和行为的载体，把行为封装在了领域模型内部。</p><p><strong>领域模型最重要的一点是，要随着业务的变化而不断演进</strong>。尽管上面的模型对于大学编程课的作业，可能还说得过去，但真实的借阅场景显然更复杂。</p><p>比如，我希望查询一本书籍的所有借阅历史。再比如，书籍的借阅是有有效期的，当有效期快到了的时候，我希望给用户发短信提醒，有效期过了就会有相应的惩罚逻辑。当“借阅”这个名词在业务的描述中频繁出现时，就是一种要为它建模的信号了。</p><p>对于现在的模型来说，“借阅”体现在Book对象的borrowerId这个字段上。你也可以继续在Book上添加validTo这种字段来表示借阅的有效期，但显然借阅历史是无法表示出来的。对于持久化来讲，借阅历史的多条数据显然无法用书籍的一条数据来表示。</p><p>这时，我们就需要为“借阅”来单独建模了。作为书籍和用户之间的关联关系，它其实是某种<strong>关联对象（Association Object）</strong>。</p><pre><code class="language-java">public class Borrowing {\n  private User user;\n  private Book book;\n}\n\npublic class User {\n  private List&lt;Borrowing&gt; borrowings;\n  public void borrow(Book[] books) {\n    for(Book book : books)\n      borrowings.add(new Borrowing(this, book));\n  }\n}\n</code></pre><p>当Borrowing这个模型建立起来后，它就可以持久化起来作为借阅的历史记录，也可以在它上面添加各种业务字段，如有效期等。</p><h2>数据映射器和仓库</h2><p>你可能注意到了，在上面的代码中，我并没有添加任何数据访问相关的逻辑。这也是领域模型模式的一个难点。<strong>领域模型中的字段需要与数据库中的表字段进行双向映射</strong>，通常来说，你可以继续使用之前的Dao来实现这种映射。</p><p>例如当一个借阅发生时，你可以：</p><pre><code class="language-java">public class BorrowingDao {\n  public void insert(Borrowing borrowing) {\n    String sql = "INSERT INTO BORROWINGS...";\n    // 执行SQL\n  }\n}\n</code></pre><p>我们把这种方式叫做<strong>数据映射器（Data Mapper）模式</strong>，它<strong>分离了领域模型和数据库访问代码的细节，也封装了数据映射的细节</strong>。</p><p>然而不管是叫BorrowingDao还是BorrowingMapper，都暗示了它们与数据库的关系。在领域模型中，我们往往希望模型更加“干净”，希望使用的是一种和数据访问无关的组件。</p><p>另一方面，这种模式也导致表和领域对象的一一对应。在简单的业务场景下这并不是问题，但在复杂的情况下，你就无法设计出合理的模型。比如上面的例子，一个借阅就是一个Borrowing，这时你很可能放弃给User和Book建模，而直接去构建Borrowing模型，这就又回到<strong>事务脚本</strong>的老路上去了。</p><p>还有一点就是，当查询的需求变得复杂时，数据映射器就显得力不从心了。</p><p>这时我们需要使用的是<strong>仓库（Repository）模式</strong>，让它来负责协调领域模型和数据映射器。仓库模式又被翻译为资源库或者仓储，不过我更倾向于翻译为仓库。在领域驱动设计中，构造一个新的复杂的领域模型时，我们可以使用<strong>工厂（Factory）模式</strong>，那工厂“生产”出来的“产品”，自然要放到仓库中了。</p><p>Repository还有一层意思，就是“知识库”或“智囊团”。之所以把它放在数据映射器之前，就是因为它比数据映射器更懂得如何去查询领域对象，你可以基于它来设计任何你想要的查询。</p><p>仓库的接口与集合的接口十分接近，你可以向仓库中添加对象，也可以从中删除对象，就好像是在操作内存中的集合一样。而实际上，真正执行操作的，是封装在仓库内部的数据映射器。仓库不过是提供了一个更加面向对象的方式，将领域对象和数据访问隔离开来。</p><pre><code class="language-java">public class UserRepository {\n  public void add(User user) { }\n  public void save(User user) { }\n  public User findById(long userId) { }\n}\n</code></pre><p>你还可以为各个仓库创建接口，定义在领域对象所在的包中。将仓库的实现类和数据映射器定义在一起，这样领域模型不依赖任何数据访问的组件，就显得十分整洁了。</p><p>在使用仓库模式时，我们只从领域对象的源头操作。我们不会去对Borrowing创建一个BorrowingRepository，而是将Borrowing放到User内部，然后通过UserRepository去获取User，进而获取到当前User所有的Borrowing。</p><p>这么做的原因是，Borrowing只是一个关联对象，并不是一个所谓的“源头”。如果用领域驱动设计中的术语来说就是，Borrowing不是一个<strong>聚合根（Aggregate Root）</strong>。你也可以将这个“源头”理解为工厂模式创建出来的产品。你要去仓库中取的是一个产品（聚合根），而不是这个产品的某个零件（关联对象）。这也是为什么在DDD中，仓库只是针对聚合根的，只有聚合根才有仓库，聚合根上的其他实体或值对象是没有仓库的。</p><p>最后，由于仓库的接口是面向集合的，复杂查询自然也不在话下。</p><p>我们在实际设计时，为了实现依赖倒置，即领域层不依赖数据访问组件，可以将仓库的接口定义在领域层，而将实现类和数据映射器定义在数据访问层。</p><h2>应用服务</h2><p>解决了业务逻辑和数据访问分离的问题，我们把目光向“前”看，看看业务逻辑之前的逻辑应该如何处理。</p><p>一个软件系统，除了业务逻辑之外，还存在一些非业务的逻辑。比如用户认证、事务、日志记录等。像前面说过的如果一个借阅快到期了就发送通知，这种对于第三方（短信通知）服务的编排，也属于这类逻辑。Martin Fowler等人把这类逻辑叫做<strong>应用逻辑（Application Logic）</strong>。你可以理解成是因为有了应用程序，才会有的逻辑。</p><p>为了把业务逻辑和应用逻辑分离，我们可以使用<strong>服务层（Service Layer）模式</strong>。它是一组在领域模型之上构建的<strong>应用服务（Application Service）</strong>，用来处理某个业务场景相关的应用逻辑。</p><p>从某种意义上，也可以认为服务层是对领域模型的封装，可以对UI层提供更加友好的接口。由于它跟业务场景一一对应，所以Bob大叔在整洁架构里，管它叫做<strong>用例（Usecase）</strong>。</p><p>对于短信通知的场景，应用服务的代码如下所示：</p><pre><code class="language-java">public class BorrowingValidityService {\n  public void validate(long userId) {\n    User user = userRepository.findById(userId);\n    for(Borrowing borrowing : users.allBorowings()) {\n      if(!borrowing.isValid()) {\n        notificationService.send(new BorrowingInvalidMessage(borrowing.getBook()));\n      }\n    }\n  }\n}\n</code></pre><p>注意，判断一个借阅是否有效属于业务逻辑，而在无效时发送短信则属于应用逻辑，要在应用服务中处理。这相当于，领域模型提供了判断借阅是否有效的能力，而如何使用这种能力，是应用逻辑来决定的，不同的场景有不同的用法。</p><p>而对于借阅的应用服务，代码如下：</p><pre><code class="language-java">public class BorrowService {\n  public void borrow(long userId, long[] bookIds) {\n    User user = userRepository.findById(userId);\n    Book[] books = bookRepository.findByIds(bookIds);\n    user.borrow(books);\n    userRepository.update(user);\n  }\n}\n</code></pre><p>我们在应用服务中，通过仓库获取领域模型，调用领域模型中的方法，然后再通过仓库更新领域模型。</p><p>如果你了解领域驱动设计（DDD），一定会相当熟悉应用服务、领域模型、仓库这些模式。但这些模式并不只属于DDD。在DDD诞生之前，这些模式就已经存在了，《企业应用架构模式》中甚至还提出了很多可以替代的模式。DDD只是把这些模式进行组合，形成了一套以领域模型模式为基础的最佳实践。</p><p><img src="https://static001.geekbang.org/resource/image/5y/4d/5yy3d4bcb26dd4yyc15dc82c7343ac4d.jpg?wh=1920x1138" alt="图片"></p><h2>小结</h2><p>我们今天从遗留系统中常见的代码样例说起，将一个事务脚本一步步重构成了DDD中常见的分层架构。这期间穿插着介绍了领域模型、数据映射器、仓库、应用服务等多种模式。不管你的系统位于这个路线的哪个阶段，你都应该有能力把它重构好。</p><p>你可能会说，你的项目业务没有这么复杂，事务脚本也能解决绝大部分应用场景。没错，事务脚本本身就是一种解决领域逻辑位置的模式，但以我的经验，这条路最终会走向混乱。</p><p>有的时候，你之所以觉得业务没那么复杂，是因为在脑子里将业务映射成了数据库表，那么写出的代码自然是事务脚本。如果你不用大脑做这一层映射，而是先将业务直接反映到领域模型中，然后再用代码去实现到数据库表的映射，往往情况就会有所好转。</p><p>你应该刻意培养自己领域建模的意识，如果没有这种意识，那么绝大多数软件对你来说，都只不过是CRUD。</p><p>下节课我们开启架构现代化的挑战，从建设新城区说起，敬请期待。</p><h2>思考题</h2><p>感谢你学完了今天的内容，今天的思考题是这样的。请你把自己的项目对号入座，看看属于哪种模式，你们有没有计划去重构它们呢 ？</p><p>感谢你学完了今天的课程，欢迎你把它分享给你的同事或朋友，我们一起来重构遗留代码。</p>',
        article_title: "10 | 代码现代化 ：代码的分层重构",
      },
    ],
  },
];
