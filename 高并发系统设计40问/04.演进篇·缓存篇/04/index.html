<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>15 | 缓存的使用姿势（三）：缓存穿透了怎么办？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/高并发系统设计40问/04.演进篇·缓存篇/04" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a aria-current="page" class="active" href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a aria-current="page" class="active" href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/高并发系统设计40问/01.开篇词">01.开篇词</a><ul><li><a href="/blog-two/高并发系统设计40问/01.开篇词/01"><span>开篇词 | 为什么你要学习高并发系统设计？</span></a></li></ul></li><li><a href="/blog-two/高并发系统设计40问/02.基础篇">02.基础篇</a><ul><li><a href="/blog-two/高并发系统设计40问/02.基础篇/01"><span>01 | 高并发系统：它的通用设计方法是什么？</span></a></li><li><a href="/blog-two/高并发系统设计40问/02.基础篇/02"><span>02 | 架构分层：我们为什么一定要这么做？</span></a></li><li><a href="/blog-two/高并发系统设计40问/02.基础篇/03"><span>03 | 系统设计目标（一）：如何提升系统性能？</span></a></li><li><a href="/blog-two/高并发系统设计40问/02.基础篇/04"><span>04 | 系统设计目标（二）：系统怎样做到高可用？</span></a></li><li><a href="/blog-two/高并发系统设计40问/02.基础篇/05"><span>05 | 系统设计目标（三）：如何让系统易于扩展？</span></a></li><li><a href="/blog-two/高并发系统设计40问/02.基础篇/06"><span>06 | 面试现场第一期：当问到组件实现原理时，面试官是在刁难你吗？</span></a></li></ul></li><li><a href="/blog-two/高并发系统设计40问/03.演进篇·数据库篇">03.演进篇·数据库篇</a><ul><li><a href="/blog-two/高并发系统设计40问/03.演进篇·数据库篇/01"><span>07 | 池化技术：如何减少频繁创建数据库连接的性能损耗？</span></a></li><li><a href="/blog-two/高并发系统设计40问/03.演进篇·数据库篇/02"><span>08 | 数据库优化方案（一）：查询请求增加时，如何做主从分离？</span></a></li><li><a href="/blog-two/高并发系统设计40问/03.演进篇·数据库篇/03"><span>09 | 数据库优化方案（二）：写入数据量增加时，如何实现分库分表？</span></a></li><li><a href="/blog-two/高并发系统设计40问/03.演进篇·数据库篇/04"><span>10 | 发号器：如何保证分库分表后ID的全局唯一性？</span></a></li><li><a href="/blog-two/高并发系统设计40问/03.演进篇·数据库篇/05"><span>11 |   NoSQL：在高并发场景下，数据库和NoSQL如何做到互补？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/高并发系统设计40问/04.演进篇·缓存篇">04.演进篇·缓存篇</a><ul><li><a href="/blog-two/高并发系统设计40问/04.演进篇·缓存篇/01"><span>12 | 缓存：数据库成为瓶颈后，动态数据的查询要如何加速？</span></a></li><li><a href="/blog-two/高并发系统设计40问/04.演进篇·缓存篇/02"><span>13 | 缓存的使用姿势（一）：如何选择缓存的读写策略？</span></a></li><li><a href="/blog-two/高并发系统设计40问/04.演进篇·缓存篇/03"><span>14 | 缓存的使用姿势（二）：缓存如何做到高可用？</span></a></li><li><a aria-current="page" class="active" href="/blog-two/高并发系统设计40问/04.演进篇·缓存篇/04"><span>15 | 缓存的使用姿势（三）：缓存穿透了怎么办？</span></a></li><li><a href="/blog-two/高并发系统设计40问/04.演进篇·缓存篇/05"><span>16 | CDN：静态资源如何加速？</span></a></li><li><a href="/blog-two/高并发系统设计40问/04.演进篇·缓存篇/06"><span>加餐 | 数据的迁移应该如何做？</span></a></li></ul></li><li><a href="/blog-two/高并发系统设计40问/05.演进篇·消息队列篇">05.演进篇·消息队列篇</a><ul><li><a href="/blog-two/高并发系统设计40问/05.演进篇·消息队列篇/01"><span>17 | 消息队列：秒杀时如何处理每秒上万次的下单请求？</span></a></li><li><a href="/blog-two/高并发系统设计40问/05.演进篇·消息队列篇/02"><span>18 | 消息投递：如何保证消息仅仅被消费一次？</span></a></li><li><a href="/blog-two/高并发系统设计40问/05.演进篇·消息队列篇/03"><span>19 | 消息队列：如何降低消息队列系统中消息的延迟？</span></a></li><li><a href="/blog-two/高并发系统设计40问/05.演进篇·消息队列篇/04"><span>20 | 面试现场第二期：当问到项目经历时，面试官究竟想要了解什么？</span></a></li><li><a href="/blog-two/高并发系统设计40问/05.演进篇·消息队列篇/05"><span>用户故事 | 从“心”出发，我还有无数个可能</span></a></li><li><a href="/blog-two/高并发系统设计40问/05.演进篇·消息队列篇/06"><span>期中测试 | 10道高并发系统设计题目自测</span></a></li></ul></li><li><a href="/blog-two/高并发系统设计40问/06.演进篇·分布式服务篇">06.演进篇·分布式服务篇</a><ul><li><a href="/blog-two/高并发系统设计40问/06.演进篇·分布式服务篇/01"><span>21 | 系统架构：每秒1万次请求的系统要做服务化拆分吗？</span></a></li><li><a href="/blog-two/高并发系统设计40问/06.演进篇·分布式服务篇/02"><span>22 | 微服务架构：微服务化后系统架构要如何改造？</span></a></li><li><a href="/blog-two/高并发系统设计40问/06.演进篇·分布式服务篇/03"><span>23 | RPC框架：10万QPS下如何实现毫秒级的服务调用？</span></a></li><li><a href="/blog-two/高并发系统设计40问/06.演进篇·分布式服务篇/04"><span>24 | 注册中心：分布式系统如何寻址？</span></a></li><li><a href="/blog-two/高并发系统设计40问/06.演进篇·分布式服务篇/05"><span>25 | 分布式Trace：横跨几十个分布式组件的慢请求要如何排查？</span></a></li><li><a href="/blog-two/高并发系统设计40问/06.演进篇·分布式服务篇/06"><span>26 | 负载均衡：怎样提升系统的横向扩展能力？</span></a></li><li><a href="/blog-two/高并发系统设计40问/06.演进篇·分布式服务篇/07"><span>27 | API网关：系统的门面要如何做呢？</span></a></li><li><a href="/blog-two/高并发系统设计40问/06.演进篇·分布式服务篇/08"><span>28 | 多机房部署：跨地域的分布式系统如何做？</span></a></li><li><a href="/blog-two/高并发系统设计40问/06.演进篇·分布式服务篇/09"><span>29 | Service Mesh：如何屏蔽服务化系统的服务治理细节？</span></a></li></ul></li><li><a href="/blog-two/高并发系统设计40问/07.演进篇·维护篇">07.演进篇·维护篇</a><ul><li><a href="/blog-two/高并发系统设计40问/07.演进篇·维护篇/01"><span>30 | 给系统加上眼睛：服务端监控要怎么做？</span></a></li><li><a href="/blog-two/高并发系统设计40问/07.演进篇·维护篇/02"><span>31 | 应用性能管理：用户的使用体验应该如何监控？</span></a></li><li><a href="/blog-two/高并发系统设计40问/07.演进篇·维护篇/03"><span>32 |  压力测试：怎样设计全链路压力测试平台？</span></a></li><li><a href="/blog-two/高并发系统设计40问/07.演进篇·维护篇/04"><span>33 | 配置管理：成千上万的配置项要如何管理？</span></a></li><li><a href="/blog-two/高并发系统设计40问/07.演进篇·维护篇/05"><span>34 | 降级熔断：如何屏蔽非核心系统故障的影响？</span></a></li><li><a href="/blog-two/高并发系统设计40问/07.演进篇·维护篇/06"><span>35 |  流量控制：高并发系统中我们如何操纵流量？</span></a></li><li><a href="/blog-two/高并发系统设计40问/07.演进篇·维护篇/07"><span>36 | 面试现场第三期：你要如何准备一场技术面试呢？</span></a></li></ul></li><li><a href="/blog-two/高并发系统设计40问/08.实战篇">08.实战篇</a><ul><li><a href="/blog-two/高并发系统设计40问/08.实战篇/01"><span>37 | 计数系统设计（一）：面对海量数据的计数器要如何做？</span></a></li><li><a href="/blog-two/高并发系统设计40问/08.实战篇/02"><span>38 | 计数系统设计（二）：50万QPS下如何设计未读数系统？</span></a></li><li><a href="/blog-two/高并发系统设计40问/08.实战篇/03"><span>39 | 信息流设计（一）：通用信息流系统的推模式要如何做？</span></a></li><li><a href="/blog-two/高并发系统设计40问/08.实战篇/04"><span>40 |  信息流设计（二）：通用信息流系统的拉模式要如何做？</span></a></li></ul></li><li><a href="/blog-two/高并发系统设计40问/09.结束语">09.结束语</a><ul><li><a href="/blog-two/高并发系统设计40问/09.结束语/01"><span>结束语 | 学不可以已</span></a></li><li><a href="/blog-two/高并发系统设计40问/09.结束语/02"><span>结课问卷获奖用户名单</span></a></li><li><a href="/blog-two/高并发系统设计40问/09.结束语/03"><span>春节特别策划 | 高并发下如何发现和排查问题？</span></a></li><li><a href="/blog-two/高并发系统设计40问/09.结束语/04"><span>春节特别策划 | 我们如何准备抵抗流量峰值？</span></a></li></ul></li><li><a href="/blog-two/高并发系统设计40问/10.结课测试">10.结课测试</a><ul><li><a href="/blog-two/高并发系统设计40问/10.结课测试/01"><span>结课测试 | 高并发系统设计的相关知识，你都掌握了吗？</span></a></li></ul></li><li><a href="/blog-two/高并发系统设计40问/summary">高并发系统设计40问</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="什么是缓存穿透" data-depth="2"><a href="/blog-two/高并发系统设计40问/04.演进篇·缓存篇/04#什么是缓存穿透"><span>什么是缓存穿透</span></a></li><li title="缓存穿透的解决方案" data-depth="2"><a href="/blog-two/高并发系统设计40问/04.演进篇·缓存篇/04#缓存穿透的解决方案"><span>缓存穿透的解决方案</span></a></li><li title="回种空值" data-depth="3"><a href="/blog-two/高并发系统设计40问/04.演进篇·缓存篇/04#回种空值"><span>回种空值</span></a></li><li title="使用布隆过滤器" data-depth="3"><a href="/blog-two/高并发系统设计40问/04.演进篇·缓存篇/04#使用布隆过滤器"><span>使用布隆过滤器</span></a></li><li title="课程小结" data-depth="2"><a href="/blog-two/高并发系统设计40问/04.演进篇·缓存篇/04#课程小结"><span>课程小结</span></a></li><li title="一课一思" data-depth="2"><a href="/blog-two/高并发系统设计40问/04.演进篇·缓存篇/04#一课一思"><span>一课一思</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="15--缓存的使用姿势三缓存穿透了怎么办"><a aria-hidden="true" tabindex="-1" href="/blog-two/高并发系统设计40问/04.演进篇·缓存篇/04#15--缓存的使用姿势三缓存穿透了怎么办"><span class="icon icon-link"></span></a>15 | 缓存的使用姿势（三）：缓存穿透了怎么办？</h1><p>你好，我是唐扬。</p><p>我用三节课的时间带你深入了解了缓存，你应该知道对于缓存来说命中率是它的生命线。</p><p>在低缓存命中率的系统中，大量查询商品信息的请求会穿透缓存到数据库，因为数据库对于并发的承受能力是比较脆弱的。一旦数据库承受不了用户大量刷新商品页面、定向搜索衣服信息，查询就会变慢，大量的请求也会阻塞在数据库查询上，造成应用服务器的连接和线程资源被占满，最终导致你的电商系统崩溃。</p><p>一般来说，我们的核心缓存的命中率要保持在99%以上，非核心缓存的命中率也要尽量保证在90%，如果低于这个标准你可能就需要优化缓存的使用方式了。</p><p>既然缓存的穿透会带来如此大的影响，那么我们该如何减少它的发生呢？本节课我就带你全面探知面对缓存穿透时，我们到底有哪些应对措施。不过在此之前你需要了解“到底什么是缓存穿透”，只有这样才能更好地考虑如何设计方案解决它。</p><h2 id="什么是缓存穿透"><a aria-hidden="true" tabindex="-1" href="/blog-two/高并发系统设计40问/04.演进篇·缓存篇/04#什么是缓存穿透"><span class="icon icon-link"></span></a>什么是缓存穿透</h2><p>缓存穿透其实是指从缓存中没有查到数据，而不得不从后端系统（比如数据库）中查询的情况。你可以把数据库比喻为手机，它是经受不了太多的划痕和磕碰的，所以你需要贴个膜再套个保护壳，就能对手机起到一定的保护作用了。</p><p>不过少量的缓存穿透不可避免，对系统也是没有损害的，主要有几点原因：</p><ul><li><p>一方面，互联网系统通常会面临极大数据量的考验，而缓存系统在容量上是有限的，不可能存储系统所有的数据，那么在查询未缓存数据的时候就会发生缓存穿透。</p></li><li><p>另一方面，互联网系统的数据访问模型一般会遵从“80/20原则”。“80/20原则”又称为帕累托法则，是意大利经济学家帕累托提出的一个经济学的理论。简单来说，它是指在一组事物中，最重要的部分通常只占20%，而其他的80%并没有那么重要。把它应用到数据访问的领域，就是我们会经常访问20%的热点数据，而另外的80%的数据则不会被经常访问。比如你买了很多衣服，很多书，但是其实经常穿的、经常看的可能也就是其中很小的一部分。</p></li></ul><p>既然缓存的容量有限，并且大部分的访问只会请求20%的热点数据，那么理论上说，我们只需要在有限的缓存空间里存储20%的热点数据就可以有效地保护脆弱的后端系统了，也就可以放弃缓存另外80%的非热点数据了。所以这种少量的缓存穿透是不可避免的，但是对系统是没有损害的。</p><p>那么什么样的缓存穿透对系统有害呢？答案是大量的穿透请求超过了后端系统的承受范围造成了后端系统的崩溃。如果把少量的请求比作毛毛细雨，那么一旦变成倾盆大雨，引发洪水，冲倒房屋，肯定就不行了。</p><p>产生这种大量穿透请求的场景有很多，接下来我就带你解析这几种场景以及相应的解决方案。</p><h2 id="缓存穿透的解决方案"><a aria-hidden="true" tabindex="-1" href="/blog-two/高并发系统设计40问/04.演进篇·缓存篇/04#缓存穿透的解决方案"><span class="icon icon-link"></span></a>缓存穿透的解决方案</h2><p>先来考虑这样一种场景：在你的电商系统的用户表中，我们需要通过用户ID查询用户的信息，缓存的读写策略采用Cache Aside策略。</p><p>那么如果要读取一个用户表中未注册的用户，会发生什么情况呢？按照这个策略，我们会先读缓存再穿透读数据库。由于用户并不存在，所以缓存和数据库中都没有查询到数据，因此也就不会向缓存中回种数据（也就是向缓存中设置值的意思），这样当再次请求这个用户数据的时候还是会再次穿透到数据库。在这种场景下缓存并不能有效地阻挡请求穿透到数据库上，它的作用就微乎其微了。</p><p>那如何解决缓存穿透呢？一般来说我们会有两种解决方案：<strong>回种空值以及使用布隆过滤器。</strong></p><p>我们先来看看第一种方案。</p><h3 id="回种空值"><a aria-hidden="true" tabindex="-1" href="/blog-two/高并发系统设计40问/04.演进篇·缓存篇/04#回种空值"><span class="icon icon-link"></span></a>回种空值</h3><p>回顾上面提到的场景，你会发现最大的问题在于数据库中并不存在用户的数据，这就造成无论查询多少次数据库中永远都不会存在这个用户的数据，穿透永远都会发生。</p><p>**类似的场景还有一些：**比如由于代码的bug导致查询数据库的时候抛出了异常，这样可以认为从数据库查询出来的数据为空，同样不会回种缓存。</p><p>那么，当我们从数据库中查询到空值或者发生异常时，我们可以向缓存中回种一个空值。但是因为空值并不是准确的业务数据，并且会占用缓存的空间，所以我们会给这个空值加一个比较短的过期时间，让空值在短时间之内能够快速过期淘汰。<strong>下面是这个流程的伪代码：</strong></p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Object nullValue = new Object();</span></div><div class="token-line"><span class="token plain">    try {</span></div><div class="token-line"><span class="token plain">      Object valueFromDB = getFromDB(uid); //从数据库中查询数据</span></div><div class="token-line"><span class="token plain">      if (valueFromDB == null) {</span></div><div class="token-line"><span class="token plain">        cache.set(uid, nullValue, 10);   //如果从数据库中查询到空值，就把空值写入缓存，设置较短的超时时间</span></div><div class="token-line"><span class="token plain">      } else {</span></div><div class="token-line"><span class="token plain">        cache.set(uid, valueFromDB, 1000);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    } catch(Exception e) {</span></div><div class="token-line"><span class="token plain">      cache.set(uid, nullValue, 10);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>回种空值虽然能够阻挡大量穿透的请求，但如果有大量获取未注册用户信息的请求，缓存内就会有有大量的空值缓存，也就会浪费缓存的存储空间，如果缓存空间被占满了，还会剔除掉一些已经被缓存的用户信息反而会造成缓存命中率的下降。</p><p>**所以这个方案，我建议你在使用的时候应该评估一下缓存容量是否能够支撑。**如果需要大量的缓存节点来支持，那么就无法通过通过回种空值的方式来解决，这时你可以考虑使用布隆过滤器。</p><h3 id="使用布隆过滤器"><a aria-hidden="true" tabindex="-1" href="/blog-two/高并发系统设计40问/04.演进篇·缓存篇/04#使用布隆过滤器"><span class="icon icon-link"></span></a>使用布隆过滤器</h3><p>1970年布隆提出了一种布隆过滤器的算法，用来判断一个元素是否在一个集合中。这种算法由一个二进制数组和一个Hash算法组成。<strong>它的基本思路如下：</strong></p><p>我们把集合中的每一个值按照提供的Hash算法算出对应的Hash值，然后将Hash值对数组长度取模后得到需要计入数组的索引值，并且将数组这个位置的值从0改成1。在判断一个元素是否存在于这个集合中时，你只需要将这个元素按照相同的算法计算出索引值，如果这个位置的值为1就认为这个元素在集合中，否则则认为不在集合中。</p><p>下图是布隆过滤器示意图，我来带你分析一下图内的信息。</p><p><img src="https://static001.geekbang.org/resource/image/87/88/873fcbbb19b49a92f490ae2cf3a30e88.jpg" alt=""/></p><p>A、B、C等元素组成了一个集合，元素D计算出的Hash值所对应的的数组中值是1，所以可以认为D也在集合中。而F在数组中的值是0，所以F不在数组中。</p><p><strong>那么我们如何使用布隆过滤器来解决缓存穿透的问题呢？</strong></p><p>还是以存储用户信息的表为例进行讲解。首先我们初始化一个很大的数组，比方说长度为20亿的数组，接下来我们选择一个Hash算法，然后我们将目前现有的所有用户的ID计算出Hash值并且映射到这个大数组中，映射位置的值设置为1，其它值设置为0。</p><p>新注册的用户除了需要写入到数据库中之外，它也需要依照同样的算法更新布隆过滤器的数组中相应位置的值。那么当我们需要查询某一个用户的信息时，先查询这个ID在布隆过滤器中是否存在，如果不存在就直接返回空值，而不需要继续查询数据库和缓存，这样就可以极大地减少异常查询带来的缓存穿透。</p><p><img src="https://static001.geekbang.org/resource/image/eb/1a/eb0c5da5deb7e729e719c30fcacd391a.jpg" alt=""/></p><p>布隆过滤器拥有极高的性能，无论是写入操作还是读取操作，时间复杂度都是O(1)是常量值。在空间上，相对于其他数据结构它也有很大的优势，比如，20亿的数组需要2000000000/8/1024/1024 = 238M的空间，而如果使用数组来存储，假设每个用户ID占用4个字节的空间，那么存储20亿用户需要2000000000 * 4 / 1024 / 1024 = 7600M的空间，是布隆过滤器的32倍。</p><p>不过任何事物都有两面性，布隆过滤器也不例外，<strong>它主要有两个缺陷：</strong></p><p>1.它在判断元素是否在集合中时是有一定错误几率的，比如它会把不是集合中的元素判断为处在集合中；</p><p>2.不支持删除元素。</p><p>**关于第一个缺陷，主要是Hash算法的问题。**因为布隆过滤器是由一个二进制数组和一个Hash算法组成的，Hash算法存在着一定的碰撞几率。Hash碰撞的含义是不同的输入值经过Hash运算后得到了相同的Hash结果。</p><p>本来，Hash的含义是不同的输入依据不同的算法映射成独一无二的固定长度的值，也就是我输入字符串“1”，根据CRC32算法，值是2212294583。但是现实中Hash算法的输入值是无限的，输出值的值空间却是固定的，比如16位的Hash值的值空间是65535，那么它的碰撞几率就是1/65535，即如果输入值的个数超过65535就一定会发生碰撞。</p><p><strong>你可能会问为什么不映射成更长的Hash值呢？</strong></p><p>因为更长的Hash值会带来更高的存储成本和计算成本。即使使用32位的Hash算法，它的值空间长度是2的32次幂减一，约等于42亿，用来映射20亿的用户数据，碰撞几率依然有接近50%。</p><p>Hash的碰撞就造成了两个用户ID ，A和B会计算出相同的Hash值，那么如果A是注册的用户，它的Hash值对应的数组中的值是1，那么B即使不是注册用户，它在数组中的位置和A是相同的，对应的值也是1，<strong>这就产生了误判。</strong></p><p>布隆过滤器的误判有一个特点，就是它只会出现“false positive”的情况。这是什么意思呢？当布隆过滤器判断元素在集合中时，这个元素可能不在集合中。但是一旦布隆过滤器判断这个元素不在集合中时，它一定不在集合中。**这一点非常适合解决缓存穿透的问题。**为什么呢？</p><p>你想，如果布隆过滤器会将集合中的元素判定为不在集合中，那么我们就不确定被布隆过滤器判定为不在集合中的元素是不是在集合中。假设在刚才的场景中，如果有大量查询未注册的用户信息的请求存在，那么这些请求到达布隆过滤器之后，即使布隆过滤器判断为不是注册用户，那么我们也不确定它是不是真的不是注册用户，那么就还是需要去数据库和缓存中查询，这就使布隆过滤器失去了价值。</p><p>所以你看，布隆过滤器虽然存在误判的情况，但是还是会减少缓存穿透的情况发生，只是我们需要尽量减少误判的几率，这样布隆过滤器的判断正确的几率更高，对缓存的穿透也更少。<strong>一个解决方案是：</strong></p><p>使用多个Hash算法为元素计算出多个Hash值，只有所有Hash值对应的数组中的值都为1时，才会认为这个元素在集合中。</p><p>**布隆过滤器不支持删除元素的缺陷也和Hash碰撞有关。**给你举一个例子，假如两个元素A和B都是集合中的元素，它们有相同的Hash值，它们就会映射到数组的同一个位置。这时我们删除了A，数组中对应位置的值也从1变成0，那么在判断B的时候发现值是0，也会判断B是不在集合中的元素，就会得到错误的结论。</p><p>**那么我是怎么解决这个问题的呢？**我会让数组中不再只有0和1两个值，而是存储一个计数。比如如果A和B同时命中了一个数组的索引，那么这个位置的值就是2，如果A被删除了就把这个值从2改为1。这个方案中的数组不再存储bit位，而是存储数值，也就会增加空间的消耗。**所以，你要依据业务场景来选择是否能够使用布隆过滤器，**比如像是注册用户的场景下，因为用户删除的情况基本不存在，所以还是可以使用布隆过滤器来解决缓存穿透的问题的。</p><p><strong>讲了这么多，关于布隆过滤器的使用上，我也给你几个建议：</strong></p><ol><li><p>选择多个Hash函数计算多个Hash值，这样可以减少误判的几率；</p></li><li><p>布隆过滤器会消耗一定的内存空间，所以在使用时需要评估你的业务场景下需要多大的内存，存储的成本是否可以接受。</p></li></ol><p>总的来说，<strong>回种空值和布隆过滤器</strong>是解决缓存穿透问题的两种最主要的解决方案，但是它们也有各自的适用场景，并不能解决所有问题。比方说当有一个极热点的缓存项，它一旦失效会有大量请求穿透到数据库，这会对数据库造成瞬时极大的压力，我们把这个场景叫做“dog-pile effect”（狗桩效应），</p><p>这是典型的缓存并发穿透的问题，**那么，我们如何来解决这个问题呢？**解决狗桩效应的思路是尽量地减少缓存穿透后的并发，方案也比较简单：</p><ol><li><p>在代码中控制在某一个热点缓存项失效之后启动一个后台线程，穿透到数据库，将数据加载到缓存中，在缓存未加载之前，所有访问这个缓存的请求都不再穿透而直接返回。</p></li><li><p>通过在Memcached或者Redis中设置分布式锁，只有获取到锁的请求才能够穿透到数据库。</p></li></ol><p>分布式锁的方式也比较简单，比方说ID为1的用户是一个热点用户，当他的用户信息缓存失效后，我们需要从数据库中重新加载数据时，先向Memcached中写入一个Key为&quot;lock.1&quot;的缓存项，然后去数据库里面加载数据，当数据加载完成后再把这个Key删掉。这时，如果另外一个线程也要请求这个用户的数据，它发现缓存中有Key为“lock.1”的缓存，就认为目前已经有线程在加载数据库中的值到缓存中了，它就可以重新去缓存中查询数据，不再穿透数据库了。</p><h2 id="课程小结"><a aria-hidden="true" tabindex="-1" href="/blog-two/高并发系统设计40问/04.演进篇·缓存篇/04#课程小结"><span class="icon icon-link"></span></a>课程小结</h2><p>本节课，我带你了解了一些解决缓存穿透的方案，你可以在发现自己的缓存系统命中率下降时从中得到一些借鉴的思路。我想让你明确的重点是：</p><ol><li><p>回种空值是一种最常见的解决思路，实现起来也最简单，如果评估空值缓存占据的缓存空间可以接受，那么可以优先使用这种方案；</p></li><li><p>布隆过滤器会引入一个新的组件，也会引入一些开发上的复杂度和运维上的成本。所以只有在存在海量查询数据库中，不存在数据的请求时才会使用，在使用时也要关注布隆过滤器对内存空间的消耗；</p></li><li><p>对于极热点缓存数据穿透造成的“狗桩效应”，可以通过设置分布式锁或者后台线程定时加载的方式来解决。</p></li></ol><p>除此之外，你还需要了解数据库是一个脆弱的资源，它无论是在扩展性、性能还是承担并发的能力上，相比缓存都处于绝对的劣势，所以我们解决缓存穿透问题的**核心目标在于减少对于数据库的并发请求。**了解了这个核心的思想，也许你还会在日常工作中找到其他更好的解决缓存穿透问题的方案。</p><h2 id="一课一思"><a aria-hidden="true" tabindex="-1" href="/blog-two/高并发系统设计40问/04.演进篇·缓存篇/04#一课一思"><span class="icon icon-link"></span></a>一课一思</h2><p>在你的日常工作中还会有哪些解决缓存穿透的方案呢？欢迎在留言区和我互动讨论。</p><p>最后，感谢你的阅读，如果这篇文章让你有所收获，欢迎将它分享给更多的朋友。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/高并发系统设计40问/04.演进篇·缓存篇/04.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:08</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
