<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>04｜跨越现实的障碍（上）：要性能还是要模型？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/04" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a aria-current="page" class="active" href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a aria-current="page" class="active" href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/如何落地业务建模/01.开篇词">01.开篇词</a><ul><li><a href="/blog-two/如何落地业务建模/01.开篇词/01"><span>开篇词｜为什么你需要学习业务建模？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计">02.旧约“前云时代”的领域驱动设计</a><ul><li><a href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/01"><span>01｜领域驱动设计到底在讲什么？</span></a></li><li><a href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/02"><span>02｜统一语言是必要的吗？</span></a></li><li><a href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/03"><span>03｜我们要怎么理解领域驱动设计？</span></a></li><li><a aria-current="page" class="active" href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/04"><span>04｜跨越现实的障碍（上）：要性能还是要模型？</span></a></li><li><a href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/05"><span>05｜跨越现实的障碍（中）：富含知识还是代码坏味道？</span></a></li><li><a href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/06"><span>06 | 跨越现实的障碍（下）：架构分层就对了吗？</span></a></li><li><a href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/07"><span>07｜统一语言可以是领域模型本身吗？</span></a></li><li><a href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/08"><span>08 | 什么办法可以在讨论中自然形成统一语言？</span></a></li><li><a href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/09"><span>09｜怎么才能更有效地获得事件流？</span></a></li><li><a href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/10"><span>10 | 将模型实现为RESTful API（上）</span></a></li><li><a href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/11"><span>11｜将模型实现为RESTful API（下）</span></a></li></ul></li><li><a href="/blog-two/如何落地业务建模/03.深度答疑专题">03.深度答疑专题</a><ul><li><a href="/blog-two/如何落地业务建模/03.深度答疑专题/01"><span>说点题外话01｜好耦和与坏耦和</span></a></li><li><a href="/blog-two/如何落地业务建模/03.深度答疑专题/02"><span>说点题外话02｜模式并不是解决方案</span></a></li><li><a href="/blog-two/如何落地业务建模/03.深度答疑专题/03"><span>说点题外话03｜银弹可以杀死狼人，但你怎么知道狼人不是你呢？</span></a></li><li><a href="/blog-two/如何落地业务建模/03.深度答疑专题/04"><span>说点题外话04｜面向对象的原则适用于RESTful API吗？</span></a></li></ul></li><li><a href="/blog-two/如何落地业务建模/04.新约云时代的业务建模">04.新约云时代的业务建模</a><ul><li><a href="/blog-two/如何落地业务建模/04.新约云时代的业务建模/01"><span>12｜云时代的挑战（上）：弹性边界还是业务边界？</span></a></li><li><a href="/blog-two/如何落地业务建模/04.新约云时代的业务建模/02"><span>13｜云时代的挑战（下）：如何保持弹性边界的独立性？</span></a></li><li><a href="/blog-two/如何落地业务建模/04.新约云时代的业务建模/03"><span>14 | 8X Flow（上）：何为业务？何为领域？</span></a></li><li><a href="/blog-two/如何落地业务建模/04.新约云时代的业务建模/04"><span>15｜8X Flow（中）：如何通过模型发现业务系统的变化点？</span></a></li><li><a href="/blog-two/如何落地业务建模/04.新约云时代的业务建模/05"><span>16｜8X Flow（下）：多于一个例子</span></a></li><li><a href="/blog-two/如何落地业务建模/04.新约云时代的业务建模/06"><span>17｜中台建模（上）：到底什么是中台？</span></a></li><li><a href="/blog-two/如何落地业务建模/04.新约云时代的业务建模/07"><span>18｜中台建模（下）：如何寻找可复用的业务模式？</span></a></li><li><a href="/blog-two/如何落地业务建模/04.新约云时代的业务建模/08"><span>19｜如何将模型实现为微服务？</span></a></li><li><a href="/blog-two/如何落地业务建模/04.新约云时代的业务建模/09"><span>20｜云时代的下一站：SaaS化与魔球建模法</span></a></li></ul></li><li><a href="/blog-two/如何落地业务建模/05.结束语">05.结束语</a><ul><li><a href="/blog-two/如何落地业务建模/05.结束语/01"><span>结课测试题｜这些业务建模知识你都掌握了吗？</span></a></li><li><a href="/blog-two/如何落地业务建模/05.结束语/02"><span>结束语｜吃喝玩乐如何让我成为更好的程序员？</span></a></li><li><a href="/blog-two/如何落地业务建模/05.结束语/03"><span>编辑手记01｜写给专栏读者的一封小信</span></a></li></ul></li><li><a href="/blog-two/如何落地业务建模/06.特别放送专题">06.特别放送专题</a><ul><li><a href="/blog-two/如何落地业务建模/06.特别放送专题/01"><span>用户故事01｜知瑕：如何通过刻意练习，掌握建模方法？</span></a></li><li><a href="/blog-two/如何落地业务建模/06.特别放送专题/02"><span>用户故事02｜邹海龙：大道千条，我选其一</span></a></li><li><a href="/blog-two/如何落地业务建模/06.特别放送专题/03"><span>直播加餐｜如何使用8X Flow实施面向业务设计？</span></a></li></ul></li><li><a href="/blog-two/如何落地业务建模/summary">如何落地业务建模</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="无法封装的数据库开销" data-depth="2"><a href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/04#无法封装的数据库开销"><span>无法封装的数据库开销</span></a></li><li title="集合遍历与N+1" data-depth="3"><a href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/04#集合遍历与n1"><span>集合遍历与N+1</span></a></li><li title="Smalltalk中集合与数据库是等价的" data-depth="3"><a href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/04#smalltalk中集合与数据库是等价的"><span>Smalltalk中集合与数据库是等价的</span></a></li><li title="多层架构彻底割裂了集合与数据库" data-depth="3"><a href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/04#多层架构彻底割裂了集合与数据库"><span>多层架构彻底割裂了集合与数据库</span></a></li><li title="关联对象" data-depth="2"><a href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/04#关联对象"><span>关联对象</span></a></li><li title="使用关联对象实现聚合关系" data-depth="3"><a href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/04#使用关联对象实现聚合关系"><span>使用关联对象实现聚合关系</span></a></li><li title="隔离技术实现细节与领域逻辑" data-depth="3"><a href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/04#隔离技术实现细节与领域逻辑"><span>隔离技术实现细节与领域逻辑</span></a></li><li title="通过集体逻辑揭示意图" data-depth="3"><a href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/04#通过集体逻辑揭示意图"><span>通过集体逻辑揭示意图</span></a></li><li title="小结" data-depth="2"><a href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/04#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/04#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="04跨越现实的障碍上要性能还是要模型"><a aria-hidden="true" tabindex="-1" href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/04#04跨越现实的障碍上要性能还是要模型"><span class="icon icon-link"></span></a>04｜跨越现实的障碍（上）：要性能还是要模型？</h1><p>你好，我是徐昊。今天我们来聊聊通过关联对象（Assocation Object）建模聚合（Aggregation）。</p><p>在前面三节课，我们学习了领域驱动设计中的“两关联一循环”：模型与软件实现关联；统一语言与模型关联；提炼知识的循环。其中，统一语言与提炼知识的循环作为一种更为平衡的权责关系，促进了业务方与技术方更好的协作。而这一切又是以模型与软件实现关联为基础。</p><p>然而落地到实践中，关联模型与软件实现总有一些让人纠结与苦恼的地方。引起这些苦恼的主要原因是<strong>架构风格的变化</strong>。我们已经从单机时代过渡到了多层单体架构，以及云原生分布式架构，但我们所采用的建模思路与编程风格并没有彻底跟上时代的步伐，这种差异通常会以<strong>性能问题</strong>或是<strong>代码坏味道</strong>的形式出现。</p><p>如果我们想要真正发挥出领域驱动设计的作用，就需要<strong>在不同架构风格下，找到能够维持模型与软件实现统一的办法</strong>。这也是这个领域常看常新，总能产生新实践的原因。</p><p>因而接下来，我会用三节课来介绍一组实现模式，帮助我们应对从单机架构过渡到多层架构，保持模型与软件实现的关联。这些模式也是我们后面学习在微服务和云原生时代，实施领域驱动设计方法的基础。</p><p>今天这节课，我们就先从关联对象这一方法开始讲起。关联对象是一个古老的设计/分析模式，Martin Fowler在<a target="_blank" rel="noopener noreferrer" href="https://book.douban.com/subject/4832380/">《分析模式》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中讨论过它。Peter Coad将它视为一种常见的业务构成模式，并应用到业务分析中。而我大概从2005年开始，使用它建模领域驱动设计中的聚合与关联关系，以解决领域模型（Domain Model）中对技术组件的封装问题。</p><p>不过，在讲解到关联对象的具体做法之前，我们需要先看一下<strong>领域驱动设计中的聚合关系在具体实现中存在哪些问题</strong>。了解了问题所在，我们才能更有针对性地去寻找解决办法。</p><h2 id="无法封装的数据库开销"><a aria-hidden="true" tabindex="-1" href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/04#无法封装的数据库开销"><span class="icon icon-link"></span></a>无法封装的数据库开销</h2><p>在应用领域驱动设计的时候，聚合与聚合根（Aggregation Root）是构成“富含知识的模型（Knowledge Rich Model）”的关键。通过聚合关系，我们可以将<strong>被聚合对象的集合逻辑放置于聚合/聚合根里，而不是散落在外，或是放在其他无关的服务中</strong>。这么做可以使得逻辑富集于模型中，避免“逻辑泄露”。</p><p>不过落到具体实现上，我们经常会遇到这样一个挑战，即：<strong>这些被聚合的对象，通常都是被数据库持久化</strong>（Persistent）<strong>的集合</strong>（Collection）。也就是说，数据库系统的引入，网络I/O与其他性能开销无法被接口抽象隔离。而将具体技术实现引入领域模型，则有悖领域驱动设计的理念。</p><p>接下来，我们就通过一个例子，在具体的上下文中看一看存在什么问题。然后，再看一下这个问题在建模思路上产生的根源，以及要如何修正我们的建模思路。</p><h3 id="集合遍历与n1"><a aria-hidden="true" tabindex="-1" href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/04#集合遍历与n1"><span class="icon icon-link"></span></a>集合遍历与N+1</h3><p>让我们再回到在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/387945">第二讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>里展示的极客时间专栏的例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class User {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       private List&lt;Subscription&gt; subscriptions;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       // 获取用户订阅的所有专栏</span></div><div class="token-line"><span class="token plain">       public List&lt;Subscription&gt; getSubscriptions() {</span></div><div class="token-line"><span class="token plain">         ...</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">       // 计算所订阅的专栏的总价</span></div><div class="token-line"><span class="token plain">       public double getTotalSubscriptionFee() {</span></div><div class="token-line"><span class="token plain">         ...</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    class UserRepository {</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">      public User findById(long id) {</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">      }</span></div></pre></div><p>按照面向对象和领域驱动设计提倡的做法，User作为聚合根，需要管控其对应的Subscription。现在我们有一个简单且常见的需求：在页面上，显示对用户已经订阅过的专栏进行分页处理。那么，我们大概会这么写：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">user.getSubscriptions().subList(from, from + pageSize);</span></div></pre></div><p>可以发现，在这段代码里，我们假设所有的Subscription都在内存里，因此所有的计算与逻辑都可以在内存中完成了。那么，我们就需要在读取User的时候，将它对应的所有订阅过的专栏信息都从数据库读取到内存中，以便后续使用。</p><p>如果是少量订阅的场景，比如几个或者几十个，那这段代码并没有什么问题。但如果有个特别好学的人，买了几万甚至几百万个专栏呢（先假设专栏有无限个）？此时将所有订阅过的专栏都读取到内存里，这就意味着会有巨大的网络I/O开销和内存占用。</p><p>当然，这里你可能会说，JPA/Hibernate等ORM提供了延迟加载啊。是的，但这又会引入<strong>经典的性能瓶颈N + 1问题</strong>。因为随着延迟加载集合的遍历，其中的Subscription对象会被依次加载。</p><p>延迟加载的实现流程是这样的：</p><ul><li>先执行一条查询获取集合的概况。比如总共有多少条记录之类的信息。</li><li>然后根据概况信息，生成一个集合对象。这时候集合对象基本上是空的，不占用什么内存空间。</li><li>随后，当我们需要集合内的具体信息的时候，它再根据我们需要访问的对象，按需从数据库中读取。</li></ul><p>理论上讲，这是为了避免一次性读入大量数据带来的性能问题，而提出的解决办法。</p><p>然而，如果需要获取所有的数据，那么我们总共就会有N+1次数据库访问：1次是指第一次获取概况的访问，N次指而后集合中N个对象每个一次。而每一次加载，都伴随着对数据库的访问，自然就会带来I/O与数据库的开销。特别是频繁地对数据库访问，可能会阻塞其他人，从而造成性能瓶颈。</p><p>在这种情况下，我们其实没有什么好的选择：<strong>要么是一次性读入全部数据，避免N + 1问题；要么是引入N+1问题，变成钝刀子割肉</strong>。</p><p>为了避免这两种情况，很自然地，你会想起这样一种做法：通过查询语句一次性定位所需分页，这样只需要一次查询就能解决问题。不过这么做的困难在于，<strong>分页查询的逻辑要放在哪个对象上，才能保持模型与软件实现的关联</strong>。</p><p>一种做法是<strong>为订阅</strong>（Subscription）<strong>构造一个独立的Repository对象</strong>，将逻辑放在里面（也是Spring推荐的做法）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">interface SubscriptionRepository extends ... {</span></div><div class="token-line"><span class="token plain">      public Page&lt;Subscription&gt; findPaginated(int from, int size);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这种做法的问题就是会导致<strong>逻辑泄露</strong>。Subscription被User聚合，那么User所拥有的Subscription的集合逻辑应该被封装在User中，这样才能保证User是“逻辑丰富的模型”，因为<strong>非聚合根提供Repository是一种坏味道</strong>。</p><p>如果聚合到User上是可行的吗？其实也不行。因为这么做会将技术实现细节引入领域逻辑中，而无法保持领域逻辑的独立。代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class User {</span></div><div class="token-line"><span class="token plain">        public List&lt;Subscription&gt; getSubscriptions() {</span></div><div class="token-line"><span class="token plain">          ....</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        public List&lt;Subscription&gt; getSubscriptions(int from, int size) {</span></div><div class="token-line"><span class="token plain">           return db.executeQuery(....);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">     }</span></div></pre></div><p>造成这种两难局面的根源在于，<strong>我们希望在模型中使用集合接口，并借助它封装具体技术实现的细节</strong>。因为在我们的概念中，<strong>内存中的集合与数据库是等价的，都可以通过集合接口封装</strong>。但实际情况是，我们无法忽略数据库带来的额外作用与开销，内存中的集合与数据库并不是等价的，封装失败。</p><p>那么，为什么在我们的概念中，我们会认为内存中的集合与数据库是等价的，是可以通过集合接口封装的呢？这就要从面向对象技术的开端——Smalltalk系统说起了。</p><h3 id="smalltalk中集合与数据库是等价的"><a aria-hidden="true" tabindex="-1" href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/04#smalltalk中集合与数据库是等价的"><span class="icon icon-link"></span></a>Smalltalk中集合与数据库是等价的</h3><p>鲜少有人了解的一个事实是，<strong>集合与数据库的等价，在早期面向对象系统Smalltalk中是一个基础概念</strong>。</p><p>这其实不难理解，如果对象中包含的状态可以映射为数据库表中的一列，那么一组对象自然就可以映射成一张表了。有了一张表，自然也就可以看作是一个最小的数据库了。</p><p>Smalltalk作为面向对象系统内置的一套<strong>面向对象数据库</strong>（Object Oriented Database）。于是在使用Smalltalk系统时，集合与数据库是无差别的。如下图所示，展示了Smalltalk系统的构成。</p><p><img src="https://static001.geekbang.org/resource/image/c3/3d/c3d0e09fd9faa5bdc4313032fe15423d.jpg?wh=7885x4244" alt=""/></p><p>如上图所示，Smalltalk中除了虚拟机（Virtual Machine）之外，还有虚拟镜像（Virtual Image，VI）。<strong>虚拟镜像相当于虚拟机内存的持久化保存</strong>。每次虚拟机启动的时候，都会把虚拟镜像中的信息读入到内存中以恢复状态，而Java、.NET虚拟机并不会保留之前内存中的信息。</p><p>打个比方。Smalltalk虚拟机的启动过程，类似于VMWare虚拟机上的Pause，内存中的所有状态都被持久化保存了，那么我们可以继续从之前暂停的地方开始。而其他语言的虚拟机则是彻底地重启（Restart），并不会保留之前的结果。</p><p>在Smalltalk的虚拟镜像中，存储着所有的代码和数据。我们称呼Smalltalk为一个面向对象系统，而不仅仅是面向对象语言。因为它既是一门面向对象语言，也是一个虚拟机的操作系统，还是一个面向对象数据库。</p><p>那么在这样的系统中，Smalltalk中的集合（无论是Array、List，还是什么）就等同于一个数据库。只要这个集合被创建出来，除非显示化地通过垃圾回收销毁，否则它就会被虚拟镜像持久化。<strong>垃圾收集和持久化一样，都可以被看作是对象生命周期</strong>（Object Lifecycle）<strong>的一个状态</strong>。</p><p>因此，数据库中的数据和非数据库中的数据，都可以通过Collection表达，我们不用再去区分它。而在Smalltalk中，这种等价关系深刻影响了我们的思路和建模习惯，毕竟我们所熟知的面向对象语言都从Smalltalk中借鉴了大量的概念。而早期的建模者也大都来自Smalltalk社区，比如Peter Coad、Kent Beck、Martin Fowler等（当然我也是）。所以我们学习建模方法的时候，或多或少有一些源自Smalltalk社区的习惯。</p><p>然而随着时代的发展，这种习惯在多层架构（Mulit-tier Architecture）下遇到了挑战。那么接下来我们就看看多层架构是怎么彻底割裂了集合与数据库的。</p><h3 id="多层架构彻底割裂了集合与数据库"><a aria-hidden="true" tabindex="-1" href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/04#多层架构彻底割裂了集合与数据库"><span class="icon icon-link"></span></a>多层架构彻底割裂了集合与数据库</h3><p>Smalltalk在中国未曾真正地流行过，大多数人是从C++甚至是Java、.NET开始接触面向对象编程的。而无论是C++、Java，还是后来的面向对象编程语言，其实都不是完整的面向对象系统。</p><p>集合作为面向对象中的重要概念，被吸纳入这些语言后，就去掉了与数据库的强关联（毕竟这些语言默认不带有数据库模块）。因此，集合虽然在概念上仍然等同于数据库，但如此简单粗暴的建模，就会遇到我们前面提到的“是否N+1”的两难选择。</p><p>那么Java、.NET这些语言为什么要这么做呢？它们为什么不能像Smalltalk一样，内涵完整地面对象数据库呢？这其实是架构风格演化的结果。</p><p>我们明显可以发现，<strong>Smalltalk是典型的单机单体架构</strong>。从操作系统、数据库到应用程序，都在一个虚拟机上，就好像是一台小型机一样。这样的<strong>架构结构无法水平扩展</strong>（horizontal scaling）<strong>，只能垂直扩展</strong>（vertical scaling）。这就意味着我们需要<strong>不断提高单点的计算能力，才能提高整个的容量与吞吐</strong>。这并不符合架构的整体发展趋势。</p><p>进入21世纪后，随着对系统容量要求的增加，易于水平扩展的三层架构逐渐成为行业主流。而数据库作为一个独立组件，则不再与应用合体。示意图如下：</p><p><img src="https://static001.geekbang.org/resource/image/11/2a/11142c4ab83c9ef344e7e811c274b02a.jpg?wh=8000x4500" alt=""/></p><p>于是，Smalltalk的面向对象系统在这种架构下分别变成了：应用程序中间件（对应Smalltalk虚拟机）和数据库（对应Smalltalk虚拟镜像的持久化数据部分）。</p><p>多层架构彻底割裂了对象集合与数据库，这对我们实现领域模型建模提出了挑战，对Collection逻辑的建模也就难以摆脱具体实现细节了。那就是我们<strong>必须明确哪些是持久化的数据，并对它的一些逻辑区别对待</strong>。这就是原味面向对象范型（Vanilla Object Oriented），在架构风格演化过程中遇到的挑战。</p><p>几乎所有实施过DDD的人，都在这个问题上挣扎过。如果对于如此常见且如此简单的分页功能，我们都无法将模型与软件实现关联的话。那么，面对更复杂的问题时我们要怎么办呢？这是大多数怀揣理想准备实施DDD的人，碰到的第一个阻碍。</p><p>关联对象就是一种解决这个问题的设计模式。</p><h2 id="关联对象"><a aria-hidden="true" tabindex="-1" href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/04#关联对象"><span class="icon icon-link"></span></a>关联对象</h2><p><strong>关联对象</strong>，顾名思义，就是<strong>将对象间的关联关系直接建模出来，然后再通过接口与抽象的隔离，把具体技术实现细节封装到接口的实现中</strong>。这样既可以保证概念上的统一，又能够避免技术实现上的限制。</p><p>现在让我们再来看看极客时间专栏的例子，如果使用关联对象，如何帮我们避免N+1和逻辑泄露的问题。</p><h3 id="使用关联对象实现聚合关系"><a aria-hidden="true" tabindex="-1" href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/04#使用关联对象实现聚合关系"><span class="icon icon-link"></span></a>使用关联对象实现聚合关系</h3><p>首先我们需要定义关联对象，因为我们需要表达的是User与Subscription间的一对多的关系，那么最简单的命名方法是将两个对象名字组合，从而得到关联对象的名字UserSubscriptions：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public interface UserSubscriptions extends Iterable&lt;Subscription&gt; {</span></div><div class="token-line"><span class="token plain">       List&lt;Subscription&gt; subList(int from, int to); //分页</span></div><div class="token-line"><span class="token plain">       double getTotalSubscriptionFee(); //获取总共花费</span></div><div class="token-line"><span class="token plain">       int count(); //获取总订阅数</span></div><div class="token-line"><span class="token plain">       Iterable&lt;Subscription&gt; sort(...);</span></div><div class="token-line"><span class="token plain">       ....</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>当然，我们最好是从业务上下文出发，寻找更具有业务含义的名字，毕竟我们是要形成统一语言的，源自业务的名字总是更容易被非技术角色所理解。</p><p>比如这里我们要表达的是用户已经订阅的专栏，或者是用户已经购买的专栏，那么PaidColumn，甚至MySubscriptions，都不错，看哪一个更容易被团队接受了。我这里选择MySubscriptions，于是User对象就变成了这样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public interface MySubscriptions extends Iterable&lt;Subscription&gt; {</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public class User {</span></div><div class="token-line"><span class="token plain">      private MySubscriptions mySubscriptions;</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      public MySubscriptions getMySubscriptions() {</span></div><div class="token-line"><span class="token plain">         return mySubscriptions</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>那么之前对于分页和计算的调用也就相应地变为：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">user.getMySubscriptions().subList(0, 10);</span></div><div class="token-line"><span class="token plain">    user.getMySubscriptions().getTotalSubscriptionFee();</span></div></pre></div><p>很明显，我们没有逻辑泄露，User是Subscription的聚合根，那么与之相关的逻辑也仍然被封装在User的上下文中，当然是进一步被封装在关联对象中。</p><p>那么我们怎么解决持久化的问题呢？怎么从领域对象中，移除掉对技术实现的依赖呢？秘诀就在于<strong>接口与实现分离</strong>。代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package model.impl.db;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public class MySubscriptionsDB implements MySubscriptions {</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">      private User user;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      public List&lt;Subscription&gt; subList(int from, int to) {</span></div><div class="token-line"><span class="token plain">        return db.executeQuery(...);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      ...</span></div></pre></div><p>在这里，我们将与数据库访问相关的逻辑毫不避讳地封装到MySubscriptionsDB中。不过，作为领域对象的User类，并不会知道它使用了数据库，因为它仅仅通过MySubscriptions接口，访问它所需要的功能。此时我们可以通过简单的分包的策略：</p><p><img src="https://static001.geekbang.org/resource/image/e8/04/e8c35b784e7ec2553df31d7c1c364004.jpg?wh=7164x3335" alt=""/></p><p>从上图中包的架构上看，模型的包中有MySubscriptions、User、UserRepository。与数据库相关的代码的包里有MySubscriptionsDB和UserRepositoryDB。于是，我们成功地将核心的领域逻辑与实现细节分开了。</p><p>当然最后还有一个问题：<strong>如何将MySubscriptionsDB与User结合在一起</strong>？最直接的做法就是这样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public UserRepositoryDB implements UserRepository {</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">      public User findBy(long id) {</span></div><div class="token-line"><span class="token plain">          User user = .....;</span></div><div class="token-line"><span class="token plain">          return setMySubscription(user);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      public List&lt;User&gt; findBy(....) {</span></div><div class="token-line"><span class="token plain">          List&lt;User&gt; user = .....;</span></div><div class="token-line"><span class="token plain">          return user.map(user -&gt; setMySubscription(user));</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      private User setMySubscription(User user) {</span></div><div class="token-line"><span class="token plain">          user.setMySubscriptions(new MySubscriptionDB(db, user));</span></div><div class="token-line"><span class="token plain">          return user;      </span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>因为User是聚合根，从数据库中读取的User对象都需要从UserRepository中获取。那么，在UserRepository的具体实现中为User对象设置MySubscription对象，是再自然不过的选择了。</p><p>当然更简洁漂亮的做法，是通过Java CDI API或是框架提供的生命周期实践监听器，来完成关联对象的设置。</p><h3 id="隔离技术实现细节与领域逻辑"><a aria-hidden="true" tabindex="-1" href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/04#隔离技术实现细节与领域逻辑"><span class="icon icon-link"></span></a>隔离技术实现细节与领域逻辑</h3><p>通过引入关联对象，我们可以更好地隔离领域逻辑与技术实现细节。在这里，我们还是用极客时间专栏的例子来解释。</p><p>如果这时候Subscription信息并不是存在数据库中，而是通过RESTful API从另一个系统中获取的。那么，我们只需提供另一个MySubscriptions的实现就可以了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package model.impl.api;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public class MySubscriptionsAPI implements MySubscriptions {</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">      private User user;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      public List&lt;Subscription&gt; subList(int from, int to) {</span></div><div class="token-line"><span class="token plain">        return client.findSubscriptions(....);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      ...</span></div></pre></div><p>这种改变并不会传递到领域逻辑层，对于分页和计算的调用仍然为：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">user.getMySubscriptions().subList(0, 10);</span></div><div class="token-line"><span class="token plain">    user.getMySubscriptions().getTotalSubscriptionFee();</span></div></pre></div><p>RESTful API的性能瓶颈和需要调整的地方与数据库不同，这种变化都被关联对象的接口封装隔离了。</p><p>从面向对象编程的角度来说，我们很容易理解为什么关联对象可以带来如此多的好处。在诸多面向对象的最佳实践中，有一条是说要尽可能避免使用原始类型（primitive type）。因为原始类型没有对概念进行提取，也缺乏封装，所以我们应该尽可能地使用自定义的类去替换它们。</p><p>不过如果我们把语言内提供的集合类型（List等）也当作原始类型的话，关联对象就是对这一条建议自然的扩展：<strong>使用自定义关联对象，而不是集合类型来表示对象间的关联</strong>。</p><h3 id="通过集体逻辑揭示意图"><a aria-hidden="true" tabindex="-1" href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/04#通过集体逻辑揭示意图"><span class="icon icon-link"></span></a>通过集体逻辑揭示意图</h3><p>关联对象除了可以帮助聚拢逻辑、隔离实现细节之外，还能从概念上帮助我们获得更好的领域模型，因为关联对象是对集体逻辑的直接建模。</p><p>所谓<strong>集体逻辑，是指个体不具备，而成为一个集体之后才具备的能力。哪怕是同一群个体，组成了不同的集体，就会具有不同的逻辑</strong>。</p><p>我们仍然回到极客时间专栏的例子上，来帮助你理解。比如我们现在的模型是这样的：<br/><img src="https://static001.geekbang.org/resource/image/72/a2/7288282fa92473a66ef9d012d90b6aa2.jpg?wh=7000x2908" alt=""/></p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class User {</span></div><div class="token-line"><span class="token plain">       private List&lt;Subscription&gt; subscriptions;</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">       ....</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public class Column {</span></div><div class="token-line"><span class="token plain">        private List&lt;Subscription&gt; subscriptions;</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        ....</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这段代码中，User中的List表示用户已订阅的所有专栏，而Column中的List，则表示所有订阅了专栏的用户。虽然同为Subscription的集合，但是当它们组成集体时，在不同的上下文中则具有不同的含义。</p><p>那么如果显式地表达为关联对象，可以进一步澄清我们的意图，得到揭示意图的接口（Intention Revealing Interface）。代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class User {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       public static interface MySubscriptions extends Iterable&lt;Subscription&gt; {</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">       private MySubscriptions mySubscriptions;</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public class Column {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public static interface MyReaders extends Iterable&lt;Subscription&gt; {</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        private MyReaders myReaders；</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        ..</span></div></pre></div><p>在这段代码中，我们通过引入关联对象，可以将这两个不同的集体变更为User.MySubscriptions和Column.MyReaders，然后在各自的上下文去定义不同的集体逻辑。</p><p>比如我订阅的专栏可以计算我一共付了多少钱，而在我的读者中，可以计算订阅者对专栏的平均打分情况，示意代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public static interface MySubscriptions extends Iterable&lt;Subscription&gt; {</span></div><div class="token-line"><span class="token plain">      double getTotalFee();</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public static interface MyReaders extends Iterable&lt;Subscription&gt; {</span></div><div class="token-line"><span class="token plain">      double getAverageRating();</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/04#小结"><span class="icon icon-link"></span></a><strong>小结</strong></h2><p>我们来简单地总结一下。随着架构风格的演化与改变，面向对象技术中的集合，从与数据库完全等价，变成了与数据库完全割裂的东西。</p><p>然而在概念上，我们仍留有<strong>通过集合封装内存中的对象与数据库中的数据</strong>的习惯。这使得我们在使用领域驱动设计的时候，特别是使用聚合关系的时候，变得左右为难：<strong>要么放弃性能，获得更好的模型；要么泄露逻辑，以得到可接受的性能</strong>。</p><p>但是关联对象，则可以让我们在更加明确揭示意图的同时，去解决性能与逻辑封装的问题。我个人从很早就开始将关联对象作为实现聚合关系的默认方法了，它从未让我失望（it never fails me）。我建议你也试一试，这样我就不用给你解释什么叫惊喜了。</p><p>编辑小提示：为了方便读者间的交流学习，我们建立了微信读者群。想要加入的同学，戳此加入<a target="_blank" rel="noopener noreferrer" href="https://jinshuju.net/f/wjtvTP">“如何落地业务建模”交流群<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>&gt;&gt;&gt;</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-two/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/04#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>关联对象实际上是通过将隐式的概念显式化建模来解决问题的，这是面向对象技术解决问题的通则：永远可以通过引入另一个对象解决问题。那么在领域模型中还有哪些隐式概念呢？这些概念会给我们带来什么麻烦呢？</p><p><img src="https://static001.geekbang.org/resource/image/f8/cd/f8900fc84acabbc502b519bf358786cd.jpg?wh=1500x1798" alt=""/></p><p>欢迎把你的思考和想法分享在留言区，我会和你交流。同时呢，我也会把其中一些不错的回答置顶，供大家学习。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/如何落地业务建模/02.旧约“前云时代”的领域驱动设计/04.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:39</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
