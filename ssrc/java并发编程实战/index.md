# java并发编程实战
- [01.开篇词](/java并发编程实战/01.开篇词)
  - [开篇词 | 你为什么需要学习并发编程？](/java并发编程实战/01.开篇词/01)
- [02.学习攻略](/java并发编程实战/02.学习攻略)
  - [学习攻略 | 如何才能学好并发编程？](/java并发编程实战/02.学习攻略/01)
- [03.第一部分并发理论基础](/java并发编程实战/03.第一部分并发理论基础)
  - [01 | 可见性、原子性和有序性问题：并发编程Bug的源头](/java并发编程实战/03.第一部分并发理论基础/01)
  - [02 | Java内存模型：看Java如何解决可见性和有序性问题](/java并发编程实战/03.第一部分并发理论基础/02)
  - [03 | 互斥锁（上）：解决原子性问题](/java并发编程实战/03.第一部分并发理论基础/03)
  - [04 | 互斥锁（下）：如何用一把锁保护多个资源？](/java并发编程实战/03.第一部分并发理论基础/04)
  - [05 | 一不小心就死锁了，怎么办？](/java并发编程实战/03.第一部分并发理论基础/05)
  - [06 | 用“等待-通知”机制优化循环等待](/java并发编程实战/03.第一部分并发理论基础/06)
  - [07 | 安全性、活跃性以及性能问题](/java并发编程实战/03.第一部分并发理论基础/07)
  - [08 | 管程：并发编程的万能钥匙](/java并发编程实战/03.第一部分并发理论基础/08)
  - [09 | Java线程（上）：Java线程的生命周期](/java并发编程实战/03.第一部分并发理论基础/09)
  - [10 | Java线程（中）：创建多少线程才是合适的？](/java并发编程实战/03.第一部分并发理论基础/10)
  - [11 | Java线程（下）：为什么局部变量是线程安全的？](/java并发编程实战/03.第一部分并发理论基础/11)
  - [12 | 如何用面向对象思想写好并发程序？](/java并发编程实战/03.第一部分并发理论基础/12)
  - [13 | 理论基础模块热点问题答疑](/java并发编程实战/03.第一部分并发理论基础/13)
- [04.第二部分并发工具类](/java并发编程实战/04.第二部分并发工具类)
  - [14 | Lock和Condition（上）：隐藏在并发包中的管程](/java并发编程实战/04.第二部分并发工具类/01)
  - [15 | Lock和Condition（下）：Dubbo如何用管程实现异步转同步？](/java并发编程实战/04.第二部分并发工具类/02)
  - [16 | Semaphore：如何快速实现一个限流器？](/java并发编程实战/04.第二部分并发工具类/03)
  - [17 | ReadWriteLock：如何快速实现一个完备的缓存？](/java并发编程实战/04.第二部分并发工具类/04)
  - [18 | StampedLock：有没有比读写锁更快的锁？](/java并发编程实战/04.第二部分并发工具类/05)
  - [19 | CountDownLatch和CyclicBarrier：如何让多线程步调一致？](/java并发编程实战/04.第二部分并发工具类/06)
  - [20 | 并发容器：都有哪些“坑”需要我们填？](/java并发编程实战/04.第二部分并发工具类/07)
  - [21 | 原子类：无锁工具类的典范](/java并发编程实战/04.第二部分并发工具类/08)
  - [22 | Executor与线程池：如何创建正确的线程池？](/java并发编程实战/04.第二部分并发工具类/09)
  - [23 | Future：如何用多线程实现最优的“烧水泡茶”程序？](/java并发编程实战/04.第二部分并发工具类/10)
  - [24 | CompletableFuture：异步编程没那么难](/java并发编程实战/04.第二部分并发工具类/11)
  - [25 | CompletionService：如何批量执行异步任务？](/java并发编程实战/04.第二部分并发工具类/12)
  - [26 | Fork/Join：单机版的MapReduce](/java并发编程实战/04.第二部分并发工具类/13)
  - [27 | 并发工具类模块热点问题答疑](/java并发编程实战/04.第二部分并发工具类/14)
- [05.第三部分并发设计模式](/java并发编程实战/05.第三部分并发设计模式)
  - [28 | Immutability模式：如何利用不变性解决并发问题？](/java并发编程实战/05.第三部分并发设计模式/01)
  - [29 | Copy-on-Write模式：不是延时策略的COW](/java并发编程实战/05.第三部分并发设计模式/02)
  - [30 | 线程本地存储模式：没有共享，就没有伤害](/java并发编程实战/05.第三部分并发设计模式/03)
  - [31 | Guarded Suspension模式：等待唤醒机制的规范实现](/java并发编程实战/05.第三部分并发设计模式/04)
  - [32 | Balking模式：再谈线程安全的单例模式](/java并发编程实战/05.第三部分并发设计模式/05)
  - [33 | Thread-Per-Message模式：最简单实用的分工方法](/java并发编程实战/05.第三部分并发设计模式/06)
  - [34 | Worker Thread模式：如何避免重复创建线程？](/java并发编程实战/05.第三部分并发设计模式/07)
  - [35 | 两阶段终止模式：如何优雅地终止线程？](/java并发编程实战/05.第三部分并发设计模式/08)
  - [36 | 生产者-消费者模式：用流水线思想提高效率](/java并发编程实战/05.第三部分并发设计模式/09)
  - [37 | 设计模式模块热点问题答疑](/java并发编程实战/05.第三部分并发设计模式/10)
- [06.第四部分案例分析](/java并发编程实战/06.第四部分案例分析)
  - [38 | 案例分析（一）：高性能限流器Guava RateLimiter](/java并发编程实战/06.第四部分案例分析/01)
  - [39 | 案例分析（二）：高性能网络应用框架Netty](/java并发编程实战/06.第四部分案例分析/02)
  - [40 | 案例分析（三）：高性能队列Disruptor](/java并发编程实战/06.第四部分案例分析/03)
  - [41 | 案例分析（四）：高性能数据库连接池HiKariCP](/java并发编程实战/06.第四部分案例分析/04)
- [07.第五部分其他并发模型](/java并发编程实战/07.第五部分其他并发模型)
  - [42 | Actor模型：面向对象原生的并发模型](/java并发编程实战/07.第五部分其他并发模型/01)
  - [43 | 软件事务内存：借鉴数据库的并发经验](/java并发编程实战/07.第五部分其他并发模型/02)
  - [44 | 协程：更轻量级的线程](/java并发编程实战/07.第五部分其他并发模型/03)
  - [45 | CSP模型：Golang的主力队员](/java并发编程实战/07.第五部分其他并发模型/04)
- [08.结束语](/java并发编程实战/08.结束语)
  - [结束语 | 十年之后，初心依旧](/java并发编程实战/08.结束语/01)
  - [结课测试 | 这些Java并发编程实战的知识你都掌握了吗？](/java并发编程实战/08.结束语/02)
- [09.用户故事](/java并发编程实战/09.用户故事)
  - [用户来信 | 真好，面试考到这些并发编程，我都答对了！](/java并发编程实战/09.用户故事/01)
  - [3 个用户来信 | 打开一个新的并发世界](/java并发编程实战/09.用户故事/02)
