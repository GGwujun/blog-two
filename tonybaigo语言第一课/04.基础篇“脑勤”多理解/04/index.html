<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>13｜基本数据类型：为什么Go要原生支持字符串类型？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/tonybaigo语言第一课/04.基础篇“脑勤”多理解/04" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a aria-current="page" class="active" href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a aria-current="page" class="active" href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-two/tonybaigo语言第一课/01.开篇词/01"><span>开篇词｜这样入门Go，才能少走弯路</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/02.前置篇心定之旅">02.前置篇心定之旅</a><ul><li><a href="/blog-two/tonybaigo语言第一课/02.前置篇心定之旅/01"><span>01｜前世今生：你不得不了解的Go的历史和现状</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/02.前置篇心定之旅/02"><span>02｜拒绝“Hello and Bye”：Go语言的设计哲学是怎么一回事？</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手">03.入门篇勤加练手</a><ul><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/01"><span>03｜配好环境：选择一种最适合你的Go安装方法</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/02"><span>04｜初窥门径：一个Go程序的结构是怎样的？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/03"><span>05｜标准先行：Go项目的布局标准是什么？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/04"><span>06｜构建模式：Go是怎么解决包依赖管理问题的？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/05"><span>07｜构建模式：Go Module的6类常规操作</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/06"><span>08｜入口函数与包初始化：搞清Go程序的执行次序</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/07"><span>09｜即学即练：构建一个Web服务就是这么简单</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解">04.基础篇“脑勤”多理解</a><ul><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/01"><span>10｜变量声明：静态语言有别于动态语言的重要特征</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/02"><span>11｜代码块与作用域：如何保证变量不会被遮蔽？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/03"><span>12｜基本数据类型：Go原生支持的数值类型有哪些？</span></a></li><li><a aria-current="page" class="active" href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/04"><span>13｜基本数据类型：为什么Go要原生支持字符串类型？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/05"><span>14｜常量：Go在“常量”设计上的创新有哪些？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/06"><span>15｜同构复合类型：从定长数组到变长切片</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/07"><span>16｜复合数据类型：原生map类型的实现机制是怎样的？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/08"><span>17｜复合数据类型：用结构体建立对真实世界的抽象</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/09"><span>18｜控制结构：if的“快乐路径”原则</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/10"><span>19｜控制结构：Go的for循环，仅此一种</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/11"><span>20｜控制结构：Go中的switch语句有哪些变化？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/12"><span>21｜函数：请叫我“一等公民”</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/13"><span>22｜函数：怎么结合多返回值进行错误处理？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/14"><span>期中测试｜一起检验下你的学习成果吧</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/15"><span>23｜函数：怎么让函数更简洁健壮？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/16"><span>24｜方法：理解“方法”的本质</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/17"><span>25｜方法：方法集合与如何选择receiver类型？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/18"><span>26｜方法：如何用类型嵌入模拟实现“继承”？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/19"><span>27｜即学即练：跟踪函数调用链，理解代码更直观</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/20"><span>用户故事｜罗杰：我的Go语言学习之路</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心">05.核心篇“脑勤+”洞彻核心</a><ul><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/01"><span>28｜接口：接口即契约</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02"><span>29｜接口：为什么nil接口不等于nil？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/03"><span>30｜接口：Go中最强大的魔法</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/04"><span>元旦快乐｜这是一份暂时停更的声明</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/05"><span>31｜并发：Go的并发方案实现方案是怎样的？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/06"><span>32｜并发：聊聊Goroutine调度器的原理</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07"><span>33｜并发：小channel中蕴含大智慧</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/08"><span>34｜并发：如何使用共享变量？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/09"><span>35｜即学即练：如何实现一个轻量级线程池？</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”">06.实战篇打通“最后一公里”</a><ul><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01"><span>36｜打稳根基：怎么实现一个TCP服务器？（上）</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/02"><span>37｜代码操练：怎么实现一个TCP服务器？（中）</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/03"><span>38｜成果优化：怎么实现一个TCP服务器？（下）</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/04"><span>结课测试｜快来检验下你的学习成果吧！</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇">07.加餐篇</a><ul><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/01"><span>加餐｜我“私藏”的那些优质且权威的Go语言学习资料</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/02"><span>加餐｜聊聊Go 1.17版本的那些新特性</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/03"><span>加餐｜如何拉取私有的Go Module？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/04"><span>加餐｜作为Go Module的作者，你应该知道的几件事</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/05"><span>加餐｜聊聊最近大热的Go泛型</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/06"><span>加餐｜聊聊Go语言的指针</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵">08.大咖助阵</a><ul><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/01"><span>大咖助阵｜孔令飞：从小白到“老鸟”，我的Go语言进阶之路</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/02"><span>大咖助阵｜叶剑峰：Go语言中常用的那些代码优化点</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/03"><span>大咖助阵｜徐祥曦：从销售到分布式存储工程师，我与 Go  的故事</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/04"><span>大咖助阵｜曹春晖：聊聊 Go 语言的 GC 实现</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/05"><span>大咖助阵｜大明：Go泛型，泛了，但没有完全泛</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/06"><span>大咖助阵｜海纳：聊聊语言中的类型系统与泛型</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/09.结束语">09.结束语</a><ul><li><a href="/blog-two/tonybaigo语言第一课/09.结束语/01"><span>结束语｜和你一起迎接Go的黄金十年</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/summary">tonybaigo语言第一课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="原生支持字符串有什么好处？" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/04#原生支持字符串有什么好处"><span>原生支持字符串有什么好处？</span></a></li><li title="Go字符串的组成" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/04#go字符串的组成"><span>Go字符串的组成</span></a></li><li title="rune类型与字符字面值" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/04#rune类型与字符字面值"><span>rune类型与字符字面值</span></a></li><li title="字符串字面值" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/04#字符串字面值"><span>字符串字面值</span></a></li><li title="UTF-8编码方案" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/04#utf-8编码方案"><span>UTF-8编码方案</span></a></li><li title="Go字符串类型的内部表示" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/04#go字符串类型的内部表示"><span>Go字符串类型的内部表示</span></a></li><li title="Go字符串类型的常见操作" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/04#go字符串类型的常见操作"><span>Go字符串类型的常见操作</span></a></li><li title="小结" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/04#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/04#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="13基本数据类型为什么go要原生支持字符串类型"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/04#13基本数据类型为什么go要原生支持字符串类型"><span class="icon icon-link"></span></a>13｜基本数据类型：为什么Go要原生支持字符串类型？</h1><p>你好，我是Tony Bai。</p><p>在上节课中，我们讲解了在Go编程中最广泛使用的一类基本数据类型：<strong>数值类型</strong>，包括整型、浮点类型和复数类型。这一节课，我们继续来学习Go语言中另一类基本数据类型：<strong>字符串类型</strong>。</p><p>字符串类型，是现代编程语言中最常用的数据类型之一，多数主流编程语言都提供了对这个类型的原生支持，少数没有提供原生字符串的类型的主流语言（比如C语言）也通过其他形式提供了对字符串的支持。</p><p>对于这样在日常开发中高频使用的基本数据类型，我们要给予更多的关注。所以，我们这一节课，将会按照Why-What-How的逻辑，讲清楚Go对字符串类型的支持，让你对Go语言中的字符串有个完整而清晰的认识。</p><p>首先，让我们来看看为什么Go要原生支持字符串类型。</p><h2 id="原生支持字符串有什么好处"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/04#原生支持字符串有什么好处"><span class="icon icon-link"></span></a>原生支持字符串有什么好处？</h2><p>我们前面提过，Go是站在巨人的肩膀上成长起来的现代编程语言。它继承了前辈语言的优点，又改进了前辈语言中的不足。这其中一处就体现在Go对字符串类型的原生支持上。</p><p>这样的设计会有什么好处呢？作为对比，我们先来看看前辈语言之一的C语言对字符串的支持情况。</p><p>C语言没有提供对字符串类型的原生支持，也就是说，C语言中并没有“字符串”这个数据类型。在C语言中，字符串是以字符串字面值或以’\0’结尾的字符类型数组来呈现的，比如下面代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#define GO_SLOGAN &quot;less is more&quot;</span></div><div class="token-line"><span class="token plain">    const char * s1 = &quot;hello, gopher&quot;</span></div><div class="token-line"><span class="token plain">    char s2[] = &quot;I love go&quot;</span></div></pre></div><p>这样定义的非原生字符串在使用过程中会有很多问题，比如：</p><ul><li>不是原生类型，编译器不会对它进行类型校验，导致类型安全性差；</li><li>字符串操作时要时刻考虑结尾的’\0’，防止缓冲区溢出；</li><li>以字符数组形式定义的“字符串”，它的值是可变的，在并发场景中需要考虑同步问题；</li><li>获取一个字符串的长度代价较大，通常是O(n)时间复杂度；</li><li>C语言没有内置对非ASCII字符（如中文字符）的支持。</li></ul><p>这些问题都大大加重了开发人员在使用字符串时的心智负担。于是，Go设计者们选择了原生支持字符串类型。</p><p>在Go中，字符串类型为<strong>string</strong>。Go语言通过string类型统一了对“字符串”的抽象。这样无论是字符串常量、字符串变量或是代码中出现的字符串字面值，它们的类型都被统一设置为string，比如上面C代码换成等价的Go代码是这样的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const (</span></div><div class="token-line"><span class="token plain">    	GO_SLOGAN = &quot;less is more&quot; // GO_SLOGAN是string类型常量</span></div><div class="token-line"><span class="token plain">    	s1 = &quot;hello, gopher&quot;       // s1是string类型常量</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    var s2 = &quot;I love go&quot; // s2是string类型变量</span></div></pre></div><p>那既然我们都说了，Go原生支持string的做法是对前辈语言的改进，这样的设计到底有哪些优秀的性质，会带来什么好处呢？</p><p><strong>第一点：string类型的数据是不可变的，提高了字符串的并发安全性和存储利用率。</strong></p><p>Go语言规定，字符串类型的值在它的生命周期内是不可改变的。这就是说，如果我们声明了一个字符串类型的变量，那我们是无法通过这个变量改变它对应的字符串值的，但这并不是说我们不能为一个字符串类型变量进行二次赋值。</p><p>什么意思呢？我们看看下面的代码就好理解了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var s string = &quot;hello&quot;</span></div><div class="token-line"><span class="token plain">    s[0] = &#x27;k&#x27;   // 错误：字符串的内容是不可改变的</span></div><div class="token-line"><span class="token plain">    s = &quot;gopher&quot; // ok</span></div></pre></div><p>在这段代码中，我们声明了一个字符串类型变量s。当我们试图通过下标方式把这个字符串的第一个字符由h改为k的时候，我们会收到编译器错误的提示：<strong>字符串是不可变的</strong>。但我们仍可以像最后一行代码那样，为变量s重新赋值为另外一个字符串。</p><p>Go这样的“字符串类型数据不可变”的性质给开发人员带来的最大好处，就是我们不用再担心字符串的并发安全问题。这样，Go字符串可以被多个Goroutine（Go语言的轻量级用户线程，后面我们会详细讲解）共享，开发者不用因为担心并发安全问题，使用会带来一定开销的同步机制。</p><p>另外，也由于字符串的不可变性，针对同一个字符串值，无论它在程序的几个位置被使用，Go编译器只需要为它分配一块存储就好了，大大提高了存储利用率。</p><p><strong>第二点：没有结尾’\0’，而且获取长度的时间复杂度是常数时间，消除了获取字符串长度的开销。</strong></p><p>在C语言中，获取一个字符串的长度可以调用标准库的strlen函数，这个函数的实现原理是遍历字符串中的每个字符并做计数，直到遇到字符串的结尾’\0’停止。显然这是一个线性时间复杂度的算法，执行时间与字符串中字符个数成正比。并且，它存在一个约束，那就是传入的字符串必须有结尾’\0’，结尾’\0’是字符串的结束标志。如果你使用过C语言，想必你也吃过字符串结尾’\0’的亏。</p><p>Go语言修正了这个缺陷，Go字符串中没有结尾’\0’，获取字符串长度更不需要结尾’\0’作为结束标志。并且，Go获取字符串长度是一个常数级时间复杂度，无论字符串中字符个数有多少，我们都可以快速得到字符串的长度值。至于这方面的原理，我们等会再详细说明。</p><p><strong>第三点：原生支持“所见即所得”的原始字符串，大大降低构造多行字符串时的心智负担。</strong></p><p>如果我们要在C语言中构造多行字符串，一般就是两个方法：要么使用多个字符串的自然拼接，要么需要结合续行符&quot;&quot;。但因为有转义字符的存在，我们很难控制好格式。**Go语言就简单多了，**通过一对反引号原生支持构造“所见即所得”的原始字符串（Raw String）。而且，Go语言原始字符串中的任意转义字符都不会起到转义的作用。比如下面这段代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var s string = `         ,_---~~~~~----._</span></div><div class="token-line"><span class="token plain">        _,,_,*^____      _____*g*\&quot;*,--,</span></div><div class="token-line"><span class="token plain">       / __/ /&#x27;     ^.  /      \ ^@q   f</span></div><div class="token-line"><span class="token plain">      [  @f | @))    |  | @))   l  0 _/</span></div><div class="token-line"><span class="token plain">       \/   \~____ / __ \_____/     \</span></div><div class="token-line"><span class="token plain">        |           _l__l_           I</span></div><div class="token-line"><span class="token plain">        }          [______]           I</span></div><div class="token-line"><span class="token plain">        ]            | | |            |</span></div><div class="token-line"><span class="token plain">        ]             ~ ~             |</span></div><div class="token-line"><span class="token plain">        |                            |</span></div><div class="token-line"><span class="token plain">         |                           |`</span></div><div class="token-line"><span class="token plain">    fmt.Println(s)</span></div></pre></div><p>你可以看到，字符串变量s被赋值了一个由一对反引号包裹的Gopher图案。这个Gopher图案由诸多ASCII字符组成，其中就包括了转义字符。这个时候，如果我们通过Println函数输出这个字符串，得到的图案和上面的图案并无二致。</p><p><strong>第四点：对非ASCII字符提供原生支持，消除了源码在不同环境下显示乱码的可能。</strong></p><p>Go语言源文件默认采用的是Unicode字符集，Unicode字符集是目前市面上最流行的字符集，它囊括了几乎所有主流非ASCII字符（包括中文字符）。Go字符串中的每个字符都是一个Unicode字符，并且这些Unicode字符是以UTF-8编码格式存储在内存当中的。在接下来讲解Go字符串的组成时，我们还会对这部分内容做进一步讲解。</p><p>知道了Go原生支持字符串类型带来的诸多变化和好处后，我们接下来就要深入到Go字符串的机制里看看，看看Go字符串是由什么组成的。</p><h2 id="go字符串的组成"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/04#go字符串的组成"><span class="icon icon-link"></span></a>Go字符串的组成</h2><p>Go语言在看待Go字符串组成这个问题上，有两种视角。一种是<strong>字节视角</strong>，也就是和所有其它支持字符串的主流语言一样，<strong>Go语言中的字符串值也是一个可空的字节序列，字节序列中的字节个数称为该字符串的长度。一个个的字节只是孤立数据，不表意。</strong></p><p>比如在下面代码中，我们输出了字符串中的每个字节，以及整个字符串的长度：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var s = &quot;中国人&quot;</span></div><div class="token-line"><span class="token plain">    fmt.Printf(&quot;the length of s = %d\n&quot;, len(s)) // 9</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    for i := 0; i &lt; len(s); i++ {</span></div><div class="token-line"><span class="token plain">    	fmt.Printf(&quot;0x%x &quot;, s[i]) // 0xe4 0xb8 0xad 0xe5 0x9b 0xbd 0xe4 0xba 0xba</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    fmt.Printf(&quot;\n&quot;)</span></div></pre></div><p>我们看到，由“中国人”构成的字符串的字节序列长度为9。并且，仅从某一个输出的字节来看，它是不能与字符串中的任一个字符对应起来的。</p><p>如果要表意，我们就需要从字符串的另外一个视角来看，也就是<strong>字符串是由一个可空的字符序列构成</strong>。这个时候我们再看下面代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var s = &quot;中国人&quot;</span></div><div class="token-line"><span class="token plain">    fmt.Println(&quot;the character count in s is&quot;, utf8.RuneCountInString(s)) // 3</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    for _, c := range s {</span></div><div class="token-line"><span class="token plain">    	fmt.Printf(&quot;0x%x &quot;, c) // 0x4e2d 0x56fd 0x4eba</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    fmt.Printf(&quot;\n&quot;)</span></div></pre></div><p>在这段代码中，我们输出了字符串中的字符数量，也输出了这个字符串中的每个字符。前面说过，Go采用的是Unicode字符集，每个字符都是一个Unicode字符，那么这里输出的0x4e2d、0x56fd和0x4eba就应该是某种Unicode字符的表示了。没错，以0x4e2d为例，它是汉字“中”在Unicode字符集表中的码点（Code Point）。</p><p>那么，什么是Unicode码点呢？</p><p>Unicode字符集中的每个字符，都被分配了统一且唯一的字符编号。所谓<strong>Unicode码点</strong>，就是指将Unicode字符集中的所有字符“排成一队”，字符在这个“队伍”中的<strong>位次</strong>，就是它在Unicode字符集中的码点。也就说，一个码点唯一对应一个字符。“码点”的概念和我们马上要讲的rune类型有很大关系。</p><h3 id="rune类型与字符字面值"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/04#rune类型与字符字面值"><span class="icon icon-link"></span></a>rune类型与字符字面值</h3><p>Go使用rune这个类型来表示一个Unicode码点。rune本质上是int32类型的别名类型，它与int32类型是完全等价的，在Go源码中我们可以看到它的定义是这样的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// $GOROOT/src/builtin.go</span></div><div class="token-line"><span class="token plain">    type rune = int32</span></div></pre></div><p>由于一个Unicode码点唯一对应一个Unicode字符。所以我们可以说，<strong>一个rune实例就是一个Unicode字符，一个Go字符串也可以被视为rune实例的集合。我们可以通过字符字面值来初始化一个rune变量。</strong></p><p>在Go中，字符字面值有多种表示法，最常见的是<strong>通过单引号括起的字符字面值</strong>，比如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&#x27;a&#x27;  // ASCII字符</span></div><div class="token-line"><span class="token plain">    &#x27;中&#x27; // Unicode字符集中的中文字符</span></div><div class="token-line"><span class="token plain">    &#x27;\n&#x27; // 换行字符</span></div><div class="token-line"><span class="token plain">    &#x27;\&#x27;&#x27; // 单引号字符</span></div></pre></div><p>我们还可以使用**Unicode专用的转义字符\u或\U作为前缀，**来表示一个Unicode字符，比如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&#x27;\u4e2d&#x27;     // 字符：中</span></div><div class="token-line"><span class="token plain">    &#x27;\U00004e2d&#x27; // 字符：中</span></div><div class="token-line"><span class="token plain">    &#x27;\u0027&#x27;     // 单引号字符</span></div></pre></div><p>这里，我们要注意，\u后面接两个十六进制数。如果是用两个十六进制数无法表示的Unicode字符，我们可以使用\U，\U后面可以接四个十六进制数来表示一个Unicode字符。</p><p>而且，由于表示码点的rune本质上就是一个整型数，所以我们还可<strong>用整型值来直接作为字符字面值给rune变量赋值</strong>，比如下面代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&#x27;\x27&#x27;  // 使用十六进制表示的单引号字符</span></div><div class="token-line"><span class="token plain">    &#x27;\047&#x27;  // 使用八进制表示的单引号字符</span></div></pre></div><h3 id="字符串字面值"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/04#字符串字面值"><span class="icon icon-link"></span></a>字符串字面值</h3><p>字符串是字符的集合，了解了字符字面值后，字符串的字面值也就很简单了。只不过字符串是多个字符，所以我们需要<strong>把表示单个字符的单引号，换为表示多个字符组成的字符串的双引号</strong>就可以了。我们可以看下面这些例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&quot;abc\n&quot;</span></div><div class="token-line"><span class="token plain">    &quot;中国人&quot;</span></div><div class="token-line"><span class="token plain">    &quot;\u4e2d\u56fd\u4eba&quot; // 中国人</span></div><div class="token-line"><span class="token plain">    &quot;\U00004e2d\U000056fd\U00004eba&quot; // 中国人</span></div><div class="token-line"><span class="token plain">    &quot;中\u56fd\u4eba&quot; // 中国人，不同字符字面值形式混合在一起</span></div><div class="token-line"><span class="token plain">    &quot;\xe4\xb8\xad\xe5\x9b\xbd\xe4\xba\xba&quot; // 十六进制表示的字符串字面值：中国人</span></div></pre></div><p>我们看到，将单个Unicode字符字面值一个接一个地连在一起，并用双引号包裹起来就构成了字符串字面值。甚至，我们也可以像倒数第二行那样，将不同字符字面值形式混合在一起，构成一个字符串字面值。</p><p>不过，这里你可能发现了一个问题，上面示例代码的最后一行使用的是十六进制形式的字符串字面值，但每个字节的值与前面几行的码点值完全对应不上啊，这是为什么呢？</p><p>这个字节序列实际上是“中国人”这个Unicode字符串的UTF-8编码值。什么是UTF-8编码？它又与Unicode字符集有什么关系呢？</p><h3 id="utf-8编码方案"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/04#utf-8编码方案"><span class="icon icon-link"></span></a>UTF-8编码方案</h3><p>UTF-8编码解决的是Unicode码点值在计算机中如何存储和表示（位模式）的问题。那你可能会说，码点唯一确定一个Unicode字符，直接用码点值不行么？</p><p>这的确是可以的，并且UTF-32编码标准就是采用的这个方案。UTF-32编码方案固定使用4个字节表示每个Unicode字符码点，这带来的好处就是编解码简单，但缺点也很明显，主要有下面几点：</p><ul><li>这种编码方案使用4个字节存储和传输一个整型数的时候，需要考虑不同平台的字节序问题;</li><li>由于采用4字节的固定长度编码，与采用1字节编码的ASCII字符集无法兼容；</li><li>所有Unicode字符码点都用4字节编码，显然空间利用率很差。</li></ul><p>针对这些问题，Go语言之父Rob Pike发明了UTF-8编码方案。和UTF-32方案不同，UTF-8方案使用变长度字节，对Unicode字符的码点进行编码。编码采用的字节数量与Unicode字符在码点表中的序号有关：表示序号（码点）小的字符使用的字节数量少，表示序号（码点）大的字符使用的字节数多。</p><p>UTF-8编码使用的字节数量从1个到4个不等。前128个与ASCII字符重合的码点（U+0000~U+007F）使用1个字节表示；带变音符号的拉丁文、希腊文、西里尔字母、阿拉伯文等使用2个字节来表示；而东亚文字（包括汉字）使用3个字节表示；其他极少使用的语言的字符则使用4个字节表示。</p><p>这样的编码方案是兼容ASCII字符内存表示的，这意味着采用UTF-8方案在内存中表示Unicode字符时，已有的ASCII字符可以被直接当成Unicode字符进行存储和传输，不用再做任何改变。</p><p>此外，UTF-8的编码单元为一个字节（也就是一次编解码一个字节），所以我们在处理UTF-8方案表示的Unicode字符的时候，就不需要像UTF-32方案那样考虑字节序问题了。相对于UTF-32方案，UTF-8方案的空间利用率也是最高的。</p><p>现在，UTF-8编码方案已经成为Unicode字符编码方案的事实标准，各个平台、浏览器等默认均使用UTF-8编码方案对Unicode字符进行编、解码。Go语言也不例外，采用了UTF-8编码方案存储Unicode字符，我们在前面按字节输出一个字符串值时看到的字节序列，就是对字符进行UTF-8编码后的值。</p><p>那么现在我们就使用Go在标准库中提供的UTF-8包，对Unicode字符（rune）进行编解码试试看：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// rune -&gt; []byte                                                                            </span></div><div class="token-line"><span class="token plain">    func encodeRune() {                                                                          </span></div><div class="token-line"><span class="token plain">        var r rune = 0x4E2D                                                                      </span></div><div class="token-line"><span class="token plain">        fmt.Printf(&quot;the unicode charactor is %c\n&quot;, r) // 中                                     </span></div><div class="token-line"><span class="token plain">        buf := make([]byte, 3)                                                                   </span></div><div class="token-line"><span class="token plain">        _ = utf8.EncodeRune(buf, r) // 对rune进行utf-8编码                                                           </span></div><div class="token-line"><span class="token plain">        fmt.Printf(&quot;utf-8 representation is 0x%X\n&quot;, buf) // 0xE4B8AD                            </span></div><div class="token-line"><span class="token plain">    }                                                                                            </span></div><div class="token-line"><span class="token plain">                                                                                                 </span></div><div class="token-line"><span class="token plain">    // []byte -&gt; rune                                                                            </span></div><div class="token-line"><span class="token plain">    func decodeRune() {                                                                          </span></div><div class="token-line"><span class="token plain">        var buf = []byte{0xE4, 0xB8, 0xAD}                                                       </span></div><div class="token-line"><span class="token plain">        r, _ := utf8.DecodeRune(buf) // 对buf进行utf-8解码</span></div><div class="token-line"><span class="token plain">        fmt.Printf(&quot;the unicode charactor after decoding [0xE4, 0xB8, 0xAD] is %s\n&quot;, string(r)) // 中</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这段代码中，encodeRune通过调用UTF-8的EncodeRune函数实现了对一个rune，也就是一个Unicode字符的编码，decodeRune则调用UTF-8包的decodeRune，将一段内存字节转换回一个Unicode字符。</p><p>好了，现在我们已经搞清楚Go语言中字符串类型的性质和组成了。有了这些基础之后，我们就可以看看Go是如何实现字符串类型的。也就是说，在Go的编译器和运行时中，一个字符串变量究竟是如何表示的？</p><h2 id="go字符串类型的内部表示"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/04#go字符串类型的内部表示"><span class="icon icon-link"></span></a>Go字符串类型的内部表示</h2><p>其实，我们前面提到的Go字符串类型的这些优秀的性质，Go字符串在编译器和运行时中的内部表示是分不开的。Go字符串类型的内部表示究竟是什么样的呢？在标准库的reflect包中，我们找到了答案，你可以看看下面代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// $GOROOT/src/reflect/value.go</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // StringHeader是一个string的运行时表示</span></div><div class="token-line"><span class="token plain">    type StringHeader struct {</span></div><div class="token-line"><span class="token plain">        Data uintptr</span></div><div class="token-line"><span class="token plain">        Len  int</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们可以看到，**string类型其实是一个“描述符”，它本身并不真正存储字符串数据，而仅是由一个指向底层存储的指针和字符串的长度字段组成的。**我也画了一张图，直观地展示了一个string类型变量在Go内存中的存储：</p><p><img src="https://static001.geekbang.org/resource/image/6c/28/6c94a2f5a0f942e361792b26f5abfa28.jpg?wh=1920x1047" alt="图片"/></p><p>你看，Go编译器把源码中的string类型映射为运行时的一个二元组（Data, Len），真实的字符串值数据就存储在一个被Data指向的底层数组中。通过Data字段，我们可以得到这个数组的内容，你可以看看下面这段代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func dumpBytesArray(arr []byte) {</span></div><div class="token-line"><span class="token plain">        fmt.Printf(&quot;[&quot;)</span></div><div class="token-line"><span class="token plain">        for _, b := range arr {</span></div><div class="token-line"><span class="token plain">            fmt.Printf(&quot;%c &quot;, b)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        fmt.Printf(&quot;]\n&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">        var s = &quot;hello&quot;</span></div><div class="token-line"><span class="token plain">        hdr := (*reflect.StringHeader)(unsafe.Pointer(&amp;s)) // 将string类型变量地址显式转型为reflect.StringHeader</span></div><div class="token-line"><span class="token plain">        fmt.Printf(&quot;0x%x\n&quot;, hdr.Data) // 0x10a30e0</span></div><div class="token-line"><span class="token plain">        p := (*[5]byte)(unsafe.Pointer(hdr.Data)) // 获取Data字段所指向的数组的指针</span></div><div class="token-line"><span class="token plain">        dumpBytesArray((*p)[:]) // [h e l l o ]   // 输出底层数组的内容</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这段代码利用了unsafe.Pointer的通用指针转型能力，按照StringHeader给出的结构内存布局，“顺藤摸瓜”，一步步找到了底层数组的地址，并输出了底层数组内容。</p><p>知道了string类型的实现原理后，我们再回头看看Go字符串类型性质中“获取长度的时间复杂度是常数时间”那句，是不是就很好理解了？之所以是常数时间，那是因为字符串类型中包含了字符串长度信息，当我们用len函数获取字符串长度时，len函数只要简单地将这个信息提取出来就可以了。</p><p>了解了string类型的实现原理后，我们还可以得到这样一个结论，那就是**我们直接将string类型通过函数/方法参数传入也不会带来太多的开销。**因为传入的仅仅是一个“描述符”，而不是真正的字符串数据。</p><p>那么，了解了Go字符串的一些基本信息和原理后，我们从理论转向实际，看看日常开发中围绕字符串类型都有哪些常见操作。</p><h2 id="go字符串类型的常见操作"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/04#go字符串类型的常见操作"><span class="icon icon-link"></span></a>Go字符串类型的常见操作</h2><p>由于字符串的不可变性，针对字符串，我们更多是尝试对其进行读取，或者将它作为一个组成单元去构建其他字符串，又或是转换为其他类型。下面我们逐一来看一下这些字符串操作：</p><p><strong>第一个操作：下标操作。</strong></p><p>在字符串的实现中，真正存储数据的是底层的数组。字符串的下标操作本质上等价于底层数组的下标操作。我们在前面的代码中实际碰到过针对字符串的下标操作，形式是这样的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var s = &quot;中国人&quot;</span></div><div class="token-line"><span class="token plain">    fmt.Printf(&quot;0x%x\n&quot;, s[0]) // 0xe4：字符“中” utf-8编码的第一个字节</span></div></pre></div><p>我们可以看到，通过下标操作，我们获取的是字符串中特定下标上的字节，而不是字符。</p><p><strong>第二个操作：字符迭代。</strong></p><p>Go有两种迭代形式：常规for迭代与for range迭代。<strong>你要注意，通过这两种形式的迭代对字符串进行操作得到的结果是不同的</strong>。</p><p>通过常规for迭代对字符串进行的操作是一种字节视角的迭代，每轮迭代得到的的结果都是组成字符串内容的一个字节，以及该字节所在的下标值，这也等价于对字符串底层数组的迭代，比如下面代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var s = &quot;中国人&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    for i := 0; i &lt; len(s); i++ {</span></div><div class="token-line"><span class="token plain">    	fmt.Printf(&quot;index: %d, value: 0x%x\n&quot;, i, s[i])</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>运行这段代码，我们会看到，经过常规for迭代后，我们获取到的是字符串里字符的UTF-8编码中的一个字节：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">index: 0, value: 0xe4</span></div><div class="token-line"><span class="token plain">    index: 1, value: 0xb8</span></div><div class="token-line"><span class="token plain">    index: 2, value: 0xad</span></div><div class="token-line"><span class="token plain">    index: 3, value: 0xe5</span></div><div class="token-line"><span class="token plain">    index: 4, value: 0x9b</span></div><div class="token-line"><span class="token plain">    index: 5, value: 0xbd</span></div><div class="token-line"><span class="token plain">    index: 6, value: 0xe4</span></div><div class="token-line"><span class="token plain">    index: 7, value: 0xba</span></div><div class="token-line"><span class="token plain">    index: 8, value: 0xba</span></div></pre></div><p>而像下面这样使用for range迭代，我们得到的又是什么呢？我们继续看代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var s = &quot;中国人&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    for i, v := range s {</span></div><div class="token-line"><span class="token plain">        fmt.Printf(&quot;index: %d, value: 0x%x\n&quot;, i, v)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>同样运行一下这段代码，我们得到：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">index: 0, value: 0x4e2d</span></div><div class="token-line"><span class="token plain">    index: 3, value: 0x56fd</span></div><div class="token-line"><span class="token plain">    index: 6, value: 0x4eba</span></div></pre></div><p>我们看到，通过for range迭代，我们每轮迭代得到的是字符串中Unicode字符的码点值，以及该字符在字符串中的偏移值。我们可以通过这样的迭代，获取字符串中的字符个数，而通过Go提供的内置函数len，我们只能获取字符串内容的长度（字节个数）。当然了，获取字符串中字符个数更专业的方法，是调用标准库UTF-8包中的RuneCountInString函数，这点你可以自己试一下。</p><p><strong>第三个操作：字符串连接。</strong></p><p>我们前面已经知道，字符串内容是不可变的，但这并不妨碍我们基于已有字符串创建新字符串。Go原生支持通过+/+=操作符进行字符串连接，这也是对开发者体验最好的字符串连接操作，你可以看看下面这段代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">s := &quot;Rob Pike, &quot;</span></div><div class="token-line"><span class="token plain">    s = s + &quot;Robert Griesemer, &quot;</span></div><div class="token-line"><span class="token plain">    s += &quot; Ken Thompson&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fmt.Println(s) // Rob Pike, Robert Griesemer, Ken Thompson</span></div></pre></div><p>不过，虽然通过+/+=进行字符串连接的开发体验是最好的，但连接性能就未必是最快的了。除了这个方法外，Go还提供了strings.Builder、strings.Join、fmt.Sprintf等函数来进行字符串连接操作。关于这些方法的性能讨论，我放到了后面的思考题里，我想让你先去找一下答案。</p><p><strong>第四个操作：字符串比较。</strong></p><p>Go字符串类型支持各种比较关系操作符，包括= =、!= 、&gt;=、&lt;=、&gt; 和 &lt;。在字符串的比较上，Go采用字典序的比较策略，分别从每个字符串的起始处，开始逐个字节地对两个字符串类型变量进行比较。</p><p>当两个字符串之间出现了第一个不相同的元素，比较就结束了，这两个元素的比较结果就会做为串最终的比较结果。如果出现两个字符串长度不同的情况，长度比较小的字符串会用空元素补齐，空元素比其他非空元素都小。</p><p>这里我给了一个Go字符串比较的示例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func main() {</span></div><div class="token-line"><span class="token plain">            // ==</span></div><div class="token-line"><span class="token plain">            s1 := &quot;世界和平&quot;</span></div><div class="token-line"><span class="token plain">            s2 := &quot;世界&quot; + &quot;和平&quot;</span></div><div class="token-line"><span class="token plain">            fmt.Println(s1 == s2) // true</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // !=</span></div><div class="token-line"><span class="token plain">            s1 = &quot;Go&quot;</span></div><div class="token-line"><span class="token plain">            s2 = &quot;C&quot;</span></div><div class="token-line"><span class="token plain">            fmt.Println(s1 != s2) // true</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // &lt; and &lt;=</span></div><div class="token-line"><span class="token plain">            s1 = &quot;12345&quot;</span></div><div class="token-line"><span class="token plain">            s2 = &quot;23456&quot;</span></div><div class="token-line"><span class="token plain">            fmt.Println(s1 &lt; s2)  // true</span></div><div class="token-line"><span class="token plain">            fmt.Println(s1 &lt;= s2) // true</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // &gt; and &gt;=</span></div><div class="token-line"><span class="token plain">            s1 = &quot;12345&quot;</span></div><div class="token-line"><span class="token plain">            s2 = &quot;123&quot;</span></div><div class="token-line"><span class="token plain">            fmt.Println(s1 &gt; s2)  // true</span></div><div class="token-line"><span class="token plain">            fmt.Println(s1 &gt;= s2) // true</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>你可以看到，鉴于Go string类型是不可变的，所以说如果两个字符串的长度不相同，那么我们不需要比较具体字符串数据，也可以断定两个字符串是不同的。但是如果两个字符串长度相同，就要进一步判断，数据指针是否指向同一块底层存储数据。如果还相同，那么我们可以说两个字符串是等价的，如果不同，那就还需要进一步去比对实际的数据内容。</p><p><strong>第五个操作：字符串转换。</strong></p><p>在这方面，Go支持字符串与字节切片、字符串与rune切片的双向转换，并且这种转换无需调用任何函数，只需使用显式类型转换就可以了。我们看看下面代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var s string = &quot;中国人&quot;</span></div><div class="token-line"><span class="token plain">                          </span></div><div class="token-line"><span class="token plain">    // string -&gt; []rune</span></div><div class="token-line"><span class="token plain">    rs := []rune(s) </span></div><div class="token-line"><span class="token plain">    fmt.Printf(&quot;%x\n&quot;, rs) // [4e2d 56fd 4eba]</span></div><div class="token-line"><span class="token plain">                    </span></div><div class="token-line"><span class="token plain">    // string -&gt; []byte</span></div><div class="token-line"><span class="token plain">    bs := []byte(s) </span></div><div class="token-line"><span class="token plain">    fmt.Printf(&quot;%x\n&quot;, bs) // e4b8ade59bbde4baba</span></div><div class="token-line"><span class="token plain">                    </span></div><div class="token-line"><span class="token plain">    // []rune -&gt; string</span></div><div class="token-line"><span class="token plain">    s1 := string(rs)</span></div><div class="token-line"><span class="token plain">    fmt.Println(s1) // 中国人</span></div><div class="token-line"><span class="token plain">                    </span></div><div class="token-line"><span class="token plain">    // []byte -&gt; string</span></div><div class="token-line"><span class="token plain">    s2 := string(bs)</span></div><div class="token-line"><span class="token plain">    fmt.Println(s2) // 中国人</span></div></pre></div><p>这样的转型看似简单，但无论是string转切片，还是切片转string，这类转型背后也是有着一定开销的。这些开销的根源就在于string是不可变的，运行时要为转换后的类型分配新内存。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/04#小结"><span class="icon icon-link"></span></a>小结</h2><p>好了，今天的课讲到这里就结束了。这一节课，我们学习了Go中另外一类最常用的基本数据类型：字符串类型。Go原生支持字符串类型，所有字符串变量、常量、字面值都统一设置为string类型，对string的原生支持使得Go字符串有了很多优秀性质。</p><p>我们可以使用两个视角来看待Go字符串的组成，一种是字节视角。Go字符串是由一个可空的字节序列组成，字节的个数称为字符串的长度；另外一种是字符视角。Go字符串是由一个可空的字符序列构成。Go字符串中的每个字符都是一个Unicode字符。</p><p>Go使用rune类型来表示一个Unicode字符的码点。为了传输和存储Unicode字符，Go还使用了UTF-8编码方案，UTF-8编码方案使用变长字节的编码方式，码点小的字符用较少的字节编码，码点大的字符用较多字节编码，这种编码方式兼容ASCII字符集，并且拥有很高的空间利用率。</p><p>Go语言在运行时层面通过一个二元组结构（Data, Len）来表示一个string类型变量，其中Data是一个指向存储字符串数据内容区域的指针值，Len是字符串的长度。因此，本质上，一个string变量仅仅是一个“描述符”，并不真正包含字符串数据。因此，我们即便直接将string类型变量作为函数参数，其传递的开销也是恒定的，不会随着字符串大小的变化而变化。</p><p>Go为其原生支持的string类型提供了许多原生操作类型，在进行字符串操作时你要注意以下几点：</p><ul><li>通过常规for迭代与for range迭代所得到的结果不同，常规for迭代采用的是字节视角；而for range迭代采用的是字符视角；</li><li>基于+/+=操作符的字符串连接是对开发者体验最好的字符串连接方式，但却不是性能最好的方式；</li><li>无论是字符串转切片，还是切片转字符串，都会有内存分配的开销，这缘于Go字符串数据内容不可变的性质。</li></ul><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/04#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>我们前面讲到，Go提供多种字符串连接服务，包括基于+/+=的字符连接、基于strings.Builder、strings.Join、fmt.Sprintf等函数来进行字符串连接操作。那么，哪种连接方式是性能最高的呢？期待在留言区看到你的想法。</p><p>欢迎把这节课分享给更多对Go语言字符串类型感兴趣的朋友。我是Tony Bai，我们下节课见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/tonybaigo语言第一课/04.基础篇“脑勤”多理解/04.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:32</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
