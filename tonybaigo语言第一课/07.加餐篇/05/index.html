<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>加餐｜聊聊最近大热的Go泛型</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/tonybaigo语言第一课/07.加餐篇/05" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a aria-current="page" class="active" href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a aria-current="page" class="active" href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-two/tonybaigo语言第一课/01.开篇词/01"><span>开篇词｜这样入门Go，才能少走弯路</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/02.前置篇心定之旅">02.前置篇心定之旅</a><ul><li><a href="/blog-two/tonybaigo语言第一课/02.前置篇心定之旅/01"><span>01｜前世今生：你不得不了解的Go的历史和现状</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/02.前置篇心定之旅/02"><span>02｜拒绝“Hello and Bye”：Go语言的设计哲学是怎么一回事？</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手">03.入门篇勤加练手</a><ul><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/01"><span>03｜配好环境：选择一种最适合你的Go安装方法</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/02"><span>04｜初窥门径：一个Go程序的结构是怎样的？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/03"><span>05｜标准先行：Go项目的布局标准是什么？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/04"><span>06｜构建模式：Go是怎么解决包依赖管理问题的？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/05"><span>07｜构建模式：Go Module的6类常规操作</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/06"><span>08｜入口函数与包初始化：搞清Go程序的执行次序</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/07"><span>09｜即学即练：构建一个Web服务就是这么简单</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解">04.基础篇“脑勤”多理解</a><ul><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/01"><span>10｜变量声明：静态语言有别于动态语言的重要特征</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/02"><span>11｜代码块与作用域：如何保证变量不会被遮蔽？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/03"><span>12｜基本数据类型：Go原生支持的数值类型有哪些？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/04"><span>13｜基本数据类型：为什么Go要原生支持字符串类型？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/05"><span>14｜常量：Go在“常量”设计上的创新有哪些？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/06"><span>15｜同构复合类型：从定长数组到变长切片</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/07"><span>16｜复合数据类型：原生map类型的实现机制是怎样的？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/08"><span>17｜复合数据类型：用结构体建立对真实世界的抽象</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/09"><span>18｜控制结构：if的“快乐路径”原则</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/10"><span>19｜控制结构：Go的for循环，仅此一种</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/11"><span>20｜控制结构：Go中的switch语句有哪些变化？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/12"><span>21｜函数：请叫我“一等公民”</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/13"><span>22｜函数：怎么结合多返回值进行错误处理？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/14"><span>期中测试｜一起检验下你的学习成果吧</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/15"><span>23｜函数：怎么让函数更简洁健壮？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/16"><span>24｜方法：理解“方法”的本质</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/17"><span>25｜方法：方法集合与如何选择receiver类型？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/18"><span>26｜方法：如何用类型嵌入模拟实现“继承”？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/19"><span>27｜即学即练：跟踪函数调用链，理解代码更直观</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/20"><span>用户故事｜罗杰：我的Go语言学习之路</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心">05.核心篇“脑勤+”洞彻核心</a><ul><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/01"><span>28｜接口：接口即契约</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02"><span>29｜接口：为什么nil接口不等于nil？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/03"><span>30｜接口：Go中最强大的魔法</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/04"><span>元旦快乐｜这是一份暂时停更的声明</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/05"><span>31｜并发：Go的并发方案实现方案是怎样的？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/06"><span>32｜并发：聊聊Goroutine调度器的原理</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07"><span>33｜并发：小channel中蕴含大智慧</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/08"><span>34｜并发：如何使用共享变量？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/09"><span>35｜即学即练：如何实现一个轻量级线程池？</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”">06.实战篇打通“最后一公里”</a><ul><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01"><span>36｜打稳根基：怎么实现一个TCP服务器？（上）</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/02"><span>37｜代码操练：怎么实现一个TCP服务器？（中）</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/03"><span>38｜成果优化：怎么实现一个TCP服务器？（下）</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/04"><span>结课测试｜快来检验下你的学习成果吧！</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/tonybaigo语言第一课/07.加餐篇">07.加餐篇</a><ul><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/01"><span>加餐｜我“私藏”的那些优质且权威的Go语言学习资料</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/02"><span>加餐｜聊聊Go 1.17版本的那些新特性</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/03"><span>加餐｜如何拉取私有的Go Module？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/04"><span>加餐｜作为Go Module的作者，你应该知道的几件事</span></a></li><li><a aria-current="page" class="active" href="/blog-two/tonybaigo语言第一课/07.加餐篇/05"><span>加餐｜聊聊最近大热的Go泛型</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/06"><span>加餐｜聊聊Go语言的指针</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵">08.大咖助阵</a><ul><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/01"><span>大咖助阵｜孔令飞：从小白到“老鸟”，我的Go语言进阶之路</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/02"><span>大咖助阵｜叶剑峰：Go语言中常用的那些代码优化点</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/03"><span>大咖助阵｜徐祥曦：从销售到分布式存储工程师，我与 Go  的故事</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/04"><span>大咖助阵｜曹春晖：聊聊 Go 语言的 GC 实现</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/05"><span>大咖助阵｜大明：Go泛型，泛了，但没有完全泛</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/06"><span>大咖助阵｜海纳：聊聊语言中的类型系统与泛型</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/09.结束语">09.结束语</a><ul><li><a href="/blog-two/tonybaigo语言第一课/09.结束语/01"><span>结束语｜和你一起迎接Go的黄金十年</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/summary">tonybaigo语言第一课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="为什么要加入泛型？" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/05#为什么要加入泛型"><span>为什么要加入泛型？</span></a></li><li title="Go泛型设计的简史" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/05#go泛型设计的简史"><span>Go泛型设计的简史</span></a></li><li title="Go泛型的基本语法" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/05#go泛型的基本语法"><span>Go泛型的基本语法</span></a></li><li title="类型参数（type parameter）" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/05#类型参数type-parameter"><span>类型参数（type parameter）</span></a></li><li title="约束（constraint）" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/05#约束constraint"><span>约束（constraint）</span></a></li><li title="类型具化（instantiation）" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/05#类型具化instantiation"><span>类型具化（instantiation）</span></a></li><li title="泛型类型" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/05#泛型类型"><span>泛型类型</span></a></li><li title="Go泛型的性能" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/05#go泛型的性能"><span>Go泛型的性能</span></a></li><li title="Go泛型的使用建议" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/05#go泛型的使用建议"><span>Go泛型的使用建议</span></a></li><li title="什么情况适合使用泛型" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/05#什么情况适合使用泛型"><span>什么情况适合使用泛型</span></a></li><li title="什么情况不宜使用泛型" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/05#什么情况不宜使用泛型"><span>什么情况不宜使用泛型</span></a></li><li title="小结" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/05#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/05#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="加餐聊聊最近大热的go泛型"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/07.加餐篇/05#加餐聊聊最近大热的go泛型"><span class="icon icon-link"></span></a>加餐｜聊聊最近大热的Go泛型</h1><p>你好，我是Tony Bai。</p><p>美国时间2022年1月31日，在中国人民欢庆虎年春节之际，Go核心团队发布了<a target="_blank" rel="noopener noreferrer" href="https://go.dev/blog/go1.18beta2">Go 1.18 Beta2版本<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。在Go 1.18beta2版本发布的<a target="_blank" rel="noopener noreferrer" href="https://go.dev/blog/go1.18beta2">博文<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中，Go核心团队还给出了Go 1.18版本的发布计划：<strong>2022年2月发布Go 1.18RC（release candidate，即发布候选版），2022年3月发布Go 1.18最终版本</strong>。</p><p>考虑到Go 1.18版本中引入了Go语言开源以来最大的语法特性变化：<strong>泛型（generic）</strong>，改动和影响都很大，Go核心团队将Go 1.18版本延迟一个月，放到3月发布也不失为稳妥之举。</p><p>在Go泛型正式落地之前，我想在这篇加餐中带你认识一下Go泛型，目的是“抛砖引玉”，为你后续系统学习和应用Go泛型语法特性开个头儿。</p><p>我们今天将围绕Go为什么加入泛型、泛型设计方案的演化历史、Go泛型的主要语法以及Go泛型的使用建议几个方面，聊聊Go泛型的那些事儿。</p><p>首先，我们先来了解一下Go语言为什么要加入泛型语法特性。</p><h2 id="为什么要加入泛型"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/07.加餐篇/05#为什么要加入泛型"><span class="icon icon-link"></span></a>为什么要加入泛型？</h2><p>根据近几年的Go官方用户调查结果，在“你最想要的Go语言特性”这项调查中，泛型霸榜多年。你可以看下这张摘自最新的<a target="_blank" rel="noopener noreferrer" href="https://go.dev/blog/survey2020-results">2020年Go官方用户调查结果<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的图片：</p><p><img src="https://static001.geekbang.org/resource/image/12/66/12c48b37821f63e81e7ee52ae6175566.png?wh=1910x1244" alt="图片"/></p><p>既然Go社区对泛型特性的需求如此强烈，那么Go核心团队为何要在Go开源后的第13个年头，才将这个特性加入语言当中呢？这里的故事说来话长。要想了解其中原因，我们需要先来了解一下<strong>什么是泛型</strong>？</p><p><a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Generic_programming">维基百科<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>提到：最初泛型编程这个概念来自于缪斯.大卫和斯捷潘诺夫.亚历山大合著的“泛型编程”一文。那篇文章对泛型编程的诠释是：“<strong>泛型编程的中心思想是对具体的、高效的算法进行抽象，以获得通用的算法，然后这些算法可以与不同的数据表示法结合起来，产生各种各样有用的软件</strong>”。说白了就是将算法与类型解耦，实现算法更广泛的复用。</p><p>我们举个简单的例子。这里是一个简单得不能再简单的加法函数，这个函数接受两个int32类型参数作为加数：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func Add(a, b int32) int32 {</span></div><div class="token-line"><span class="token plain">    	return a + b</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>不过上面的函数Add仅适用于int32类型的加数，如果我们要对int、int64、byte等类型的加数进行加法运算，我们还需要实现AddInt、AddInt64、AddByte等函数。</p><p>那如果我们用泛型编程的思想来解决这个问题，是怎样呢？</p><p>我们需要将<strong>算法与类型解耦</strong>，实现一个泛型版的Add算法，我们用Go泛型语法实现的泛型版Add是这样的（注意这里需要使用Go 1.18beta1或后续版本进行编译和运行）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func Add[T constraints.Integer](a, b T) T {</span></div><div class="token-line"><span class="token plain">        return a + b</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这样，我们就可以直接使用泛型版Add函数去进行各种整型类型的加法运算了，比如下面代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func main() {</span></div><div class="token-line"><span class="token plain">        var m, n int = 5, 6</span></div><div class="token-line"><span class="token plain">        println(Add(m,n)) // Add[int](m, n)</span></div><div class="token-line"><span class="token plain">        var i,j int64 = 15, 16</span></div><div class="token-line"><span class="token plain">        println(Add(i,j)) // Add[int64](i, j)</span></div><div class="token-line"><span class="token plain">        var c,d byte = 0x11, 0x12</span></div><div class="token-line"><span class="token plain">        println(Add(c,d)) // Add[byte](c, d)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>通过这个例子我们可以看到，在没有泛型的情况下，我们需要针对不同类型重复实现相同的算法逻辑，比如上面例子提到的AddInt、AddInt64等。</p><p>这对于简单的、诸如上面这样的加法函数还可忍受，但对于复杂的算法，比如涉及复杂排序、查找、树、图等算法，以及一些容器类型（链表、栈、队列等）的实现时，缺少了泛型的支持还真是麻烦。</p><p>在没有泛型之前，Gopher们通常使用空接口类型interface<!-- -->{<!-- -->}<!-- -->，作为算法操作的对象的数据类型，不过这样做的不足之处也很明显：一是无法进行类型安全检查，二是性能有损失。</p><p>**那么回到前面的问题，既然泛型有这么多优点，为什么Go不早点加入泛型呢？**其实这个问题在<a target="_blank" rel="noopener noreferrer" href="https://go.dev/doc/faq#generics">Go FAQ<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中早有答案，我总结一下大概三点主要理由：</p><ul><li>这个语法特性不紧迫，不是Go早期的设计目标；</li></ul><p>在Go诞生早期，很多基本语法特性的优先级都要高于泛型。此外，Go团队更多将语言的设计目标定位在规模化（scalability）、可读性、并发性上，泛型与这些主要目标关联性不强。等Go成熟后，Go团队会在适当时候引入泛型。</p><ul><li>与简单的设计哲学有悖；</li></ul><p>Go语言最吸睛的地方就是<strong>简单</strong>，简单也是Go设计哲学之首！但泛型这个语法特性会给语言带来复杂性，这种复杂性不仅体现在语法层面上引入了新的语法元素，也体现在类型系统和运行时层面上为支持泛型进行了复杂的实现。</p><ul><li>尚未找到合适的、价值足以抵消其引入的复杂性的理想设计方案。</li></ul><p>从Go开源那一天开始，Go团队就没有间断过对泛型的探索，并一直尝试寻找一个理想的泛型设计方案，但始终未能如愿。</p><p>直到近几年Go团队觉得Go已经逐渐成熟，是时候下决心解决Go社区主要关注的几个问题了，包括泛型、包依赖以及错误处理等，并安排伊恩·泰勒和罗伯特·格瑞史莫花费更多精力在泛型的设计方案上，这才有了在即将发布的Go 1.18版本中泛型语法特性的落地。</p><p>为了让你更清晰地看到Go团队在泛型上付出的努力，同时也能了解Go泛型的设计过程与来龙去脉，这里我简单整理了一个Go泛型设计的简史，你可以参考一下。</p><h2 id="go泛型设计的简史"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/07.加餐篇/05#go泛型设计的简史"><span class="icon icon-link"></span></a>Go泛型设计的简史</h2><p>Go核心团队对泛型的探索，是从<strong>2009年12月3日</strong>Russ Cox在其博客站点上发表的一篇文章开始的。在这篇叫<a target="_blank" rel="noopener noreferrer" href="https://research.swtch.com/generic">“泛型窘境”<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的文章中，Russ Cox提出了Go泛型实现的三个可遵循的方法，以及每种方法的不足，也就是三个slow（拖慢）：</p><ul><li><strong>拖慢程序员</strong>：不实现泛型，不会引入复杂性，但就像前面例子中那样，需要程序员花费精力重复实现AddInt、AddInt64等；</li><li><strong>拖慢编译器</strong>：就像C++的泛型实现方案那样，通过增加编译器负担为每个类型实例生成一份单独的泛型函数的实现，这种方案产生了大量的代码，其中大部分是多余的，有时候还需要一个好的链接器来消除重复的拷贝；</li><li><strong>拖慢执行性能</strong>：就像Java的泛型实现方案那样，通过隐式的装箱和拆箱操作消除类型差异，虽然节省了空间，但代码执行效率低。</li></ul><p>在当时，三个slow之间需要取舍，就如同数据一致性的CAP原则一样，无法将三个slow同时消除。</p><p>之后，伊恩·泰勒主要负责持续跟进Go泛型方案的设计，从2010到2016年，伊恩·泰勒先后提出了几版泛型设计方案，它们是：</p><ul><li>2010年6月份，伊恩·泰勒提出的<a target="_blank" rel="noopener noreferrer" href="https://go.googlesource.com/proposal/+/master/design/15292/2010-06-type-functions.md">Type Functions<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>设计方案；</li><li>2011年3月份，伊恩·泰勒提出的<a target="_blank" rel="noopener noreferrer" href="https://go.googlesource.com/proposal/+/master/design/15292/2011-03-gen.md">Generalized Types<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>设计方案；</li><li>2013年10月份，伊恩·泰勒提出的<a target="_blank" rel="noopener noreferrer" href="https://go.googlesource.com/proposal/+/master/design/15292/2013-10-gen.md">Generalized Types设计方案更新版<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>；</li><li>2013年12月份，伊恩·泰勒提出的<a target="_blank" rel="noopener noreferrer" href="https://go.googlesource.com/proposal/+/master/design/15292/2013-12-type-params.md">Type Parameters<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>设计方案；</li><li>2016年9月份，布莱恩-C-米尔斯提出的<a target="_blank" rel="noopener noreferrer" href="https://go.googlesource.com/proposal/+/master/design/15292/2016-09-compile-time-functions.md">Compile-time Functions and First Class Types<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>设计方案。</li></ul><p>虽然这些方案因为存在各种不足，最终都没有被接受，但这些探索为后续Go泛型的最终落地奠定了基础。</p><p>2017年7月，Russ Cox在GopherCon 2017大会上发表演讲“<a target="_blank" rel="noopener noreferrer" href="https://go.dev/blog/toward-go2">Toward Go 2<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”，正式吹响Go向下一个阶段演化的号角，包括重点解决泛型、包依赖以及错误处理等Go社区最广泛关注的问题。</p><p>后来，在2018年8月，也就是GopherCon 2018大会结束后不久，Go核心团队发布了Go2 draft proposal，这里面涵盖了由伊恩·泰勒和罗伯特·格瑞史莫操刀主写的Go泛型的<a target="_blank" rel="noopener noreferrer" href="https://github.com/golang/proposal/blob/00fd2f65291738699cd265243559718f1fb7d8c5/design/go2draft-contracts.md">第一版draft proposal<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>这版设计草案引入了<strong>contract关键字</strong>来定义泛型类型参数（type parameter）的约束、类型参数放在普通函数参数列表前面的<strong>小括号</strong>中，并用type关键字声明。下面是这个草案的语法示例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 第一版泛型技术草案中的典型泛型语法</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    contract stringer(x T) {</span></div><div class="token-line"><span class="token plain">        var s string = x.String()</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func Stringify(type T stringer)(s []T) (ret []string) {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>接着，在2019年7月，伊恩·泰勒在GopherCon 2019大会上发表演讲<a target="_blank" rel="noopener noreferrer" href="https://go.dev/blog/why-generics">“Why Generics?”<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，并更新了<a target="_blank" rel="noopener noreferrer" href="https://github.com/golang/proposal/blob/4a54a00950b56dd0096482d0edae46969d7432a6/design/go2draft-contracts.md">泛型的技术草案<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，简化了contract的语法设计，下面是简化后的contract语法，你可以对比上面代码示例中的contract语法看看：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">contract stringer(T) {</span></div><div class="token-line"><span class="token plain">        T String() string</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>后来，在2020年6月，一篇叫<a target="_blank" rel="noopener noreferrer" href="https://arxiv.org/abs/2005.11710">《Featherweight Go》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>论文发表在arxiv.org上，这篇论文出自著名计算机科学家、函数语言专家、Haskell语言的设计者之一、Java泛型的设计者菲利普-瓦德勒（PHILIP WADLER）之手。</p><p>Rob Pike邀请他Go核心团队解决Go语言的泛型扩展问题，这篇论文就是菲利普-瓦德对这次邀请的回应</p><p>这篇论文为Go语言的一个最小语法子集设计了泛型语法Featherweight Generic Go（FGG），并成功地给出了FGG到Feighterweight Go（FG）的可行性实现的形式化证明。这篇论文的形式化证明给Go团队带来了很大信心，也让Go团队在一些泛型语法问题上达成更广泛的一致。</p><p>2020年6月末，伊恩·泰勒和罗伯特·格瑞史莫在Go官方博客发表了文章<a target="_blank" rel="noopener noreferrer" href="http://go.dev/blog/generics-next-step">《The Next Step for Generics》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，介绍了Go泛型工作的最新进展。Go团队放弃了之前的技术草案，并重新编写了<a target="_blank" rel="noopener noreferrer" href="https://github.com/golang/proposal/blob/d44c4ded9c1a13dcf715ac641ce760170fbbcf64/design/go2draft-type-parameters.md">一个新草案<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>在这份新技术方案中，Go团队放弃了引入contract关键字作为泛型类型参数的约束，而采用扩展后的interface来替代contract。这样上面的Stringify函数就可以写成如下形式：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type Stringer interface {</span></div><div class="token-line"><span class="token plain">        String() string</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func Stringify(type T Stringer)(s []T) (ret []string) {</span></div><div class="token-line"><span class="token plain">        ... ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>同时，Go团队还推出了可以<a target="_blank" rel="noopener noreferrer" href="https://go2goplay.golang.org/">在线试验Go泛型语法的playground<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，这样Gopher们可以直观体验新语法，并给出自己的意见反馈。</p><p>然后，在2020年11月的GopherCon 2020大会，罗伯特·格瑞史莫与全世界的Gopher同步了Go泛型的最新进展和roadmap，在最新的技术草案版本中，包裹类型参数的小括号被方括号取代，类型参数前面的type关键字也不再需要了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func Stringify[T Stringer](s []T) (ret []string) {</span></div><div class="token-line"><span class="token plain">        ... ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>与此同时，go2goplay.golang.org也支持了方括号语法，Gopher们可以在线体验。</p><p>接下来的2021年1月，<a target="_blank" rel="noopener noreferrer" href="https://go.dev/blog/generics-proposal">Go团队正式提出将泛型加入Go的proposal<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，2021年2月，这个提案被正式接受。</p><p>然后是2021年4月，伊恩·泰勒在GitHub上发布<a target="_blank" rel="noopener noreferrer" href="https://github.com/golang/go/issues/45346">issue<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，提议去除原Go泛型方案中置于interface定义中的type list中的type关键字，并引入type set的概念，下面是相关示例代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 之前使用type list的方案</span></div><div class="token-line"><span class="token plain">    type SignedInteger interface {</span></div><div class="token-line"><span class="token plain">    	type int, int8, int16, int32, int64</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // type set理念下的新语法</span></div><div class="token-line"><span class="token plain">    type SignedInteger interface {</span></div><div class="token-line"><span class="token plain">    	~int | ~int8 | ~int16 | ~int32 | ~int64</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>那什么是type set（类型集合）呢？伊恩·泰勒给出了这个概念的定义：</p><ul><li>每个类型都有一个type set。</li><li>非接口类型的类型的type set中仅包含其自身。比如非接口类型T，它的type set中唯一的元素就是它自身：<!-- -->{<!-- -->T<!-- -->}<!-- -->；</li><li>对于一个普通的、没有type list的普通接口类型来说，它的type set是一个无限集合。所有实现了这个接口类型所有方法的类型，都是该集合的一个元素，另外，由于该接口类型本身也声明了其所有方法，因此接口类型自身也是其Type set的一员；</li><li>空接口类型interface<!-- -->{<!-- -->}<!-- -->的type set中囊括了所有可能的类型。</li></ul><p>这样一来，我们可以试试用type set概念，重新表述一下一个类型T实现一个接口类型I：也就是当类型T是接口类型I的type set的一员时，T便实现了接口I；对于使用嵌入接口类型组合而成的接口类型，其type set就是其所有的嵌入的接口类型的type set的交集。</p><p>而对于一个带有自身Method的嵌入其他接口类型的接口类型，比如下面代码中的MyInterface3：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type MyInterface3 interface {</span></div><div class="token-line"><span class="token plain">    	E1</span></div><div class="token-line"><span class="token plain">    	E2</span></div><div class="token-line"><span class="token plain">    	MyMethod03()</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>它的type set可以看成E1、E2和E3（<code>type E3 interface <!-- -->{<!-- --> MyMethod03()<!-- -->}</code>）的type set的交集。</p><p>最后，在2021年12月14日，<a target="_blank" rel="noopener noreferrer" href="https://go.dev/blog/go1.18beta1">Go 1.18 beta1版本发布<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，这个版本包含了对Go泛型的正式支持。</p><p>经过12年的努力与不断地自我否定，Go团队终于将泛型引入到Go中，并且经过缜密设计的语法并<strong>没有违背Go1的兼容性</strong>。那么接下来，我们就正式看看Go泛型的基本语法。</p><h2 id="go泛型的基本语法"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/07.加餐篇/05#go泛型的基本语法"><span class="icon icon-link"></span></a>Go泛型的基本语法</h2><p>我们前面也说了，Go泛型是Go开源以来在语法层面的最大一次变动，<a target="_blank" rel="noopener noreferrer" href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md">Go泛型的最后一版技术提案<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>长达数十页，我们要是把其中的细节都展开细讲，那都可以自成一本小册子了。因此，Go泛型语法不是一篇加餐可以系统学习完的，我这里不会抠太多细节，只给你呈现主要的语法</p><p>Go泛型的核心是类型参数（type parameter），下面我们就从类型参数开始，了解一下Go泛型的基本语法。</p><h3 id="类型参数type-parameter"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/07.加餐篇/05#类型参数type-parameter"><span class="icon icon-link"></span></a>类型参数（type parameter）</h3><p>类型参数是在函数声明、方法声明的receiver部分或类型定义的类型参数列表中，声明的（非限定）类型名称。类型参数在声明中充当了一个未知类型的占位符（placeholder），在泛型函数或泛型类型实例化时，类型参数会被一个类型实参替换。</p><p>为了让你更好地理解类型参数究竟如何声明，它又起到了什么作用，我们以函数为例，对普通函数的参数与泛型函数的类型参数作一下对比：</p><p>我们知道，普通函数的参数列表是这样的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func Foo(x, y aType, z anotherType)</span></div></pre></div><p>这里，x, y, z是形参（parameter）的名字，也就是变量，而aType，anotherType是形参的类型，也就是类型。</p><p>我们再来看一下泛型函数的类型参数（type parameter）列表：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func GenericFoo[P aConstraint, Q anotherConstraint](x,y P, z Q)</span></div></pre></div><p>这里，P，Q是类型形参的名字，也就是类型，aConstraint，anotherConstraint代表类型参数的约束（constraint），我们可以理解为对类型参数可选值的一种限定。</p><p>从GenericFoo函数的声明中，我们可以看到，泛型函数的声明相比于普通函数多出了一个组成部分：类型参数列表。</p><p>类型参数列表位于函数名与函数参数列表之间，通过一个<strong>方括号</strong>括起。类型参数列表不支持变长类型参数。而且，类型参数列表中声明的类型参数，可以作为函数普通参数列表中的形参类型。</p><p>但在泛型函数声明时，我们并不知道P、Q两个类型参数具体代表的究竟是什么类型，因此函数参数列表中的P、Q更像是未知类型的占位符。</p><p>那么P、Q的类型什么时候才能确定呢？这就要等到泛型函数具化（instantiation）时才能确定。另外，按惯例，类型参数（type parameter）的名字都是首字母大写的，通常都是用单个大写字母命名。</p><p>在类型参数列表中修饰类型参数的就是约束（constraint）。那什么是约束呢？我们继续往下看。</p><h3 id="约束constraint"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/07.加餐篇/05#约束constraint"><span class="icon icon-link"></span></a>约束（constraint）</h3><p>约束（constraint）规定了一个类型实参（type argument）必须满足的条件要求。如果某个类型满足了某个约束规定的所有条件要求，那么它就是这个约束修饰的类型形参的一个合法的类型实参。</p><p>在Go泛型中，<strong>我们使用interface类型来定义约束</strong>。为此，Go接口类型的定义也进行了扩展，我们既可以声明接口的方法集合，也可以声明可用作类型实参的类型列表。下面是一个约束定义与使用的示例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type C1 interface {</span></div><div class="token-line"><span class="token plain">        ~int | ~int32</span></div><div class="token-line"><span class="token plain">        M1()</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    type T struct{}</span></div><div class="token-line"><span class="token plain">    func (T) M1() {</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    type T1 int</span></div><div class="token-line"><span class="token plain">    func (T1) M1() {</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func foo[P C1](t P)() {</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">        var t1 T1</span></div><div class="token-line"><span class="token plain">        foo(t1)</span></div><div class="token-line"><span class="token plain">        var t T</span></div><div class="token-line"><span class="token plain">        foo(t) // 编译器报错：T does not implement C1</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这段代码中，C1是我们定义的约束，它声明了一个方法M1，以及两个可用作类型实参的类型(~int | ~int32)。我们看到，类型列表中的多个类型实参类型用“|”分隔。</p><p>在这段代码中，我们还定义了两个自定义类型T和T1，两个类型都实现了M1方法，但T类型的底层类型为struct<!-- -->{<!-- -->}<!-- -->，而T1类型的底层类型为int，这样就导致了虽然T类型满足了约束C1的方法集合，但类型T因为底层类型并不是int或int32而不满足约束C1，这也就会导致<code>foo(t)</code>调用在编译阶段报错。</p><p>不过，我这里还要建议你：<strong>做约束的接口类型与做传统接口的接口类型最好要分开定义</strong>，除非约束类型真的既需要方法集合，也需要类型列表。</p><p>知道了类型参数声明的形式，也知道了约束如何定义后，我们再来看看如何使用带有类型参数的泛型函数。</p><h3 id="类型具化instantiation"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/07.加餐篇/05#类型具化instantiation"><span class="icon icon-link"></span></a>类型具化（instantiation）</h3><p>声明了泛型函数后，接下来就要调用泛型函数来实现具体的业务逻辑。现在我们就通过一个泛型版本Sort函数的调用例子，看看调用泛型函数的过程都发生了什么：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func Sort[Elem interface{ Less(y Elem) bool }](list []Elem) {</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    type book struct{}</span></div><div class="token-line"><span class="token plain">    func (x book) Less(y book) bool {</span></div><div class="token-line"><span class="token plain">            return true</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">        var bookshelf []book</span></div><div class="token-line"><span class="token plain">        Sort[book](bookshelf) // 泛型函数调用</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>根据Go泛型的实现原理，上面的泛型函数调用Sort[book]（<a href="/blog-two/tonybaigo语言第一课/07.加餐篇/bookshelf">book</a>shelf）会分成两个阶段：</p><p>第一个阶段就是具化（instantiation）。</p><p>形象点说，<strong>具化（instantiation）就好比一家生产“排序机器”的工厂根据要排序的对象的类型，将这样的机器生产出来的过程</strong>。我们继续举前面的例子来分析一下，整个具化过程如下：</p><ol><li>工厂接单：<strong>Sort[book]</strong>，发现要排序的对象类型为book；</li><li>模具检查与匹配：检查book类型是否满足模具的约束要求（也就是是否实现了约束定义中的Less方法）。如果满足，就将其作为类型实参替换Sort函数中的类型形参，结果为**Sort[book]****，**如果不满足，编译器就会报错；</li><li>生产机器：将泛型函数Sort具化为一个<strong>新函数</strong>，这里我们把它起名为<strong>booksort</strong>，其函数原型为<strong>func([]book)</strong>。本质上<strong>booksort := Sort[book]</strong>。</li></ol><p>第二阶段是调用（invocation）。</p><p>一旦“排序机器”被生产出来，那么它就可以对目标对象进行排序了，这和普通的函数调用没有区别。这里就相当于调用booksort（bookshelf），整个过程只需要检查传入的函数实参（bookshelf）的类型与booksort函数原型中的形参类型（[]book）是否匹配就可以了。</p><p>我们用伪代码来表述上面两个过程：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Sort[book](bookshelf)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &lt;=&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    具化：booksort := Sort[book]</span></div><div class="token-line"><span class="token plain">    调用：booksort(bookshelf)</span></div></pre></div><p>不过，每次调用Sort都要传入类型实参book，这和普通函数调用相比还是繁琐了不少。那么能否像普通函数那样只传入普通参数实参，不用传入类型参数实参呢？</p><p>答案是可以的。</p><p>Go编译器会根据传入的实参变量，进行实参类型参数的自动推导（Argument type inference），也就是说上面的例子，我们只需要像这样进行Sort的调用就可以了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Sort(bookshelf)</span></div></pre></div><p>有了对类型参数的实参类型的自动推导，大多数泛型函数的调用方式与常规函数调用一致，不会给Gopher带去额外的代码编写负担。</p><h3 id="泛型类型"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/07.加餐篇/05#泛型类型"><span class="icon icon-link"></span></a>泛型类型</h3><p>除了函数可以携带类型参数变身为“泛型函数”外，类型也可以拥有类型参数而化身为“泛型类型”，比如下面代码就定义了一个向量泛型类型：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type Vector[T any] []T</span></div></pre></div><p>这是一个带有类型参数的类型定义，类型参数位于类型名的后面，同样用方括号括起。在类型定义体中可以引用类型参数列表中的参数名（比如T）。类型参数同样拥有自己的约束，如上面代码中的<strong>any</strong>。在Go 1.18中，any是interface<!-- -->{<!-- -->}<!-- -->的别名，也是一个预定义标识符，使用any作为类型参数的约束，代表没有任何约束。</p><p>使用泛型类型，我们也要遵循先具化，再使用的顺序，比如下面例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type Vector[T any] []T</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func (v Vector[T]) Dump() {</span></div><div class="token-line"><span class="token plain">        fmt.Printf(&quot;%#v\n&quot;, v)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">        var iv = Vector[int]{1,2,3,4}</span></div><div class="token-line"><span class="token plain">        var sv Vector[string]</span></div><div class="token-line"><span class="token plain">        sv = []string{&quot;a&quot;,&quot;b&quot;, &quot;c&quot;, &quot;d&quot;}</span></div><div class="token-line"><span class="token plain">        iv.Dump()</span></div><div class="token-line"><span class="token plain">        sv.Dump()</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这段代码中，我们在使用Vector[T]之前都显式用类型实参对泛型类型进行了具化，从而得到具化后的类型Vector[int]和Vector[string]。 Vector[int]的底层类型为[]int，Vector[string]的底层类型为[]string。然后我们再对具化后的类型进行操作。</p><p>以上就是Go泛型语法特性的一些主要语法概念，我们可以看到，泛型的加入确实进一步提高了程序员的开发效率，大幅提升了算法的重用性。</p><p>那么，Go泛型方案对Go程序的运行时性能又带来了哪些影响呢？我们接下来就来通过例子验证一下。</p><h2 id="go泛型的性能"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/07.加餐篇/05#go泛型的性能"><span class="icon icon-link"></span></a>Go泛型的性能</h2><p>我们创建一个性能基准测试的例子，参加这次测试的三位选手分别来自：</p><ul><li>Go标准库sort包（非泛型版）的Ints函数</li><li>Go团队维护golang.org/x/exp/slices中的泛型版Sort函数</li><li>对golang.org/x/exp/slices中的泛型版Sort函数进行改造得到的、仅针对[]int进行排序的Sort函数</li></ul><p>相关的源码较多，我这里就不贴出来了，你可以到<a target="_blank" rel="noopener noreferrer" href="https://github.com/bigwhite/publication/tree/master/column/timegeek/go-first-course/go-generics">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>下载相关源码。</p><p>下面是使用Go 1.18beta2版本在macOS上运行该测试的结果：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$go test -bench .          </span></div><div class="token-line"><span class="token plain">    goos: darwin</span></div><div class="token-line"><span class="token plain">    goarch: amd64</span></div><div class="token-line"><span class="token plain">    pkg: demo</span></div><div class="token-line"><span class="token plain">    cpu: Intel(R) Core(TM) i5-8257U CPU @ 1.40GHz</span></div><div class="token-line"><span class="token plain">    BenchmarkSortInts-8     	      96	  12407700 ns/op	      24 B/op	       1 allocs/op</span></div><div class="token-line"><span class="token plain">    BenchmarkSlicesSort-8   	     172	   6961381 ns/op	       0 B/op	       0 allocs/op</span></div><div class="token-line"><span class="token plain">    BenchmarkIntSort-8      	     172	   6881815 ns/op	       0 B/op	       0 allocs/op</span></div><div class="token-line"><span class="token plain">    PASS</span></div></pre></div><p>我们看到，泛型版和仅支持[]int的Sort函数的性能是一致的，性能都要比目前标准库的Ints函数高出近一倍，并且在排序过程中没有额外的内存分配。由此我们可以得出结论：<strong>至少在这个例子中，泛型在运行时并未给算法带来额外的负担</strong>。</p><p>现在看来，Go泛型没有拖慢程序员的开发效率，也没有拖慢运行效率，那么按照Russ Cox的“泛型窘境”文章中的结论，Go泛型是否拖慢编译性能了呢？</p><p>不过，因为目前采用Go泛型重写的项目比较少，我们还没法举例对比，但<a target="_blank" rel="noopener noreferrer" href="https://tip.golang.org/doc/go1.18">Go 1.18发布说明<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中给出了一个结论：<strong>Go 1.18编译器的性能要比Go 1.17下降15%左右</strong>。不过，Go核心团队也承诺将在Go 1.19中改善编译器的性能，这里也希望到时候的优化能抵消Go泛型带来的影响。</p><p>了解了Go泛型并未影响到运行时性能，这让我们的心里有了底。但关于Go泛型，想必你还会有疑问，那就是：我们应该在什么时候使用泛型，又应该如何使用泛型呢？最后我们就来看看这两个问题的答案。</p><h2 id="go泛型的使用建议"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/07.加餐篇/05#go泛型的使用建议"><span class="icon icon-link"></span></a>Go泛型的使用建议</h2><p>前面说过，Go当初没有及时引入泛型的一个原因就是与Go语言“简单”的设计哲学有悖，现在加入了泛型，随之而来的就是增加了语言的复杂性。</p><p>为了尽量降低复杂性，Go团队做了很多工作，包括前面提到的在语法中加入类型实参的自动推导等语法糖，尽量减少给开发人员编码时带去额外负担，也尽可能保持Go代码良好的可读性。</p><p>此外，Go核心团队最担心的就是“泛型被滥用”，所以Go核心团队在各种演讲场合都在努力地告诉大家Go泛型的适用场景以及应该如何使用。这里我也梳理一下来自Go团队的这些建议，你可以参考一下。</p><h3 id="什么情况适合使用泛型"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/07.加餐篇/05#什么情况适合使用泛型"><span class="icon icon-link"></span></a>什么情况适合使用泛型</h3><p>首先，类型参数的一种有用的情况，就是<strong>当编写的函数的操作元素的类型为slice、map、channel等特定类型的时候</strong>。如果一个函数接受这些类型的形参，并且函数代码没有对参数的元素类型作出任何假设，那么使用类型参数可能会非常有用。在这种场合下，泛型方案可以替代反射方案，获得更高的性能。</p><p>另一个适合使用类型参数的情况是<strong>编写通用数据结构</strong>。所谓的通用数据结构，指的是像切片或map这样，但Go语言又没有提供原生支持的类型。比如一个链表或一个二叉树。</p><p>今天，需要这类数据结构的程序会使用特定的元素类型实现它们，或者是使用接口类型（interface<!-- -->{<!-- -->}<!-- -->）来实现。不过，如果我们使用类型参数替换特定元素类型，可以实现一个更通用的数据结构，这个通用的数据结构可以被其他程序复用。而且，用类型参数替换接口类型通常也会让数据存储的更为高效。</p><p>另外，在一些场合，使用类型参数替代接口类型，意味着代码可以避免进行类型断言（type assertion），并且在编译阶段还可以进行全面的类型静态检查。</p><h3 id="什么情况不宜使用泛型"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/07.加餐篇/05#什么情况不宜使用泛型"><span class="icon icon-link"></span></a>什么情况不宜使用泛型</h3><p>首先，如果你要对某一类型的值进行的全部操作，仅仅是在那个值上调用一个方法，请使用interface类型，而不是类型参数。比如：io.Reader易读且高效，没有必要像下面代码中这样使用一个类型参数像调用Read方法那样去从一个值中读取数据：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func ReadAll[reader io.Reader](r reader) ([]byte, error)  // 错误的作法</span></div><div class="token-line"><span class="token plain">    func ReadAll(r io.Reader) ([]byte, error)                 // 正确的作法</span></div></pre></div><p>使用类型参数的原因是它们让你的代码更清晰，<strong>如果它们会让你的代码变得更复杂，就不要使用</strong>。</p><p>第二，当不同的类型使用一个共同的方法时，如果一个方法的实现对于所有类型都相同，就使用类型参数；相反，如果每种类型的实现各不相同，请使用不同的方法，不要使用类型参数。</p><p>最后，如果你发现自己多次编写完全相同的代码（样板代码），各个版本之间唯一的差别是代码使用不同的类型，那就请你考虑是否可以使用类型参数。反之，在你注意到自己要多次编写完全相同的代码之前，应该避免使用类型参数。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/07.加餐篇/05#小结"><span class="icon icon-link"></span></a>小结</h2><p>好了，今天的加餐讲到这里就结束了。在这一讲中，我带你初步了解了Go泛型的那些事儿，主要是想为你后续系统学习Go泛型引个路。</p><p>正如Go团队在Go FAQ中描述的那样，Go团队从来没有拒绝泛型，只是长时间来没有找到一个合适的实现方案。Go团队需要在Russ Cox的“泛型窘境”中提到的三个slow中寻找平衡。</p><p>十多年来，Go团队一直在尝试与打磨，终于在近几年取得了突破性的进展，设计出一种可以向后兼容Go1的方案，并下决心在Go 1.18版本中落地泛型。</p><p>Go泛型也称为类型参数，我们可以在函数声明、方法声明的receiver部分或类型定义中使用类型参数，来实现泛型函数和泛型类型。我们还需为类型参数设定约束，通过扩展的interface类型定义，我们可以定义这种约束。</p><p>目前来看，Go泛型的引入并没有给程序运行带来额外性能开销，但在一定程度上拖慢的编译器的性能。同时也带来了语法上的复杂性，为此，Go团队建议大家谨慎使用泛型，同时给出了一些使用建议。</p><p>最后要和你特别说明一下，Go 1.18仅仅是Go泛型的起点，就像Go Module构建机制一样，Go泛型的成熟与稳定还需要几个Go发布版本的努力。而且我们这一讲中涉及到泛型的代码都需要你安装Go 1.18beta1或以上版本。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/07.加餐篇/05#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>Go泛型对于你来说估计还比较陌生，这里我也给你留了一个作业，那就是仔细阅读一遍Go泛型的技术方案：<a target="_blank" rel="noopener noreferrer" href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md">https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>如果你在阅读过程中有任何问题，欢迎在留言区提出。我是Tony Bai，我们下节课再见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/tonybaigo语言第一课/07.加餐篇/05.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:34</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
