<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>加餐｜聊聊Go 1.17版本的那些新特性</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/tonybaigo语言第一课/07.加餐篇/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a aria-current="page" class="active" href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a aria-current="page" class="active" href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-two/tonybaigo语言第一课/01.开篇词/01"><span>开篇词｜这样入门Go，才能少走弯路</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/02.前置篇心定之旅">02.前置篇心定之旅</a><ul><li><a href="/blog-two/tonybaigo语言第一课/02.前置篇心定之旅/01"><span>01｜前世今生：你不得不了解的Go的历史和现状</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/02.前置篇心定之旅/02"><span>02｜拒绝“Hello and Bye”：Go语言的设计哲学是怎么一回事？</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手">03.入门篇勤加练手</a><ul><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/01"><span>03｜配好环境：选择一种最适合你的Go安装方法</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/02"><span>04｜初窥门径：一个Go程序的结构是怎样的？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/03"><span>05｜标准先行：Go项目的布局标准是什么？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/04"><span>06｜构建模式：Go是怎么解决包依赖管理问题的？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/05"><span>07｜构建模式：Go Module的6类常规操作</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/06"><span>08｜入口函数与包初始化：搞清Go程序的执行次序</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/07"><span>09｜即学即练：构建一个Web服务就是这么简单</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解">04.基础篇“脑勤”多理解</a><ul><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/01"><span>10｜变量声明：静态语言有别于动态语言的重要特征</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/02"><span>11｜代码块与作用域：如何保证变量不会被遮蔽？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/03"><span>12｜基本数据类型：Go原生支持的数值类型有哪些？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/04"><span>13｜基本数据类型：为什么Go要原生支持字符串类型？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/05"><span>14｜常量：Go在“常量”设计上的创新有哪些？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/06"><span>15｜同构复合类型：从定长数组到变长切片</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/07"><span>16｜复合数据类型：原生map类型的实现机制是怎样的？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/08"><span>17｜复合数据类型：用结构体建立对真实世界的抽象</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/09"><span>18｜控制结构：if的“快乐路径”原则</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/10"><span>19｜控制结构：Go的for循环，仅此一种</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/11"><span>20｜控制结构：Go中的switch语句有哪些变化？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/12"><span>21｜函数：请叫我“一等公民”</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/13"><span>22｜函数：怎么结合多返回值进行错误处理？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/14"><span>期中测试｜一起检验下你的学习成果吧</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/15"><span>23｜函数：怎么让函数更简洁健壮？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/16"><span>24｜方法：理解“方法”的本质</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/17"><span>25｜方法：方法集合与如何选择receiver类型？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/18"><span>26｜方法：如何用类型嵌入模拟实现“继承”？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/19"><span>27｜即学即练：跟踪函数调用链，理解代码更直观</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/20"><span>用户故事｜罗杰：我的Go语言学习之路</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心">05.核心篇“脑勤+”洞彻核心</a><ul><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/01"><span>28｜接口：接口即契约</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02"><span>29｜接口：为什么nil接口不等于nil？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/03"><span>30｜接口：Go中最强大的魔法</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/04"><span>元旦快乐｜这是一份暂时停更的声明</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/05"><span>31｜并发：Go的并发方案实现方案是怎样的？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/06"><span>32｜并发：聊聊Goroutine调度器的原理</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07"><span>33｜并发：小channel中蕴含大智慧</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/08"><span>34｜并发：如何使用共享变量？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/09"><span>35｜即学即练：如何实现一个轻量级线程池？</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”">06.实战篇打通“最后一公里”</a><ul><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01"><span>36｜打稳根基：怎么实现一个TCP服务器？（上）</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/02"><span>37｜代码操练：怎么实现一个TCP服务器？（中）</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/03"><span>38｜成果优化：怎么实现一个TCP服务器？（下）</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/04"><span>结课测试｜快来检验下你的学习成果吧！</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/tonybaigo语言第一课/07.加餐篇">07.加餐篇</a><ul><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/01"><span>加餐｜我“私藏”的那些优质且权威的Go语言学习资料</span></a></li><li><a aria-current="page" class="active" href="/blog-two/tonybaigo语言第一课/07.加餐篇/02"><span>加餐｜聊聊Go 1.17版本的那些新特性</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/03"><span>加餐｜如何拉取私有的Go Module？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/04"><span>加餐｜作为Go Module的作者，你应该知道的几件事</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/05"><span>加餐｜聊聊最近大热的Go泛型</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/06"><span>加餐｜聊聊Go语言的指针</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵">08.大咖助阵</a><ul><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/01"><span>大咖助阵｜孔令飞：从小白到“老鸟”，我的Go语言进阶之路</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/02"><span>大咖助阵｜叶剑峰：Go语言中常用的那些代码优化点</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/03"><span>大咖助阵｜徐祥曦：从销售到分布式存储工程师，我与 Go  的故事</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/04"><span>大咖助阵｜曹春晖：聊聊 Go 语言的 GC 实现</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/05"><span>大咖助阵｜大明：Go泛型，泛了，但没有完全泛</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/06"><span>大咖助阵｜海纳：聊聊语言中的类型系统与泛型</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/09.结束语">09.结束语</a><ul><li><a href="/blog-two/tonybaigo语言第一课/09.结束语/01"><span>结束语｜和你一起迎接Go的黄金十年</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/summary">tonybaigo语言第一课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="新的语法特性" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/02#新的语法特性"><span>新的语法特性</span></a></li><li title="支持将切片转换为数组指针" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/02#支持将切片转换为数组指针"><span>支持将切片转换为数组指针</span></a></li><li title="Go Module构建模式的变化" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/02#go-module构建模式的变化"><span>Go Module构建模式的变化</span></a></li><li title="修剪的module依赖图" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/02#修剪的module依赖图"><span>修剪的module依赖图</span></a></li><li title="Go编译器的变化" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/02#go编译器的变化"><span>Go编译器的变化</span></a></li><li title="基于寄存器的调用惯例" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/02#基于寄存器的调用惯例"><span>基于寄存器的调用惯例</span></a></li><li title="//go:build形式的构建约束指示符" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/02#gobuild形式的构建约束指示符"><span>//go:build形式的构建约束指示符</span></a></li><li title="小结" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/02#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/02#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="加餐聊聊go-117版本的那些新特性"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/07.加餐篇/02#加餐聊聊go-117版本的那些新特性"><span class="icon icon-link"></span></a>加餐｜聊聊Go 1.17版本的那些新特性</h1><p>你好，我是Tony Bai。</p><p>现在是2021年12月，万众期盼的潜力网红版本Go 1.18的开发已经冻结，Go核心开发团队正在紧锣密鼓地修bug。我们已经可以开始期待2022年的2月份，Go 1.18将携带包括泛型语法的大批新特性赶来。不过当下我们不能“舍近求远”，今年8月中旬Go核心团队发布的<a target="_blank" rel="noopener noreferrer" href="https://go.dev/blog/go1.17">Go 1.17版本<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>才是当下最具统治力的Go社区网红，它的影响力依旧处于巅峰。</p><p>根据我们在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/427489">第3讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中提到的Go版本选择策略，我估计很多Go开发者都还没切换到Go 1.17版本，没有亲自体验过Go 1.17新特性带来的变化；还有一些Go开发者虽然已经升级到Go 1.17版本，但也仅限于对Go 1.17版本的基本使用，可能还不是很清楚Go 1.17版本中究竟有哪些新特性，以及这些新特性会带给他们哪些好处。</p><p>所以今天这讲，我们就来聊聊Go 1.17版本中的新特性，目的是让那些没用过Go 1.17版本，或者用过Go 1.17版本但还不知道它新特性变化的Go开发者，对Go 1.17有一个全面的了解。</p><p>Go 1.17版本中的新特性很多，在这里我就不一一列举了，我仅挑几个有代表性的、重要的新特性和你好好聊聊。这里会包括新的语法特性、Go Module机制变化，以及Go编译器与运行时方面的变化。</p><h2 id="新的语法特性"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/07.加餐篇/02#新的语法特性"><span class="icon icon-link"></span></a>新的语法特性</h2><p>在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/426740">第2讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>学习Go语言设计哲学时，我们知道了Go语言的设计者们在语言设计之初，就<strong>拒绝了走语言特性融合的道路</strong>，选择了“做减法”，并致力于打造一门<strong>简单</strong>的编程语言。从诞生到现在，Go语言自身语法特性变化很小，甚至可以用<strong>屈指可数</strong>来形容，因此新语法特性对于Gopher来说属于“稀缺品”。这也直接导致了每次Go新版本发布，我们都要先看看语法特性是否有变更，每个新加入语法特性都值得我们投入更多关注，去深入研究。</p><p>不出所料，Go 1.17版本在语法特性方面仅仅做了一处增强，那就是<strong>支持切片转换为数组指针</strong>。下面我们详细来看一下。</p><h3 id="支持将切片转换为数组指针"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/07.加餐篇/02#支持将切片转换为数组指针"><span class="icon icon-link"></span></a>支持将切片转换为数组指针</h3><p>在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/444348">第15讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中，我们对Go中的切片做了系统全面的讲解。我们知道，通过数组切片化，我们可以将一个数组转换为切片。转换后，数组将成为转换后的切片的底层数组，通过切片，我们可以直接改变数组中的元素，就像下面代码这样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">a := [3]int{11, 12, 13}</span></div><div class="token-line"><span class="token plain">    b := a[:] // 通过切片化将数组a转换为切片b</span></div><div class="token-line"><span class="token plain">    b[1] += 10</span></div><div class="token-line"><span class="token plain">    fmt.Printf(&quot;%v\n&quot;, a) // [11 22 13]</span></div></pre></div><p>但反过来就不行了。在Go 1.17版本之前，Go并不支持将切片再转换回数组类型。当然，如果你非要这么做也不是没有办法，我们可以通过unsafe包以不安全的方式实现这样的转换，如下面代码所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">b := []int{11, 12, 13}</span></div><div class="token-line"><span class="token plain">    var p = (*[3]int)(unsafe.Pointer(&amp;b[0]))</span></div><div class="token-line"><span class="token plain">    p[1] += 10</span></div><div class="token-line"><span class="token plain">    fmt.Printf(&quot;%v\n&quot;, b) // [11 22 13]</span></div></pre></div><p>但是unsafe包，正如其名，它的安全性没有得到编译器和runtime层的保证，只能由开发者自己保证，所以我建议Gopher们在通常情况下不要使用。</p><p>2009年末，也就是Go语言宣布开源后不久，<a target="_blank" rel="noopener noreferrer" href="https://github.com/rogpeppe">Roger Peppe<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>便提出一个<a target="_blank" rel="noopener noreferrer" href="https://github.com/golang/go/issues/395">issue<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，希望Go核心团队考虑在语法层面补充从切片到数组的转换语法，同时希望这种转换以及转换后的数组在使用时的下标边界，能得到编译器和runtime的协助检查。<strong>十二年后</strong>这个issue终于被Go核心团队接受，并在Go 1.17版本加入到Go语法特性当中。</p><p>所以，在Go 1.17版本中，我们可以像下面代码这样将一个切片转换为数组类型指针，不用再借助unsafe包的“黑魔法”了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">b := []int{11, 12, 13}</span></div><div class="token-line"><span class="token plain">    p := (*[3]int)(b) // 将切片转换为数组类型指针</span></div><div class="token-line"><span class="token plain">    p[1] = p[1] + 10</span></div><div class="token-line"><span class="token plain">    fmt.Printf(&quot;%v\n&quot;, b) // [11 22 13]</span></div></pre></div><p>不过，这里你要注意的是，Go会通过运行时而不是编译器去对这类切片到数组指针的转换代码做检查，如果发现越界行为，就会触发运行时panic。Go运行时实施检查的一条原则就是“<strong>转换后的数组长度不能大于原切片的长度</strong>”，注意这里是切片的长度（len），而不是切片的容量（cap）。于是你会看到，下面的转换有些合法，有些非法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var b = []int{11, 12, 13}</span></div><div class="token-line"><span class="token plain">    var p = (*[4]int)(b) // cannot convert slice with length 3 to pointer to array with length 4</span></div><div class="token-line"><span class="token plain">    var p = (*[0]int)(b) // ok，*p = []</span></div><div class="token-line"><span class="token plain">    var p = (*[1]int)(b) // ok，*p = [11]</span></div><div class="token-line"><span class="token plain">    var p = (*[2]int)(b) // ok，*p = [11, 12]</span></div><div class="token-line"><span class="token plain">    var p = (*[3]int)(b) // ok，*p = [11, 12, 13]</span></div><div class="token-line"><span class="token plain">    var p = (*[3]int)(b[:1]) // cannot convert slice with length 1 to pointer to array with length 3</span></div></pre></div><p>另外，nil切片或cap为0的empty切片都可以被转换为一个长度为0的数组指针，比如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var b1 []int // nil切片</span></div><div class="token-line"><span class="token plain">    p1 := (*[0]int)(b1)</span></div><div class="token-line"><span class="token plain">    var b2 = []int{} // empty切片</span></div><div class="token-line"><span class="token plain">    p2 := (*[0]int)(b2)</span></div></pre></div><p>说完了Go语法特性的变化后，我们再来看看Go Module构建模式在Go 1.17中的演进。</p><h2 id="go-module构建模式的变化"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/07.加餐篇/02#go-module构建模式的变化"><span class="icon icon-link"></span></a>Go Module构建模式的变化</h2><p>自从Go 1.11版本引入Go Module构建模式以来，每个Go大版本发布时，Go Module都会有不少的积极变化，Go 1.17版本也不例外。</p><h3 id="修剪的module依赖图"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/07.加餐篇/02#修剪的module依赖图"><span class="icon icon-link"></span></a>修剪的module依赖图</h3><p>Go 1.17版本中，Go Module最重要的一个变化就是<strong>pruned module graph</strong>，即<strong>修剪的module依赖图</strong>。要理解这个概念，我们先来讲什么是<strong>完整module依赖图。</strong></p><p>在Go 1.17之前的版本中，某个module的依赖图是由这个module的直接依赖以及所有间接依赖组成的。这样，无论某个间接依赖是否真正为原module的构建做出贡献，Go命令在解决依赖时都会读取每个依赖的go.mod，包括那些没有被真正使用到的module，这样形成的module依赖图被称为<strong>完整module依赖图（complete module graph）</strong>。</p><p>从Go 1.17的版本开始，Go不再使用“完整module依赖图”，而是引入了pruned module graph，也就是修剪的module依赖图。修剪的module依赖图就是在完整module依赖图的基础上，将那些对构建完全没有“贡献”的间接依赖module修剪掉后，剩余的依赖图。使用修剪后的module依赖图进行构建，有助于避免下载或阅读那些不必要的go.mod文件，这样Go命令可以不去获取那些不相关的依赖关系，从而在日常开发中节省时间。</p><p>这么说还是比较抽象，我们用下图中的例子来详细解释一下module依赖图修剪的原理。</p><p><img src="https://static001.geekbang.org/resource/image/2d/0b/2da4da70a5yy998bf635209642b5c80b.jpg?wh=1980x1080" alt=""/></p><p>上图中的例子来自于Go 1.17源码中的src/cmd/go/testdata/script/mod_lazy_new_import.txt，通过执行<a target="_blank" rel="noopener noreferrer" href="https://golang.org/x/exp/cmd/txtar">txtar工具<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，我们可以将这个txt转换为mod_lazy_new_import.txt中描述的示例结构，转换命令为: <code>txtar \-x &lt; $GOROOT/src/cmd/go/testdata/script/mod_lazy_new_import.txt</code>。</p><p>在这个示例中，main module中的lazy.go导入了module a的package x，后者则导入了module b中的package b。并且，module a还有一个package y，这个包导入了module c的package c。通过go mod graph命令，我们可以得到main module的完整module依赖图，也就是上图的右上角的那张。</p><p>现在问题来了！package y是因为自身是module a的一部分而被main module依赖的，它自己没有为main module的构建做出任何“代码级贡献”，同理，package y所依赖的module c亦是如此。但是在Go 1.17之前的版本中，如果Go编译器找不到module c，那么main module的构建也会失败，这会让开发者们觉得不够合理！</p><p>现在，我们直观地看一下在Go 1.16.5下，这个示例的go.mod是怎样的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">module example.com/lazy</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    go 1.15</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    require example.com/a v0.1.0</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    replace (</span></div><div class="token-line"><span class="token plain">    	example.com/a v0.1.0 =&gt; ./a</span></div><div class="token-line"><span class="token plain">    	example.com/b v0.1.0 =&gt; ./b</span></div><div class="token-line"><span class="token plain">    	example.com/c v0.1.0 =&gt; ./c1</span></div><div class="token-line"><span class="token plain">    	example.com/c v0.2.0 =&gt; ./c2</span></div><div class="token-line"><span class="token plain">    )</span></div></pre></div><p>我们只需要关注require块中的内容就可以了，下面的replace块主要是为了示例能找到各种依赖module而设置的。</p><p>我们知道，在Go 1.16及以前支持Go Module的版本建立的Go Module中，在go.mod经过go mod tidy后，require块中保留的都是main module的直接依赖，<a target="_blank" rel="noopener noreferrer" href="https://go.dev/ref/mod#go-mod-file-require">在某些情况下，也会记录indirect依赖<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，这些依赖会在行尾用indirect指示符明示。但在这里，我们看不到main module的间接依赖以及它们的版本，我们可以用go mod graph来查看module依赖图：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$go mod graph</span></div><div class="token-line"><span class="token plain">    example.com/lazy example.com/a@v0.1.0</span></div><div class="token-line"><span class="token plain">    example.com/a@v0.1.0 example.com/b@v0.1.0</span></div><div class="token-line"><span class="token plain">    example.com/a@v0.1.0 example.com/c@v0.1.0</span></div></pre></div><p>这个go mod graph的输出，和我们在上面图中右上角画的module graph是一致的。此时，如果我们将replace中的第三行（example.com/c v0.1.0 =&gt; ./c1这一行）删除，也就是让Go编译器找不到module <a href="/blog-two/tonybaigo语言第一课/07.加餐篇/mailto:c@v0.1.0">c@v0.1.0</a>，那么我们构建main modue时就会得到下面的错误提示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$go build</span></div><div class="token-line"><span class="token plain">    go: example.com/a@v0.1.0 requires</span></div><div class="token-line"><span class="token plain">    	example.com/c@v0.1.0: missing go.sum entry; to add it:</span></div><div class="token-line"><span class="token plain">    	go mod download example.com/c</span></div></pre></div><p>现在我们将执行权限交给Go 1.17看看会怎样！</p><p>这个时候，我们需要对go.mod做一些修改，也就是将go.mod中的go 1.15改为go 1.17，这样Go 1.17才能起到作用。接下来，我们执行go mod tidy，让Go 1.17重新构建go.mod：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$go mod tidy</span></div><div class="token-line"><span class="token plain">    $cat go.mod</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    module example.com/lazy</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    go 1.17</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    require example.com/a v0.1.0</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    require example.com/b v0.1.0 // indirect</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    replace (</span></div><div class="token-line"><span class="token plain">    	example.com/a v0.1.0 =&gt; ./a</span></div><div class="token-line"><span class="token plain">    	example.com/b v0.1.0 =&gt; ./b</span></div><div class="token-line"><span class="token plain">    	example.com/c v0.1.0 =&gt; ./c1</span></div><div class="token-line"><span class="token plain">    	example.com/c v0.2.0 =&gt; ./c2</span></div><div class="token-line"><span class="token plain">    )</span></div></pre></div><p>我们看到执行go mod tidy之后，go.mod发生了变化：增加了一个require语句块，记录了main module的间接依赖，也就是module <a href="/blog-two/tonybaigo语言第一课/07.加餐篇/mailto:b@v0.10">b@v0.10</a>。</p><p>现在，我们也同样将go.mod replace块中的第三行（example.com/c v0.1.0 =&gt; ./c1这一行）删除，再来用go 1.17构建一次main module。</p><p>这一次我们没有看到Go编译器的错误提示。也就是说在构建过程中，Go编译器看到的main module依赖图中并没有module <a href="/blog-two/tonybaigo语言第一课/07.加餐篇/mailto:c@v0.1.0">c@v0.1.0</a>。这是因为module c并没有为main module的构建提供“代码级贡献”，所以Go命令把它从module依赖图中剪除了。这一次，Go编译器使用的真实的依赖图是上图右下角的那张。这种将那些对构建完全没有“贡献”的间接依赖module从构建时使用的依赖图中修剪掉的过程，就被称为<strong>module依赖图修剪（pruned module graph）</strong>。</p><p>**但module依赖图修剪也带来了一个副作用，那就是go.mod文件size的变大。**因为从Go 1.17版本开始，每次调用go mod tidy，Go命令都会对main module的依赖做一次深度扫描（deepening scan），并将main module的所有直接和间接依赖都记录在go.mod中。考虑到依赖的内容较多，go 1.17会将直接依赖和间接依赖分别放在多个不同的require块中。</p><p>所以，在Go 1.17版本中，go.mod中存储了main module的所有依赖module列表，这似乎也是Go项目第一次有了项目依赖的完整列表。不知道会不会让你想起其他主流语言构架系统中的那个lock文件呢？虽然go.mod并不是lock文件，但有了完整依赖列表，至少我们可以像其他语言的lock文件那样，知晓当前Go项目所有依赖的精确版本了。</p><p>在讲解下一个重要变化之前，我还要提一点小变化，那就是<strong>在Go 1.17版本中，go get已经不再被用来安装某个命令的可执行文件了</strong>。如果你依旧使用go get安装，Go命令会提示错误。这也是很多同学在学习我们课程的入门篇时经常会问的一个问题。</p><p>新版本中，我们需要使用go install来安装，并且使用go install安装时还要用@vx.y.z明确要安装的命令的二进制文件的版本，或者是使用@latest来安装最新版本。</p><p>除了Go语法特性与Go Module有重要变化之外，Go编译器的变化对Go程序的构建与运行影响同样十分巨大，我们接下来就来看一下Go 1.17在这方面的重要变化。</p><h2 id="go编译器的变化"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/07.加餐篇/02#go编译器的变化"><span class="icon icon-link"></span></a>Go编译器的变化</h2><p>在Go1.17版本，Go编译器的变化主要是在AMD64架构下实现了基于寄存器的调用惯例，以及新引入了//go:build形式的构建约束指示符。现在我们就来分析下这两点。</p><h3 id="基于寄存器的调用惯例"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/07.加餐篇/02#基于寄存器的调用惯例"><span class="icon icon-link"></span></a>基于寄存器的调用惯例</h3><p>Go 1.17版本中，Go编译器最大的变化是在AMD64架构下率先实现了<a target="_blank" rel="noopener noreferrer" href="https://github.com/golang/go/issues/40724">从基于堆栈的调用惯例到基于寄存器的调用惯例的切换<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>所谓“调用惯例（calling convention）”，是指调用方和被调用方对于函数调用的一个明确的约定，包括函数参数与返回值的传递方式、传递顺序。只有双方都遵守同样的约定，函数才能被正确地调用和执行。如果不遵守这个约定，函数将无法正确执行。</p><p>Go 1.17版本之前，Go采用基于栈的调用约定，也就是说函数的参数与返回值都通过栈来传递，这种方式的优点是实现简单，不用担心底层CPU架构寄存器的差异，适合跨平台，但缺点就是牺牲了一些性能。</p><p>我们都知道，寄存器的访问速度是要远高于内存的。所以，现在大多数平台上的大多数语言实现都使用基于寄存器的调用约定，通过寄存器而不是内存传递函数参数和返回结果，并指定一些寄存器为调用保存寄存器，允许函数在不同的调用中保持状态。Go核心团队决定在1.17版本向这些语言看齐，并在AMD64架构下率先实现基于寄存器的调用惯例。</p><p>我们可以在Go 1.17的版本发布说明文档中看到，切换到基于寄存器的调用惯例后，一组有代表性的Go包和程序的基准测试显示，Go程序的运行性能提高了约5%，二进制文件大小典型减少约2%。</p><p>那我们这里就来实测一下，看看是否真的能提升那么多。下面是一个使用多种方法进行字符串连接的benchmark测试源码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var sl []string = []string{</span></div><div class="token-line"><span class="token plain">    	&quot;Rob Pike &quot;,</span></div><div class="token-line"><span class="token plain">    	&quot;Robert Griesemer &quot;,</span></div><div class="token-line"><span class="token plain">    	&quot;Ken Thompson &quot;,</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func concatStringByOperator(sl []string) string {</span></div><div class="token-line"><span class="token plain">    	var s string</span></div><div class="token-line"><span class="token plain">    	for _, v := range sl {</span></div><div class="token-line"><span class="token plain">    		s += v</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	return s</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func concatStringBySprintf(sl []string) string {</span></div><div class="token-line"><span class="token plain">    	var s string</span></div><div class="token-line"><span class="token plain">    	for _, v := range sl {</span></div><div class="token-line"><span class="token plain">    		s = fmt.Sprintf(&quot;%s%s&quot;, s, v)</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	return s</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func concatStringByJoin(sl []string) string {</span></div><div class="token-line"><span class="token plain">    	return strings.Join(sl, &quot;&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func concatStringByStringsBuilder(sl []string) string {</span></div><div class="token-line"><span class="token plain">    	var b strings.Builder</span></div><div class="token-line"><span class="token plain">    	for _, v := range sl {</span></div><div class="token-line"><span class="token plain">    		b.WriteString(v)</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	return b.String()</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func concatStringByStringsBuilderWithInitSize(sl []string) string {</span></div><div class="token-line"><span class="token plain">    	var b strings.Builder</span></div><div class="token-line"><span class="token plain">    	b.Grow(64)</span></div><div class="token-line"><span class="token plain">    	for _, v := range sl {</span></div><div class="token-line"><span class="token plain">    		b.WriteString(v)</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	return b.String()</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func concatStringByBytesBuffer(sl []string) string {</span></div><div class="token-line"><span class="token plain">    	var b bytes.Buffer</span></div><div class="token-line"><span class="token plain">    	for _, v := range sl {</span></div><div class="token-line"><span class="token plain">    		b.WriteString(v)</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	return b.String()</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func concatStringByBytesBufferWithInitSize(sl []string) string {</span></div><div class="token-line"><span class="token plain">    	buf := make([]byte, 0, 64)</span></div><div class="token-line"><span class="token plain">    	b := bytes.NewBuffer(buf)</span></div><div class="token-line"><span class="token plain">    	for _, v := range sl {</span></div><div class="token-line"><span class="token plain">    		b.WriteString(v)</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	return b.String()</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func BenchmarkConcatStringByOperator(b *testing.B) {</span></div><div class="token-line"><span class="token plain">    	for n := 0; n &lt; b.N; n++ {</span></div><div class="token-line"><span class="token plain">    		concatStringByOperator(sl)</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func BenchmarkConcatStringBySprintf(b *testing.B) {</span></div><div class="token-line"><span class="token plain">    	for n := 0; n &lt; b.N; n++ {</span></div><div class="token-line"><span class="token plain">    		concatStringBySprintf(sl)</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func BenchmarkConcatStringByJoin(b *testing.B) {</span></div><div class="token-line"><span class="token plain">    	for n := 0; n &lt; b.N; n++ {</span></div><div class="token-line"><span class="token plain">    		concatStringByJoin(sl)</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func BenchmarkConcatStringByStringsBuilder(b *testing.B) {</span></div><div class="token-line"><span class="token plain">    	for n := 0; n &lt; b.N; n++ {</span></div><div class="token-line"><span class="token plain">    		concatStringByStringsBuilder(sl)</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func BenchmarkConcatStringByStringsBuilderWithInitSize(b *testing.B) {</span></div><div class="token-line"><span class="token plain">    	for n := 0; n &lt; b.N; n++ {</span></div><div class="token-line"><span class="token plain">    		concatStringByStringsBuilderWithInitSize(sl)</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func BenchmarkConcatStringByBytesBuffer(b *testing.B) {</span></div><div class="token-line"><span class="token plain">    	for n := 0; n &lt; b.N; n++ {</span></div><div class="token-line"><span class="token plain">    		concatStringByBytesBuffer(sl)</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func BenchmarkConcatStringByBytesBufferWithInitSize(b *testing.B) {</span></div><div class="token-line"><span class="token plain">    	for n := 0; n &lt; b.N; n++ {</span></div><div class="token-line"><span class="token plain">    		concatStringByBytesBufferWithInitSize(sl)</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们使用Go 1.16.5和Go 1.17分别运行这个Benchmark示例，结果如下：</p><p>Go 1.16.5：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$go test -bench .</span></div><div class="token-line"><span class="token plain">    goos: darwin</span></div><div class="token-line"><span class="token plain">    goarch: amd64</span></div><div class="token-line"><span class="token plain">    pkg: github.com/bigwhite/demo</span></div><div class="token-line"><span class="token plain">    cpu: Intel(R) Core(TM) i5-8257U CPU @ 1.40GHz</span></div><div class="token-line"><span class="token plain">    BenchmarkConcatStringByOperator-8                     	12132355	        91.51 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkConcatStringBySprintf-8                      	 2707862	       445.1 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkConcatStringByJoin-8                         	24101215	        50.84 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkConcatStringByStringsBuilder-8               	11104750	       124.4 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkConcatStringByStringsBuilderWithInitSize-8   	24542085	        48.24 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkConcatStringByBytesBuffer-8                  	14425054	        77.73 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkConcatStringByBytesBufferWithInitSize-8      	20863174	        49.07 ns/op</span></div><div class="token-line"><span class="token plain">    PASS</span></div><div class="token-line"><span class="token plain">    ok  	github.com/bigwhite/demo	9.166s</span></div></pre></div><p>Go 1.17：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$go test -bench .</span></div><div class="token-line"><span class="token plain">    goos: darwin</span></div><div class="token-line"><span class="token plain">    goarch: amd64</span></div><div class="token-line"><span class="token plain">    pkg: github.com/bigwhite/demo</span></div><div class="token-line"><span class="token plain">    cpu: Intel(R) Core(TM) i5-8257U CPU @ 1.40GHz</span></div><div class="token-line"><span class="token plain">    BenchmarkConcatStringByOperator-8                     	13058850	        89.47 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkConcatStringBySprintf-8                      	 2889898	       410.1 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkConcatStringByJoin-8                         	25469310	        47.15 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkConcatStringByStringsBuilder-8               	13064298	        92.33 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkConcatStringByStringsBuilderWithInitSize-8   	29780911	        41.14 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkConcatStringByBytesBuffer-8                  	16900072	        70.28 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkConcatStringByBytesBufferWithInitSize-8      	27310650	        43.96 ns/op</span></div><div class="token-line"><span class="token plain">    PASS</span></div><div class="token-line"><span class="token plain">    ok  	github.com/bigwhite/demo	9.198s</span></div></pre></div><p>我们可以看到，相对于Go 1.16.5跑出的结果，Go 1.17在每一个测试项上都有小幅的性能提升，有些性能提升甚至达到10%左右（以BenchmarkConcatStringBySprintf为例，它的性能提升为(445.1-410.1)/445.1=7.8%）。也就是说你的Go源码使用Go 1.17版本重新编译一下，就能获得大约5%的性能提升，这种新版本带来的性能的“自然提升”显然是广大Gopher乐意看到的。</p><p>我们再来看看编译后的Go二进制文件的Size变化。我们以一个自有的1w行左右代码的Go程序为例，分别用Go 1.16.5和Go 1.17进行编译，得到的结果如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">-rwxr-xr-x   1 tonybai  staff  7264432  8 13 18:31 myapp-go1.16.5*</span></div><div class="token-line"><span class="token plain">    -rwxr-xr-x   1 tonybai  staff  6934352  8 13 18:32 myapp-go1.17*</span></div></pre></div><p>我们看到，Go 1.17编译后的二进制文件大小相比Go 1.16.5版本减少了约4%，比Go官方文档发布的平均效果还要好上一些。</p><p>而且，Go 1.17发布说明也提到了：**改为基于寄存器的调用惯例后，绝大多数程序不会受到影响。**只有那些之前就已经违反unsafe.Pointer的使用规则的代码可能会受到影响，比如不遵守unsafe规则通过unsafe.Pointer访问函数参数，或者依赖一些像比较函数代码指针的未公开的行为。</p><h3 id="gobuild形式的构建约束指示符"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/07.加餐篇/02#gobuild形式的构建约束指示符"><span class="icon icon-link"></span></a>//go:build形式的构建约束指示符</h3><p>此外，Go编译器还在Go 1.17中引入了//go:build形式的构建约束指示符，以替代原先易错的// +build形式。</p><p>在Go 1.17之前，我们可以通过在源码文件头部放置// +build构建约束指示符来实现构建约束，但这种形式十分易错，并且它并不支持&amp;&amp;和||这样的直观的逻辑操作符，而是用逗号、空格替代，这里你可以看下原// +build形式构建约束指示符的用法及含义：</p><p><img src="https://static001.geekbang.org/resource/image/22/21/22c37012e48157bdc9a71110bc314421.png?wh=1920x532" alt="图片"/></p><p>但这种与程序员直觉“有悖”的形式让Gopher们十分痛苦，于是Go 1.17回归“<del>正规</del>正轨”，引入了<a target="_blank" rel="noopener noreferrer" href="https://go.googlesource.com/proposal/+/master/design/draft-gobuild.md">//go:build形式的构建约束指示符<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。一方面，这可以与源文件中的其他指示符保持形式一致，比如 //go:nosplit、//go:norace、//go:noinline、//go:generate等。</p><p>另一方面，新形式将支持&amp;&amp;和||逻辑操作符，这样的形式就是自解释的，这样，我们程序员就不需要再像上面那样列出一个表来解释每个指示符组合的含义了。新形式是这样的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//go:build linux &amp;&amp; (386 || amd64 || arm || arm64 || mips64 || mips64le || ppc64 || ppc64le)</span></div><div class="token-line"><span class="token plain">    //go:build linux &amp;&amp; (mips64 || mips64le)</span></div><div class="token-line"><span class="token plain">    //go:build linux &amp;&amp; (ppc64 || ppc64le)</span></div><div class="token-line"><span class="token plain">    //go:build linux &amp;&amp; !386 &amp;&amp; !arm</span></div></pre></div><p>考虑到兼容性，Go命令可以识别这两种形式的构建约束指示符，但推荐Go 1.17之后都用新引入的这种形式。</p><p>另外，gofmt也可以兼容处理两种形式。它的处理原则是：如果一个源码文件只有// +build形式的指示符，gofmt会把和它等价的//go:build行加入。否则，如果一个源文件中同时存在这两种形式的指示符行，那么//+build行的信息就会被//go:build行的信息所覆盖。</p><p>除了gofmt外，go vet工具也会检测源文件中是否同时存在不同形式的、语义不一致的构建指示符，比如针对下面这段代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//go:build linux &amp;&amp; !386 &amp;&amp; !arm</span></div><div class="token-line"><span class="token plain">    // +build linux</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    package main</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import &quot;fmt&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">    	fmt.Println(&quot;hello, world&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>go vet会提示如下问题：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">./buildtag.go:2:1: +build lines do not match //go:build condition</span></div></pre></div><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/07.加餐篇/02#小结"><span class="icon icon-link"></span></a>小结</h2><p>Go 1.17版本的一些重要新特性就介绍到这里了，除了上面这些重要变化之外，Go 1.17还有很多变更与改进，如果你还意犹未尽，建议你去认真读读<a target="_blank" rel="noopener noreferrer" href="https://go.dev/doc/go1.17">Go 1.17的发布说明文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>另外我还要多说一句，Go 1.17版本的这些变更都是在Go1兼容性的承诺范围内的。也就是说，Go 1.17版本秉持了Go语言开源以来各个版本的一贯原则：<strong>向后兼容</strong>，也就是即使你使用Go 1.17版本，也可以成功编译你十年前写下的Go代码。</p><p>读到这里，你是不是有一种要尽快切换到Go 1.17版本的冲动呢！赶快<a target="_blank" rel="noopener noreferrer" href="https://go.dev/dl">去Go官网下载Go 1.17的最新补丁版本<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，开启你的Go1.17体验之旅吧。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/07.加餐篇/02#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>在你阅读完<a target="_blank" rel="noopener noreferrer" href="https://go.dev/doc/go1.17">Go 1.17的发布说明文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>之后，你会发现Go 1.17版本中的变化有很多，除了上面几个重要特性变化外，最让你受益或印象深刻的变化是哪一个呢？欢迎在留言区分享。</p><p>欢迎你把这节课分享给更多对Go 1.17版本感兴趣的朋友。我是Tony Bai，我们下节课见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/tonybaigo语言第一课/07.加餐篇/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:34</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
