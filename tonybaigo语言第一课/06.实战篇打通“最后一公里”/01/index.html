<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>36｜打稳根基：怎么实现一个TCP服务器？（上）</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a aria-current="page" class="active" href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a aria-current="page" class="active" href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-two/tonybaigo语言第一课/01.开篇词/01"><span>开篇词｜这样入门Go，才能少走弯路</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/02.前置篇心定之旅">02.前置篇心定之旅</a><ul><li><a href="/blog-two/tonybaigo语言第一课/02.前置篇心定之旅/01"><span>01｜前世今生：你不得不了解的Go的历史和现状</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/02.前置篇心定之旅/02"><span>02｜拒绝“Hello and Bye”：Go语言的设计哲学是怎么一回事？</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手">03.入门篇勤加练手</a><ul><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/01"><span>03｜配好环境：选择一种最适合你的Go安装方法</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/02"><span>04｜初窥门径：一个Go程序的结构是怎样的？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/03"><span>05｜标准先行：Go项目的布局标准是什么？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/04"><span>06｜构建模式：Go是怎么解决包依赖管理问题的？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/05"><span>07｜构建模式：Go Module的6类常规操作</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/06"><span>08｜入口函数与包初始化：搞清Go程序的执行次序</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/07"><span>09｜即学即练：构建一个Web服务就是这么简单</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解">04.基础篇“脑勤”多理解</a><ul><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/01"><span>10｜变量声明：静态语言有别于动态语言的重要特征</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/02"><span>11｜代码块与作用域：如何保证变量不会被遮蔽？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/03"><span>12｜基本数据类型：Go原生支持的数值类型有哪些？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/04"><span>13｜基本数据类型：为什么Go要原生支持字符串类型？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/05"><span>14｜常量：Go在“常量”设计上的创新有哪些？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/06"><span>15｜同构复合类型：从定长数组到变长切片</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/07"><span>16｜复合数据类型：原生map类型的实现机制是怎样的？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/08"><span>17｜复合数据类型：用结构体建立对真实世界的抽象</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/09"><span>18｜控制结构：if的“快乐路径”原则</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/10"><span>19｜控制结构：Go的for循环，仅此一种</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/11"><span>20｜控制结构：Go中的switch语句有哪些变化？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/12"><span>21｜函数：请叫我“一等公民”</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/13"><span>22｜函数：怎么结合多返回值进行错误处理？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/14"><span>期中测试｜一起检验下你的学习成果吧</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/15"><span>23｜函数：怎么让函数更简洁健壮？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/16"><span>24｜方法：理解“方法”的本质</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/17"><span>25｜方法：方法集合与如何选择receiver类型？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/18"><span>26｜方法：如何用类型嵌入模拟实现“继承”？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/19"><span>27｜即学即练：跟踪函数调用链，理解代码更直观</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/20"><span>用户故事｜罗杰：我的Go语言学习之路</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心">05.核心篇“脑勤+”洞彻核心</a><ul><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/01"><span>28｜接口：接口即契约</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02"><span>29｜接口：为什么nil接口不等于nil？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/03"><span>30｜接口：Go中最强大的魔法</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/04"><span>元旦快乐｜这是一份暂时停更的声明</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/05"><span>31｜并发：Go的并发方案实现方案是怎样的？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/06"><span>32｜并发：聊聊Goroutine调度器的原理</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07"><span>33｜并发：小channel中蕴含大智慧</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/08"><span>34｜并发：如何使用共享变量？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/09"><span>35｜即学即练：如何实现一个轻量级线程池？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”">06.实战篇打通“最后一公里”</a><ul><li><a aria-current="page" class="active" href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01"><span>36｜打稳根基：怎么实现一个TCP服务器？（上）</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/02"><span>37｜代码操练：怎么实现一个TCP服务器？（中）</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/03"><span>38｜成果优化：怎么实现一个TCP服务器？（下）</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/04"><span>结课测试｜快来检验下你的学习成果吧！</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇">07.加餐篇</a><ul><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/01"><span>加餐｜我“私藏”的那些优质且权威的Go语言学习资料</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/02"><span>加餐｜聊聊Go 1.17版本的那些新特性</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/03"><span>加餐｜如何拉取私有的Go Module？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/04"><span>加餐｜作为Go Module的作者，你应该知道的几件事</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/05"><span>加餐｜聊聊最近大热的Go泛型</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/06"><span>加餐｜聊聊Go语言的指针</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵">08.大咖助阵</a><ul><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/01"><span>大咖助阵｜孔令飞：从小白到“老鸟”，我的Go语言进阶之路</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/02"><span>大咖助阵｜叶剑峰：Go语言中常用的那些代码优化点</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/03"><span>大咖助阵｜徐祥曦：从销售到分布式存储工程师，我与 Go  的故事</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/04"><span>大咖助阵｜曹春晖：聊聊 Go 语言的 GC 实现</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/05"><span>大咖助阵｜大明：Go泛型，泛了，但没有完全泛</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/06"><span>大咖助阵｜海纳：聊聊语言中的类型系统与泛型</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/09.结束语">09.结束语</a><ul><li><a href="/blog-two/tonybaigo语言第一课/09.结束语/01"><span>结束语｜和你一起迎接Go的黄金十年</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/summary">tonybaigo语言第一课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="什么是网络编程" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01#什么是网络编程"><span>什么是网络编程</span></a></li><li title="问题描述" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01#问题描述"><span>问题描述</span></a></li><li title="TCP Socket编程模型" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01#tcp-socket编程模型"><span>TCP Socket编程模型</span></a></li><li title="Go语言socket编程模型" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01#go语言socket编程模型"><span>Go语言socket编程模型</span></a></li><li title="socket监听（listen）与接收连接（accept）" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01#socket监听listen与接收连接accept"><span>socket监听（listen）与接收连接（accept）</span></a></li><li title="向服务端建立TCP连接" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01#向服务端建立tcp连接"><span>向服务端建立TCP连接</span></a></li><li title="全双工通信" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01#全双工通信"><span>全双工通信</span></a></li><li title="Socket读操作" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01#socket读操作"><span>Socket读操作</span></a></li><li title="Socket写操作" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01#socket写操作"><span>Socket写操作</span></a></li><li title="并发Socket读写" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01#并发socket读写"><span>并发Socket读写</span></a></li><li title="Socket关闭" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01#socket关闭"><span>Socket关闭</span></a></li><li title="小结" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="36打稳根基怎么实现一个tcp服务器上"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01#36打稳根基怎么实现一个tcp服务器上"><span class="icon icon-link"></span></a>36｜打稳根基：怎么实现一个TCP服务器？（上）</h1><p>你好，我是Tony Bai。欢迎来到这门课的最后一个部分：实战篇。</p><p>在进入正文之前，我先来说点题外话。去年我读过一本名为<a target="_blank" rel="noopener noreferrer" href="https://book.douban.com/subject/26935989/">《陪孩子走过初中三年》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的书，书中作者女儿的初中班主任有一句“名言”：“跟上了！”作者对这句名言的解读是：学习上，她强调孩子们学习的时候不要掉队，意思是一要跟上老师的步子，上课认真听讲，课后老师留的作业要不打折扣地去完成；二也要跟上年级和班级的进度。只要能紧紧地跟上，学习就不会有太大的问题。</p><p>在前面课程的留言区，我也经常用“<strong>跟上了</strong>”作为学习这门课的建议，和我一起同步走到这里的同学，都是践行“跟上了”这句“名言”的典范，从开篇词到现在，你是不是已经感受到了自己在Go语言方面的进步了呢？</p><p>好了，我们言归正传。关于最后一篇写啥，我也想了许久。开篇词中提过，实战篇的职责是带着你走完Go语言学习的“最后一公里”，那究竟什么是“最后一公里呢？该如何理解这最后一公里呢？</p><p>我的理解是，在掌握了前面的Go语言语法的前提下，这“最后一公里”就是<strong>面对一个实际问题的解决思路</strong>。很多语言初学者都有这样一个问题，即便学完了语法，面对一个实际问题时，还是也不知道该从何处着手。</p><p>其实这个事并没有那么难，尤其是程序员这一行，遇到一个实际问题，我们通常使用这个思路：</p><p><img src="https://static001.geekbang.org/resource/image/2e/94/2e9979276111eac4e55689dfb4de0a94.jpg?wh=1126x586" alt="图片"/></p><p>我们简单解释一下这张图。</p><p>首先是要理解问题。解决实际问题的过程起始于对问题的理解。我们要搞清楚为什么会有这个问题，问题究竟是什么。对于技术人员来说，最终目的是识别出可能要用到的技术点。</p><p>然后我们要对识别出的技术点，做相应的技术预研与储备。怎么做技术预研呢？我们至少要了解技术诞生的背景、技术的原理、技术能解决哪些问题以及不能解决哪些问题，还有技术的优点与不足，等等。当然，如果没有新技术点，可以忽略这一步。</p><p>最后，我们要基于技术预研和储备的结果，进行解决方案的设计与实现，这个是技术人最擅长的。</p><p>那为什么这个解决实际问题的步骤是一个循环呢？这是由问题的难易程度，以及人的认知能力有差别所决定的。如果问题简单或人的认知能力很强，我们可以一次性解决这个实际问题；如果问题复杂或人的认知能力稍弱，那么一个循环可能无法彻底解决这个问题，我们就会再一次进入该循环，直到问题得到完美解决。</p><p>你也看到了，这事儿说起来有些枯燥，那我们就来实践一下。在实战篇的这三讲中，我们就来“走一遍”这个过程。</p><p>那我们选一个什么例子呢？我们还是从<a target="_blank" rel="noopener noreferrer" href="https://go.dev/blog/survey2020-results">Go官方用户2020调查报告<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中寻找答案，看看“我用Go在哪些领域开展工作”的调查结果：</p><p><img src="https://static001.geekbang.org/resource/image/1d/a4/1dd60015a47425a050142859c14c61a4.png?wh=1048x1242" alt="图片"/></p><p>我们看到，“<strong>Web编程</strong>”和“<strong>网络编程</strong>”分别位列第一名和第四名，我们在09讲的小实战项目中曾接触过简单的Web编程，因此这里，我们选择一个不同于Web编程的网络编程的例子，做为实战篇的实战项目。在实战篇的三讲中，我们就参照这个实际问题解决过程循环，逐步来解决一个网络编程类的实际问题。</p><h3 id="什么是网络编程"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01#什么是网络编程"><span class="icon icon-link"></span></a>什么是网络编程</h3><p>什么是网络编程呢？网络编程的范围很大，因为我们熟知的网络是分层的，OSI规定了七层参考模型，而实际上我们使用的主流网络模型实现，是TCP/IP模型，它只有四层：</p><p><img src="https://static001.geekbang.org/resource/image/13/26/1339ef73cbd62791byy28821fd5ed926.jpg?wh=1920x1047" alt="图片"/></p><p>通常来说，我们更多关注OSI网络模型中的传输层（四层）与应用层（七层），也就是TCP/IP网络模型中的最上面两层。</p><p>TCP/IP网络模型，实现了两种传输层协议：TCP和UDP。TCP是面向连接的流协议，为通信的两端提供稳定可靠的数据传输服务；而UDP则提供了一种无需建立连接就可以发送数据包的方法。两种协议各有擅长的应用场景。</p><p>我们日常开发中使用最多的是TCP协议。基于TCP协议，我们实现了各种各样的满足用户需求的应用层协议。比如，我们常用的HTTP协议就是应用层协议的一种，而且是使用得最广泛的一种。而基于HTTP的Web编程就是一种针对应用层的网络编程。我们还可以<strong>基于传输层暴露给开发者的编程接口，实现应用层的自定义应用协议</strong>。</p><p>这个传输层暴露给开发者的编程接口，究竟是什么呢？目前各大主流操作系统平台中，最常用的传输层暴露给用户的网络编程接口，就是套接字（socket）。<strong>直接基于socket编程实现应用层通信业务，也是最常见的一种网络编程形式</strong>。</p><p>所以，这一节课，我们就使用一个基于socket网络编程的例子，我们先来看看这个例子对应的实际问题是什么。</p><h2 id="问题描述"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01#问题描述"><span class="icon icon-link"></span></a>问题描述</h2><p>我们面临的实际问题是这样的：<strong>实现一个基于TCP的自定义应用层协议的通信服务端</strong>。仅仅这一句话，你可能还不是很清楚，我们展开说明一下。</p><p>我们的输入，是一个基于传输层自定义的应用层协议规范。由于TCP是面向连接的流协议传输机制，数据流本身没有明显的边界，这样定义协议时，就需要自行定义确定边界的方法，因此，基于TCP的自定义应用层协议通常有两种常见的定义模式：</p><ul><li><p>**二进制模式：**采用长度字段标识独立数据包的边界。采用这种方式定义的常见协议包括MQTT（物联网最常用的应用层协议之一）、SMPP（短信网关点对点接口协议）等；</p></li><li><p><strong>文本模式</strong>：采用特定分隔符标识流中的数据包的边界，常见的包括HTTP协议等。</p></li></ul><p>相比之下，二进制模式要比文本模式编码更紧凑也更高效，所以我们这个问题中的自定义协议也采用了<strong>二进制模式</strong>，协议规范内容如下图：</p><p><img src="https://static001.geekbang.org/resource/image/70/21/70b43197100a790f3a78db50997c1d21.jpg?wh=1980x1080" alt=""/></p><p>关于协议内容的分析，我们放到设计与实现的那一讲中再细说，这里我们再看一下使用这个协议的通信两端的通信流程：</p><p><img src="https://static001.geekbang.org/resource/image/bb/1e/bbf6078436ff91207cf6232ce7a66b1e.jpg?wh=1920x1047" alt="图片"/></p><p>我们看到，这是一个典型的“请求/响应”通信模型。连接由客户端发起，建立连接后，客户端发起请求，服务端收到请求后处理并返回响应，就这样一个请求一个响应的进行下去，直到客户端主动断开连接为止。</p><p><strong>而我们的任务，就是实现支持这个协议通信的服务端。</strong></p><p>我们先假设各位小伙伴都没有亲自开发过类似的通信服务器，所以当理解完这个问题后，我们需要识别出解决这一问题可能使用到的技术点。不过这个问题并不复杂，我们可以很容易地识别出其中的技术点。</p><p>首先，前面说过socket是传输层给用户提供的编程接口，我们要进行的网络通信绕不开socket，因此我们首先需要了解socket编程模型。</p><p>其次，一旦通过socket将双方的连接建立后，剩下的就是通过网络I/O操作在两端收发数据了，学习基本网络I/O操作的方法与注意事项也必不可少。</p><p>最后，任何一端准备发送数据或收到数据后都要对数据进行操作，由于TCP是流协议，我们需要了解针对字节的操作。</p><p>按照问题解决循环，一旦识别出技术点，接下来我们要做的就是技术预研与储备。在Go中，字节操作基本上就是byte切片的操作，这些用法我们在第15讲中已经学过了。所以，这一讲，我们就来学习一下<strong>socket编程模型以及网络I/O操作</strong>，为后两讲的设计与实现打稳根基，做好铺垫。</p><h2 id="tcp-socket编程模型"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01#tcp-socket编程模型"><span class="icon icon-link"></span></a>TCP Socket编程模型</h2><p>TCP Socket诞生以来，它的编程模型，也就是网络I/O模型已几经演化。网络I/O模型定义的是应用线程与操作系统内核之间的交互行为模式。我们通常用<strong>阻塞（Blocking）</strong>/**非阻塞（Non-Blocking）**来描述网络I/O模型。</p><p>阻塞/非阻塞，是以内核是否等数据全部就绪后，才返回（给发起系统调用的应用线程）来区分的。如果内核一直等到全部数据就绪才返回，这种行为模式就称为<strong>阻塞</strong>。如果内核查看数据就绪状态后，即便没有就绪也立即返回错误（给发起系统调用的应用线程），那么这种行为模式则称为<strong>非阻塞</strong>。</p><p>常用的网络I/O模型包括下面这几种：</p><ul><li><strong>阻塞I/O(Blocking I/O)</strong></li></ul><p>阻塞I/O是最常用的模型，这个模型下应用线程与内核之间的交互行为模式是这样的：</p><p><img src="https://static001.geekbang.org/resource/image/66/70/66e154f76d647a51b45fcfddf4697c70.jpg?wh=1920x1047" alt="图片"/></p><p>我们看到，在<strong>阻塞I/O模型</strong>下，当用户空间应用线程，向操作系统内核发起I/O请求后（一般为操作系统提供的I/O系列系统调用），内核会尝试执行这个I/O操作，并等所有数据就绪后，将数据从内核空间拷贝到用户空间，最后系统调用从内核空间返回。而在这个期间内，用户空间应用线程将阻塞在这个I/O系统调用上，无法进行后续处理，只能等待。</p><p>因此，在这样的模型下，一个线程仅能处理一个网络连接上的数据通信。即便连接上没有数据，线程也只能阻塞在对Socket的读操作上（以等待对端的数据）。虽然这个模型对应用整体来说是低效的，但对开发人员来说，这个模型却是最容易实现和使用的，所以，各大平台在默认情况下都将Socket设置为阻塞的。</p><ul><li><strong>非阻塞I/O（Non-Blocking I/O）</strong></li></ul><p>非阻塞I/O模型下，应用线程与内核之间的交互行为模式是这样的：</p><p><img src="https://static001.geekbang.org/resource/image/4c/b3/4c5e3980f756e03b9ca023185b91b5b3.jpg?wh=1920x1047" alt="图片"/></p><p>和阻塞I/O模型正相反，在<strong>非阻塞模型</strong>下，当用户空间线程向操作系统内核发起I/O请求后，内核会执行这个I/O操作，如果这个时候数据尚未就绪，就会立即将“未就绪”的状态以错误码形式（比如：EAGAIN/EWOULDBLOCK），返回给这次I/O系统调用的发起者。而后者就会根据系统调用的返回状态来决定下一步该怎么做。</p><p>在非阻塞模型下，位于用户空间的I/O请求发起者通常会通过轮询的方式，去一次次发起I/O请求，直到读到所需的数据为止。不过，这样的轮询是对CPU计算资源的极大浪费，因此，非阻塞I/O模型单独应用于实际生产的比例并不高。</p><ul><li><strong>I/O多路复用（I/O Multiplexing）</strong></li></ul><p>为了避免非阻塞I/O模型轮询对计算资源的浪费，同时也考虑到阻塞I/O模型的低效，开发人员首选的网络I/O模型，逐渐变成了建立在内核提供的多路复用函数select/poll等（以及性能更好的epoll等函数）基础上的<strong>I/O多路复用模型</strong>。</p><p>这个模型下，应用线程与内核之间的交互行为模式如下图：</p><p><img src="https://static001.geekbang.org/resource/image/93/b9/9389908c507b5efea24bf961b1d594b9.jpg?wh=1920x1047" alt="图片"/></p><p>从图中我们看到，在这种模型下，应用线程首先将需要进行I/O操作的Socket，都添加到多路复用函数中（这里以select为例），然后阻塞，等待select系统调用返回。当内核发现有数据到达时，对应的Socket具备了通信条件，这时select函数返回。然后用户线程会针对这个Socket再次发起网络I/O请求，比如一个read操作。由于数据已就绪，这次网络I/O操作将得到预期的操作结果。</p><p>我们看到，相比于阻塞模型一个线程只能处理一个Socket的低效，I/O多路复用模型中，一个应用线程可以同时处理多个Socket。同时，I/O多路复用模型由内核实现可读/可写事件的通知，避免了非阻塞模型中轮询，带来的CPU计算资源浪费的问题。</p><p>目前，主流网络服务器采用的都是“I/O多路复用”模型，有的也结合了多线程。不过，<strong>I/O多路复用</strong>模型在支持更多连接、提升I/O操作效率的同时，也给使用者带来了不小的复杂度，以至于后面出现了许多高性能的I/O多路复用框架，比如：<a target="_blank" rel="noopener noreferrer" href="http://libevent.org/">libevent<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a target="_blank" rel="noopener noreferrer" href="http://software.schmorp.de/pkg/libev.html">libev<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a target="_blank" rel="noopener noreferrer" href="https://github.com/libuv/libuv">libuv<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>等，以帮助开发者简化开发复杂性，降低心智负担。</p><p>那么，在这三种socket编程模型中，Go语言使用的是哪一种呢？我们继续往下看。</p><h2 id="go语言socket编程模型"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01#go语言socket编程模型"><span class="icon icon-link"></span></a>Go语言socket编程模型</h2><p>Go语言设计者考虑得更多的是Gopher的开发体验。前面我们也说过，阻塞I/O模型是对开发人员最友好的，也是心智负担最低的模型，而<strong>I/O多路复用</strong>的这种<strong>通过回调割裂执行流</strong>的模型，对开发人员来说还是过于复杂了，于是Go选择了为开发人员提供<strong>阻塞I/O模型</strong>，Gopher只需在Goroutine中以最简单、最易用的**“阻塞I/O模型”**的方式，进行Socket操作就可以了。</p><p>再加上，Go没有使用基于线程的并发模型，而是使用了开销更小的Goroutine作为基本执行单元，这让每个Goroutine处理一个TCP连接成为可能，并且在高并发下依旧表现出色。</p><p>不过，网络I/O操作都是系统调用，Goroutine执行I/O操作的话，一旦阻塞在系统调用上，就会导致M也被阻塞，为了解决这个问题，Go设计者将这个“复杂性”隐藏在Go运行时中，他们在运行时中实现了网络轮询器（netpoller)，netpoller的作用，就是只阻塞执行网络I/O操作的Goroutine，但不阻塞执行Goroutine的线程（也就是M）。</p><p>这样一来，对于Go程序的用户层（相对于Go运行时层）来说，它眼中看到的goroutine采用了“阻塞I/O模型”进行网络I/O操作，Socket都是“阻塞”的。</p><p>但实际上，这样的“假象”，是通过Go运行时中的netpoller <strong>I/O多路复用机制</strong>，“模拟”出来的，对应的、真实的底层操作系统Socket，实际上是非阻塞的。只是运行时拦截了针对底层Socket的系统调用返回的错误码，并通过<strong>netpoller</strong>和Goroutine调度，让Goroutine“阻塞”在用户层所看到的Socket描述符上。</p><p>比如：当用户层针对某个Socket描述符发起<code>read</code>操作时，如果这个Socket对应的连接上还没有数据，运行时就会将这个Socket描述符加入到netpoller中监听，同时发起此次读操作的Goroutine会被挂起。</p><p>直到Go运行时收到这个Socket数据可读的通知，Go运行时才会重新唤醒等待在这个Socket上准备读数据的那个Goroutine。而这个过程，从Goroutine的视角来看，就像是read操作一直阻塞在那个Socket描述符上一样。</p><p>而且，Go语言在网络轮询器（netpoller）中采用了I/O多路复用的模型。考虑到最常见的多路复用系统调用select有比较多的限制，比如：监听Socket的数量有上限（1024）、时间复杂度高，等等，Go运行时选择了在不同操作系统上，使用操作系统各自实现的高性能多路复用函数，比如：Linux上的epoll、Windows上的iocp、FreeBSD/MacOS上的kqueue、Solaris上的event port等，这样可以最大程度提高netpoller的调度和执行性能。</p><p>了解完Go socket编程模型后，接下来，我们就深入到几个常用的基于socket的网络I/O操作中，逐一了解一下这些操作的机制与注意事项。</p><h2 id="socket监听listen与接收连接accept"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01#socket监听listen与接收连接accept"><span class="icon icon-link"></span></a>socket监听（listen）与接收连接（accept）</h2><p>socket编程的核心在于服务端，而服务端有着自己一套相对固定的套路：Listen+Accept。在这套固定套路的基础上，我们的服务端程序通常采用一个Goroutine处理一个连接，它的大致结构如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func handleConn(c net.Conn) {</span></div><div class="token-line"><span class="token plain">         defer c.Close()</span></div><div class="token-line"><span class="token plain">         for {</span></div><div class="token-line"><span class="token plain">             // read from the connection</span></div><div class="token-line"><span class="token plain">             // ... ...</span></div><div class="token-line"><span class="token plain">             // write to the connection</span></div><div class="token-line"><span class="token plain">             //... ...</span></div><div class="token-line"><span class="token plain">         }</span></div><div class="token-line"><span class="token plain">     }</span></div><div class="token-line"><span class="token plain">     </span></div><div class="token-line"><span class="token plain">     func main() {</span></div><div class="token-line"><span class="token plain">         l, err := net.Listen(&quot;tcp&quot;, &quot;:8888&quot;)</span></div><div class="token-line"><span class="token plain">         if err != nil {</span></div><div class="token-line"><span class="token plain">             fmt.Println(&quot;listen error:&quot;, err)</span></div><div class="token-line"><span class="token plain">             return</span></div><div class="token-line"><span class="token plain">         }</span></div><div class="token-line"><span class="token plain">     </span></div><div class="token-line"><span class="token plain">         for {</span></div><div class="token-line"><span class="token plain">             c, err := l.Accept()</span></div><div class="token-line"><span class="token plain">             if err != nil {</span></div><div class="token-line"><span class="token plain">                 fmt.Println(&quot;accept error:&quot;, err)</span></div><div class="token-line"><span class="token plain">                 break</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">             // start a new goroutine to handle</span></div><div class="token-line"><span class="token plain">             // the new connection.</span></div><div class="token-line"><span class="token plain">             go handleConn(c)</span></div><div class="token-line"><span class="token plain">         }</span></div><div class="token-line"><span class="token plain">     }</span></div></pre></div><p>在这个服务端程序中，我们在第12行使用了net包的Listen函数绑定（bind）服务器端口8888，并将它转换为监听状态，Listen返回成功后，这个服务会进入一个循环，并调用net.Listener的Accept方法接收新客户端连接。</p><p>在没有新连接的时候，这个服务会阻塞在Accept调用上，直到有客户端连接上来，Accept方法将返回一个net.Conn实例。通过这个net.Conn，我们可以和新连上的客户端进行通信。这个服务程序启动了一个新Goroutine，并将net.Conn传给这个Goroutine，这样这个Goroutine就专职负责处理与这个客户端的通信了。</p><p>而net.Listen函数很少报错，除非是监听的端口已经被占用，那样程序将输出类似这样的错误：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">bind: address already in use</span></div></pre></div><p>当服务程序启动成功后，我们可以通过netstat命令，查看端口的监听情况：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$netstat -an|grep 8888    </span></div><div class="token-line"><span class="token plain">    tcp46       0      0  *.8888                 *.*                    LISTEN</span></div></pre></div><p>了解了服务端的“套路”后，我们再来看看客户端。</p><h2 id="向服务端建立tcp连接"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01#向服务端建立tcp连接"><span class="icon icon-link"></span></a>向服务端建立TCP连接</h2><p>一旦服务端按照上面的<code>Listen + Accept</code>结构成功启动，客户端便可以使用<code>net.Dial</code>或<code>net.DialTimeout</code>向服务端发起连接建立的请求：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">conn, err := net.Dial(&quot;tcp&quot;, &quot;localhost:8888&quot;)</span></div><div class="token-line"><span class="token plain">    conn, err := net.DialTimeout(&quot;tcp&quot;, &quot;localhost:8888&quot;, 2 * time.Second)</span></div></pre></div><p>Dial函数向服务端发起TCP连接，这个函数会一直阻塞，直到连接成功或失败后，才会返回。而DialTimeout带有超时机制，如果连接耗时大于超时时间，这个函数会返回超时错误。 对于客户端来说，连接的建立还可能会遇到几种特殊情形。</p><p><strong>第一种情况：网络不可达或对方服务未启动。</strong></p><p>如果传给<code>Dial</code>的服务端地址是网络不可达的，或者服务地址中端口对应的服务并没有启动，端口未被监听（Listen），<code>Dial</code>几乎会立即返回类似这样的错误：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">dial error: dial tcp :8888: getsockopt: connection refused</span></div></pre></div><p><strong>第二种情况：对方服务的listen backlog队列满。</strong></p><p>当对方服务器很忙，瞬间有大量客户端尝试向服务端建立连接时，服务端可能会出现listen backlog队列满，接收连接（accept）不及时的情况，这就会导致客户端的<code>Dial</code>调用阻塞，直到服务端进行一次accept，从backlog队列中腾出一个槽位，客户端的Dial才会返回成功。</p><p>而且，不同操作系统下backlog队列的长度是不同的，在macOS下，这个默认值如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$sysctl -a|grep kern.ipc.somaxconn</span></div><div class="token-line"><span class="token plain">    kern.ipc.somaxconn: 128</span></div></pre></div><p>在Ubuntu Linux下，backlog队列的长度值与系统中<code>net.ipv4.tcp_max_syn_backlog</code>的设置有关。</p><p>那么，极端情况下，如果服务端一直不执行<code>accept</code>操作，那么客户端会一直阻塞吗？</p><p>答案是不会！我们看一个实测结果。如果服务端运行在macOS下，那么客户端会阻塞大约1分多钟，才会返回超时错误：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">dial error: dial tcp :8888: getsockopt: operation timed out</span></div></pre></div><p>而如果服务端运行在Ubuntu上，客户端的<code>Dial</code>调用大约在2分多钟后提示超时错误，这个结果也和Linux的系统设置有关。</p><p><strong>第三种情况：若网络延迟较大，Dial将阻塞并超时。</strong></p><p>如果网络延迟较大，TCP连接的建立过程（三次握手）将更加艰难坎坷，会经历各种丢包，时间消耗自然也会更长，这种情况下，<code>Dial</code>函数会阻塞。如果经过长时间阻塞后依旧无法建立连接，那么<code>Dial</code>也会返回类似<code>getsockopt: operation timed out</code>的错误。</p><p>在连接建立阶段，多数情况下<code>Dial</code>是可以满足需求的，即便是阻塞一小会儿也没事。但对于那些需要有严格的连接时间限定的Go应用，如果一定时间内没能成功建立连接，程序可能会需要执行一段“错误”处理逻辑，所以，这种情况下，我们使用<code>DialTimeout</code>函数更适合。</p><h2 id="全双工通信"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01#全双工通信"><span class="icon icon-link"></span></a>全双工通信</h2><p>一旦客户端调用Dial成功，我们就在客户端与服务端之间建立起了一条全双工的通信通道。通信双方通过各自获得的Socket，可以在向对方发送数据包的同时，接收来自对方的数据包。下图展示了系统层面对这条全双工通信通道的实现原理：</p><p><img src="https://static001.geekbang.org/resource/image/37/b0/370808418c01bf37967cdb505848e3b0.jpg?wh=1920x616" alt="图片"/></p><p>任何一方的操作系统，都会为已建立的连接分配一个发送缓冲区和一个接收缓冲区。</p><p>以客户端为例，客户端会通过成功连接服务端后得到的conn（封装了底层的socket）向服务端发送数据包。这些数据包会先进入到己方的发送缓冲区中，之后，这些数据会被操作系统内核通过网络设备和链路，发到服务端的接收缓冲区中，服务端程序再通过代表客户端连接的conn读取服务端接收缓冲区中的数据，并处理。</p><p>反之，服务端发向客户端的数据包也是先后经过服务端的发送缓冲区、客户端的接收缓冲区，最终到达客户端的应用的。</p><p>理解了这个通信原理，我们再理解下面的Socket操作就容易许多了。</p><h2 id="socket读操作"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01#socket读操作"><span class="icon icon-link"></span></a>Socket读操作</h2><p>连接建立起来后，我们就要在连接上进行读写以完成业务逻辑。我们前面说过，Go运行时隐藏了<strong>I/O多路复用</strong>的复杂性。Go语言使用者只需采用<strong>Goroutine+阻塞I/O模型</strong>，就可以满足大部分场景需求。Dial连接成功后，会返回一个net.Conn接口类型的变量值，这个接口变量的底层类型为一个*TCPConn：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//$GOROOT/src/net/tcpsock.go</span></div><div class="token-line"><span class="token plain">    type TCPConn struct {</span></div><div class="token-line"><span class="token plain">        conn</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>TCPConn内嵌了一个非导出类型：<code>conn</code>（封装了底层的socket），因此，TCPConn“继承”了<code>conn</code>类型的<code>Read</code>和<code>Write</code>方法，后续通过<code>Dial</code>函数返回值调用的<code>Read</code>和<code>Write</code>方法都是net.conn的方法，它们分别代表了对socket的读和写。</p><p>接下来，我们先来通过几个场景来总结一下Go中从socket读取数据的行为特点。</p><p><strong>首先是Socket中无数据的场景。</strong></p><p>连接建立后，如果客户端未发送数据，服务端会阻塞在Socket的读操作上，这和前面提到的“阻塞I/O模型”的行为模式是一致的。执行该这个操作的Goroutine也会被挂起。Go运行时会监视这个Socket，直到它有数据读事件，才会重新调度这个Socket对应的Goroutine完成读操作。</p><p><strong>第二种情况是Socket中有部分数据。</strong></p><p>如果Socket中有部分数据就绪，且数据数量小于一次读操作期望读出的数据长度，那么读操作将会成功读出这部分数据，并返回，而不是等待期望长度数据全部读取后，再返回。</p><p>举个例子，服务端创建一个长度为10的切片作为接收数据的缓冲区，等待Read操作将读取的数据放入切片。当客户端在已经建立成功的连接上，成功写入两个字节的数据（比如：hi）后，服务端的Read方法将成功读取数据，并返回<code>n=2，err=nil</code>，而不是等收满10个字节后才返回。</p><p><strong>第三种情况是Socket中有足够数据。</strong></p><p>如果连接上有数据，且数据长度大于等于一次<code>Read</code>操作期望读出的数据长度，那么<code>Read</code>将会成功读出这部分数据，并返回。这个情景是最符合我们对<code>Read</code>的期待的了。</p><p>我们以上面的例子为例，当客户端在已经建立成功的连接上，成功写入15个字节的数据后，服务端进行第一次<code>Read</code>时，会用连接上的数据将我们传入的切片缓冲区（长度为10）填满后返回：<code>n = 10, err = nil</code>。这个时候，内核缓冲区中还剩5个字节数据，当服务端再次调用<code>Read</code>方法时，就会把剩余数据全部读出。</p><p><strong>最后一种情况是设置读操作超时。</strong></p><p>有些场合，对socket的读操作的阻塞时间有严格限制的，但由于Go使用的是阻塞I/O模型，如果没有可读数据，Read操作会一直阻塞在对Socket的读操作上。</p><p>这时，我们可以通过net.Conn提供的SetReadDeadline方法，设置读操作的超时时间，当超时后仍然没有数据可读的情况下，Read操作会解除阻塞并返回超时错误，这就给Read方法的调用者提供了进行其他业务处理逻辑的机会。</p><p>SetReadDeadline方法接受一个绝对时间作为超时的deadline，一旦通过这个方法设置了某个socket的Read deadline，那么无论后续的Read操作是否超时，只要我们不重新设置Deadline，那么后面与这个socket有关的所有读操作，都会返回超时失败错误。</p><p>下面是结合SetReadDeadline设置的服务端一般处理逻辑：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func handleConn(c net.Conn) {</span></div><div class="token-line"><span class="token plain">        defer c.Close()</span></div><div class="token-line"><span class="token plain">        for {</span></div><div class="token-line"><span class="token plain">            // read from the connection</span></div><div class="token-line"><span class="token plain">            var buf = make([]byte, 128)</span></div><div class="token-line"><span class="token plain">            c.SetReadDeadline(time.Now().Add(time.Second))</span></div><div class="token-line"><span class="token plain">            n, err := c.Read(buf)</span></div><div class="token-line"><span class="token plain">            if err != nil {</span></div><div class="token-line"><span class="token plain">                log.Printf(&quot;conn read %d bytes,  error: %s&quot;, n, err)</span></div><div class="token-line"><span class="token plain">                if nerr, ok := err.(net.Error); ok &amp;&amp; nerr.Timeout() {</span></div><div class="token-line"><span class="token plain">                    // 进行其他业务逻辑的处理</span></div><div class="token-line"><span class="token plain">                    continue</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">                return</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            log.Printf(&quot;read %d bytes, content is %s\n&quot;, n, string(buf[:n]))</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>如果我们要取消超时设置，可以使用SetReadDeadline（time.Time<!-- -->{<!-- -->}<!-- -->）实现。</p><h2 id="socket写操作"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01#socket写操作"><span class="icon icon-link"></span></a>Socket写操作</h2><p>通过net.Conn实例的Write方法，我们可以将数据写入Socket。当Write调用的返回值n的值，与预期要写入的数据长度相等，且err = nil时，我们就执行了一次成功的Socket写操作，这是我们在调用Write时遇到的最常见的情形。</p><p>和Socket的读操作一些特殊情形相比，Socket写操作遇到的特殊情形同样不少，我们也逐一看一下。</p><p><strong>第一种情况：写阻塞。</strong></p><p>TCP协议通信两方的操作系统内核，都会为这个连接保留数据缓冲区，调用Write向Socket写入数据，实际上是将数据写入到操作系统协议栈的数据缓冲区中。TCP是全双工通信，因此每个方向都有独立的数据缓冲。当发送方将对方的接收缓冲区，以及自身的发送缓冲区都写满后，再调用Write方法就会出现阻塞的情况。</p><p>我们来看一个具体例子。这个例子的客户端代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func main() {</span></div><div class="token-line"><span class="token plain">        log.Println(&quot;begin dial...&quot;)</span></div><div class="token-line"><span class="token plain">        conn, err := net.Dial(&quot;tcp&quot;, &quot;:8888&quot;)</span></div><div class="token-line"><span class="token plain">        if err != nil {</span></div><div class="token-line"><span class="token plain">            log.Println(&quot;dial error:&quot;, err)</span></div><div class="token-line"><span class="token plain">            return</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        defer conn.Close()</span></div><div class="token-line"><span class="token plain">        log.Println(&quot;dial ok&quot;)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        data := make([]byte, 65536)</span></div><div class="token-line"><span class="token plain">        var total int</span></div><div class="token-line"><span class="token plain">        for {</span></div><div class="token-line"><span class="token plain">            n, err := conn.Write(data)</span></div><div class="token-line"><span class="token plain">            if err != nil {</span></div><div class="token-line"><span class="token plain">                total += n</span></div><div class="token-line"><span class="token plain">                log.Printf(&quot;write %d bytes, error:%s\n&quot;, n, err)</span></div><div class="token-line"><span class="token plain">                break</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            total += n</span></div><div class="token-line"><span class="token plain">            log.Printf(&quot;write %d bytes this time, %d bytes in total\n&quot;, n, total)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        log.Printf(&quot;write %d bytes in total\n&quot;, total)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>客户端每次调用Write方法向服务端写入65536个字节，并在Write方法返回后，输出此次Write的写入字节数和程序启动后写入的总字节数量。</p><p>服务端的处理程序逻辑，我也摘录了主要部分，你可以看一下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">... ...</span></div><div class="token-line"><span class="token plain">    func handleConn(c net.Conn) {</span></div><div class="token-line"><span class="token plain">        defer c.Close()</span></div><div class="token-line"><span class="token plain">        time.Sleep(time.Second * 10)</span></div><div class="token-line"><span class="token plain">        for {</span></div><div class="token-line"><span class="token plain">            // read from the connection</span></div><div class="token-line"><span class="token plain">            time.Sleep(5 * time.Second)</span></div><div class="token-line"><span class="token plain">            var buf = make([]byte, 60000)</span></div><div class="token-line"><span class="token plain">            log.Println(&quot;start to read from conn&quot;)</span></div><div class="token-line"><span class="token plain">            n, err := c.Read(buf)</span></div><div class="token-line"><span class="token plain">            if err != nil {</span></div><div class="token-line"><span class="token plain">                log.Printf(&quot;conn read %d bytes,  error: %s&quot;, n, err)</span></div><div class="token-line"><span class="token plain">                if nerr, ok := err.(net.Error); ok &amp;&amp; nerr.Timeout() {</span></div><div class="token-line"><span class="token plain">                    continue</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            log.Printf(&quot;read %d bytes, content is %s\n&quot;, n, string(buf[:n]))</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    ... ...</span></div></pre></div><p>我们可以看到，服务端在前10秒中并不读取数据，因此当客户端一直调用Write方法写入数据时，写到一定量后就会发生阻塞。你可以看一下客户端的执行输出：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">2022/01/14 14:57:33 begin dial...</span></div><div class="token-line"><span class="token plain">    2022/01/14 14:57:33 dial ok</span></div><div class="token-line"><span class="token plain">    2022/01/14 14:57:33 write 65536 bytes this time, 65536 bytes in total</span></div><div class="token-line"><span class="token plain">    ... ...</span></div><div class="token-line"><span class="token plain">    2022/01/14 14:57:33 write 65536 bytes this time, 589824 bytes in total</span></div><div class="token-line"><span class="token plain">    2022/01/14 14:57:33 write 65536 bytes this time, 655360 bytes in total  &lt;-- 之后，写操作将阻塞</span></div></pre></div><p>后续当服务端每隔5秒进行一次读操作后，内核socket缓冲区腾出了空间，客户端就又可以写入了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">服务端：</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    2022/01/14 15:07:01 accept a new connection</span></div><div class="token-line"><span class="token plain">    2022/01/14 15:07:16 start to read from conn</span></div><div class="token-line"><span class="token plain">    2022/01/14 15:07:16 read 60000 bytes, content is</span></div><div class="token-line"><span class="token plain">    2022/01/14 15:07:21 start to read from conn</span></div><div class="token-line"><span class="token plain">    2022/01/14 15:07:21 read 60000 bytes, content is</span></div><div class="token-line"><span class="token plain">    2022/01/14 15:07:26 start to read from conn</span></div><div class="token-line"><span class="token plain">    2022/01/14 15:07:26 read 60000 bytes, content is</span></div><div class="token-line"><span class="token plain">    ....</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    客户端(得以继续写入)：</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    2022/01/14 15:07:01 write 65536 bytes this time, 720896 bytes in total</span></div><div class="token-line"><span class="token plain">    2022/01/14 15:07:06 write 65536 bytes this time, 786432 bytes in total</span></div><div class="token-line"><span class="token plain">    2022/01/14 15:07:16 write 65536 bytes this time, 851968 bytes in total</span></div><div class="token-line"><span class="token plain">    2022/01/14 15:07:16 write 65536 bytes this time, 917504 bytes in total</span></div><div class="token-line"><span class="token plain">    2022/01/14 15:07:27 write 65536 bytes this time, 983040 bytes in total</span></div><div class="token-line"><span class="token plain">    2022/01/14 15:07:27 write 65536 bytes this time, 1048576 bytes in total</span></div><div class="token-line"><span class="token plain">    .... ...</span></div></pre></div><p><strong>第二种情况：写入部分数据。</strong></p><p>Write操作存在写入部分数据的情况，比如上面例子中，当客户端输出日志停留在“write 65536 bytes this time, 655360 bytes in total”时，我们杀掉服务端，这时我们就会看到客户端输出以下日志：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">...</span></div><div class="token-line"><span class="token plain">    2022/01/14 15:19:14 write 65536 bytes this time, 655360 bytes in total</span></div><div class="token-line"><span class="token plain">    2022/01/14 15:19:16 write 24108 bytes, error:write tcp 127.0.0.1:62245-&gt;127.0.0.1:8888: write: broken pipe</span></div><div class="token-line"><span class="token plain">    2022/01/14 15:19:16 write 679468 bytes in total</span></div></pre></div><p>显然，<code>Write</code>并不是在655360这个地方阻塞的，而是后续又写入24108个字节后发生了阻塞，服务端Socket关闭后，我们看到客户端又写入24108字节后，才返回的<code>broken pipe</code>错误。由于这24108字节数据并未真正被服务端接收到，程序需要考虑妥善处理这些数据，以防数据丢失。</p><p><strong>第三种情况：写入超时。</strong></p><p>如果我们非要给Write操作增加一个期限，可以调用SetWriteDeadline方法。比如，我们可以将上面例子中的客户端源码拷贝一份，然后在新客户端源码中的Write调用之前，增加一行超时时间设置代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">conn.SetWriteDeadline(time.Now().Add(time.Microsecond * 10))</span></div></pre></div><p>然后先后启动服务端与新客户端，我们可以看到写入超时的情况下，Write方法的返回结果：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">客户端输出：</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    2022/01/14 15:26:34 begin dial...</span></div><div class="token-line"><span class="token plain">    2022/01/14 15:26:34 dial ok</span></div><div class="token-line"><span class="token plain">    2022/01/14 15:26:34 write 65536 bytes this time, 65536 bytes in total</span></div><div class="token-line"><span class="token plain">    ... ...</span></div><div class="token-line"><span class="token plain">    2022/01/14 15:26:34 write 65536 bytes this time, 655360 bytes in total</span></div><div class="token-line"><span class="token plain">    2022/01/14 15:26:34 write 24108 bytes, error:write tcp 127.0.0.1:62325-&gt;127.0.0.1:8888: i/o timeout</span></div><div class="token-line"><span class="token plain">    2022/01/14 15:26:34 write 679468 bytes in total</span></div></pre></div><p>我们可以看到，在Write方法写入超时时，依旧存在**数据部分写入（仅写入24108个字节）**的情况。另外，和SetReadDeadline一样，只要我们通过SetWriteDeadline设置了写超时，那无论后续Write方法是否成功，如果不重新设置写超时或取消写超时，后续对Socket的写操作都将以超时失败告终。</p><p>综合上面这些例子，虽然Go给我们提供了阻塞I/O的便利，但在调用<code>Read</code>和<code>Write</code>时，依旧要综合函数返回的<code>n</code>和<code>err</code>的结果以做出正确处理。</p><p>不过，前面说的Socket读与写都是限于单Goroutine下的操作，如果多个Goroutine并发读或写一个socket会发生什么呢？我们继续往下看。</p><h2 id="并发socket读写"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01#并发socket读写"><span class="icon icon-link"></span></a>并发Socket读写</h2><p>Goroutine的网络编程模型，决定了存在着不同Goroutine间共享<code>conn</code>的情况，那么<code>conn</code>的读写是否是Goroutine并发安全的呢？不过，在深入这个问题之前，我们先从应用的角度上，看看并发read操作和write操作的Goroutine安全的必要性。</p><p>对于Read操作而言，由于TCP是面向字节流，<code>conn.Read</code>无法正确区分数据的业务边界，因此，多个Goroutine对同一个conn进行read的意义不大，Goroutine读到不完整的业务包，反倒增加了业务处理的难度。</p><p>但对于Write操作而言，倒是有多个Goroutine并发写的情况。不过conn读写是否是Goroutine安全的测试并不是很好做，我们先深入一下运行时代码，从理论上给这个问题定个性。</p><p>首先，<code>net.conn</code>只是<code>*netFD</code> 的外层包裹结构，最终Write和Read都会落在其中的<code>fd</code>字段上：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//$GOROOT/src/net/net.go</span></div><div class="token-line"><span class="token plain">    type conn struct {</span></div><div class="token-line"><span class="token plain">        fd *netFD</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>另外，netFD在不同平台上有着不同的实现，我们以<code>net/fd_posix.go</code>中的<code>netFD</code>为例看看：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// $GOROOT/src/net/fd_unix.go</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // Network file descriptor.</span></div><div class="token-line"><span class="token plain">    type netFD struct {</span></div><div class="token-line"><span class="token plain">        pfd poll.FD </span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        // immutable until Close</span></div><div class="token-line"><span class="token plain">        family      int</span></div><div class="token-line"><span class="token plain">        sotype      int</span></div><div class="token-line"><span class="token plain">        isConnected bool // handshake completed or use of association with peer</span></div><div class="token-line"><span class="token plain">        net         string</span></div><div class="token-line"><span class="token plain">        laddr       Addr</span></div><div class="token-line"><span class="token plain">        raddr       Addr</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>netFD中最重要的字段是poll.FD类型的pfd，它用于表示一个网络连接。我也把它的结构摘录了一部分：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// $GOROOT/src/internal/poll/fd_unix.go</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // FD is a file descriptor. The net and os packages use this type as a</span></div><div class="token-line"><span class="token plain">    // field of a larger type representing a network connection or OS file.</span></div><div class="token-line"><span class="token plain">    type FD struct {</span></div><div class="token-line"><span class="token plain">        // Lock sysfd and serialize access to Read and Write methods.</span></div><div class="token-line"><span class="token plain">        fdmu fdMutex</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        // System file descriptor. Immutable until Close.</span></div><div class="token-line"><span class="token plain">        Sysfd int</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        // I/O poller.</span></div><div class="token-line"><span class="token plain">        pd pollDesc </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // Writev cache.</span></div><div class="token-line"><span class="token plain">        iovecs *[]syscall.Iovec</span></div><div class="token-line"><span class="token plain">        ... ...    </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们看到，<code>FD</code>类型中包含了一个运行时实现的<code>fdMutex</code>类型字段。从它的注释来看，这个<code>fdMutex</code>用来串行化对字段<code>Sysfd</code>的Write和Read操作。也就是说，所有对这个FD所代表的连接的Read和Write操作，都是由<code>fdMutex</code>来同步的。从<code>FD</code>的Read和Write方法的实现，也证实了这一点：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// $GOROOT/src/internal/poll/fd_unix.go</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func (fd *FD) Read(p []byte) (int, error) {</span></div><div class="token-line"><span class="token plain">        if err := fd.readLock(); err != nil {</span></div><div class="token-line"><span class="token plain">            return 0, err</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        defer fd.readUnlock()</span></div><div class="token-line"><span class="token plain">        if len(p) == 0 {</span></div><div class="token-line"><span class="token plain">            // If the caller wanted a zero byte read, return immediately</span></div><div class="token-line"><span class="token plain">            // without trying (but after acquiring the readLock).</span></div><div class="token-line"><span class="token plain">            // Otherwise syscall.Read returns 0, nil which looks like</span></div><div class="token-line"><span class="token plain">            // io.EOF.</span></div><div class="token-line"><span class="token plain">            // TODO(bradfitz): make it wait for readability? (Issue 15735)</span></div><div class="token-line"><span class="token plain">            return 0, nil</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if err := fd.pd.prepareRead(fd.isFile); err != nil {</span></div><div class="token-line"><span class="token plain">            return 0, err</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if fd.IsStream &amp;&amp; len(p) &gt; maxRW {</span></div><div class="token-line"><span class="token plain">            p = p[:maxRW]</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        for {</span></div><div class="token-line"><span class="token plain">            n, err := ignoringEINTRIO(syscall.Read, fd.Sysfd, p)</span></div><div class="token-line"><span class="token plain">            if err != nil {</span></div><div class="token-line"><span class="token plain">                n = 0</span></div><div class="token-line"><span class="token plain">                if err == syscall.EAGAIN &amp;&amp; fd.pd.pollable() {</span></div><div class="token-line"><span class="token plain">                    if err = fd.pd.waitRead(fd.isFile); err == nil {</span></div><div class="token-line"><span class="token plain">                        continue</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            err = fd.eofError(n, err)</span></div><div class="token-line"><span class="token plain">            return n, err</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func (fd *FD) Write(p []byte) (int, error) {</span></div><div class="token-line"><span class="token plain">        if err := fd.writeLock(); err != nil {</span></div><div class="token-line"><span class="token plain">            return 0, err</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        defer fd.writeUnlock()</span></div><div class="token-line"><span class="token plain">        if err := fd.pd.prepareWrite(fd.isFile); err != nil {</span></div><div class="token-line"><span class="token plain">            return 0, err</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        var nn int</span></div><div class="token-line"><span class="token plain">        for {</span></div><div class="token-line"><span class="token plain">            max := len(p)</span></div><div class="token-line"><span class="token plain">            if fd.IsStream &amp;&amp; max-nn &gt; maxRW {</span></div><div class="token-line"><span class="token plain">                max = nn + maxRW</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            n, err := ignoringEINTRIO(syscall.Write, fd.Sysfd, p[nn:max])</span></div><div class="token-line"><span class="token plain">            if n &gt; 0 {</span></div><div class="token-line"><span class="token plain">                nn += n</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            if nn == len(p) {</span></div><div class="token-line"><span class="token plain">                return nn, err</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            if err == syscall.EAGAIN &amp;&amp; fd.pd.pollable() {</span></div><div class="token-line"><span class="token plain">                if err = fd.pd.waitWrite(fd.isFile); err == nil {</span></div><div class="token-line"><span class="token plain">                    continue</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            if err != nil {</span></div><div class="token-line"><span class="token plain">                return nn, err</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            if n == 0 {</span></div><div class="token-line"><span class="token plain">                return nn, io.ErrUnexpectedEOF</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>你看，每次Write操作都是受lock保护，直到这次数据全部写完才会解锁。因此，在应用层面，要想保证多个Goroutine在一个<code>conn</code>上write操作是安全的，需要一次write操作完整地写入一个“业务包”。一旦将业务包的写入拆分为多次write，那也无法保证某个Goroutine的某“业务包”数据在<code>conn</code>发送的连续性。</p><p>同时，我们也可以看出即便是Read操作，也是有lock保护的。多个Goroutine对同一<code>conn</code>的并发读，不会出现读出内容重叠的情况，但就像前面讲并发读的必要性时说的那样，一旦采用了不恰当长度的切片作为buf，很可能读出不完整的业务包，这反倒会带来业务上的处理难度。</p><p>比如一个完整数据包：<code>world</code>，当Goroutine的读缓冲区长度 &lt; 5时，就存在这样一种可能：一个Goroutine读出了“worl”，而另外一个Goroutine读出了&quot;d&quot;。</p><p>最后我们再来看看Socket关闭。</p><h2 id="socket关闭"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01#socket关闭"><span class="icon icon-link"></span></a>Socket关闭</h2><p>通常情况下，当客户端需要断开与服务端的连接时，客户端会调用net.Conn的Close方法关闭与服务端通信的Socket。如果客户端主动关闭了Socket，那么服务端的<code>Read</code>调用将会读到什么呢？这里要分“有数据关闭”和“无数据关闭”两种情况。</p><p>“有数据关闭”是指在客户端关闭连接（Socket）时，Socket中还有服务端尚未读取的数据。在这种情况下，服务端的Read会成功将剩余数据读取出来，最后一次Read操作将得到<code>io.EOF</code>错误码，表示客户端已经断开了连接。如果是在“无数据关闭”情形下，服务端调用的Read方法将直接返回<code>io.EOF</code>。</p><p>不过因为Socket是全双工的，客户端关闭Socket后，如果服务端Socket尚未关闭，这个时候服务端向Socket的写入操作依然可能会成功，因为数据会成功写入己方的内核socket缓冲区中，即便最终发不到对方socket缓冲区也会这样。因此，当发现对方socket关闭后，己方应该正确合理处理自己的socket，再继续write已经没有任何意义了。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01#小结"><span class="icon icon-link"></span></a>小结</h2><p>好了，今天的课讲到这里就结束了，从这一讲开始我们开启了实战篇的学习。</p><p>在实战篇中，我会带着你“走完最后一公里”，所谓“最后一公里”，我的理解是从空有一身Go“绝技”到可以解决实际问题的进化，在这个过程中，我们需要怎么做？我们可以跟着理解问题、技术预研与储备，以及设计、实现与优化这三个循环解决思路，完成这个进化。</p><p>这一讲，我们的实际问题聚焦在<strong>实现一个基于TCP的自定义应用层协议的通信服务端</strong>，我们分析了通信协议与通信过程，并识别出若干技术点，其中以socket编程模型与网络I/O操作为重点，对这两个技术点进行了预研与储备。</p><p>虽然目前主流socket网络编程模型是I/O多路复用模型，但考虑到这个模型在使用时的体验较差，Go语言将这种复杂性隐藏到运行时层，并结合Goroutine的轻量级特性，在用户层提供了基于I/O阻塞模型的Go socket网络编程模型，这一模型就大大降低了gopher在编写socket应用程序时的心智负担。</p><p>而且，Go在net包中提供了针对socket的各种操作函数与方法，在这一讲中我们详细分析了其中的重要函数的使用，以及这些函数在特殊场景下需要注意的事项，你一定要掌握这一部分，因为这是我们下一讲进行设计与实现的根基与铺垫。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>这一讲内容比较多，针对Go net包提供的各种操作，我建议你自己编写代码，逐个去实现这一讲中各个操作里的示例代码，为下一讲做好充分的准备。</p><p>欢迎你把这节课分享给更多感兴趣的朋友。我是Tony Bai，我们下节课见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:33</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
