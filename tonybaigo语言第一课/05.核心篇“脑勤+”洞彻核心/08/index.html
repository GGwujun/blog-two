<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>34｜并发：如何使用共享变量？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/08" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a aria-current="page" class="active" href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a aria-current="page" class="active" href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-two/tonybaigo语言第一课/01.开篇词/01"><span>开篇词｜这样入门Go，才能少走弯路</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/02.前置篇心定之旅">02.前置篇心定之旅</a><ul><li><a href="/blog-two/tonybaigo语言第一课/02.前置篇心定之旅/01"><span>01｜前世今生：你不得不了解的Go的历史和现状</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/02.前置篇心定之旅/02"><span>02｜拒绝“Hello and Bye”：Go语言的设计哲学是怎么一回事？</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手">03.入门篇勤加练手</a><ul><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/01"><span>03｜配好环境：选择一种最适合你的Go安装方法</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/02"><span>04｜初窥门径：一个Go程序的结构是怎样的？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/03"><span>05｜标准先行：Go项目的布局标准是什么？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/04"><span>06｜构建模式：Go是怎么解决包依赖管理问题的？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/05"><span>07｜构建模式：Go Module的6类常规操作</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/06"><span>08｜入口函数与包初始化：搞清Go程序的执行次序</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/07"><span>09｜即学即练：构建一个Web服务就是这么简单</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解">04.基础篇“脑勤”多理解</a><ul><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/01"><span>10｜变量声明：静态语言有别于动态语言的重要特征</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/02"><span>11｜代码块与作用域：如何保证变量不会被遮蔽？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/03"><span>12｜基本数据类型：Go原生支持的数值类型有哪些？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/04"><span>13｜基本数据类型：为什么Go要原生支持字符串类型？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/05"><span>14｜常量：Go在“常量”设计上的创新有哪些？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/06"><span>15｜同构复合类型：从定长数组到变长切片</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/07"><span>16｜复合数据类型：原生map类型的实现机制是怎样的？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/08"><span>17｜复合数据类型：用结构体建立对真实世界的抽象</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/09"><span>18｜控制结构：if的“快乐路径”原则</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/10"><span>19｜控制结构：Go的for循环，仅此一种</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/11"><span>20｜控制结构：Go中的switch语句有哪些变化？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/12"><span>21｜函数：请叫我“一等公民”</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/13"><span>22｜函数：怎么结合多返回值进行错误处理？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/14"><span>期中测试｜一起检验下你的学习成果吧</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/15"><span>23｜函数：怎么让函数更简洁健壮？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/16"><span>24｜方法：理解“方法”的本质</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/17"><span>25｜方法：方法集合与如何选择receiver类型？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/18"><span>26｜方法：如何用类型嵌入模拟实现“继承”？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/19"><span>27｜即学即练：跟踪函数调用链，理解代码更直观</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/20"><span>用户故事｜罗杰：我的Go语言学习之路</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心">05.核心篇“脑勤+”洞彻核心</a><ul><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/01"><span>28｜接口：接口即契约</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02"><span>29｜接口：为什么nil接口不等于nil？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/03"><span>30｜接口：Go中最强大的魔法</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/04"><span>元旦快乐｜这是一份暂时停更的声明</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/05"><span>31｜并发：Go的并发方案实现方案是怎样的？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/06"><span>32｜并发：聊聊Goroutine调度器的原理</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07"><span>33｜并发：小channel中蕴含大智慧</span></a></li><li><a aria-current="page" class="active" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/08"><span>34｜并发：如何使用共享变量？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/09"><span>35｜即学即练：如何实现一个轻量级线程池？</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”">06.实战篇打通“最后一公里”</a><ul><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01"><span>36｜打稳根基：怎么实现一个TCP服务器？（上）</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/02"><span>37｜代码操练：怎么实现一个TCP服务器？（中）</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/03"><span>38｜成果优化：怎么实现一个TCP服务器？（下）</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/04"><span>结课测试｜快来检验下你的学习成果吧！</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇">07.加餐篇</a><ul><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/01"><span>加餐｜我“私藏”的那些优质且权威的Go语言学习资料</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/02"><span>加餐｜聊聊Go 1.17版本的那些新特性</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/03"><span>加餐｜如何拉取私有的Go Module？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/04"><span>加餐｜作为Go Module的作者，你应该知道的几件事</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/05"><span>加餐｜聊聊最近大热的Go泛型</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/06"><span>加餐｜聊聊Go语言的指针</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵">08.大咖助阵</a><ul><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/01"><span>大咖助阵｜孔令飞：从小白到“老鸟”，我的Go语言进阶之路</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/02"><span>大咖助阵｜叶剑峰：Go语言中常用的那些代码优化点</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/03"><span>大咖助阵｜徐祥曦：从销售到分布式存储工程师，我与 Go  的故事</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/04"><span>大咖助阵｜曹春晖：聊聊 Go 语言的 GC 实现</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/05"><span>大咖助阵｜大明：Go泛型，泛了，但没有完全泛</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/06"><span>大咖助阵｜海纳：聊聊语言中的类型系统与泛型</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/09.结束语">09.结束语</a><ul><li><a href="/blog-two/tonybaigo语言第一课/09.结束语/01"><span>结束语｜和你一起迎接Go的黄金十年</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/summary">tonybaigo语言第一课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="sync包低级同步原语可以用在哪？" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/08#sync包低级同步原语可以用在哪"><span>sync包低级同步原语可以用在哪？</span></a></li><li title="sync包中同步原语使用的注意事项" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/08#sync包中同步原语使用的注意事项"><span>sync包中同步原语使用的注意事项</span></a></li><li title="互斥锁（Mutex）还是读写锁（RWMutex）？" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/08#互斥锁mutex还是读写锁rwmutex"><span>互斥锁（Mutex）还是读写锁（RWMutex）？</span></a></li><li title="条件变量" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/08#条件变量"><span>条件变量</span></a></li><li title="原子操作（atomic operations）" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/08#原子操作atomic-operations"><span>原子操作（atomic operations）</span></a></li><li title="小结" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/08#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/08#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="34并发如何使用共享变量"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/08#34并发如何使用共享变量"><span class="icon icon-link"></span></a>34｜并发：如何使用共享变量？</h1><p>你好，我是Tony Bai。</p><p>在前面的讲解中，我们学习了Go的并发实现方案，知道了Go基于Tony Hoare的<strong>CSP并发模型</strong>理论，实现了Goroutine、channel等并发原语。</p><p>并且，Go语言之父Rob Pike还有一句经典名言：“不要通过共享内存来通信，应该通过通信来共享内存（Don’t communicate by sharing memory, share memory by communicating）”，这就奠定了Go应用并发设计的主流风格：<strong>使用channel进行不同Goroutine间的通信</strong>。</p><p>不过，Go也并没有彻底放弃基于共享内存的并发模型，而是在提供CSP并发模型原语的同时，还通过标准库的sync包，提供了针对传统的、基于共享内存并发模型的低级同步原语，包括：互斥锁（sync.Mutex）、读写锁（sync.RWMutex）、条件变量（sync.Cond）等，并通过atomic包提供了原子操作原语等等。显然，基于共享内存的并发模型在Go语言中依然有它的“用武之地”。</p><p>所以，在并发的最后一讲，我们就围绕sync包中的几个同步结构与对应的方法，聊聊基于共享内存的并发模型在Go中的应用。</p><p>我们先来看看在哪些场景下，我们需要用到sync包提供的低级同步原语。</p><h2 id="sync包低级同步原语可以用在哪"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/08#sync包低级同步原语可以用在哪"><span class="icon icon-link"></span></a>sync包低级同步原语可以用在哪？</h2><p>这里我要先强调一句，一般情况下，我建议你优先使用CSP并发模型进行并发程序设计。但是在下面一些场景中，我们依然需要sync包提供的低级同步原语。</p><p><strong>首先是需要高性能的临界区（critical section）同步机制场景。</strong></p><p>在Go中，channel并发原语也可以用于对数据对象访问的同步，我们可以把channel看成是一种高级的同步原语，它自身的实现也是建构在低级同步原语之上的。也正因为如此，channel自身的性能与低级同步原语相比要略微逊色，开销要更大。</p><p>这里，关于sync.Mutex和channel各自实现的临界区同步机制，我做了一个简单的性能基准测试对比，通过对比结果，我们可以很容易看出两者的性能差异：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var cs = 0 // 模拟临界区要保护的数据</span></div><div class="token-line"><span class="token plain">    var mu sync.Mutex</span></div><div class="token-line"><span class="token plain">    var c = make(chan struct{}, 1)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func criticalSectionSyncByMutex() {</span></div><div class="token-line"><span class="token plain">        mu.Lock()</span></div><div class="token-line"><span class="token plain">        cs++</span></div><div class="token-line"><span class="token plain">        mu.Unlock()</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func criticalSectionSyncByChan() {</span></div><div class="token-line"><span class="token plain">        c &lt;- struct{}{}</span></div><div class="token-line"><span class="token plain">        cs++</span></div><div class="token-line"><span class="token plain">        &lt;-c</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func BenchmarkCriticalSectionSyncByMutex(b *testing.B) {</span></div><div class="token-line"><span class="token plain">        for n := 0; n &lt; b.N; n++ {</span></div><div class="token-line"><span class="token plain">            criticalSectionSyncByMutex()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func BenchmarkCriticalSectionSyncByMutexInParallel(b *testing.B) {</span></div><div class="token-line"><span class="token plain">        b.RunParallel(func(pb *testing.PB) {</span></div><div class="token-line"><span class="token plain">            for pb.Next() {</span></div><div class="token-line"><span class="token plain">                criticalSectionSyncByMutex()</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func BenchmarkCriticalSectionSyncByChan(b *testing.B) {</span></div><div class="token-line"><span class="token plain">        for n := 0; n &lt; b.N; n++ {</span></div><div class="token-line"><span class="token plain">            criticalSectionSyncByChan()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func BenchmarkCriticalSectionSyncByChanInParallel(b *testing.B) {</span></div><div class="token-line"><span class="token plain">        b.RunParallel(func(pb *testing.PB) {</span></div><div class="token-line"><span class="token plain">            for pb.Next() {</span></div><div class="token-line"><span class="token plain">                criticalSectionSyncByChan()</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>运行这个对比测试（Go 1.17），我们得到：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$go test -bench .</span></div><div class="token-line"><span class="token plain">    goos: darwin</span></div><div class="token-line"><span class="token plain">    goarch: amd64</span></div><div class="token-line"><span class="token plain">    ... ...</span></div><div class="token-line"><span class="token plain">    BenchmarkCriticalSectionSyncByMutex-8             	88083549	        13.64 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkCriticalSectionSyncByMutexInParallel-8   	22337848	        55.29 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkCriticalSectionSyncByChan-8              	28172056	        42.48 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkCriticalSectionSyncByChanInParallel-8    	 5722972	       208.1 ns/op</span></div><div class="token-line"><span class="token plain">    PASS</span></div></pre></div><p>通过这个对比实验，我们可以看到，无论是在单Goroutine情况下，还是在并发测试情况下，<code>sync.Mutex</code>实现的同步机制的性能，都要比channel实现的高出三倍多。</p><p>因此，通常在需要高性能的临界区（critical section）同步机制的情况下，sync包提供的低级同步原语更为适合。</p><p><strong>第二种就是在不想转移结构体对象所有权，但又要保证结构体内部状态数据的同步访问的场景。</strong></p><p>基于channel的并发设计，有一个特点：在Goroutine间通过channel转移数据对象的所有权。所以，只有拥有数据对象所有权（从channel接收到该数据）的Goroutine才可以对该数据对象进行状态变更。</p><p>如果你的设计中没有转移结构体对象所有权，但又要保证结构体内部状态数据在多个Goroutine之间同步访问，那么你可以使用sync包提供的低级同步原语来实现，比如最常用的<code>sync.Mutex</code>。</p><p>了解了这些应用场景之后，接着我们就来看看如何使用sync包中的各个同步结构，不过在使用之前，我们需要先看看一个sync包中同步原语使用的注意事项。</p><h2 id="sync包中同步原语使用的注意事项"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/08#sync包中同步原语使用的注意事项"><span class="icon icon-link"></span></a>sync包中同步原语使用的注意事项</h2><p>在sync包的注释中（在<code>$GOROOT/src/sync/mutex.go</code>文件的头部注释），我们看到这样一行说明：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Values containing the types defined in this package should not be copied.</span></div></pre></div><p>翻译过来就是：“不应复制那些包含了此包中类型的值”。</p><p>在sync包的其他源文件中，我们同样看到类似的一些注释：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// $GOROOT/src/sync/mutex.go</span></div><div class="token-line"><span class="token plain">    // A Mutex must not be copied after first use. （禁止复制首次使用后的Mutex）</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // $GOROOT/src/sync/rwmutex.go</span></div><div class="token-line"><span class="token plain">    // A RWMutex must not be copied after first use.（禁止复制首次使用后的RWMutex）</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // $GOROOT/src/sync/cond.go</span></div><div class="token-line"><span class="token plain">    // A Cond must not be copied after first use.（禁止复制首次使用后的Cond）</span></div><div class="token-line"><span class="token plain">    ... ...</span></div></pre></div><p>那么，为什么首次使用Mutex等sync包中定义的结构类型后，我们不应该再对它们进行复制操作呢？我们以Mutex这个同步原语为例，看看它的实现是怎样的。</p><p>Go标准库中sync.Mutex的定义是这样的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// $GOROOT/src/sync/mutex.go</span></div><div class="token-line"><span class="token plain">    type Mutex struct {</span></div><div class="token-line"><span class="token plain">        state int32</span></div><div class="token-line"><span class="token plain">        sema  uint32</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们看到，Mutex的定义非常简单，由两个整型字段state和sema组成：</p><ul><li>state：表示当前互斥锁的状态；</li><li>sema：用于控制锁状态的信号量。</li></ul><p>初始情况下，Mutex的实例处于<strong>Unlocked</strong>状态（state和sema均为0）。对Mutex实例的复制也就是两个整型字段的复制。一旦发生复制，原变量与副本就是两个单独的内存块，各自发挥同步作用，互相就没有了关联。</p><p>如果发生复制后，你仍然认为原变量与副本保护的是同一个数据对象，那可就大错特错了。我们来看一个例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func main() {</span></div><div class="token-line"><span class="token plain">         var wg sync.WaitGroup</span></div><div class="token-line"><span class="token plain">         i := 0</span></div><div class="token-line"><span class="token plain">         var mu sync.Mutex // 负责对i的同步访问</span></div><div class="token-line"><span class="token plain">     </span></div><div class="token-line"><span class="token plain">         wg.Add(1)</span></div><div class="token-line"><span class="token plain">         // g1</span></div><div class="token-line"><span class="token plain">         go func(mu1 sync.Mutex) {</span></div><div class="token-line"><span class="token plain">             mu1.Lock()</span></div><div class="token-line"><span class="token plain">             i = 10</span></div><div class="token-line"><span class="token plain">             time.Sleep(10 * time.Second)</span></div><div class="token-line"><span class="token plain">             fmt.Printf(&quot;g1: i = %d\n&quot;, i)</span></div><div class="token-line"><span class="token plain">             mu1.Unlock()</span></div><div class="token-line"><span class="token plain">             wg.Done()</span></div><div class="token-line"><span class="token plain">         }(mu)</span></div><div class="token-line"><span class="token plain">     </span></div><div class="token-line"><span class="token plain">         time.Sleep(time.Second)</span></div><div class="token-line"><span class="token plain">     </span></div><div class="token-line"><span class="token plain">         mu.Lock()</span></div><div class="token-line"><span class="token plain">         i = 1</span></div><div class="token-line"><span class="token plain">         fmt.Printf(&quot;g0: i = %d\n&quot;, i)</span></div><div class="token-line"><span class="token plain">         mu.Unlock()</span></div><div class="token-line"><span class="token plain">     </span></div><div class="token-line"><span class="token plain">         wg.Wait()</span></div><div class="token-line"><span class="token plain">     }</span></div></pre></div><p>在这个例子中，我们使用一个sync.Mutex类型变量mu来同步对整型变量i的访问。我们创建一个新Goroutine：g1，g1通过函数参数得到mu的一份拷贝mu1，然后g1会通过mu1来同步对整型变量i的访问。</p><p>那么，g0通过mu和g1通过mu的拷贝mu1，是否能实现对同一个变量i的同步访问呢？我们来看看运行这个示例的运行结果：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">g0: i = 1</span></div><div class="token-line"><span class="token plain">    g1: i = 1</span></div></pre></div><p>从结果来看，这个程序并没有实现对i的同步访问，第9行g1对mu1的加锁操作，并没能阻塞第19行g0对mu的加锁。于是，g1刚刚将i赋值为10后，g0就又将i赋值为1了。</p><p>出现这种结果的原因就是我们前面分析的情况，一旦Mutex类型变量被拷贝，原变量与副本就各自发挥作用，互相没有关联了。甚至，如果拷贝的时机不对，比如在一个mutex处于locked的状态时对它进行了拷贝，就会对副本进行加锁操作，将导致加锁的Goroutine永远阻塞下去。</p><p>通过前面这个例子，我们可以很直观地看到：如果对使用过的、sync包中的类型的示例进行复制，并使用了复制后得到的副本，将导致不可预期的结果。所以，在使用sync包中的类型的时候，我们推荐通过<strong>闭包</strong>方式，或者是**传递类型实例（或包裹该类型的类型实例）的地址（指针）**的方式进行。这就是使用sync包时最值得我们注意的事项。</p><p>接下来，我们就来逐个分析日常使用较多的sync包中同步原语。我们先来看看互斥锁与读写锁。</p><h2 id="互斥锁mutex还是读写锁rwmutex"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/08#互斥锁mutex还是读写锁rwmutex"><span class="icon icon-link"></span></a>互斥锁（Mutex）还是读写锁（RWMutex）？</h2><p>sync包提供了两种用于临界区同步的原语：互斥锁（Mutex）和读写锁（RWMutex）。它们都是零值可用的数据类型，也就是不需要显式初始化就可以使用，并且使用方法都比较简单。在上面的示例中，我们已经看到了Mutex的应用方法，这里再总结一下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var mu sync.Mutex</span></div><div class="token-line"><span class="token plain">    mu.Lock()   // 加锁</span></div><div class="token-line"><span class="token plain">    doSomething()</span></div><div class="token-line"><span class="token plain">    mu.Unlock() // 解锁</span></div></pre></div><p>一旦某个Goroutine调用的Mutex执行Lock操作成功，它将成功持有这把互斥锁。这个时候，如果有其他Goroutine执行Lock操作，就会阻塞在这把互斥锁上，直到持有这把锁的Goroutine调用Unlock释放掉这把锁后，才会抢到这把锁的持有权并进入临界区。</p><p>由此，我们也可以得到使用互斥锁的两个原则：</p><ul><li><strong>尽量减少在锁中的操作</strong>。这可以减少其他因Goroutine阻塞而带来的损耗与延迟。</li><li><strong>一定要记得调用Unlock解锁</strong>。忘记解锁会导致程序局部死锁，甚至是整个程序死锁，会导致严重的后果。同时，我们也可以结合第23讲学习到的defer，优雅地执行解锁操作。</li></ul><p>读写锁与互斥锁用法大致相同，只不过多了一组加读锁和解读锁的方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var rwmu sync.RWMutex</span></div><div class="token-line"><span class="token plain">    rwmu.RLock()   //加读锁</span></div><div class="token-line"><span class="token plain">    readSomething()</span></div><div class="token-line"><span class="token plain">    rwmu.RUnlock() //解读锁</span></div><div class="token-line"><span class="token plain">    rwmu.Lock()    //加写锁</span></div><div class="token-line"><span class="token plain">    changeSomething()</span></div><div class="token-line"><span class="token plain">    rwmu.Unlock()  //解写锁</span></div></pre></div><p>写锁与Mutex的行为十分类似，一旦某Goroutine持有写锁，其他Goroutine无论是尝试加读锁，还是加写锁，都会被阻塞在写锁上。</p><p>但读锁就宽松多了，一旦某个Goroutine持有读锁，它不会阻塞其他尝试加读锁的Goroutine，但加写锁的Goroutine依然会被阻塞住。</p><p>通常，<strong>互斥锁（Mutex）是临时区同步原语的首选</strong>，它常被用来对结构体对象的内部状态、缓存等进行保护，是使用最为广泛的临界区同步原语。相比之下，读写锁的应用就没那么广泛了，只活跃于它擅长的场景下。</p><p>那读写锁（RWMutex）究竟擅长在哪种场景下呢？我们先来看一组基准测试：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var cs1 = 0 // 模拟临界区要保护的数据</span></div><div class="token-line"><span class="token plain">    var mu1 sync.Mutex</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    var cs2 = 0 // 模拟临界区要保护的数据</span></div><div class="token-line"><span class="token plain">    var mu2 sync.RWMutex</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func BenchmarkWriteSyncByMutex(b *testing.B) {</span></div><div class="token-line"><span class="token plain">        b.RunParallel(func(pb *testing.PB) {</span></div><div class="token-line"><span class="token plain">            for pb.Next() {</span></div><div class="token-line"><span class="token plain">                mu1.Lock()</span></div><div class="token-line"><span class="token plain">                cs1++</span></div><div class="token-line"><span class="token plain">                mu1.Unlock()</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func BenchmarkReadSyncByMutex(b *testing.B) {</span></div><div class="token-line"><span class="token plain">        b.RunParallel(func(pb *testing.PB) {</span></div><div class="token-line"><span class="token plain">            for pb.Next() {</span></div><div class="token-line"><span class="token plain">                mu1.Lock()</span></div><div class="token-line"><span class="token plain">                _ = cs1</span></div><div class="token-line"><span class="token plain">                mu1.Unlock()</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func BenchmarkReadSyncByRWMutex(b *testing.B) {</span></div><div class="token-line"><span class="token plain">        b.RunParallel(func(pb *testing.PB) {</span></div><div class="token-line"><span class="token plain">            for pb.Next() {</span></div><div class="token-line"><span class="token plain">                mu2.RLock()</span></div><div class="token-line"><span class="token plain">                _ = cs2</span></div><div class="token-line"><span class="token plain">                mu2.RUnlock()</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func BenchmarkWriteSyncByRWMutex(b *testing.B) {</span></div><div class="token-line"><span class="token plain">        b.RunParallel(func(pb *testing.PB) {</span></div><div class="token-line"><span class="token plain">            for pb.Next() {</span></div><div class="token-line"><span class="token plain">                mu2.Lock()</span></div><div class="token-line"><span class="token plain">                cs2++</span></div><div class="token-line"><span class="token plain">                mu2.Unlock()</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        })</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这些基准测试都是并发测试，度量的是Mutex、RWMutex在并发下的读写性能。我们分别在cpu=2、8、16、32的情况下运行这个并发性能测试，测试结果如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">goos: darwin</span></div><div class="token-line"><span class="token plain">    goarch: amd64</span></div><div class="token-line"><span class="token plain">    ... ...</span></div><div class="token-line"><span class="token plain">    BenchmarkWriteSyncByMutex-2     	73423770	        16.12 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkReadSyncByMutex-2      	84031135	        15.08 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkReadSyncByRWMutex-2    	37182219	        31.87 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkWriteSyncByRWMutex-2   	40727782	        29.08 ns/op</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    BenchmarkWriteSyncByMutex-8     	22153354	        56.39 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkReadSyncByMutex-8      	24164278	        51.12 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkReadSyncByRWMutex-8    	38589122	        31.17 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkWriteSyncByRWMutex-8   	18482208	        65.27 ns/op</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    BenchmarkWriteSyncByMutex-16      	20672842	        62.94 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkReadSyncByMutex-16       	19247158	        62.94 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkReadSyncByRWMutex-16     	29978614	        39.98 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkWriteSyncByRWMutex-16    	16095952	        78.19 ns/op</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    BenchmarkWriteSyncByMutex-32      	20539290	        60.20 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkReadSyncByMutex-32       	18807060	        72.61 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkReadSyncByRWMutex-32     	29772936	        40.45 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkWriteSyncByRWMutex-32    	13320544	        86.53 ns/op</span></div></pre></div><p>通过测试结果对比，我们得到了一些结论：</p><ul><li>并发量较小的情况下，Mutex性能最好；随着并发量增大，Mutex的竞争激烈，导致加锁和解锁性能下降；</li><li>RWMutex的读锁性能并没有随着并发量的增大，而发生较大变化，性能始终恒定在40ns左右；</li><li>在并发量较大的情况下，RWMutex的写锁性能和Mutex、RWMutex读锁相比，是最差的，并且随着并发量增大，RWMutex写锁性能有继续下降趋势。</li></ul><p>由此，我们就可以看出，<strong>读写锁适合应用在具有一定并发量且读多写少的场合</strong>。在大量并发读的情况下，多个Goroutine可以同时持有读锁，从而减少在锁竞争中等待的时间。</p><p>而互斥锁，即便是读请求的场合，同一时刻也只能有一个Goroutine持有锁，其他Goroutine只能阻塞在加锁操作上等待被调度。</p><p>接下来，我们继续看条件变量sync.Cond。</p><h2 id="条件变量"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/08#条件变量"><span class="icon icon-link"></span></a>条件变量</h2><p><code>sync.Cond</code>是传统的条件变量原语概念在Go语言中的实现。我们可以把一个条件变量理解为一个容器，这个容器中存放着一个或一组等待着某个条件成立的Goroutine。当条件成立后，这些处于等待状态的Goroutine将得到通知，并被唤醒继续进行后续的工作。这与百米飞人大战赛场上，各位运动员等待裁判员的发令枪声的情形十分类似。</p><p>条件变量是同步原语的一种，如果没有条件变量，开发人员可能需要在Goroutine中通过连续轮询的方式，检查某条件是否为真，这种连续轮询非常消耗资源，因为Goroutine在这个过程中是处于活动状态的，但它的工作又没有进展。</p><p>这里我们先看一个用<code>sync.Mutex</code> 实现对条件轮询等待的例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type signal struct{}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    var ready bool</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func worker(i int) {</span></div><div class="token-line"><span class="token plain">    	fmt.Printf(&quot;worker %d: is working...\n&quot;, i)</span></div><div class="token-line"><span class="token plain">    	time.Sleep(1 * time.Second)</span></div><div class="token-line"><span class="token plain">    	fmt.Printf(&quot;worker %d: works done\n&quot;, i)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func spawnGroup(f func(i int), num int, mu *sync.Mutex) &lt;-chan signal {</span></div><div class="token-line"><span class="token plain">    	c := make(chan signal)</span></div><div class="token-line"><span class="token plain">    	var wg sync.WaitGroup</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	for i := 0; i &lt; num; i++ {</span></div><div class="token-line"><span class="token plain">    		wg.Add(1)</span></div><div class="token-line"><span class="token plain">    		go func(i int) {</span></div><div class="token-line"><span class="token plain">    			for {</span></div><div class="token-line"><span class="token plain">    				mu.Lock()</span></div><div class="token-line"><span class="token plain">    				if !ready {</span></div><div class="token-line"><span class="token plain">    					mu.Unlock()</span></div><div class="token-line"><span class="token plain">    					time.Sleep(100 * time.Millisecond)</span></div><div class="token-line"><span class="token plain">    					continue</span></div><div class="token-line"><span class="token plain">    				}</span></div><div class="token-line"><span class="token plain">    				mu.Unlock()</span></div><div class="token-line"><span class="token plain">    				fmt.Printf(&quot;worker %d: start to work...\n&quot;, i)</span></div><div class="token-line"><span class="token plain">    				f(i)</span></div><div class="token-line"><span class="token plain">    				wg.Done()</span></div><div class="token-line"><span class="token plain">    				return</span></div><div class="token-line"><span class="token plain">    			}</span></div><div class="token-line"><span class="token plain">    		}(i + 1)</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	go func() {</span></div><div class="token-line"><span class="token plain">    		wg.Wait()</span></div><div class="token-line"><span class="token plain">    		c &lt;- signal(struct{}{})</span></div><div class="token-line"><span class="token plain">    	}()</span></div><div class="token-line"><span class="token plain">    	return c</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">    	fmt.Println(&quot;start a group of workers...&quot;)</span></div><div class="token-line"><span class="token plain">    	mu := &amp;sync.Mutex{}</span></div><div class="token-line"><span class="token plain">    	c := spawnGroup(worker, 5, mu)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	time.Sleep(5 * time.Second) // 模拟ready前的准备工作</span></div><div class="token-line"><span class="token plain">    	fmt.Println(&quot;the group of workers start to work...&quot;)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	mu.Lock()</span></div><div class="token-line"><span class="token plain">    	ready = true</span></div><div class="token-line"><span class="token plain">    	mu.Unlock()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	&lt;-c</span></div><div class="token-line"><span class="token plain">    	fmt.Println(&quot;the group of workers work done!&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>就像前面提到的，轮询的方式开销大，轮询间隔设置的不同，条件检查的及时性也会受到影响。<br/><code>sync.Cond</code>为Goroutine在这个场景下提供了另一种可选的、资源消耗更小、使用体验更佳的同步方式。使用条件变量原语，我们可以在实现相同目标的同时，避免对条件的轮询。</p><p>我们用<code>sync.Cond</code>对上面的例子进行改造，改造后的代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type signal struct{}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    var ready bool</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func worker(i int) {</span></div><div class="token-line"><span class="token plain">    	fmt.Printf(&quot;worker %d: is working...\n&quot;, i)</span></div><div class="token-line"><span class="token plain">    	time.Sleep(1 * time.Second)</span></div><div class="token-line"><span class="token plain">    	fmt.Printf(&quot;worker %d: works done\n&quot;, i)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func spawnGroup(f func(i int), num int, groupSignal *sync.Cond) &lt;-chan signal {</span></div><div class="token-line"><span class="token plain">    	c := make(chan signal)</span></div><div class="token-line"><span class="token plain">    	var wg sync.WaitGroup</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	for i := 0; i &lt; num; i++ {</span></div><div class="token-line"><span class="token plain">    		wg.Add(1)</span></div><div class="token-line"><span class="token plain">    		go func(i int) {</span></div><div class="token-line"><span class="token plain">    			groupSignal.L.Lock()</span></div><div class="token-line"><span class="token plain">    			for !ready {</span></div><div class="token-line"><span class="token plain">    				groupSignal.Wait()</span></div><div class="token-line"><span class="token plain">    			}</span></div><div class="token-line"><span class="token plain">    			groupSignal.L.Unlock()</span></div><div class="token-line"><span class="token plain">    			fmt.Printf(&quot;worker %d: start to work...\n&quot;, i)</span></div><div class="token-line"><span class="token plain">    			f(i)</span></div><div class="token-line"><span class="token plain">    			wg.Done()</span></div><div class="token-line"><span class="token plain">    		}(i + 1)</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	go func() {</span></div><div class="token-line"><span class="token plain">    		wg.Wait()</span></div><div class="token-line"><span class="token plain">    		c &lt;- signal(struct{}{})</span></div><div class="token-line"><span class="token plain">    	}()</span></div><div class="token-line"><span class="token plain">    	return c</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">    	fmt.Println(&quot;start a group of workers...&quot;)</span></div><div class="token-line"><span class="token plain">    	groupSignal := sync.NewCond(&amp;sync.Mutex{})</span></div><div class="token-line"><span class="token plain">    	c := spawnGroup(worker, 5, groupSignal)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	time.Sleep(5 * time.Second) // 模拟ready前的准备工作</span></div><div class="token-line"><span class="token plain">    	fmt.Println(&quot;the group of workers start to work...&quot;)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	groupSignal.L.Lock()</span></div><div class="token-line"><span class="token plain">    	ready = true</span></div><div class="token-line"><span class="token plain">    	groupSignal.Broadcast()</span></div><div class="token-line"><span class="token plain">    	groupSignal.L.Unlock()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	&lt;-c</span></div><div class="token-line"><span class="token plain">    	fmt.Println(&quot;the group of workers work done!&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们运行这个示例程序，得到：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">start a group of workers...</span></div><div class="token-line"><span class="token plain">    the group of workers start to work...</span></div><div class="token-line"><span class="token plain">    worker 2: start to work...</span></div><div class="token-line"><span class="token plain">    worker 2: is working...</span></div><div class="token-line"><span class="token plain">    worker 3: start to work...</span></div><div class="token-line"><span class="token plain">    worker 3: is working...</span></div><div class="token-line"><span class="token plain">    worker 1: start to work...</span></div><div class="token-line"><span class="token plain">    worker 1: is working...</span></div><div class="token-line"><span class="token plain">    worker 4: start to work...</span></div><div class="token-line"><span class="token plain">    worker 5: start to work...</span></div><div class="token-line"><span class="token plain">    worker 5: is working...</span></div><div class="token-line"><span class="token plain">    worker 4: is working...</span></div><div class="token-line"><span class="token plain">    worker 4: works done</span></div><div class="token-line"><span class="token plain">    worker 2: works done</span></div><div class="token-line"><span class="token plain">    worker 3: works done</span></div><div class="token-line"><span class="token plain">    worker 1: works done</span></div><div class="token-line"><span class="token plain">    worker 5: works done</span></div><div class="token-line"><span class="token plain">    the group of workers work done!</span></div></pre></div><p>我们看到，<code>sync.Cond</code>实例的初始化，需要一个满足实现了<code>sync.Locker</code>接口的类型实例，通常我们使用<code>sync.Mutex</code>。</p><p>条件变量需要这个互斥锁来同步临界区，保护用作条件的数据。加锁后，各个等待条件成立的Goroutine判断条件是否成立，如果不成立，则调用<code>sync.Cond</code>的Wait方法进入等待状态。Wait方法在Goroutine挂起前会进行Unlock操作。</p><p>当main goroutine将<code>ready</code>置为true，并调用<code>sync.Cond</code>的Broadcast方法后，各个阻塞的Goroutine将被唤醒，并从Wait方法中返回。Wait方法返回前，Wait方法会再次加锁让Goroutine进入临界区。接下来Goroutine会再次对条件数据进行判定，如果条件成立，就会解锁并进入下一个工作阶段；如果条件依旧不成立，那么会再次进入循环体，并调用Wait方法挂起等待。</p><p>和<code>sync.Mutex</code> 、<code>sync.RWMutex</code>等相比，<code>sync.Cond</code> 应用的场景更为有限，只有在需要“等待某个条件成立”的场景下，Cond才有用武之地。</p><p>其实，面向CSP并发模型的channel原语和面向传统共享内存并发模型的sync包提供的原语，已经能够满足Go语言应用并发设计中99.9%的并发同步需求了。而剩余那0.1%的需求，我们可以使用Go标准库提供的atomic包来实现。</p><h2 id="原子操作atomic-operations"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/08#原子操作atomic-operations"><span class="icon icon-link"></span></a>原子操作（atomic operations）</h2><p>atomic包是Go语言给用户提供的原子操作原语的相关接口。原子操作（atomic operations）是相对于普通指令操作而言的。</p><p>我们以一个整型变量自增的语句为例说明一下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var a int</span></div><div class="token-line"><span class="token plain">    a++</span></div></pre></div><p>a++这行语句需要3条普通机器指令来完成变量a的自增：</p><ul><li>LOAD：将变量从内存加载到CPU寄存器；</li><li>ADD：执行加法指令；</li><li>STORE：将结果存储回原内存地址中。</li></ul><p>这3条普通指令在执行过程中是可以被中断的。而原子操作的指令是不可中断的，它就好比一个事务，要么不执行，一旦执行就一次性全部执行完毕，中间不可分割。也正因为如此，原子操作也可以被用于共享数据的并发同步。</p><p>原子操作由底层硬件直接提供支持，是一种硬件实现的指令级的“事务”，因此相对于操作系统层面和Go运行时层面提供的同步技术而言，它更为原始。</p><p>atomic包封装了CPU实现的部分原子操作指令，为用户层提供体验良好的原子操作函数，因此atomic包中提供的原语更接近硬件底层，也更为低级，它也常被用于实现更为高级的并发同步技术，比如channel和sync包中的同步原语。</p><p>我们以atomic.SwapInt64函数在x86_64平台上的实现为例，看看这个函数的实现方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// $GOROOT/src/sync/atomic/doc.go</span></div><div class="token-line"><span class="token plain">    func SwapInt64(addr *int64, new int64) (old int64)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // $GOROOT/src/sync/atomic/asm.s</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    TEXT ·SwapInt64(SB),NOSPLIT,$0</span></div><div class="token-line"><span class="token plain">            JMP     runtime∕internal∕atomic·Xchg64(SB)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // $GOROOT/src/runtime/internal/atomic/asm_amd64.s</span></div><div class="token-line"><span class="token plain">    TEXT runtime∕internal∕atomic·Xchg64(SB), NOSPLIT, $0-24</span></div><div class="token-line"><span class="token plain">            MOVQ    ptr+0(FP), BX</span></div><div class="token-line"><span class="token plain">            MOVQ    new+8(FP), AX</span></div><div class="token-line"><span class="token plain">            XCHGQ   AX, 0(BX)</span></div><div class="token-line"><span class="token plain">            MOVQ    AX, ret+16(FP)</span></div><div class="token-line"><span class="token plain">            RET</span></div></pre></div><p>从函数SwapInt64的实现中，我们可以看到：它基本就是对x86_64 CPU实现的原子操作指令<code>XCHGQ</code>的直接封装。</p><p>原子操作的特性，让atomic包也可以被用作对共享数据的并发同步，那么和更为高级的channel以及sync包中原语相比，我们究竟该怎么选择呢？</p><p>我们先来看看atomic包提供了哪些能力。</p><p>atomic包提供了两大类原子操作接口，一类是针对整型变量的，包括有符号整型、无符号整型以及对应的指针类型；另外一类是针对自定义类型的。因此，第一类原子操作接口的存在让atomic包天然适合去实现某一个共享整型变量的并发同步。</p><p>我们再看一个例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var n1 int64</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func addSyncByAtomic(delta int64) int64 {</span></div><div class="token-line"><span class="token plain">    	return atomic.AddInt64(&amp;n1, delta)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func readSyncByAtomic() int64 {</span></div><div class="token-line"><span class="token plain">    	return atomic.LoadInt64(&amp;n1)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    var n2 int64</span></div><div class="token-line"><span class="token plain">    var rwmu sync.RWMutex</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func addSyncByRWMutex(delta int64) {</span></div><div class="token-line"><span class="token plain">    	rwmu.Lock()</span></div><div class="token-line"><span class="token plain">    	n2 += delta</span></div><div class="token-line"><span class="token plain">    	rwmu.Unlock()</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func readSyncByRWMutex() int64 {</span></div><div class="token-line"><span class="token plain">    	var n int64</span></div><div class="token-line"><span class="token plain">    	rwmu.RLock()</span></div><div class="token-line"><span class="token plain">    	n = n2</span></div><div class="token-line"><span class="token plain">    	rwmu.RUnlock()</span></div><div class="token-line"><span class="token plain">    	return n</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func BenchmarkAddSyncByAtomic(b *testing.B) {</span></div><div class="token-line"><span class="token plain">    	b.RunParallel(func(pb *testing.PB) {</span></div><div class="token-line"><span class="token plain">    		for pb.Next() {</span></div><div class="token-line"><span class="token plain">    			addSyncByAtomic(1)</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    	})</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func BenchmarkReadSyncByAtomic(b *testing.B) {</span></div><div class="token-line"><span class="token plain">    	b.RunParallel(func(pb *testing.PB) {</span></div><div class="token-line"><span class="token plain">    		for pb.Next() {</span></div><div class="token-line"><span class="token plain">    			readSyncByAtomic()</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    	})</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func BenchmarkAddSyncByRWMutex(b *testing.B) {</span></div><div class="token-line"><span class="token plain">    	b.RunParallel(func(pb *testing.PB) {</span></div><div class="token-line"><span class="token plain">    		for pb.Next() {</span></div><div class="token-line"><span class="token plain">    			addSyncByRWMutex(1)</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    	})</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func BenchmarkReadSyncByRWMutex(b *testing.B) {</span></div><div class="token-line"><span class="token plain">    	b.RunParallel(func(pb *testing.PB) {</span></div><div class="token-line"><span class="token plain">    		for pb.Next() {</span></div><div class="token-line"><span class="token plain">    			readSyncByRWMutex()</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    	})</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们分别在cpu=2、 8、16、32的情况下运行上述性能基准测试，得到结果如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">goos: darwin</span></div><div class="token-line"><span class="token plain">    goarch: amd64</span></div><div class="token-line"><span class="token plain">    ... ...</span></div><div class="token-line"><span class="token plain">    BenchmarkAddSyncByAtomic-2     	75426774	        17.69 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkReadSyncByAtomic-2    	1000000000	         0.7437 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkAddSyncByRWMutex-2    	39041671	        30.16 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkReadSyncByRWMutex-2   	41325093	        28.48 ns/op</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    BenchmarkAddSyncByAtomic-8     	77497987	        15.25 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkReadSyncByAtomic-8    	1000000000	         0.2395 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkAddSyncByRWMutex-8    	17702034	        67.16 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkReadSyncByRWMutex-8   	29966182	        40.37 ns/op</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    BenchmarkAddSyncByAtomic-16      	57727968	        20.39 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkReadSyncByAtomic-16     	1000000000	         0.2536 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkAddSyncByRWMutex-16     	15029635	        78.61 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkReadSyncByRWMutex-16    	29722464	        40.28 ns/op</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    BenchmarkAddSyncByAtomic-32      	58010497	        20.40 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkReadSyncByAtomic-32     	1000000000	         0.2402 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkAddSyncByRWMutex-32     	11748312	        93.15 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkReadSyncByRWMutex-32    	29845912	        40.54 ns/op</span></div></pre></div><p>通过这个运行结果，我们可以得出一些结论：</p><ul><li>读写锁的性能随着并发量增大的情况，与前面讲解的sync.RWMutex一致；</li><li>利用原子操作的无锁并发写的性能，随着并发量增大几乎保持恒定；</li><li>利用原子操作的无锁并发读的性能，随着并发量增大有持续提升的趋势，并且性能是读锁的约200倍。</li></ul><p>通过这些结论，我们大致可以看到atomic原子操作的特性：随着并发量提升，使用atomic实现的<strong>共享变量</strong>的并发读写性能表现更为稳定，尤其是原子读操作，和sync包中的读写锁原语比起来，atomic表现出了更好的伸缩性和高性能。</p><p>由此，我们也可以看出atomic包更适合<strong>一些对性能十分敏感、并发量较大且读多写少的场合</strong>。</p><p>不过，atomic原子操作可用来同步的范围有比较大限制，只能同步一个整型变量或自定义类型变量。如果我们要对一个复杂的临界区数据进行同步，那么首选的依旧是sync包中的原语。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/08#小结"><span class="icon icon-link"></span></a>小结</h2><p>好了，今天的课讲到这里就结束了，现在我们一起来回顾一下吧。</p><p>虽然Go推荐基于通信来共享内存的并发设计风格，但Go并没有彻底抛弃对基于共享内存并发模型的支持，Go通过标准库的sync包以及atomic包提供了低级同步原语。这些原语有着它们自己的应用场景。</p><p>如果我们考虑使用低级同步原语，一般都是因为低级同步原语可以提供<strong>更佳的性能表现</strong>，性能基准测试结果告诉我们，使用低级同步原语的性能可以高出channel许多倍。在性能敏感的场景下，我们依然离不开这些低级同步原语。</p><p>在使用sync包提供的同步原语之前，我们一定要牢记这些原语使用的注意事项：<strong>不要复制首次使用后的Mutex/RWMutex/Cond等</strong>。一旦复制，你将很大可能得到意料之外的运行结果。</p><p>sync包中的低级同步原语各有各的擅长领域，你可以记住：</p><ul><li>在具有一定并发量且读多写少的场合使用RWMutex；</li><li>在需要“等待某个条件成立”的场景下使用Cond；</li><li>当你不确定使用什么原语时，那就使用Mutex吧。</li></ul><p>如果你对同步的性能有极致要求，且并发量较大，读多写少，那么可以考虑一下atomic包提供的原子操作函数。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/08#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>使用基于共享内存的并发模型时，最令人头疼的可能就是“死锁”问题的存在了。你了解死锁的产生条件么？能编写一个程序模拟一下死锁的发生么？</p><p>欢迎你把这节课分享给更多对Go并发感兴趣的朋友。我是Tony Bai，我们下节课见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/08.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:33</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
