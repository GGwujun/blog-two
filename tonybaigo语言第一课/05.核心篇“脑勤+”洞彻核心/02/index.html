<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>29｜接口：为什么nil接口不等于nil？</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a aria-current="page" class="active" href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a aria-current="page" class="active" href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-two/tonybaigo语言第一课/01.开篇词/01"><span>开篇词｜这样入门Go，才能少走弯路</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/02.前置篇心定之旅">02.前置篇心定之旅</a><ul><li><a href="/blog-two/tonybaigo语言第一课/02.前置篇心定之旅/01"><span>01｜前世今生：你不得不了解的Go的历史和现状</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/02.前置篇心定之旅/02"><span>02｜拒绝“Hello and Bye”：Go语言的设计哲学是怎么一回事？</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手">03.入门篇勤加练手</a><ul><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/01"><span>03｜配好环境：选择一种最适合你的Go安装方法</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/02"><span>04｜初窥门径：一个Go程序的结构是怎样的？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/03"><span>05｜标准先行：Go项目的布局标准是什么？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/04"><span>06｜构建模式：Go是怎么解决包依赖管理问题的？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/05"><span>07｜构建模式：Go Module的6类常规操作</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/06"><span>08｜入口函数与包初始化：搞清Go程序的执行次序</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/07"><span>09｜即学即练：构建一个Web服务就是这么简单</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解">04.基础篇“脑勤”多理解</a><ul><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/01"><span>10｜变量声明：静态语言有别于动态语言的重要特征</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/02"><span>11｜代码块与作用域：如何保证变量不会被遮蔽？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/03"><span>12｜基本数据类型：Go原生支持的数值类型有哪些？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/04"><span>13｜基本数据类型：为什么Go要原生支持字符串类型？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/05"><span>14｜常量：Go在“常量”设计上的创新有哪些？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/06"><span>15｜同构复合类型：从定长数组到变长切片</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/07"><span>16｜复合数据类型：原生map类型的实现机制是怎样的？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/08"><span>17｜复合数据类型：用结构体建立对真实世界的抽象</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/09"><span>18｜控制结构：if的“快乐路径”原则</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/10"><span>19｜控制结构：Go的for循环，仅此一种</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/11"><span>20｜控制结构：Go中的switch语句有哪些变化？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/12"><span>21｜函数：请叫我“一等公民”</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/13"><span>22｜函数：怎么结合多返回值进行错误处理？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/14"><span>期中测试｜一起检验下你的学习成果吧</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/15"><span>23｜函数：怎么让函数更简洁健壮？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/16"><span>24｜方法：理解“方法”的本质</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/17"><span>25｜方法：方法集合与如何选择receiver类型？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/18"><span>26｜方法：如何用类型嵌入模拟实现“继承”？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/19"><span>27｜即学即练：跟踪函数调用链，理解代码更直观</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/20"><span>用户故事｜罗杰：我的Go语言学习之路</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心">05.核心篇“脑勤+”洞彻核心</a><ul><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/01"><span>28｜接口：接口即契约</span></a></li><li><a aria-current="page" class="active" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02"><span>29｜接口：为什么nil接口不等于nil？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/03"><span>30｜接口：Go中最强大的魔法</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/04"><span>元旦快乐｜这是一份暂时停更的声明</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/05"><span>31｜并发：Go的并发方案实现方案是怎样的？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/06"><span>32｜并发：聊聊Goroutine调度器的原理</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07"><span>33｜并发：小channel中蕴含大智慧</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/08"><span>34｜并发：如何使用共享变量？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/09"><span>35｜即学即练：如何实现一个轻量级线程池？</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”">06.实战篇打通“最后一公里”</a><ul><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01"><span>36｜打稳根基：怎么实现一个TCP服务器？（上）</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/02"><span>37｜代码操练：怎么实现一个TCP服务器？（中）</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/03"><span>38｜成果优化：怎么实现一个TCP服务器？（下）</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/04"><span>结课测试｜快来检验下你的学习成果吧！</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇">07.加餐篇</a><ul><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/01"><span>加餐｜我“私藏”的那些优质且权威的Go语言学习资料</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/02"><span>加餐｜聊聊Go 1.17版本的那些新特性</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/03"><span>加餐｜如何拉取私有的Go Module？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/04"><span>加餐｜作为Go Module的作者，你应该知道的几件事</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/05"><span>加餐｜聊聊最近大热的Go泛型</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/06"><span>加餐｜聊聊Go语言的指针</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵">08.大咖助阵</a><ul><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/01"><span>大咖助阵｜孔令飞：从小白到“老鸟”，我的Go语言进阶之路</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/02"><span>大咖助阵｜叶剑峰：Go语言中常用的那些代码优化点</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/03"><span>大咖助阵｜徐祥曦：从销售到分布式存储工程师，我与 Go  的故事</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/04"><span>大咖助阵｜曹春晖：聊聊 Go 语言的 GC 实现</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/05"><span>大咖助阵｜大明：Go泛型，泛了，但没有完全泛</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/06"><span>大咖助阵｜海纳：聊聊语言中的类型系统与泛型</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/09.结束语">09.结束语</a><ul><li><a href="/blog-two/tonybaigo语言第一课/09.结束语/01"><span>结束语｜和你一起迎接Go的黄金十年</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/summary">tonybaigo语言第一课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="接口的静态特性与动态特性" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02#接口的静态特性与动态特性"><span>接口的静态特性与动态特性</span></a></li><li title="nil error值 != nil" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02#nil-error值--nil"><span>nil error值 != nil</span></a></li><li title="接口类型变量的内部表示" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02#接口类型变量的内部表示"><span>接口类型变量的内部表示</span></a></li><li title="第一种：nil接口变量" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02#第一种nil接口变量"><span>第一种：nil接口变量</span></a></li><li title="第二种：空接口类型变量" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02#第二种空接口类型变量"><span>第二种：空接口类型变量</span></a></li><li title="第三种：非空接口类型变量" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02#第三种非空接口类型变量"><span>第三种：非空接口类型变量</span></a></li><li title="第四种：空接口类型变量与非空接口类型变量的等值比较" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02#第四种空接口类型变量与非空接口类型变量的等值比较"><span>第四种：空接口类型变量与非空接口类型变量的等值比较</span></a></li><li title="输出接口类型变量内部表示的详细信息" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02#输出接口类型变量内部表示的详细信息"><span>输出接口类型变量内部表示的详细信息</span></a></li><li title="接口类型的装箱（boxing）原理" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02#接口类型的装箱boxing原理"><span>接口类型的装箱（boxing）原理</span></a></li><li title="小结" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="29接口为什么nil接口不等于nil"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02#29接口为什么nil接口不等于nil"><span class="icon icon-link"></span></a>29｜接口：为什么nil接口不等于nil？</h1><p>你好，我是Tony Bai。</p><p>上一讲我们学习了Go接口的基础知识与设计惯例，知道Go接口是构建Go应用骨架的重要元素。从语言设计角度来看，Go语言的接口（interface）和并发（concurrency）原语是我最喜欢的两类Go语言语法元素。Go语言核心团队的技术负责人Russ Cox也曾说过这样一句话：“<strong>如果要从Go语言中挑选出一个特性放入其他语言，我会选择接口</strong>”，这句话足以说明接口这一语法特性在这位Go语言大神心目中的地位。</p><p>为什么接口在Go中有这么高的地位呢？这是因为<strong>接口是Go这门静态语言中唯一“动静兼备”的语法特性</strong>。而且，接口“动静兼备”的特性给Go带来了强大的表达能力，但同时也给Go语言初学者带来了不少困惑。要想真正解决这些困惑，我们必须深入到Go运行时层面，看看Go语言在运行时是如何表示接口类型的。在这一讲中，我就带着你一起深入到接口类型的运行时表示层面看看。</p><p>好，在解惑之前，我们先来看看接口的静态与动态特性，看看“动静皆备”到底是什么意思。</p><h2 id="接口的静态特性与动态特性"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02#接口的静态特性与动态特性"><span class="icon icon-link"></span></a>接口的静态特性与动态特性</h2><p>接口的<strong>静态特性</strong>体现在<strong>接口类型变量具有静态类型</strong>，比如<code>var err error</code>中变量err的静态类型为error。拥有静态类型，那就意味着编译器会在编译阶段对所有接口类型变量的赋值操作进行类型检查，编译器会检查右值的类型是否实现了该接口方法集合中的所有方法。如果不满足，就会报错：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var err error = 1 // cannot use 1 (type int) as type error in assignment: int does not implement error (missing Error method)</span></div></pre></div><p>而接口的<strong>动态特性</strong>，就体现在接口类型变量在运行时还存储了右值的真实类型信息，这个右值的真实类型被称为接口类型变量的<strong>动态类型</strong>。你看一下下面示例代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var err error</span></div><div class="token-line"><span class="token plain">    err = errors.New(&quot;error1&quot;)</span></div><div class="token-line"><span class="token plain">    fmt.Printf(&quot;%T\n&quot;, err)  // *errors.errorString</span></div></pre></div><p>我们可以看到，这个示例通过errros.New构造了一个错误值，赋值给了error接口类型变量err，并通过fmt.Printf函数输出接口类型变量err的动态类型为*errors.errorString。</p><p>那接口的这种“动静皆备”的特性，又带来了什么好处呢？</p><p>首先，接口类型变量在程序运行时可以被赋值为不同的动态类型变量，每次赋值后，接口类型变量中存储的动态类型信息都会发生变化，这让Go语言可以像动态语言（比如Python）那样拥有使用<a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Duck_typing">Duck Typing（鸭子类型）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的灵活性。所谓鸭子类型，就是指某类型所表现出的特性（比如是否可以作为某接口类型的右值），不是由其基因（比如C++中的父类）决定的，而是由类型所表现出来的行为（比如类型拥有的方法）决定的。</p><p>比如下面的例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type QuackableAnimal interface {</span></div><div class="token-line"><span class="token plain">        Quack()</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    type Duck struct{}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func (Duck) Quack() {</span></div><div class="token-line"><span class="token plain">        println(&quot;duck quack!&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    type Dog struct{}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func (Dog) Quack() {</span></div><div class="token-line"><span class="token plain">        println(&quot;dog quack!&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    type Bird struct{}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func (Bird) Quack() {</span></div><div class="token-line"><span class="token plain">        println(&quot;bird quack!&quot;)</span></div><div class="token-line"><span class="token plain">    }                         </span></div><div class="token-line"><span class="token plain">                              </span></div><div class="token-line"><span class="token plain">    func AnimalQuackInForest(a QuackableAnimal) {</span></div><div class="token-line"><span class="token plain">        a.Quack()             </span></div><div class="token-line"><span class="token plain">    }                         </span></div><div class="token-line"><span class="token plain">                              </span></div><div class="token-line"><span class="token plain">    func main() {             </span></div><div class="token-line"><span class="token plain">        animals := []QuackableAnimal{new(Duck), new(Dog), new(Bird)}</span></div><div class="token-line"><span class="token plain">        for _, animal := range animals {</span></div><div class="token-line"><span class="token plain">            AnimalQuackInForest(animal)</span></div><div class="token-line"><span class="token plain">        }  </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个例子中，我们用接口类型QuackableAnimal来代表具有“会叫”这一特征的动物，而Duck、Bird和Dog类型各自都具有这样的特征，于是我们可以将这三个类型的变量赋值给QuackableAnimal接口类型变量a。每次赋值，变量a中存储的动态类型信息都不同，Quack方法的执行结果将根据变量a中存储的动态类型信息而定。</p><p>这里的Duck、Bird、Dog都是“鸭子类型”，但它们之间并没有什么联系，之所以能作为右值赋值给QuackableAnimal类型变量，只是因为他们表现出了QuackableAnimal所要求的特征罢了。</p><p>不过，与动态语言不同的是，Go接口还可以保证“动态特性”使用时的安全性。比如，编译器在编译期就可以捕捉到将int类型变量传给QuackableAnimal接口类型变量这样的明显错误，决不会让这样的错误遗漏到运行时才被发现。</p><p>接口类型的动静特性让我们看到了接口类型的强大，但在日常使用过程中，很多人都会产生各种困惑，其中最经典的一个困惑莫过于“nil的error值不等于nil”了。下面我们来详细看一下。</p><h2 id="nil-error值--nil"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02#nil-error值--nil"><span class="icon icon-link"></span></a>nil error值 != nil</h2><p>这里我们直接来看一段改编自<a target="_blank" rel="noopener noreferrer" href="https://go.dev/doc/faq#nil_error">GO FAQ中的例子<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type MyError struct {</span></div><div class="token-line"><span class="token plain">        error</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    var ErrBad = MyError{</span></div><div class="token-line"><span class="token plain">        error: errors.New(&quot;bad things happened&quot;),</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func bad() bool {</span></div><div class="token-line"><span class="token plain">        return false</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func returnsError() error {</span></div><div class="token-line"><span class="token plain">        var p *MyError = nil</span></div><div class="token-line"><span class="token plain">        if bad() {</span></div><div class="token-line"><span class="token plain">            p = &amp;ErrBad</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return p</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">        err := returnsError()</span></div><div class="token-line"><span class="token plain">        if err != nil {</span></div><div class="token-line"><span class="token plain">            fmt.Printf(&quot;error occur: %+v\n&quot;, err)</span></div><div class="token-line"><span class="token plain">            return</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        fmt.Println(&quot;ok&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这个例子中，我们的关注点集中在returnsError这个函数上面。这个函数定义了一个<code>*MyError</code>类型的变量p，初值为nil。如果函数bad返回false，returnsError函数就会直接将p（此时p = nil）作为返回值返回给调用者，之后调用者会将returnsError函数的返回值（error接口类型）与nil进行比较，并根据比较结果做出最终处理。</p><p>如果你是一个初学者，我猜你的的思路大概是这样的：p为nil，returnsError返回p，那么main函数中的err就等于nil，于是程序输出<strong>ok</strong>后退出。</p><p>但真实的运行结果是什么样的呢？我们来看一下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">error occur: &lt;nil&gt;</span></div></pre></div><p>我们看到，示例程序并未如我们前面预期的那样输出ok。程序显然是进入了错误处理分支，输出了err的值。那这里就有一个问题了：明明returnsError函数返回的p值为nil，为什么却满足了<code>if err != nil</code>的条件进入错误处理分支呢？</p><p>要想弄清楚这个问题，我们需要进一步了解接口类型变量的内部表示。</p><h2 id="接口类型变量的内部表示"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02#接口类型变量的内部表示"><span class="icon icon-link"></span></a>接口类型变量的内部表示</h2><p>接口类型“动静兼备”的特性也决定了它的变量的内部表示绝不像一个静态类型变量（如int、float64）那样简单，我们可以在<code>$GOROOT/src/runtime/runtime2.go</code>中找到接口类型变量在运行时的表示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// $GOROOT/src/runtime/runtime2.go</span></div><div class="token-line"><span class="token plain">    type iface struct {</span></div><div class="token-line"><span class="token plain">        tab  *itab</span></div><div class="token-line"><span class="token plain">        data unsafe.Pointer</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    type eface struct {</span></div><div class="token-line"><span class="token plain">        _type *_type</span></div><div class="token-line"><span class="token plain">        data  unsafe.Pointer</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们看到，在运行时层面，接口类型变量有两种内部表示：<code>iface</code>和<code>eface</code>，这两种表示分别用于不同的接口类型变量：</p><ul><li>eface用于表示没有方法的空接口（<strong>e</strong>mpty inter<strong>face</strong>）类型变量，也就是interface<!-- -->{<!-- -->}<!-- -->类型的变量；</li><li>iface用于表示其余拥有方法的接口<strong>i</strong>nter<strong>face</strong>类型变量。</li></ul><p>这两个结构的共同点是它们都有两个指针字段，并且第二个指针字段的功能相同，都是指向当前赋值给该接口类型变量的动态类型变量的值。</p><p>那它们的不同点在哪呢？就在于eface表示的空接口类型并没有方法列表，因此它的第一个指针字段指向一个<code>_type</code>类型结构，这个结构为该接口类型变量的动态类型的信息，它的定义是这样的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// $GOROOT/src/runtime/type.go</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    type _type struct {</span></div><div class="token-line"><span class="token plain">        size       uintptr</span></div><div class="token-line"><span class="token plain">        ptrdata    uintptr // size of memory prefix holding all pointers</span></div><div class="token-line"><span class="token plain">        hash       uint32</span></div><div class="token-line"><span class="token plain">        tflag      tflag</span></div><div class="token-line"><span class="token plain">        align      uint8</span></div><div class="token-line"><span class="token plain">        fieldAlign uint8</span></div><div class="token-line"><span class="token plain">        kind       uint8</span></div><div class="token-line"><span class="token plain">        // function for comparing objects of this type</span></div><div class="token-line"><span class="token plain">        // (ptr to object A, ptr to object B) -&gt; ==?</span></div><div class="token-line"><span class="token plain">        equal func(unsafe.Pointer, unsafe.Pointer) bool</span></div><div class="token-line"><span class="token plain">        // gcdata stores the GC type data for the garbage collector.</span></div><div class="token-line"><span class="token plain">        // If the KindGCProg bit is set in kind, gcdata is a GC program.</span></div><div class="token-line"><span class="token plain">        // Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span></div><div class="token-line"><span class="token plain">        gcdata    *byte</span></div><div class="token-line"><span class="token plain">        str       nameOff</span></div><div class="token-line"><span class="token plain">        ptrToThis typeOff</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>而iface除了要存储动态类型信息之外，还要存储接口本身的信息（接口的类型信息、方法列表信息等）以及动态类型所实现的方法的信息，因此iface的第一个字段指向一个<code>itab</code>类型结构。itab结构的定义如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// $GOROOT/src/runtime/runtime2.go</span></div><div class="token-line"><span class="token plain">    type itab struct {</span></div><div class="token-line"><span class="token plain">        inter *interfacetype</span></div><div class="token-line"><span class="token plain">        _type *_type</span></div><div class="token-line"><span class="token plain">        hash  uint32 // copy of _type.hash. Used for type switches.</span></div><div class="token-line"><span class="token plain">        _     [4]byte</span></div><div class="token-line"><span class="token plain">        fun   [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里我们也可以看到，itab结构中的第一个字段<code>inter</code>指向的interfacetype结构，存储着这个接口类型自身的信息。你看一下下面这段代码表示的interfacetype类型定义， 这个interfacetype结构由类型信息（typ）、包路径名（pkgpath）和接口方法集合切片（mhdr）组成。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// $GOROOT/src/runtime/type.go</span></div><div class="token-line"><span class="token plain">    type interfacetype struct {</span></div><div class="token-line"><span class="token plain">        typ     _type</span></div><div class="token-line"><span class="token plain">        pkgpath name</span></div><div class="token-line"><span class="token plain">        mhdr    []imethod</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>itab结构中的字段<code>_type</code>则存储着这个接口类型变量的动态类型的信息，字段<code>fun</code>则是动态类型已实现的接口方法的调用地址数组。</p><p>下面我们再结合例子用图片来直观展现eface和iface的结构。首先我们看一个用eface表示的空接口类型变量的例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type T struct {</span></div><div class="token-line"><span class="token plain">        n int</span></div><div class="token-line"><span class="token plain">        s string</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">        var t = T {</span></div><div class="token-line"><span class="token plain">            n: 17,</span></div><div class="token-line"><span class="token plain">            s: &quot;hello, interface&quot;,</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        var ei interface{} = t // Go运行时使用eface结构表示ei</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个例子中的空接口类型变量ei在Go运行时的表示是这样的：</p><p><img src="https://static001.geekbang.org/resource/image/2d/ae/2d8f103e2973d2e31c9f4237e6799eae.jpg?wh=1920x1047" alt="图片"/></p><p>我们看到空接口类型的表示较为简单，图中上半部分_type字段指向它的动态类型T的类型信息，下半部分的data则是指向一个T类型的实例值。</p><p>我们再来看一个更复杂的用iface表示非空接口类型变量的例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type T struct {</span></div><div class="token-line"><span class="token plain">        n int</span></div><div class="token-line"><span class="token plain">        s string</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func (T) M1() {}</span></div><div class="token-line"><span class="token plain">    func (T) M2() {}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    type NonEmptyInterface interface {</span></div><div class="token-line"><span class="token plain">        M1()</span></div><div class="token-line"><span class="token plain">        M2()</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">        var t = T{</span></div><div class="token-line"><span class="token plain">            n: 18,</span></div><div class="token-line"><span class="token plain">            s: &quot;hello, interface&quot;,</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        var i NonEmptyInterface = t</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>和eface比起来，iface的表示稍微复杂些。我也画了一幅表示上面NonEmptyInterface接口类型变量在Go运行时表示的示意图：</p><p><img src="https://static001.geekbang.org/resource/image/36/44/369810ba10b9b8792d8edfd8e931b344.jpg?wh=1980x1080" alt=""/></p><p>由上面的这两幅图，我们可以看出，每个接口类型变量在运行时的表示都是由两部分组成的，针对不同接口类型我们可以简化记作：<code>eface(_type, data)</code>和<code>iface(tab, data)</code>。</p><p>而且，虽然eface和iface的第一个字段有所差别，但tab和_type可以统一看作是动态类型的类型信息。Go语言中每种类型都会有唯一的_type信息，无论是内置原生类型，还是自定义类型都有。Go运行时会为程序内的全部类型建立只读的共享_type信息表，因此拥有相同动态类型的同类接口类型变量的_type/tab信息是相同的。</p><p>而接口类型变量的data部分则是指向一个动态分配的内存空间，这个内存空间存储的是赋值给接口类型变量的动态类型变量的值。未显式初始化的接口类型变量的值为<code>nil</code>，也就是这个变量的_type/tab和data都为nil。</p><p>也就是说，我们判断两个接口类型变量是否相同，只需要判断_type/tab是否相同，以及data指针指向的内存空间所存储的数据值是否相同就可以了。这里要注意不是data指针的值相同噢。</p><p>不过，通过肉眼去辨别接口类型变量是否相等总是困难一些，我们可以引入一些<strong>helper函数</strong>。借助这些函数，我们可以清晰地输出接口类型变量的内部表示，这样就可以一目了然地看出两个变量是否相等了。</p><p>由于eface和iface是runtime包中的非导出结构体定义，我们不能直接在包外使用，所以也就无法直接访问到两个结构体中的数据。不过，Go语言提供了println预定义函数，可以用来输出eface或iface的两个指针字段的值。</p><p>在编译阶段，编译器会根据要输出的参数的类型将println替换为特定的函数，这些函数都定义在<code>$GOROOT/src/runtime/print.go</code>文件中，而针对eface和iface类型的打印函数实现如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// $GOROOT/src/runtime/print.go</span></div><div class="token-line"><span class="token plain">    func printeface(e eface) {</span></div><div class="token-line"><span class="token plain">        print(&quot;(&quot;, e._type, &quot;,&quot;, e.data, &quot;)&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func printiface(i iface) {</span></div><div class="token-line"><span class="token plain">        print(&quot;(&quot;, i.tab, &quot;,&quot;, i.data, &quot;)&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们看到，printeface和printiface会输出各自的两个指针字段的值。下面我们就来使用println函数输出各类接口类型变量的内部表示信息，并结合输出结果，解析接口类型变量的等值比较操作。</p><h3 id="第一种nil接口变量"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02#第一种nil接口变量"><span class="icon icon-link"></span></a>第一种：nil接口变量</h3><p>我们前面提过，未赋初值的接口类型变量的值为nil，这类变量也就是nil接口变量，我们来看这类变量的内部表示输出的例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func printNilInterface() {</span></div><div class="token-line"><span class="token plain">    	// nil接口变量</span></div><div class="token-line"><span class="token plain">    	var i interface{} // 空接口类型</span></div><div class="token-line"><span class="token plain">    	var err error     // 非空接口类型</span></div><div class="token-line"><span class="token plain">    	println(i)</span></div><div class="token-line"><span class="token plain">    	println(err)</span></div><div class="token-line"><span class="token plain">    	println(&quot;i = nil:&quot;, i == nil)</span></div><div class="token-line"><span class="token plain">    	println(&quot;err = nil:&quot;, err == nil)</span></div><div class="token-line"><span class="token plain">    	println(&quot;i = err:&quot;, i == err)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>运行这个函数，输出结果是这样的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">(0x0,0x0)</span></div><div class="token-line"><span class="token plain">    (0x0,0x0)</span></div><div class="token-line"><span class="token plain">    i = nil: true</span></div><div class="token-line"><span class="token plain">    err = nil: true</span></div><div class="token-line"><span class="token plain">    i = err: true</span></div></pre></div><p>我们看到，无论是空接口类型还是非空接口类型变量，一旦变量值为nil，那么它们内部表示均为<code>(0x0,0x0)</code>，也就是类型信息、数据值信息均为空。因此上面的变量i和err等值判断为true。</p><h3 id="第二种空接口类型变量"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02#第二种空接口类型变量"><span class="icon icon-link"></span></a>第二种：空接口类型变量</h3><p>下面是空接口类型变量的内部表示输出的例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func printEmptyInterface() {</span></div><div class="token-line"><span class="token plain">          var eif1 interface{} // 空接口类型</span></div><div class="token-line"><span class="token plain">          var eif2 interface{} // 空接口类型</span></div><div class="token-line"><span class="token plain">          var n, m int = 17, 18</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">          eif1 = n</span></div><div class="token-line"><span class="token plain">          eif2 = m</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          println(&quot;eif1:&quot;, eif1)</span></div><div class="token-line"><span class="token plain">          println(&quot;eif2:&quot;, eif2)</span></div><div class="token-line"><span class="token plain">          println(&quot;eif1 = eif2:&quot;, eif1 == eif2) // false</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">          eif2 = 17</span></div><div class="token-line"><span class="token plain">          println(&quot;eif1:&quot;, eif1)</span></div><div class="token-line"><span class="token plain">          println(&quot;eif2:&quot;, eif2)</span></div><div class="token-line"><span class="token plain">          println(&quot;eif1 = eif2:&quot;, eif1 == eif2) // true</span></div><div class="token-line"><span class="token plain">     </span></div><div class="token-line"><span class="token plain">          eif2 = int64(17)</span></div><div class="token-line"><span class="token plain">          println(&quot;eif1:&quot;, eif1)</span></div><div class="token-line"><span class="token plain">          println(&quot;eif2:&quot;, eif2)</span></div><div class="token-line"><span class="token plain">          println(&quot;eif1 = eif2:&quot;, eif1 == eif2) // false</span></div><div class="token-line"><span class="token plain">     }</span></div></pre></div><p>这个例子的运行输出结果是这样的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">eif1: (0x10ac580,0xc00007ef48)</span></div><div class="token-line"><span class="token plain">    eif2: (0x10ac580,0xc00007ef40)</span></div><div class="token-line"><span class="token plain">    eif1 = eif2: false</span></div><div class="token-line"><span class="token plain">    eif1: (0x10ac580,0xc00007ef48)</span></div><div class="token-line"><span class="token plain">    eif2: (0x10ac580,0x10eb3d0)</span></div><div class="token-line"><span class="token plain">    eif1 = eif2: true</span></div><div class="token-line"><span class="token plain">    eif1: (0x10ac580,0xc00007ef48)</span></div><div class="token-line"><span class="token plain">    eif2: (0x10ac640,0x10eb3d8)</span></div><div class="token-line"><span class="token plain">    eif1 = eif2: false</span></div></pre></div><p>我们按顺序分析一下这个输出结果。</p><p>首先，代码执行到第11行时，eif1与eif2已经分别被赋值整型值17与18，这样eif1和eif2的动态类型的类型信息是相同的（都是0x10ac580），但data指针指向的内存块中存储的值不同，一个是17，一个是18，于是eif1不等于eif2。</p><p>接着，代码执行到第16行的时候，eif2已经被重新赋值为17，这样eif1和eif2不仅存储的动态类型的类型信息是相同的（都是0x10ac580），data指针指向的内存块中存储值也相同了，都是17，于是eif1等于eif2。</p><p>然后，代码执行到第21行时，eif2已经被重新赋值了int64类型的数值17。这样，eif1和eif2存储的动态类型的类型信息就变成不同的了，一个是int，一个是int64，即便data指针指向的内存块中存储值是相同的，最终eif1与eif2也是不相等的。</p><p>从输出结果中我们可以总结一下：<strong>对于空接口类型变量，只有_type和data所指数据内容一致的情况下，两个空接口类型变量之间才能划等号</strong>。另外，Go在创建eface时一般会为data重新分配新内存空间，将动态类型变量的值复制到这块内存空间，并将data指针指向这块内存空间。因此我们多数情况下看到的data指针值都是不同的。</p><h3 id="第三种非空接口类型变量"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02#第三种非空接口类型变量"><span class="icon icon-link"></span></a>第三种：非空接口类型变量</h3><p>这里，我们也直接来看一个非空接口类型变量的内部表示输出的例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type T int</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func (t T) Error() string { </span></div><div class="token-line"><span class="token plain">        return &quot;bad error&quot;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func printNonEmptyInterface() { </span></div><div class="token-line"><span class="token plain">        var err1 error // 非空接口类型</span></div><div class="token-line"><span class="token plain">        var err2 error // 非空接口类型</span></div><div class="token-line"><span class="token plain">        err1 = (*T)(nil)</span></div><div class="token-line"><span class="token plain">        println(&quot;err1:&quot;, err1)</span></div><div class="token-line"><span class="token plain">        println(&quot;err1 = nil:&quot;, err1 == nil)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        err1 = T(5)</span></div><div class="token-line"><span class="token plain">        err2 = T(6)</span></div><div class="token-line"><span class="token plain">        println(&quot;err1:&quot;, err1)</span></div><div class="token-line"><span class="token plain">        println(&quot;err2:&quot;, err2)</span></div><div class="token-line"><span class="token plain">        println(&quot;err1 = err2:&quot;, err1 == err2)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        err2 = fmt.Errorf(&quot;%d\n&quot;, 5)</span></div><div class="token-line"><span class="token plain">        println(&quot;err1:&quot;, err1)</span></div><div class="token-line"><span class="token plain">        println(&quot;err2:&quot;, err2)</span></div><div class="token-line"><span class="token plain">        println(&quot;err1 = err2:&quot;, err1 == err2)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个例子的运行输出结果如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">err1: (0x10ed120,0x0)</span></div><div class="token-line"><span class="token plain">    err1 = nil: false</span></div><div class="token-line"><span class="token plain">    err1: (0x10ed1a0,0x10eb310)</span></div><div class="token-line"><span class="token plain">    err2: (0x10ed1a0,0x10eb318)</span></div><div class="token-line"><span class="token plain">    err1 = err2: false</span></div><div class="token-line"><span class="token plain">    err1: (0x10ed1a0,0x10eb310)</span></div><div class="token-line"><span class="token plain">    err2: (0x10ed0c0,0xc000010050)</span></div><div class="token-line"><span class="token plain">    err1 = err2: false</span></div></pre></div><p>我们看到上面示例中每一轮通过println输出的err1和err2的tab和data值，要么data值不同，要么tab与data值都不同。</p><p>和空接口类型变量一样，只有tab和data指的数据内容一致的情况下，两个非空接口类型变量之间才能划等号。这里我们要注意err1下面的赋值情况：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">err1 = (*T)(nil)</span></div></pre></div><p>针对这种赋值，println输出的err1是（0x10ed120, 0x0），也就是非空接口类型变量的类型信息并不为空，数据指针为空，因此它与nil（0x0,0x0）之间不能划等号。</p><p>现在我们再回到我们开头的那个问题，你是不是已经豁然开朗了呢？开头的问题中，从returnsError返回的error接口类型变量err的数据指针虽然为空，但它的类型信息（iface.tab）并不为空，而是*MyError对应的类型信息，这样err与nil（0x0,0x0）相比自然不相等，这就是我们开头那个问题的答案解析，现在你明白了吗？</p><h3 id="第四种空接口类型变量与非空接口类型变量的等值比较"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02#第四种空接口类型变量与非空接口类型变量的等值比较"><span class="icon icon-link"></span></a>第四种：空接口类型变量与非空接口类型变量的等值比较</h3><p>下面是非空接口类型变量和空接口类型变量之间进行比较的例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func printEmptyInterfaceAndNonEmptyInterface() {</span></div><div class="token-line"><span class="token plain">    	var eif interface{} = T(5)</span></div><div class="token-line"><span class="token plain">    	var err error = T(5)</span></div><div class="token-line"><span class="token plain">    	println(&quot;eif:&quot;, eif)</span></div><div class="token-line"><span class="token plain">    	println(&quot;err:&quot;, err)</span></div><div class="token-line"><span class="token plain">    	println(&quot;eif = err:&quot;, eif == err)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	err = T(6)</span></div><div class="token-line"><span class="token plain">    	println(&quot;eif:&quot;, eif)</span></div><div class="token-line"><span class="token plain">    	println(&quot;err:&quot;, err)</span></div><div class="token-line"><span class="token plain">    	println(&quot;eif = err:&quot;, eif == err)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个示例的输出结果如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">eif: (0x10b3b00,0x10eb4d0)</span></div><div class="token-line"><span class="token plain">    err: (0x10ed380,0x10eb4d8)</span></div><div class="token-line"><span class="token plain">    eif = err: true</span></div><div class="token-line"><span class="token plain">    eif: (0x10b3b00,0x10eb4d0)</span></div><div class="token-line"><span class="token plain">    err: (0x10ed380,0x10eb4e0)</span></div><div class="token-line"><span class="token plain">    eif = err: false</span></div></pre></div><p>你可以看到，空接口类型变量和非空接口类型变量内部表示的结构有所不同（第一个字段：_type vs. tab)，两者似乎一定不能相等。但Go在进行等值比较时，类型比较使用的是eface的_type和iface的tab._type，因此就像我们在这个例子中看到的那样，当eif和err都被赋值为<code>T(5)</code>时，两者之间是划等号的。</p><p>好了，到这里，我们已经学完了各类接口类型变量在运行时层的表示。我们可以通过println可以查看这个表示信息，从中我们也知道了接口变量只有在类型信息与值信息都一致的情况下才能划等号。</p><h2 id="输出接口类型变量内部表示的详细信息"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02#输出接口类型变量内部表示的详细信息"><span class="icon icon-link"></span></a>输出接口类型变量内部表示的详细信息</h2><p>不过，println输出的接口类型变量的内部表示信息，在一般情况下都是足够的，但有些时候又显得过于简略，比如在上面最后一个例子中，如果仅凭<code>eif: (0x10b3b00,0x10eb4d0)</code>和<code>err: (0x10ed380,0x10eb4d8)</code>的输出，我们是无法想到两个变量是相等的。</p><p>那这时如果我们能输出接口类型变量内部表示的详细信息（比如：tab._type），那势必可以取得事半功倍的效果。接下来我们就看看这要怎么做。</p><p>前面提到过，eface和iface以及组成它们的itab和_type都是runtime包下的非导出结构体，我们无法在外部直接引用它们。但我们发现，组成eface、iface的类型都是基本数据类型，我们完全可以通过**“复制代码”**的方式将它们拿到runtime包外面来。</p><p>不过，这里要注意，由于runtime中的eface、iface，或者它们的组成可能会随着Go版本的变化发生变化，因此这个方法不具备跨版本兼容性。也就是说，基于Go 1.17版本复制的代码，可能仅适用于使用Go 1.17版本编译。这里我们就以Go 1.17版本为例看看：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// dumpinterface.go </span></div><div class="token-line"><span class="token plain">    type eface struct {</span></div><div class="token-line"><span class="token plain">        _type *_type</span></div><div class="token-line"><span class="token plain">        data  unsafe.Pointer</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    type tflag uint8</span></div><div class="token-line"><span class="token plain">    type nameOff int32</span></div><div class="token-line"><span class="token plain">    type typeOff int32</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    type _type struct {</span></div><div class="token-line"><span class="token plain">        size       uintptr</span></div><div class="token-line"><span class="token plain">        ptrdata    uintptr // size of memory prefix holding all pointers</span></div><div class="token-line"><span class="token plain">        hash       uint32</span></div><div class="token-line"><span class="token plain">        tflag      tflag</span></div><div class="token-line"><span class="token plain">        align      uint8</span></div><div class="token-line"><span class="token plain">        fieldAlign uint8</span></div><div class="token-line"><span class="token plain">        kind       uint8</span></div><div class="token-line"><span class="token plain">        // function for comparing objects of this type</span></div><div class="token-line"><span class="token plain">        // (ptr to object A, ptr to object B) -&gt; ==?</span></div><div class="token-line"><span class="token plain">        equal func(unsafe.Pointer, unsafe.Pointer) bool</span></div><div class="token-line"><span class="token plain">        // gcdata stores the GC type data for the garbage collector.</span></div><div class="token-line"><span class="token plain">        // If the KindGCProg bit is set in kind, gcdata is a GC program.</span></div><div class="token-line"><span class="token plain">        // Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span></div><div class="token-line"><span class="token plain">        gcdata    *byte</span></div><div class="token-line"><span class="token plain">        str       nameOff</span></div><div class="token-line"><span class="token plain">        ptrToThis typeOff</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    type iface struct {</span></div><div class="token-line"><span class="token plain">        tab  *itab</span></div><div class="token-line"><span class="token plain">        data unsafe.Pointer</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    type itab struct {</span></div><div class="token-line"><span class="token plain">        inter *interfacetype</span></div><div class="token-line"><span class="token plain">        _type *_type</span></div><div class="token-line"><span class="token plain">        hash  uint32 // copy of _type.hash. Used for type switches.</span></div><div class="token-line"><span class="token plain">        _     [4]byte</span></div><div class="token-line"><span class="token plain">        fun   [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ... ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    const ptrSize = unsafe.Sizeof(uintptr(0))</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func dumpEface(i interface{}) {</span></div><div class="token-line"><span class="token plain">        ptrToEface := (*eface)(unsafe.Pointer(&amp;i))</span></div><div class="token-line"><span class="token plain">        fmt.Printf(&quot;eface: %+v\n&quot;, *ptrToEface)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        if ptrToEface._type != nil {</span></div><div class="token-line"><span class="token plain">            // dump _type info</span></div><div class="token-line"><span class="token plain">            fmt.Printf(&quot;\t _type: %+v\n&quot;, *(ptrToEface._type))</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        if ptrToEface.data != nil {</span></div><div class="token-line"><span class="token plain">            // dump data</span></div><div class="token-line"><span class="token plain">            switch i.(type) {</span></div><div class="token-line"><span class="token plain">            case int:</span></div><div class="token-line"><span class="token plain">                dumpInt(ptrToEface.data)</span></div><div class="token-line"><span class="token plain">            case float64:</span></div><div class="token-line"><span class="token plain">                dumpFloat64(ptrToEface.data)</span></div><div class="token-line"><span class="token plain">            case T:</span></div><div class="token-line"><span class="token plain">                dumpT(ptrToEface.data)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // other cases ... ...</span></div><div class="token-line"><span class="token plain">            default:</span></div><div class="token-line"><span class="token plain">                fmt.Printf(&quot;\t unsupported data type\n&quot;)</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        fmt.Printf(&quot;\n&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func dumpItabOfIface(ptrToIface unsafe.Pointer) {</span></div><div class="token-line"><span class="token plain">        p := (*iface)(ptrToIface)</span></div><div class="token-line"><span class="token plain">        fmt.Printf(&quot;iface: %+v\n&quot;, *p)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        if p.tab != nil {</span></div><div class="token-line"><span class="token plain">            // dump itab</span></div><div class="token-line"><span class="token plain">            fmt.Printf(&quot;\t itab: %+v\n&quot;, *(p.tab))</span></div><div class="token-line"><span class="token plain">            // dump inter in itab</span></div><div class="token-line"><span class="token plain">            fmt.Printf(&quot;\t\t inter: %+v\n&quot;, *(p.tab.inter))</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // dump _type in itab</span></div><div class="token-line"><span class="token plain">            fmt.Printf(&quot;\t\t _type: %+v\n&quot;, *(p.tab._type))</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // dump fun in tab</span></div><div class="token-line"><span class="token plain">            funPtr := unsafe.Pointer(&amp;(p.tab.fun))</span></div><div class="token-line"><span class="token plain">            fmt.Printf(&quot;\t\t fun: [&quot;)</span></div><div class="token-line"><span class="token plain">            for i := 0; i &lt; len((*(p.tab.inter)).mhdr); i++ {</span></div><div class="token-line"><span class="token plain">                tp := (*uintptr)(unsafe.Pointer(uintptr(funPtr) + uintptr(i)*ptrSize))</span></div><div class="token-line"><span class="token plain">                fmt.Printf(&quot;0x%x(%d),&quot;, *tp, *tp)</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            fmt.Printf(&quot;]\n&quot;)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func dumpDataOfIface(i interface{}) {</span></div><div class="token-line"><span class="token plain">        // this is a trick as the data part of eface and iface are same</span></div><div class="token-line"><span class="token plain">        ptrToEface := (*eface)(unsafe.Pointer(&amp;i))</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        if ptrToEface.data != nil {</span></div><div class="token-line"><span class="token plain">            // dump data</span></div><div class="token-line"><span class="token plain">            switch i.(type) {</span></div><div class="token-line"><span class="token plain">            case int:</span></div><div class="token-line"><span class="token plain">                dumpInt(ptrToEface.data)</span></div><div class="token-line"><span class="token plain">            case float64:</span></div><div class="token-line"><span class="token plain">                dumpFloat64(ptrToEface.data)</span></div><div class="token-line"><span class="token plain">            case T:</span></div><div class="token-line"><span class="token plain">                dumpT(ptrToEface.data)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // other cases ... ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            default:</span></div><div class="token-line"><span class="token plain">                fmt.Printf(&quot;\t unsupported data type\n&quot;)</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        fmt.Printf(&quot;\n&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func dumpT(dataOfIface unsafe.Pointer) {</span></div><div class="token-line"><span class="token plain">        var p *T = (*T)(dataOfIface)</span></div><div class="token-line"><span class="token plain">        fmt.Printf(&quot;\t data: %+v\n&quot;, *p)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    ... ...</span></div></pre></div><p>这里我挑选了关键部分，省略了部分代码。上面这个dumpinterface.go中提供了三个主要函数:</p><ul><li>dumpEface: 用于输出空接口类型变量的内部表示信息；</li><li>dumpItabOfIface: 用于输出非空接口类型变量的tab字段信息；</li><li>dumpDataOfIface: 用于输出非空接口类型变量的data字段信息；</li></ul><p>我们利用这三个函数来输出一下前面printEmptyInterfaceAndNonEmptyInterface函数中的接口类型变量的信息：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package main</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import &quot;unsafe&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    type T int</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func (t T) Error() string {</span></div><div class="token-line"><span class="token plain">        return &quot;bad error&quot;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">        var eif interface{} = T(5)</span></div><div class="token-line"><span class="token plain">        var err error = T(5)</span></div><div class="token-line"><span class="token plain">        println(&quot;eif:&quot;, eif)</span></div><div class="token-line"><span class="token plain">        println(&quot;err:&quot;, err)</span></div><div class="token-line"><span class="token plain">        println(&quot;eif = err:&quot;, eif == err)</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        dumpEface(eif)</span></div><div class="token-line"><span class="token plain">        dumpItabOfIface(unsafe.Pointer(&amp;err))</span></div><div class="token-line"><span class="token plain">        dumpDataOfIface(err)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>运行这个示例代码，我们得到了这个输出结果：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">eif: (0x10b38c0,0x10e9b30)</span></div><div class="token-line"><span class="token plain">    err: (0x10eb690,0x10e9b30)</span></div><div class="token-line"><span class="token plain">    eif = err: true</span></div><div class="token-line"><span class="token plain">    eface: {_type:0x10b38c0 data:0x10e9b30}</span></div><div class="token-line"><span class="token plain">    	 _type: {size:8 ptrdata:0 hash:1156555957 tflag:15 align:8 fieldAlign:8 kind:2 equal:0x10032e0 gcdata:0x10e9a60 str:4946 ptrToThis:58496}</span></div><div class="token-line"><span class="token plain">    	 data: bad error</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    iface: {tab:0x10eb690 data:0x10e9b30}</span></div><div class="token-line"><span class="token plain">    	 itab: {inter:0x10b5e20 _type:0x10b38c0 hash:1156555957 _:[0 0 0 0] fun:[17454976]}</span></div><div class="token-line"><span class="token plain">    		 inter: {typ:{size:16 ptrdata:16 hash:235953867 tflag:7 align:8 fieldAlign:8 kind:20 equal:0x10034c0 gcdata:0x10d2418 str:3666 ptrToThis:26848} pkgpath:{bytes:&lt;nil&gt;} mhdr:[{name:2592 ityp:43520}]}</span></div><div class="token-line"><span class="token plain">    		 _type: {size:8 ptrdata:0 hash:1156555957 tflag:15 align:8 fieldAlign:8 kind:2 equal:0x10032e0 gcdata:0x10e9a60 str:4946 ptrToThis:58496}</span></div><div class="token-line"><span class="token plain">    		 fun: [0x10a5780(17454976),]</span></div><div class="token-line"><span class="token plain">    	 data: bad error</span></div></pre></div><p>从输出结果中，我们看到eif的_type（0x10b38c0）与err的tab._type（0x10b38c0）是一致的，data指针所指内容（“bad error”）也是一致的，因此<code>eif == err</code>表达式的结果为true。</p><p>再次强调一遍，上面这个实现可能仅在Go 1.17版本上测试通过，并且在输出iface或eface的data部分内容时只列出了int、float64和T类型的数据读取实现，没有列出全部类型的实现，你可以根据自己的需要实现其余数据类型。dumpinterface.go的完整代码你可以在<a target="_blank" rel="noopener noreferrer" href="https://github.com/bigwhite/publication/tree/master/column/timegeek/go-first-course/29">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>找到。</p><p>我们现在已经知道了，接口类型有着复杂的内部结构，所以我们将一个类型变量值赋值给一个接口类型变量值的过程肯定不会像<code>var i int = 5</code>那么简单，那么接口类型变量赋值的过程是怎样的呢？其实接口类型变量赋值是一个“装箱”的过程。</p><h2 id="接口类型的装箱boxing原理"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02#接口类型的装箱boxing原理"><span class="icon icon-link"></span></a>接口类型的装箱（boxing）原理</h2><p>**装箱（boxing）**是编程语言领域的一个基础概念，一般是指把一个值类型转换成引用类型，比如在支持装箱概念的Java语言中，将一个int变量转换成Integer对象就是一个装箱操作。</p><p>在Go语言中，将任意类型赋值给一个接口类型变量也是<strong>装箱</strong>操作。有了前面对接口类型变量内部表示的学习，我们知道<strong>接口类型的装箱实际就是创建一个eface或iface的过程</strong>。接下来我们就来简要描述一下这个过程，也就是接口类型的装箱原理。</p><p>我们基于下面这个例子中的接口装箱操作来说明：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// interface_internal.go</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      type T struct {</span></div><div class="token-line"><span class="token plain">          n int</span></div><div class="token-line"><span class="token plain">          s string</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      func (T) M1() {}</span></div><div class="token-line"><span class="token plain">      func (T) M2() {}</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      type NonEmptyInterface interface {</span></div><div class="token-line"><span class="token plain">          M1()</span></div><div class="token-line"><span class="token plain">          M2()</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      func main() {</span></div><div class="token-line"><span class="token plain">          var t = T{</span></div><div class="token-line"><span class="token plain">              n: 17,</span></div><div class="token-line"><span class="token plain">              s: &quot;hello, interface&quot;,</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          var ei interface{}</span></div><div class="token-line"><span class="token plain">          ei = t</span></div><div class="token-line"><span class="token plain">     </span></div><div class="token-line"><span class="token plain">          var i NonEmptyInterface</span></div><div class="token-line"><span class="token plain">          i = t</span></div><div class="token-line"><span class="token plain">          fmt.Println(ei)</span></div><div class="token-line"><span class="token plain">          fmt.Println(i)</span></div><div class="token-line"><span class="token plain">      }</span></div></pre></div><p>这个例子中，对ei和i两个接口类型变量的赋值都会触发装箱操作，要想知道Go在背后做了些什么，我们需要“下沉”一层，也就是要输出上面Go代码对应的汇编代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$go tool compile -S interface_internal.go &gt; interface_internal.s</span></div></pre></div><p>对应<code>ei = t</code>一行的汇编如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">0x0026 00038 (interface_internal.go:24) MOVQ    $17, &quot;&quot;..autotmp_15+104(SP)</span></div><div class="token-line"><span class="token plain">        0x002f 00047 (interface_internal.go:24) LEAQ    go.string.&quot;hello, interface&quot;(SB), CX</span></div><div class="token-line"><span class="token plain">        0x0036 00054 (interface_internal.go:24) MOVQ    CX, &quot;&quot;..autotmp_15+112(SP)</span></div><div class="token-line"><span class="token plain">        0x003b 00059 (interface_internal.go:24) MOVQ    $16, &quot;&quot;..autotmp_15+120(SP)</span></div><div class="token-line"><span class="token plain">        0x0044 00068 (interface_internal.go:24) LEAQ    type.&quot;&quot;.T(SB), AX</span></div><div class="token-line"><span class="token plain">        0x004b 00075 (interface_internal.go:24) LEAQ    &quot;&quot;..autotmp_15+104(SP), BX</span></div><div class="token-line"><span class="token plain">        0x0050 00080 (interface_internal.go:24) PCDATA  $1, $0</span></div><div class="token-line"><span class="token plain">        0x0050 00080 (interface_internal.go:24) CALL    runtime.convT2E(SB)</span></div></pre></div><p>对应i = t一行的汇编如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">0x005f 00095 (interface_internal.go:27) MOVQ    $17, &quot;&quot;..autotmp_15+104(SP)</span></div><div class="token-line"><span class="token plain">        0x0068 00104 (interface_internal.go:27) LEAQ    go.string.&quot;hello, interface&quot;(SB), CX</span></div><div class="token-line"><span class="token plain">        0x006f 00111 (interface_internal.go:27) MOVQ    CX, &quot;&quot;..autotmp_15+112(SP)</span></div><div class="token-line"><span class="token plain">        0x0074 00116 (interface_internal.go:27) MOVQ    $16, &quot;&quot;..autotmp_15+120(SP)</span></div><div class="token-line"><span class="token plain">        0x007d 00125 (interface_internal.go:27) LEAQ    go.itab.&quot;&quot;.T,&quot;&quot;.NonEmptyInterface(SB), AX</span></div><div class="token-line"><span class="token plain">        0x0084 00132 (interface_internal.go:27) LEAQ    &quot;&quot;..autotmp_15+104(SP), BX</span></div><div class="token-line"><span class="token plain">        0x0089 00137 (interface_internal.go:27) PCDATA  $1, $1</span></div><div class="token-line"><span class="token plain">        0x0089 00137 (interface_internal.go:27) CALL    runtime.convT2I(SB)</span></div></pre></div><p>在将动态类型变量赋值给接口类型变量语句对应的汇编代码中，我们看到了<code>convT2E</code>和<code>convT2I</code>两个runtime包的函数。这两个函数的实现位于<code>$GOROOT/src/runtime/iface.go</code>中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// $GOROOT/src/runtime/iface.go</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func convT2E(t *_type, elem unsafe.Pointer) (e eface) {</span></div><div class="token-line"><span class="token plain">        if raceenabled {</span></div><div class="token-line"><span class="token plain">            raceReadObjectPC(t, elem, getcallerpc(), funcPC(convT2E))</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if msanenabled {</span></div><div class="token-line"><span class="token plain">            msanread(elem, t.size)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        x := mallocgc(t.size, t, true)</span></div><div class="token-line"><span class="token plain">        typedmemmove(t, x, elem)</span></div><div class="token-line"><span class="token plain">        e._type = t</span></div><div class="token-line"><span class="token plain">        e.data = x</span></div><div class="token-line"><span class="token plain">        return</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func convT2I(tab *itab, elem unsafe.Pointer) (i iface) {</span></div><div class="token-line"><span class="token plain">        t := tab._type</span></div><div class="token-line"><span class="token plain">        if raceenabled {</span></div><div class="token-line"><span class="token plain">            raceReadObjectPC(t, elem, getcallerpc(), funcPC(convT2I))</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if msanenabled {</span></div><div class="token-line"><span class="token plain">            msanread(elem, t.size)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        x := mallocgc(t.size, t, true)</span></div><div class="token-line"><span class="token plain">        typedmemmove(t, x, elem)</span></div><div class="token-line"><span class="token plain">        i.tab = tab</span></div><div class="token-line"><span class="token plain">        i.data = x</span></div><div class="token-line"><span class="token plain">        return</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>convT2E用于将任意类型转换为一个eface，convT2I用于将任意类型转换为一个iface。两个函数的实现逻辑相似，主要思路就是根据传入的类型信息（convT2E的_type和convT2I的tab._type）分配一块内存空间，并将elem指向的数据拷贝到这块内存空间中，最后传入的类型信息作为返回值结构中的类型信息，返回值结构中的数据指针（data）指向新分配的那块内存空间。</p><p>由此我们也可以看出，经过装箱后，箱内的数据，也就是存放在新分配的内存空间中的数据与原变量便无瓜葛了，比如下面这个例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func main() {</span></div><div class="token-line"><span class="token plain">    	var n int = 61</span></div><div class="token-line"><span class="token plain">    	var ei interface{} = n</span></div><div class="token-line"><span class="token plain">    	n = 62  // n的值已经改变</span></div><div class="token-line"><span class="token plain">    	fmt.Println(&quot;data in box:&quot;, ei) // 输出仍是61</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>那么convT2E和convT2I函数的类型信息是从何而来的呢？</p><p>其实这些都依赖Go编译器的工作。编译器知道每个要转换为接口类型变量（toType）和动态类型变量的类型（fromType），它会根据这一对类型选择适当的convT2X函数，并在生成代码时使用选出的convT2X函数参与装箱操作。</p><p>不过，装箱是一个有性能损耗的操作，因此Go也在不断对装箱操作进行优化，包括对常见类型如整型、字符串、切片等提供系列快速转换函数：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// $GOROOT/src/runtime/iface.go</span></div><div class="token-line"><span class="token plain">    func convT16(val any) unsafe.Pointer     // val must be uint16-like</span></div><div class="token-line"><span class="token plain">    func convT32(val any) unsafe.Pointer     // val must be uint32-like</span></div><div class="token-line"><span class="token plain">    func convT64(val any) unsafe.Pointer     // val must be uint64-like</span></div><div class="token-line"><span class="token plain">    func convTstring(val any) unsafe.Pointer // val must be a string</span></div><div class="token-line"><span class="token plain">    func convTslice(val any) unsafe.Pointer  // val must be a slice</span></div></pre></div><p>这些函数去除了typedmemmove操作，增加了零值快速返回等特性。</p><p>同时Go建立了staticuint64s区域，对255以内的小整数值进行装箱操作时<a target="_blank" rel="noopener noreferrer" href="https://github.com/golang/go/issues/17725">不再分配新内存<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，而是利用staticuint64s区域的内存空间，下面是staticuint64s的定义：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// $GOROOT/src/runtime/iface.go</span></div><div class="token-line"><span class="token plain">    // staticuint64s is used to avoid allocating in convTx for small integer values.</span></div><div class="token-line"><span class="token plain">    var staticuint64s = [...]uint64{</span></div><div class="token-line"><span class="token plain">        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,</span></div><div class="token-line"><span class="token plain">        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,</span></div><div class="token-line"><span class="token plain">    	... ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02#小结"><span class="icon icon-link"></span></a>小结</h2><p>好了，今天的课讲到这里就结束了，现在我们一起来回顾一下吧。</p><p>接口类型作为参与构建Go应用骨架的重要参与者，在Go语言中有着很高的地位。它这个地位的取得离不开它拥有的“动静兼备”的语法特性。Go接口的动态特性让Go拥有与动态语言相近的灵活性，而静态特性又在编译阶段保证了这种灵活性的安全。</p><p>要更好地理解Go接口的这两种特性，我们需要深入到Go接口在运行时的表示层面上去。接口类型变量在运行时表示为eface和iface，eface用于表示空接口类型变量，iface用于表示非空接口类型变量。只有两个接口类型变量的类型信息（eface._type/iface.tab._type）相同，且数据指针（eface.data/iface.data）所指数据相同时，两个接口类型变量才是相等的。</p><p>我们可以通过println输出接口类型变量的两部分指针变量的值。而且，通过拷贝runtime包eface和iface相关类型源码，我们还可以自定义输出eface/iface详尽信息的函数，不过要注意的是，由于runtime层代码的演进，这个函数可能不具备在Go版本间的移植性。</p><p>最后，接口类型变量的赋值本质上是一种装箱操作，装箱操作是由Go编译器和运行时共同完成的，有一定的性能开销，对于性能敏感的系统来说，我们应该尽量避免或减少这类装箱操作。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>像nil error值 != nil那个例子中的“坑”你在日常编码时有遇到过吗？可以和我们分享一下吗？另外，我们这节课中的这个例子如何修改，才能让它按我们最初的预期结果输出呢？</p><p>欢迎在留言区分享你的经验和想法。也欢迎你把这节课分享给更多对Go接口感兴趣的朋友。我是Tony Bai，我们下节课见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:33</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
