<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-two/umi.css" />
    <script>
      window.routerBase = "/blog-two";
    </script>
    <script>
      //! umi version: 3.5.17
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>33｜并发：小channel中蕴含大智慧</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a aria-current="page" class="active" href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></span><span>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></span><span>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></span><span>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></span><span>杂谈</span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-two/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>后端开发<ul><li><a href="/blog-two/go语言核心36讲">go语言核心36讲</a></li><li><a href="/blog-two/go并发编程实战">go并发编程实战</a></li><li><a href="/blog-two/零基础学python">零基础学python</a></li><li><a href="/blog-two/redis核心技术与实战">redis核心技术与实战</a></li><li><a href="/blog-two/redis源码剖析与实战">redis源码剖析与实战</a></li><li><a href="/blog-two/陈天rust编程第一课">陈天rust编程第一课</a></li><li><a aria-current="page" class="active" href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/深入c语言和程序运行原理">深入c语言和程序运行原理</a></li></ul></li><li>架构师<ul><li><a href="/blog-two/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-two/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-two/ddd实战课">ddd实战课</a></li><li><a href="/blog-two/设计模式之美">设计模式之美</a></li><li><a href="/blog-two/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-two/架构实战案例解析">架构实战案例解析</a></li><li><a href="/blog-two/许式伟的架构课">许式伟的架构课</a></li><li><a href="/blog-two/高并发系统设计40问">高并发系统设计40问</a></li><li><a href="/blog-two/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-two/说透中台">说透中台</a></li><li><a href="/blog-two/消息队列进阶">消息队列进阶</a></li><li><a href="/blog-two/mysql实战45讲">mysql实战45讲</a></li><li><a href="/blog-two/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-two/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-two/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-two/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-two/从0开始学架构">从0开始学架构</a></li><li><a href="/blog-two/vim实用技巧必知必会">vim实用技巧必知必会</a></li><li><a href="/blog-two/如何落地业务建模">如何落地业务建模</a></li><li><a href="/blog-two/技术与商业案例解读">技术与商业案例解读</a></li><li><a href="/blog-two/说透数字化转型">说透数字化转型</a></li><li><a href="/blog-two/遗留系统现代化实战">遗留系统现代化实战</a></li></ul></li><li>管理<ul><li><a href="/blog-two/技术管理实战36讲">技术管理实战36讲</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/项目管理实战课">项目管理实战课</a></li><li><a href="/blog-two/技术面试官识人手册">技术面试官识人手册</a></li><li><a href="/blog-two/技术领导力实战笔记">技术领导力实战笔记</a></li><li><a href="/blog-two/朱赟的技术管理">朱赟的技术管理</a></li></ul></li><li>工作生活<ul><li><a href="/blog-two/10x程序员工作法">10x程序员工作法</a></li><li><a href="/blog-two/python自动化办公实战课">python自动化办公实战课</a></li><li><a href="/blog-two/人人都用得上的写作课">人人都用得上的写作课</a></li><li><a href="/blog-two/体验设计案例课">体验设计案例课</a></li><li><a href="/blog-two/用户体验设计实战课">用户体验设计实战课</a></li><li><a href="/blog-two/程序员的个人财富课">程序员的个人财富课</a></li><li><a href="/blog-two/程序员进阶攻略">程序员进阶攻略</a></li><li><a href="/blog-two/职场求生攻略">职场求生攻略</a></li><li><a href="/blog-two/讲好故事">讲好故事</a></li><li><a href="/blog-two/跟着高手学复盘">跟着高手学复盘</a></li></ul></li><li>杂谈</li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-two/tonybaigo语言第一课">tonybaigo语言第一课</a></li><li><a href="/blog-two/tonybaigo语言第一课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-two/tonybaigo语言第一课/01.开篇词/01"><span>开篇词｜这样入门Go，才能少走弯路</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/02.前置篇心定之旅">02.前置篇心定之旅</a><ul><li><a href="/blog-two/tonybaigo语言第一课/02.前置篇心定之旅/01"><span>01｜前世今生：你不得不了解的Go的历史和现状</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/02.前置篇心定之旅/02"><span>02｜拒绝“Hello and Bye”：Go语言的设计哲学是怎么一回事？</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手">03.入门篇勤加练手</a><ul><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/01"><span>03｜配好环境：选择一种最适合你的Go安装方法</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/02"><span>04｜初窥门径：一个Go程序的结构是怎样的？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/03"><span>05｜标准先行：Go项目的布局标准是什么？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/04"><span>06｜构建模式：Go是怎么解决包依赖管理问题的？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/05"><span>07｜构建模式：Go Module的6类常规操作</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/06"><span>08｜入口函数与包初始化：搞清Go程序的执行次序</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/03.入门篇勤加练手/07"><span>09｜即学即练：构建一个Web服务就是这么简单</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解">04.基础篇“脑勤”多理解</a><ul><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/01"><span>10｜变量声明：静态语言有别于动态语言的重要特征</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/02"><span>11｜代码块与作用域：如何保证变量不会被遮蔽？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/03"><span>12｜基本数据类型：Go原生支持的数值类型有哪些？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/04"><span>13｜基本数据类型：为什么Go要原生支持字符串类型？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/05"><span>14｜常量：Go在“常量”设计上的创新有哪些？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/06"><span>15｜同构复合类型：从定长数组到变长切片</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/07"><span>16｜复合数据类型：原生map类型的实现机制是怎样的？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/08"><span>17｜复合数据类型：用结构体建立对真实世界的抽象</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/09"><span>18｜控制结构：if的“快乐路径”原则</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/10"><span>19｜控制结构：Go的for循环，仅此一种</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/11"><span>20｜控制结构：Go中的switch语句有哪些变化？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/12"><span>21｜函数：请叫我“一等公民”</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/13"><span>22｜函数：怎么结合多返回值进行错误处理？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/14"><span>期中测试｜一起检验下你的学习成果吧</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/15"><span>23｜函数：怎么让函数更简洁健壮？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/16"><span>24｜方法：理解“方法”的本质</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/17"><span>25｜方法：方法集合与如何选择receiver类型？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/18"><span>26｜方法：如何用类型嵌入模拟实现“继承”？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/19"><span>27｜即学即练：跟踪函数调用链，理解代码更直观</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/04.基础篇“脑勤”多理解/20"><span>用户故事｜罗杰：我的Go语言学习之路</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心">05.核心篇“脑勤+”洞彻核心</a><ul><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/01"><span>28｜接口：接口即契约</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/02"><span>29｜接口：为什么nil接口不等于nil？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/03"><span>30｜接口：Go中最强大的魔法</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/04"><span>元旦快乐｜这是一份暂时停更的声明</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/05"><span>31｜并发：Go的并发方案实现方案是怎样的？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/06"><span>32｜并发：聊聊Goroutine调度器的原理</span></a></li><li><a aria-current="page" class="active" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07"><span>33｜并发：小channel中蕴含大智慧</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/08"><span>34｜并发：如何使用共享变量？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/09"><span>35｜即学即练：如何实现一个轻量级线程池？</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”">06.实战篇打通“最后一公里”</a><ul><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/01"><span>36｜打稳根基：怎么实现一个TCP服务器？（上）</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/02"><span>37｜代码操练：怎么实现一个TCP服务器？（中）</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/03"><span>38｜成果优化：怎么实现一个TCP服务器？（下）</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/06.实战篇打通“最后一公里”/04"><span>结课测试｜快来检验下你的学习成果吧！</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇">07.加餐篇</a><ul><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/01"><span>加餐｜我“私藏”的那些优质且权威的Go语言学习资料</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/02"><span>加餐｜聊聊Go 1.17版本的那些新特性</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/03"><span>加餐｜如何拉取私有的Go Module？</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/04"><span>加餐｜作为Go Module的作者，你应该知道的几件事</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/05"><span>加餐｜聊聊最近大热的Go泛型</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/07.加餐篇/06"><span>加餐｜聊聊Go语言的指针</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵">08.大咖助阵</a><ul><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/01"><span>大咖助阵｜孔令飞：从小白到“老鸟”，我的Go语言进阶之路</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/02"><span>大咖助阵｜叶剑峰：Go语言中常用的那些代码优化点</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/03"><span>大咖助阵｜徐祥曦：从销售到分布式存储工程师，我与 Go  的故事</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/04"><span>大咖助阵｜曹春晖：聊聊 Go 语言的 GC 实现</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/05"><span>大咖助阵｜大明：Go泛型，泛了，但没有完全泛</span></a></li><li><a href="/blog-two/tonybaigo语言第一课/08.大咖助阵/06"><span>大咖助阵｜海纳：聊聊语言中的类型系统与泛型</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/09.结束语">09.结束语</a><ul><li><a href="/blog-two/tonybaigo语言第一课/09.结束语/01"><span>结束语｜和你一起迎接Go的黄金十年</span></a></li></ul></li><li><a href="/blog-two/tonybaigo语言第一课/summary">tonybaigo语言第一课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="作为一等公民的channel" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#作为一等公民的channel"><span>作为一等公民的channel</span></a></li><li title="创建channel" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#创建channel"><span>创建channel</span></a></li><li title="发送与接收" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#发送与接收"><span>发送与接收</span></a></li><li title="关闭channel" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#关闭channel"><span>关闭channel</span></a></li><li title="select" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#select"><span>select</span></a></li><li title="无缓冲channel的惯用法" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#无缓冲channel的惯用法"><span>无缓冲channel的惯用法</span></a></li><li title="第一种用法：用作信号传递" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#第一种用法用作信号传递"><span>第一种用法：用作信号传递</span></a></li><li title="第二种用法：用于替代锁机制" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#第二种用法用于替代锁机制"><span>第二种用法：用于替代锁机制</span></a></li><li title="带缓冲channel的惯用法" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#带缓冲channel的惯用法"><span>带缓冲channel的惯用法</span></a></li><li title="第一种用法：用作消息队列" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#第一种用法用作消息队列"><span>第一种用法：用作消息队列</span></a></li><li title="第二种用法：用作计数信号量（counting semaphore）" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#第二种用法用作计数信号量counting-semaphore"><span>第二种用法：用作计数信号量（counting semaphore）</span></a></li><li title="len(channel)的应用" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#lenchannel的应用"><span>len(channel)的应用</span></a></li><li title="nil channel的妙用" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#nil-channel的妙用"><span>nil channel的妙用</span></a></li><li title="与select结合使用的一些惯用法" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#与select结合使用的一些惯用法"><span>与select结合使用的一些惯用法</span></a></li><li title="第一种用法：利用default分支避免阻塞" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#第一种用法利用default分支避免阻塞"><span>第一种用法：利用default分支避免阻塞</span></a></li><li title="第二种用法：实现超时机制" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#第二种用法实现超时机制"><span>第二种用法：实现超时机制</span></a></li><li title="第三种用法：实现心跳机制" data-depth="3"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#第三种用法实现心跳机制"><span>第三种用法：实现心跳机制</span></a></li><li title="小结" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="33并发小channel中蕴含大智慧"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#33并发小channel中蕴含大智慧"><span class="icon icon-link"></span></a>33｜并发：小channel中蕴含大智慧</h1><p>你好，我是Tony Bai。</p><p>通过上两节课的学习，我们知道了Go语言实现了基于CSP（Communicating Sequential Processes）理论的并发方案。</p><p>Go语言的CSP模型的实现包含两个主要组成部分：一个是Goroutine，它是Go应用并发设计的基本构建与执行单元；另一个就是channel，它在并发模型中扮演着重要的角色。channel既可以用来实现Goroutine间的通信，还可以实现Goroutine间的同步。它就好比Go并发设计这门“武功”的秘籍口诀，可以说，学会在Go并发设计时灵活运用channel，才能说真正掌握了Go并发设计的真谛。</p><p>所以，在这一讲中，我们就来系统学习channel这一并发原语的基础语法与常见使用方法。</p><h2 id="作为一等公民的channel"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#作为一等公民的channel"><span class="icon icon-link"></span></a>作为一等公民的channel</h2><p>Go对并发的原生支持可不是仅仅停留在口号上的，Go在语法层面将并发原语channel作为一等公民对待。在前面的<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/460666">第21讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中我们已经学过“一等公民”这个概念了，如果你记不太清了可以回去复习一下。</p><p>那channel作为一等公民意味着什么呢？</p><p>这意味着我们可以<strong>像使用普通变量那样使用channel</strong>，比如，定义channel类型变量、给channel变量赋值、将channel作为参数传递给函数/方法、将channel作为返回值从函数/方法中返回，甚至将channel发送到其他channel中。这就大大简化了channel原语的使用，提升了我们开发者在做并发设计和实现时的体验。</p><h3 id="创建channel"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#创建channel"><span class="icon icon-link"></span></a>创建channel</h3><p>和切片、结构体、map等一样，channel也是一种复合数据类型。也就是说，我们在声明一个channel类型变量时，必须给出其具体的元素类型，比如下面的代码这样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var ch chan int</span></div></pre></div><p>这句代码里，我们声明了一个元素为int类型的channel类型变量ch。</p><p>如果channel类型变量在声明时没有被赋予初值，那么它的默认值为nil。并且，和其他复合数据类型支持使用复合类型字面值作为变量初始值不同，为channel类型变量赋初值的唯一方法就是使用<strong>make</strong>这个Go预定义的函数，比如下面代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ch1 := make(chan int)   </span></div><div class="token-line"><span class="token plain">    ch2 := make(chan int, 5)</span></div></pre></div><p>这里，我们声明了两个元素类型为int的channel类型变量ch1和ch2，并给这两个变量赋了初值。但我们看到，两个变量的赋初值操作使用的make调用的形式有所不同。</p><p>第一行我们通过<code>make(chan T)</code>创建的、元素类型为T的channel类型，是<strong>无缓冲channel</strong>，而第二行中通过带有capacity参数的<code>make(chan T, capacity)</code>创建的元素类型为T、缓冲区长度为capacity的channel类型，是<strong>带缓冲channel</strong>。</p><p>这两种类型的变量关于发送（send）与接收（receive）的特性是不同的，我们接下来就基于这两种类型的channel，看看channel类型变量如何进行发送和接收数据元素。</p><h3 id="发送与接收"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#发送与接收"><span class="icon icon-link"></span></a>发送与接收</h3><p>Go提供了<code>&lt;-</code>操作符用于对channel类型变量进行发送与接收操作：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ch1 &lt;- 13    // 将整型字面值13发送到无缓冲channel类型变量ch1中</span></div><div class="token-line"><span class="token plain">    n := &lt;- ch1  // 从无缓冲channel类型变量ch1中接收一个整型值存储到整型变量n中</span></div><div class="token-line"><span class="token plain">    ch2 &lt;- 17    // 将整型字面值17发送到带缓冲channel类型变量ch2中</span></div><div class="token-line"><span class="token plain">    m := &lt;- ch2  // 从带缓冲channel类型变量ch2中接收一个整型值存储到整型变量m中</span></div></pre></div><p>这里我要提醒你一句，在理解channel的发送与接收操作时，你一定要始终牢记：<strong>channel是用于Goroutine间通信的</strong>，所以绝大多数对channel的读写都被分别放在了不同的Goroutine中。</p><p>现在，我们先来看看无缓冲channel类型变量（如ch1）的发送与接收。</p><p>由于无缓冲channel的运行时层实现不带有缓冲区，所以Goroutine对无缓冲channel的接收和发送操作是同步的。也就是说，对同一个无缓冲channel，只有对它进行接收操作的Goroutine和对它进行发送操作的Goroutine都存在的情况下，通信才能得以进行，否则单方面的操作会让对应的Goroutine陷入挂起状态，比如下面示例代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func main() {</span></div><div class="token-line"><span class="token plain">        ch1 := make(chan int)</span></div><div class="token-line"><span class="token plain">        ch1 &lt;- 13 // fatal error: all goroutines are asleep - deadlock!</span></div><div class="token-line"><span class="token plain">        n := &lt;-ch1</span></div><div class="token-line"><span class="token plain">        println(n)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这个示例中，我们创建了一个无缓冲的channel类型变量ch1，对ch1的读写都放在了一个Goroutine中。</p><p>运行这个示例，我们就会得到fatal error，提示我们所有Goroutine都处于休眠状态，程序处于死锁状态。要想解除这种错误状态，我们只需要将接收操作，或者发送操作放到另外一个Goroutine中就可以了，比如下面代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func main() {</span></div><div class="token-line"><span class="token plain">        ch1 := make(chan int)</span></div><div class="token-line"><span class="token plain">        go func() {</span></div><div class="token-line"><span class="token plain">            ch1 &lt;- 13 // 将发送操作放入一个新goroutine中执行</span></div><div class="token-line"><span class="token plain">        }()</span></div><div class="token-line"><span class="token plain">        n := &lt;-ch1</span></div><div class="token-line"><span class="token plain">        println(n)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>由此，我们可以得出结论：<strong>对无缓冲channel类型的发送与接收操作，一定要放在两个不同的Goroutine中进行，否则会导致deadlock</strong>。</p><p>接下来，我们再来看看带缓冲channel的发送与接收操作。</p><p>和无缓冲channel相反，带缓冲channel的运行时层实现带有缓冲区，因此，对带缓冲channel的发送操作在缓冲区未满、接收操作在缓冲区非空的情况下是<strong>异步</strong>的（发送或接收不需要阻塞等待）。</p><p>也就是说，对一个带缓冲channel来说，在缓冲区未满的情况下，对它进行发送操作的Goroutine并不会阻塞挂起；在缓冲区有数据的情况下，对它进行接收操作的Goroutine也不会阻塞挂起。</p><p>但当缓冲区满了的情况下，对它进行发送操作的Goroutine就会阻塞挂起；当缓冲区为空的情况下，对它进行接收操作的Goroutine也会阻塞挂起。</p><p>如果光看文字还不是很好理解，你可以再看看下面几个关于带缓冲channel的操作的例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ch2 := make(chan int, 1)</span></div><div class="token-line"><span class="token plain">    n := &lt;-ch2 // 由于此时ch2的缓冲区中无数据，因此对其进行接收操作将导致goroutine挂起</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ch3 := make(chan int, 1)</span></div><div class="token-line"><span class="token plain">    ch3 &lt;- 17  // 向ch3发送一个整型数17</span></div><div class="token-line"><span class="token plain">    ch3 &lt;- 27  // 由于此时ch3中缓冲区已满，再向ch3发送数据也将导致goroutine挂起</span></div></pre></div><p>也正是因为带缓冲channel与无缓冲channel在发送与接收行为上的差异，在具体使用上，它们有各自的“用武之地”，这个我们等会再细说，现在我们先继续把channel的基本语法讲完。</p><p>使用操作符<code>&lt;-</code>，我们还可以声明<strong>只发送channel类型</strong>（send-only）和<strong>只接收channel类型</strong>（recv-only），我们接着看下面这个例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ch1 := make(chan&lt;- int, 1) // 只发送channel类型</span></div><div class="token-line"><span class="token plain">    ch2 := make(&lt;-chan int, 1) // 只接收channel类型</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &lt;-ch1       // invalid operation: &lt;-ch1 (receive from send-only type chan&lt;- int)</span></div><div class="token-line"><span class="token plain">    ch2 &lt;- 13   // invalid operation: ch2 &lt;- 13 (send to receive-only type &lt;-chan int)</span></div></pre></div><p>你可以从这个例子中看到，试图从一个只发送channel类型变量中接收数据，或者向一个只接收channel类型发送数据，都会导致编译错误。通常只发送channel类型和只接收channel类型，会被用作函数的参数类型或返回值，用于限制对channel内的操作，或者是明确可对channel进行的操作的类型，比如下面这个例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func produce(ch chan&lt;- int) {</span></div><div class="token-line"><span class="token plain">        for i := 0; i &lt; 10; i++ {</span></div><div class="token-line"><span class="token plain">            ch &lt;- i + 1</span></div><div class="token-line"><span class="token plain">            time.Sleep(time.Second)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        close(ch)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func consume(ch &lt;-chan int) {</span></div><div class="token-line"><span class="token plain">        for n := range ch {</span></div><div class="token-line"><span class="token plain">            println(n)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">        ch := make(chan int, 5)</span></div><div class="token-line"><span class="token plain">        var wg sync.WaitGroup</span></div><div class="token-line"><span class="token plain">        wg.Add(2)</span></div><div class="token-line"><span class="token plain">        go func() {</span></div><div class="token-line"><span class="token plain">            produce(ch)</span></div><div class="token-line"><span class="token plain">            wg.Done()</span></div><div class="token-line"><span class="token plain">        }()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        go func() {</span></div><div class="token-line"><span class="token plain">            consume(ch)</span></div><div class="token-line"><span class="token plain">            wg.Done()</span></div><div class="token-line"><span class="token plain">        }()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        wg.Wait()</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这个例子中，我们启动了两个Goroutine，分别代表生产者（produce）与消费者（consume）。生产者只能向channel中发送数据，我们使用<code>chan&lt;- int</code>作为produce函数的参数类型；消费者只能从channel中接收数据，我们使用<code>&lt;-chan int</code>作为consume函数的参数类型。</p><p>在消费者函数consume中，我们使用了for range循环语句来从channel中接收数据，for range会阻塞在对channel的接收操作上，直到channel中有数据可接收或channel被关闭循环，才会继续向下执行。channel被关闭后，for range循环也就结束了。</p><h3 id="关闭channel"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#关闭channel"><span class="icon icon-link"></span></a>关闭channel</h3><p>在上面的例子中，produce函数在发送完数据后，调用Go内置的close函数关闭了channel。channel关闭后，所有等待从这个channel接收数据的操作都将返回。</p><p>这里我们继续看一下采用不同接收语法形式的语句，在channel被关闭后的返回值的情况：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">n := &lt;- ch      // 当ch被关闭后，n将被赋值为ch元素类型的零值</span></div><div class="token-line"><span class="token plain">    m, ok := &lt;-ch   // 当ch被关闭后，m将被赋值为ch元素类型的零值, ok值为false</span></div><div class="token-line"><span class="token plain">    for v := range ch { // 当ch被关闭后，for range循环结束</span></div><div class="token-line"><span class="token plain">        ... ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们看到，通过“comma, ok”惯用法或for range语句，我们可以准确地判定channel是否被关闭。而单纯采用<code>n := &lt;-ch</code>形式的语句，我们就无法判定从ch返回的元素类型零值，究竟是不是因为channel被关闭后才返回的。</p><p>另外，从前面produce的示例程序中，我们也可以看到，channel是在produce函数中被关闭的，这也是channel的一个使用惯例，那就是<strong>发送端负责关闭channel</strong>。</p><p>这里为什么要在发送端关闭channel呢？</p><p>这是因为发送端没有像接受端那样的、可以安全判断channel是否被关闭了的方法。同时，一旦向一个已经关闭的channel执行发送操作，这个操作就会引发panic，比如下面这个示例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ch := make(chan int, 5)</span></div><div class="token-line"><span class="token plain">    close(ch)</span></div><div class="token-line"><span class="token plain">    ch &lt;- 13 // panic: send on closed channel</span></div></pre></div><h3 id="select"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#select"><span class="icon icon-link"></span></a>select</h3><p>当涉及同时对多个channel进行操作时，我们会结合Go为CSP并发模型提供的另外一个原语<strong>select</strong>，一起使用。</p><p>通过select，我们可以同时在多个channel上进行发送/接收操作：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">select {</span></div><div class="token-line"><span class="token plain">    case x := &lt;-ch1:     // 从channel ch1接收数据</span></div><div class="token-line"><span class="token plain">    	... ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    case y, ok := &lt;-ch2: // 从channel ch2接收数据，并根据ok值判断ch2是否已经关闭</span></div><div class="token-line"><span class="token plain">    	... ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    case ch3 &lt;- z:       // 将z值发送到channel ch3中:</span></div><div class="token-line"><span class="token plain">    	... ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    default:             // 当上面case中的channel通信均无法实施时，执行该默认分支</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>当select语句中没有default分支，而且所有case中的channel操作都阻塞了的时候，整个select语句都将被阻塞，直到某一个case上的channel变成可发送，或者某个case上的channel变成可接收，select语句才可以继续进行下去。关于select语句的妙用，我们在后面还会细讲，这里我们先简单了解它的基本语法。</p><p>看到这里你应该能感受到，channel和select两种原语的操作都十分简单，它们都遵循了Go语言**“追求简单”**的设计哲学，但它们却为Go并发程序带来了强大的表达能力。学习了这些基础用法后，接下来我们再深一层，看看Go并发原语channel的一些惯用法。同样地，这里我们也分成无缓冲channel和带缓冲channel两种情况来分析。</p><h2 id="无缓冲channel的惯用法"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#无缓冲channel的惯用法"><span class="icon icon-link"></span></a>无缓冲channel的惯用法</h2><p>无缓冲channel兼具通信和同步特性，在并发程序中应用颇为广泛。现在我们来看看几个无缓冲channel的典型应用：</p><h3 id="第一种用法用作信号传递"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#第一种用法用作信号传递"><span class="icon icon-link"></span></a>第一种用法：用作信号传递</h3><p>无缓冲channel用作信号传递的时候，有两种情况，分别是1对1通知信号和1对n通知信号。我们先来分析下1对1通知信号这种情况。</p><p>我们直接来看具体的例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type signal struct{}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func worker() {</span></div><div class="token-line"><span class="token plain">        println(&quot;worker is working...&quot;)</span></div><div class="token-line"><span class="token plain">        time.Sleep(1 * time.Second)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func spawn(f func()) &lt;-chan signal {</span></div><div class="token-line"><span class="token plain">        c := make(chan signal)</span></div><div class="token-line"><span class="token plain">        go func() {</span></div><div class="token-line"><span class="token plain">            println(&quot;worker start to work...&quot;)</span></div><div class="token-line"><span class="token plain">            f()</span></div><div class="token-line"><span class="token plain">            c &lt;- signal{}</span></div><div class="token-line"><span class="token plain">        }()</span></div><div class="token-line"><span class="token plain">        return c</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">        println(&quot;start a worker...&quot;)</span></div><div class="token-line"><span class="token plain">        c := spawn(worker)</span></div><div class="token-line"><span class="token plain">        &lt;-c</span></div><div class="token-line"><span class="token plain">        fmt.Println(&quot;worker work done!&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这个例子中，spawn函数返回的channel，被用于承载新Goroutine退出的**“通知信号”**，这个信号专门用作通知main goroutine。main goroutine在调用spawn函数后一直阻塞在对这个“通知信号”的接收动作上。</p><p>我们来运行一下这个例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">start a worker...</span></div><div class="token-line"><span class="token plain">    worker start to work...</span></div><div class="token-line"><span class="token plain">    worker is working...</span></div><div class="token-line"><span class="token plain">    worker work done!</span></div></pre></div><p>有些时候，无缓冲channel还被用来实现<strong>1对n的信号通知</strong>机制。这样的信号通知机制，常被用于协调多个Goroutine一起工作，比如下面的例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func worker(i int) {</span></div><div class="token-line"><span class="token plain">        fmt.Printf(&quot;worker %d: is working...\n&quot;, i)</span></div><div class="token-line"><span class="token plain">        time.Sleep(1 * time.Second)</span></div><div class="token-line"><span class="token plain">        fmt.Printf(&quot;worker %d: works done\n&quot;, i)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func spawnGroup(f func(i int), num int, groupSignal &lt;-chan signal) &lt;-chan signal {</span></div><div class="token-line"><span class="token plain">        c := make(chan signal)</span></div><div class="token-line"><span class="token plain">        var wg sync.WaitGroup</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for i := 0; i &lt; num; i++ {</span></div><div class="token-line"><span class="token plain">            wg.Add(1)</span></div><div class="token-line"><span class="token plain">            go func(i int) {</span></div><div class="token-line"><span class="token plain">                &lt;-groupSignal</span></div><div class="token-line"><span class="token plain">                fmt.Printf(&quot;worker %d: start to work...\n&quot;, i)</span></div><div class="token-line"><span class="token plain">                f(i)</span></div><div class="token-line"><span class="token plain">                wg.Done()</span></div><div class="token-line"><span class="token plain">            }(i + 1)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        go func() {</span></div><div class="token-line"><span class="token plain">            wg.Wait()</span></div><div class="token-line"><span class="token plain">            c &lt;- signal(struct{}{})</span></div><div class="token-line"><span class="token plain">        }()</span></div><div class="token-line"><span class="token plain">        return c</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">        fmt.Println(&quot;start a group of workers...&quot;)</span></div><div class="token-line"><span class="token plain">        groupSignal := make(chan signal)</span></div><div class="token-line"><span class="token plain">        c := spawnGroup(worker, 5, groupSignal)</span></div><div class="token-line"><span class="token plain">        time.Sleep(5 * time.Second)</span></div><div class="token-line"><span class="token plain">        fmt.Println(&quot;the group of workers start to work...&quot;)</span></div><div class="token-line"><span class="token plain">        close(groupSignal)</span></div><div class="token-line"><span class="token plain">        &lt;-c</span></div><div class="token-line"><span class="token plain">        fmt.Println(&quot;the group of workers work done!&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个例子中，main goroutine创建了一组5个worker goroutine，这些Goroutine启动后会阻塞在名为groupSignal的无缓冲channel上。main goroutine通过<code>close(groupSignal)</code>向所有worker goroutine广播“开始工作”的信号，收到groupSignal后，所有worker goroutine会**“同时”**开始工作，就像起跑线上的运动员听到了裁判员发出的起跑信号枪声。</p><p>这个例子的运行结果如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">start a group of workers...</span></div><div class="token-line"><span class="token plain">    the group of workers start to work...</span></div><div class="token-line"><span class="token plain">    worker 3: start to work...</span></div><div class="token-line"><span class="token plain">    worker 3: is working...</span></div><div class="token-line"><span class="token plain">    worker 4: start to work...</span></div><div class="token-line"><span class="token plain">    worker 4: is working...</span></div><div class="token-line"><span class="token plain">    worker 1: start to work...</span></div><div class="token-line"><span class="token plain">    worker 1: is working...</span></div><div class="token-line"><span class="token plain">    worker 5: start to work...</span></div><div class="token-line"><span class="token plain">    worker 5: is working...</span></div><div class="token-line"><span class="token plain">    worker 2: start to work...</span></div><div class="token-line"><span class="token plain">    worker 2: is working...</span></div><div class="token-line"><span class="token plain">    worker 3: works done</span></div><div class="token-line"><span class="token plain">    worker 4: works done</span></div><div class="token-line"><span class="token plain">    worker 5: works done</span></div><div class="token-line"><span class="token plain">    worker 1: works done</span></div><div class="token-line"><span class="token plain">    worker 2: works done</span></div><div class="token-line"><span class="token plain">    the group of workers work done!</span></div></pre></div><p>我们可以看到，关闭一个无缓冲channel会让所有阻塞在这个channel上的接收操作返回，从而实现了一种1对n的**“广播”**机制。</p><h3 id="第二种用法用于替代锁机制"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#第二种用法用于替代锁机制"><span class="icon icon-link"></span></a>第二种用法：用于替代锁机制</h3><p>无缓冲channel具有同步特性，这让它在某些场合可以替代锁，让我们的程序更加清晰，可读性也更好。我们可以对比下两个方案，直观地感受一下。</p><p>首先我们看一个传统的、基于“共享内存”+“互斥锁”的Goroutine安全的计数器的实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type counter struct {</span></div><div class="token-line"><span class="token plain">        sync.Mutex</span></div><div class="token-line"><span class="token plain">        i int</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    var cter counter</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func Increase() int {</span></div><div class="token-line"><span class="token plain">        cter.Lock()</span></div><div class="token-line"><span class="token plain">        defer cter.Unlock()</span></div><div class="token-line"><span class="token plain">        cter.i++</span></div><div class="token-line"><span class="token plain">        return cter.i</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">        var wg sync.WaitGroup</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for i := 0; i &lt; 10; i++ {</span></div><div class="token-line"><span class="token plain">            wg.Add(1)</span></div><div class="token-line"><span class="token plain">            go func(i int) {</span></div><div class="token-line"><span class="token plain">                v := Increase()</span></div><div class="token-line"><span class="token plain">                fmt.Printf(&quot;goroutine-%d: current counter value is %d\n&quot;, i, v)</span></div><div class="token-line"><span class="token plain">                wg.Done()</span></div><div class="token-line"><span class="token plain">            }(i)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        wg.Wait()</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这个示例中，我们使用了一个带有互斥锁保护的全局变量作为计数器，所有要操作计数器的Goroutine共享这个全局变量，并在互斥锁的同步下对计数器进行自增操作。</p><p>接下来我们再看更符合Go设计惯例的实现，也就是使用无缓冲channel替代锁后的实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type counter struct {</span></div><div class="token-line"><span class="token plain">        c chan int</span></div><div class="token-line"><span class="token plain">        i int</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func NewCounter() *counter {</span></div><div class="token-line"><span class="token plain">        cter := &amp;counter{</span></div><div class="token-line"><span class="token plain">            c: make(chan int),</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        go func() {</span></div><div class="token-line"><span class="token plain">            for {</span></div><div class="token-line"><span class="token plain">                cter.i++</span></div><div class="token-line"><span class="token plain">                cter.c &lt;- cter.i</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }()</span></div><div class="token-line"><span class="token plain">        return cter</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func (cter *counter) Increase() int {</span></div><div class="token-line"><span class="token plain">        return &lt;-cter.c</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">        cter := NewCounter()</span></div><div class="token-line"><span class="token plain">        var wg sync.WaitGroup</span></div><div class="token-line"><span class="token plain">        for i := 0; i &lt; 10; i++ {</span></div><div class="token-line"><span class="token plain">            wg.Add(1)</span></div><div class="token-line"><span class="token plain">            go func(i int) {</span></div><div class="token-line"><span class="token plain">                v := cter.Increase()</span></div><div class="token-line"><span class="token plain">                fmt.Printf(&quot;goroutine-%d: current counter value is %d\n&quot;, i, v)</span></div><div class="token-line"><span class="token plain">                wg.Done()</span></div><div class="token-line"><span class="token plain">            }(i)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        wg.Wait()</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这个实现中，我们将计数器操作全部交给一个独立的Goroutine去处理，并通过无缓冲channel的同步阻塞特性，实现了计数器的控制。这样其他Goroutine通过Increase函数试图增加计数器值的动作，实质上就转化为了一次无缓冲channel的接收动作。</p><p>这种并发设计逻辑更符合Go语言所倡导的**“不要通过共享内存来通信，而是通过通信来共享内存”**的原则。</p><p>运行这个示例，我们可以得出与互斥锁方案相同的结果：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">goroutine-9: current counter value is 10</span></div><div class="token-line"><span class="token plain">    goroutine-0: current counter value is 1</span></div><div class="token-line"><span class="token plain">    goroutine-6: current counter value is 7</span></div><div class="token-line"><span class="token plain">    goroutine-2: current counter value is 3</span></div><div class="token-line"><span class="token plain">    goroutine-8: current counter value is 9</span></div><div class="token-line"><span class="token plain">    goroutine-4: current counter value is 5</span></div><div class="token-line"><span class="token plain">    goroutine-5: current counter value is 6</span></div><div class="token-line"><span class="token plain">    goroutine-1: current counter value is 2</span></div><div class="token-line"><span class="token plain">    goroutine-7: current counter value is 8</span></div><div class="token-line"><span class="token plain">    goroutine-3: current counter value is 4</span></div></pre></div><h2 id="带缓冲channel的惯用法"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#带缓冲channel的惯用法"><span class="icon icon-link"></span></a>带缓冲channel的惯用法</h2><p>带缓冲的channel与无缓冲的channel的最大不同之处，就在于它的<strong>异步性</strong>。也就是说，对一个带缓冲channel，在缓冲区未满的情况下，对它进行发送操作的Goroutine不会阻塞挂起；在缓冲区有数据的情况下，对它进行接收操作的Goroutine也不会阻塞挂起。</p><p>这种特性让带缓冲的channel有着与无缓冲channel不同的应用场合。接下来我们一个个来分析。</p><h3 id="第一种用法用作消息队列"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#第一种用法用作消息队列"><span class="icon icon-link"></span></a>第一种用法：用作消息队列</h3><p>channel经常被Go初学者视为在多个Goroutine之间通信的消息队列，这是因为，channel的原生特性与我们认知中的消息队列十分相似，包括Goroutine安全、有FIFO（first-in, first out）保证等。</p><p>其实，和无缓冲channel更多用于信号/事件管道相比，可自行设置容量、异步收发的带缓冲channel更适合被用作为消息队列，并且，带缓冲channel在数据收发的性能上要明显好于无缓冲channel。</p><p>我们可以通过对channel读写的基本测试来印证这一点。下面是一些关于无缓冲channel和带缓冲channel收发性能测试的结果（Go 1.17, MacBook Pro 8核）。基准测试的代码比较多，我就不全部贴出来了，你可以到<a target="_blank" rel="noopener noreferrer" href="https://github.com/bigwhite/publication/tree/master/column/timegeek/go-first-course/33/go-channel-operation-benchmark">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>下载。</p><ul><li><strong>单接收单发送性能的基准测试</strong></li></ul><p>我们先来看看针对一个channel只有一个发送Goroutine和一个接收Goroutine的情况，两种channel的收发性能比对数据：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 无缓冲channel</span></div><div class="token-line"><span class="token plain">    // go-channel-operation-benchmark/unbuffered-chan</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    $go test -bench . one_to_one_test.go</span></div><div class="token-line"><span class="token plain">    goos: darwin</span></div><div class="token-line"><span class="token plain">    goarch: amd64</span></div><div class="token-line"><span class="token plain">    cpu: Intel(R) Core(TM) i5-8257U CPU @ 1.40GHz</span></div><div class="token-line"><span class="token plain">    BenchmarkUnbufferedChan1To1Send-8   	 6037778	       199.7 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkUnbufferedChan1To1Recv-8   	 6286850	       194.5 ns/op</span></div><div class="token-line"><span class="token plain">    PASS</span></div><div class="token-line"><span class="token plain">    ok  	command-line-arguments	2.833s</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 带缓冲channel</span></div><div class="token-line"><span class="token plain">    // go-channel-operation-benchmark/buffered-chan</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    $go test -bench . one_to_one_cap_10_test.go</span></div><div class="token-line"><span class="token plain">    goos: darwin</span></div><div class="token-line"><span class="token plain">    goarch: amd64</span></div><div class="token-line"><span class="token plain">    cpu: Intel(R) Core(TM) i5-8257U CPU @ 1.40GHz</span></div><div class="token-line"><span class="token plain">    BenchmarkBufferedChan1To1SendCap10-8   	17089879	        66.16 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkBufferedChan1To1RecvCap10-8   	18043450	        65.57 ns/op</span></div><div class="token-line"><span class="token plain">    PASS</span></div><div class="token-line"><span class="token plain">    ok  	command-line-arguments	2.460s</span></div></pre></div><p>然后我们将channel的缓存由10改为100，再看看带缓冲channel的1对1基准测试结果：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$go test -bench . one_to_one_cap_100_test.go</span></div><div class="token-line"><span class="token plain">    goos: darwin</span></div><div class="token-line"><span class="token plain">    goarch: amd64</span></div><div class="token-line"><span class="token plain">    cpu: Intel(R) Core(TM) i5-8257U CPU @ 1.40GHz</span></div><div class="token-line"><span class="token plain">    BenchmarkBufferedChan1To1SendCap100-8   	23089318	        53.06 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkBufferedChan1To1RecvCap100-8   	23474095	        51.33 ns/op</span></div><div class="token-line"><span class="token plain">    PASS</span></div><div class="token-line"><span class="token plain">    ok  	command-line-arguments	2.542s</span></div></pre></div><ul><li><strong>多接收多发送性能基准测试</strong></li></ul><p>我们再来看看，针对一个channel有多个发送Goroutine和多个接收Goroutine的情况，两种channel的收发性能比对数据（这里建立10个发送Goroutine和10个接收Goroutine）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 无缓冲channel</span></div><div class="token-line"><span class="token plain">    // go-channel-operation-benchmark/unbuffered-chan</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    $go test -bench .  multi_to_multi_test.go </span></div><div class="token-line"><span class="token plain">    goos: darwin</span></div><div class="token-line"><span class="token plain">    goarch: amd64</span></div><div class="token-line"><span class="token plain">    cpu: Intel(R) Core(TM) i5-8257U CPU @ 1.40GHz</span></div><div class="token-line"><span class="token plain">    BenchmarkUnbufferedChanNToNSend-8   	  293930	      3779 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkUnbufferedChanNToNRecv-8   	  280904	      4190 ns/op</span></div><div class="token-line"><span class="token plain">    PASS</span></div><div class="token-line"><span class="token plain">    ok  	command-line-arguments	2.387s</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 带缓冲channel</span></div><div class="token-line"><span class="token plain">    // go-channel-operation-benchmark/buffered-chan</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    $go test -bench . multi_to_multi_cap_10_test.go </span></div><div class="token-line"><span class="token plain">    goos: darwin</span></div><div class="token-line"><span class="token plain">    goarch: amd64</span></div><div class="token-line"><span class="token plain">    cpu: Intel(R) Core(TM) i5-8257U CPU @ 1.40GHz</span></div><div class="token-line"><span class="token plain">    BenchmarkBufferedChanNToNSendCap10-8   	  736540	      1609 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkBufferedChanNToNRecvCap10-8   	  795416	      1616 ns/op</span></div><div class="token-line"><span class="token plain">    PASS</span></div><div class="token-line"><span class="token plain">    ok  	command-line-arguments	2.514s</span></div></pre></div><p>这里我们也将channel的缓存由10改为100后，看看带缓冲channel的多对多基准测试结果：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$go test -bench . multi_to_multi_cap_100_test.go </span></div><div class="token-line"><span class="token plain">    goos: darwin</span></div><div class="token-line"><span class="token plain">    goarch: amd64</span></div><div class="token-line"><span class="token plain">    cpu: Intel(R) Core(TM) i5-8257U CPU @ 1.40GHz</span></div><div class="token-line"><span class="token plain">    BenchmarkBufferedChanNToNSendCap100-8   	 1236453	       966.4 ns/op</span></div><div class="token-line"><span class="token plain">    BenchmarkBufferedChanNToNRecvCap100-8   	 1279766	       969.4 ns/op</span></div><div class="token-line"><span class="token plain">    PASS</span></div><div class="token-line"><span class="token plain">    ok  	command-line-arguments	4.309s</span></div></pre></div><p>综合前面这些结果数据，我们可以得出几个初步结论：</p><ul><li>无论是1收1发还是多收多发，带缓冲channel的收发性能都要好于无缓冲channel；</li><li>对于带缓冲channel而言，发送与接收的Goroutine数量越多，收发性能会有所下降；</li><li>对于带缓冲channel而言，选择适当容量会在一定程度上提升收发性能。</li></ul><p>不过你要注意的是，Go支持channel的初衷是将它作为Goroutine间的通信手段，它并不是专门用于消息队列场景的。如果你的项目需要专业消息队列的功能特性，比如支持优先级、支持权重、支持离线持久化等，那么channel就不合适了，可以使用第三方的专业的消息队列实现。</p><h3 id="第二种用法用作计数信号量counting-semaphore"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#第二种用法用作计数信号量counting-semaphore"><span class="icon icon-link"></span></a>第二种用法：用作计数信号量（counting semaphore）</h3><p>Go并发设计的一个惯用法，就是将带缓冲channel用作计数信号量（counting semaphore）。带缓冲channel中的当前数据个数代表的是，当前同时处于活动状态（处理业务）的Goroutine的数量，而带缓冲channel的容量（capacity），就代表了允许同时处于活动状态的Goroutine的最大数量。向带缓冲channel的一个发送操作表示获取一个信号量，而从channel的一个接收操作则表示释放一个信号量。</p><p>这里我们来看一个将带缓冲channel用作计数信号量的例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var active = make(chan struct{}, 3)</span></div><div class="token-line"><span class="token plain">    var jobs = make(chan int, 10)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">        go func() {</span></div><div class="token-line"><span class="token plain">            for i := 0; i &lt; 8; i++ {</span></div><div class="token-line"><span class="token plain">                jobs &lt;- (i + 1)</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            close(jobs)</span></div><div class="token-line"><span class="token plain">        }()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        var wg sync.WaitGroup</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for j := range jobs {</span></div><div class="token-line"><span class="token plain">            wg.Add(1)</span></div><div class="token-line"><span class="token plain">            go func(j int) {</span></div><div class="token-line"><span class="token plain">                active &lt;- struct{}{}</span></div><div class="token-line"><span class="token plain">                log.Printf(&quot;handle job: %d\n&quot;, j)</span></div><div class="token-line"><span class="token plain">                time.Sleep(2 * time.Second)</span></div><div class="token-line"><span class="token plain">                &lt;-active</span></div><div class="token-line"><span class="token plain">                wg.Done()</span></div><div class="token-line"><span class="token plain">            }(j)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        wg.Wait()</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们看到，这个示例创建了一组Goroutine来处理job，同一时间允许最多3个Goroutine处于活动状态。</p><p>为了达成这一目标，我们看到这个示例使用了一个容量（capacity）为3的带缓冲channel: <strong>active</strong>作为计数信号量，这意味着允许同时处于<strong>活动状态</strong>的最大Goroutine数量为3。</p><p>我们运行一下这个示例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">2022/01/02 10:08:55 handle job: 1</span></div><div class="token-line"><span class="token plain">    2022/01/02 10:08:55 handle job: 4</span></div><div class="token-line"><span class="token plain">    2022/01/02 10:08:55 handle job: 8</span></div><div class="token-line"><span class="token plain">    2022/01/02 10:08:57 handle job: 5</span></div><div class="token-line"><span class="token plain">    2022/01/02 10:08:57 handle job: 7</span></div><div class="token-line"><span class="token plain">    2022/01/02 10:08:57 handle job: 6</span></div><div class="token-line"><span class="token plain">    2022/01/02 10:08:59 handle job: 3</span></div><div class="token-line"><span class="token plain">    2022/01/02 10:08:59 handle job: 2</span></div></pre></div><p>从示例运行结果中的时间戳中，我们可以看到，虽然我们创建了很多Goroutine，但由于计数信号量的存在，同一时间内处于活动状态（正在处理job）的Goroutine的数量最多为3个。</p><h3 id="lenchannel的应用"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#lenchannel的应用"><span class="icon icon-link"></span></a>len(channel)的应用</h3><p><strong>len</strong>是Go语言的一个内置函数，它支持接收数组、切片、map、字符串和channel类型的参数，并返回对应类型的“长度”，也就是一个整型值。</p><p>针对channel ch的类型不同，len(ch)有如下两种语义：</p><ul><li>当ch为无缓冲channel时，len(ch)总是返回0；</li><li>当ch为带缓冲channel时，len(ch)返回当前channel ch中尚未被读取的元素个数。</li></ul><p>这样一来，针对带缓冲channel的len调用似乎才是有意义的。那我们是否可以使用len函数来实现带缓冲channel的“判满”、“判有”和“判空”逻辑呢？就像下面示例中伪代码这样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var ch chan T = make(chan T, capacity)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 判空</span></div><div class="token-line"><span class="token plain">    if len(ch) == 0 {</span></div><div class="token-line"><span class="token plain">        // 此时channel ch空了?</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 判有</span></div><div class="token-line"><span class="token plain">    if len(ch) &gt; 0 {</span></div><div class="token-line"><span class="token plain">        // 此时channel ch中有数据?</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 判满</span></div><div class="token-line"><span class="token plain">    if len(ch) == cap(ch) {</span></div><div class="token-line"><span class="token plain">        // 此时channel ch满了?</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>你可以看到，我在上面代码注释的“空了”、“有数据”和“满了”的后面都**打上了问号****。**这是为什么呢？</p><p>这是因为，channel原语用于多个Goroutine间的通信，一旦多个Goroutine共同对channel进行收发操作，len(channel)就会在多个Goroutine间形成“竞态”。单纯地依靠len(channel)来判断channel中元素状态，是不能保证在后续对channel的收发时channel状态是不变的。</p><p>我们以判空为例看看：</p><p><img src="https://static001.geekbang.org/resource/image/39/9a/39b77d5624701d2df79ff0b8865d339a.jpg?wh=1920x1047" alt="图片"/></p><p>从上图可以看到，Goroutine1使用len(channel)判空后，就会尝试从channel中接收数据。但在它真正从channel读数据之前，另外一个Goroutine2已经将数据读了出去，所以，Goroutine1后面的<strong>读取就会阻塞在channel上</strong>，导致后面逻辑的失效。</p><p>因此，<strong>为了不阻塞在channel上</strong>，常见的方法是将“判空与读取”放在一个“事务”中，将“判满与写入”放在一个“事务”中，而这类“事务”我们可以通过select实现。我们来看下面示例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func producer(c chan&lt;- int) {</span></div><div class="token-line"><span class="token plain">        var i int = 1</span></div><div class="token-line"><span class="token plain">        for {</span></div><div class="token-line"><span class="token plain">            time.Sleep(2 * time.Second)</span></div><div class="token-line"><span class="token plain">            ok := trySend(c, i)</span></div><div class="token-line"><span class="token plain">            if ok {</span></div><div class="token-line"><span class="token plain">                fmt.Printf(&quot;[producer]: send [%d] to channel\n&quot;, i)</span></div><div class="token-line"><span class="token plain">                i++</span></div><div class="token-line"><span class="token plain">                continue</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            fmt.Printf(&quot;[producer]: try send [%d], but channel is full\n&quot;, i)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func tryRecv(c &lt;-chan int) (int, bool) {</span></div><div class="token-line"><span class="token plain">        select {</span></div><div class="token-line"><span class="token plain">        case i := &lt;-c:</span></div><div class="token-line"><span class="token plain">            return i, true</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        default:</span></div><div class="token-line"><span class="token plain">            return 0, false</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func trySend(c chan&lt;- int, i int) bool {</span></div><div class="token-line"><span class="token plain">        select {</span></div><div class="token-line"><span class="token plain">        case c &lt;- i:</span></div><div class="token-line"><span class="token plain">            return true</span></div><div class="token-line"><span class="token plain">        default:</span></div><div class="token-line"><span class="token plain">            return false</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func consumer(c &lt;-chan int) {</span></div><div class="token-line"><span class="token plain">        for {</span></div><div class="token-line"><span class="token plain">            i, ok := tryRecv(c)</span></div><div class="token-line"><span class="token plain">            if !ok {</span></div><div class="token-line"><span class="token plain">                fmt.Println(&quot;[consumer]: try to recv from channel, but the channel is empty&quot;)</span></div><div class="token-line"><span class="token plain">                time.Sleep(1 * time.Second)</span></div><div class="token-line"><span class="token plain">                continue</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            fmt.Printf(&quot;[consumer]: recv [%d] from channel\n&quot;, i)</span></div><div class="token-line"><span class="token plain">            if i &gt;= 3 {</span></div><div class="token-line"><span class="token plain">                fmt.Println(&quot;[consumer]: exit&quot;)</span></div><div class="token-line"><span class="token plain">                return</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">        var wg sync.WaitGroup</span></div><div class="token-line"><span class="token plain">        c := make(chan int, 3)</span></div><div class="token-line"><span class="token plain">        wg.Add(2)</span></div><div class="token-line"><span class="token plain">        go func() {</span></div><div class="token-line"><span class="token plain">            producer(c)</span></div><div class="token-line"><span class="token plain">            wg.Done()</span></div><div class="token-line"><span class="token plain">        }()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        go func() {</span></div><div class="token-line"><span class="token plain">            consumer(c)</span></div><div class="token-line"><span class="token plain">            wg.Done()</span></div><div class="token-line"><span class="token plain">        }()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        wg.Wait()</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们看到，由于用到了select原语的default分支语义，当channel空的时候，tryRecv不会阻塞；当channel满的时候，trySend也不会阻塞。</p><p>这个示例的运行结果也证明了这一点，无论是使用tryRecv的consumer还是使用trySend的producer都不会阻塞：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[consumer]: try to recv from channel, but the channel is empty</span></div><div class="token-line"><span class="token plain">    [consumer]: try to recv from channel, but the channel is empty</span></div><div class="token-line"><span class="token plain">    [producer]: send [1] to channel</span></div><div class="token-line"><span class="token plain">    [consumer]: recv [1] from channel</span></div><div class="token-line"><span class="token plain">    [consumer]: try to recv from channel, but the channel is empty</span></div><div class="token-line"><span class="token plain">    [consumer]: try to recv from channel, but the channel is empty</span></div><div class="token-line"><span class="token plain">    [producer]: send [2] to channel</span></div><div class="token-line"><span class="token plain">    [consumer]: recv [2] from channel</span></div><div class="token-line"><span class="token plain">    [consumer]: try to recv from channel, but the channel is empty</span></div><div class="token-line"><span class="token plain">    [consumer]: try to recv from channel, but the channel is empty</span></div><div class="token-line"><span class="token plain">    [producer]: send [3] to channel</span></div><div class="token-line"><span class="token plain">    [consumer]: recv [3] from channel</span></div><div class="token-line"><span class="token plain">    [consumer]: exit</span></div><div class="token-line"><span class="token plain">    [producer]: send [4] to channel</span></div><div class="token-line"><span class="token plain">    [producer]: send [5] to channel</span></div><div class="token-line"><span class="token plain">    [producer]: send [6] to channel</span></div><div class="token-line"><span class="token plain">    [producer]: try send [7], but channel is full</span></div><div class="token-line"><span class="token plain">    [producer]: try send [7], but channel is full</span></div><div class="token-line"><span class="token plain">    [producer]: try send [7], but channel is full</span></div><div class="token-line"><span class="token plain">    ... ...</span></div></pre></div><p>这种方法适用于大多数场合，但是这种方法有一个“问题”，那就是它改变了channel的状态，会让channel接收了一个元素或发送一个元素到channel。</p><p>有些时候我们不想这么做，我们想在不改变channel状态的前提下，单纯地侦测channel的状态，而又不会因channel满或空阻塞在channel上。但很遗憾，目前没有一种方法可以在实现这样的功能的同时，适用于所有场合。</p><p>但是在特定的场景下，我们可以用len(channel)来实现。比如下面这两种场景：</p><p><img src="https://static001.geekbang.org/resource/image/b3/37/b31d081fcced758b8f99c938a0b75237.jpg?wh=1920x1047" alt="图片"/></p><p>上图中的情景(a)是一个“多发送单接收”的场景，也就是有多个发送者，但<strong>有且只有一个接收者</strong>。在这样的场景下，我们可以在接收goroutine中使用<code>len(channel)是否大于0</code>来判断是否channel中有数据需要接收。</p><p>而情景(b)呢，是一个“多接收单发送”的场景，也就是有多个接收者，但<strong>有且只有一个发送者</strong>。在这样的场景下，我们可以在发送Goroutine中使用<code>len(channel)是否小于cap(channel)</code>来判断是否可以执行向channel的发送操作。</p><h2 id="nil-channel的妙用"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#nil-channel的妙用"><span class="icon icon-link"></span></a>nil channel的妙用</h2><p>如果一个channel类型变量的值为nil，我们称它为<strong>nil channel</strong>。nil channel有一个特性，那就是对nil channel的读写都会发生阻塞。比如下面示例代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func main() {</span></div><div class="token-line"><span class="token plain">    	var c chan int</span></div><div class="token-line"><span class="token plain">    	&lt;-c //阻塞</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    或者：</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">    	var c chan int</span></div><div class="token-line"><span class="token plain">    	c&lt;-1  //阻塞</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>你会看到，无论上面的哪段代码被执行，main goroutine都会阻塞在对nil channel的操作上。</p><p>不过，nil channel的这个特性可不是一无是处，有些时候应用nil channel的这个特性可以得到事半功倍的效果。我们来看一个例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func main() {</span></div><div class="token-line"><span class="token plain">        ch1, ch2 := make(chan int), make(chan int)</span></div><div class="token-line"><span class="token plain">        go func() {</span></div><div class="token-line"><span class="token plain">            time.Sleep(time.Second * 5)</span></div><div class="token-line"><span class="token plain">            ch1 &lt;- 5</span></div><div class="token-line"><span class="token plain">            close(ch1)</span></div><div class="token-line"><span class="token plain">        }()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        go func() {</span></div><div class="token-line"><span class="token plain">            time.Sleep(time.Second * 7)</span></div><div class="token-line"><span class="token plain">            ch2 &lt;- 7</span></div><div class="token-line"><span class="token plain">            close(ch2)</span></div><div class="token-line"><span class="token plain">        }()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        var ok1, ok2 bool</span></div><div class="token-line"><span class="token plain">        for {</span></div><div class="token-line"><span class="token plain">            select {</span></div><div class="token-line"><span class="token plain">            case x := &lt;-ch1:</span></div><div class="token-line"><span class="token plain">                ok1 = true</span></div><div class="token-line"><span class="token plain">                fmt.Println(x)</span></div><div class="token-line"><span class="token plain">            case x := &lt;-ch2:</span></div><div class="token-line"><span class="token plain">                ok2 = true</span></div><div class="token-line"><span class="token plain">                fmt.Println(x)</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            if ok1 &amp;&amp; ok2 {</span></div><div class="token-line"><span class="token plain">                break</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        fmt.Println(&quot;program end&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这个示例中，我们期望程序在接收完ch1和ch2两个channel上的数据后就退出。但实际的运行情况却是这样的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">5</span></div><div class="token-line"><span class="token plain">    0</span></div><div class="token-line"><span class="token plain">    0</span></div><div class="token-line"><span class="token plain">    0</span></div><div class="token-line"><span class="token plain">    ... ... //循环输出0</span></div><div class="token-line"><span class="token plain">    7</span></div><div class="token-line"><span class="token plain">    program end</span></div></pre></div><p>我们原本期望上面这个在依次输出5和7两个数字后退出，但实际运行的输出结果却是在输出5之后，程序输出了许多的0值，之后才输出7并退出。</p><p>这是怎么回事呢？我们简单分析一下这段代码的运行过程：</p><ul><li>前5s，select一直处于阻塞状态；</li><li>第5s，ch1返回一个5后被close，select语句的<code>case x := &lt;-ch1</code>这个分支被选出执行，程序输出5，并回到for循环并重新select；</li><li>由于ch1被关闭，从一个已关闭的channel接收数据将永远不会被阻塞，于是新一轮select又把<code>case x := &lt;-ch1</code>这个分支选出并执行。由于ch1处于关闭状态，从这个channel获取数据，我们会得到这个channel对应类型的零值，这里就是0。于是程序再次输出0；程序按这个逻辑循环执行，一直输出0值；</li><li>2s后，ch2被写入了一个数值7。这样在某一轮select的过程中，分支<code>case x := &lt;-ch2</code>被选中得以执行，程序输出7之后满足退出条件，于是程序终止。</li></ul><p>那我们可以怎么改进一下这个程序，让它能按照我们的预期输出呢？</p><p>是时候让nil channel登场了！用nil channel改进后的示例代码是这样的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func main() {</span></div><div class="token-line"><span class="token plain">        ch1, ch2 := make(chan int), make(chan int)</span></div><div class="token-line"><span class="token plain">        go func() {</span></div><div class="token-line"><span class="token plain">            time.Sleep(time.Second * 5)</span></div><div class="token-line"><span class="token plain">            ch1 &lt;- 5</span></div><div class="token-line"><span class="token plain">            close(ch1)</span></div><div class="token-line"><span class="token plain">        }()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        go func() {</span></div><div class="token-line"><span class="token plain">            time.Sleep(time.Second * 7)</span></div><div class="token-line"><span class="token plain">            ch2 &lt;- 7</span></div><div class="token-line"><span class="token plain">            close(ch2)</span></div><div class="token-line"><span class="token plain">        }()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for {</span></div><div class="token-line"><span class="token plain">            select {</span></div><div class="token-line"><span class="token plain">            case x, ok := &lt;-ch1:</span></div><div class="token-line"><span class="token plain">                if !ok {</span></div><div class="token-line"><span class="token plain">                    ch1 = nil</span></div><div class="token-line"><span class="token plain">                } else {</span></div><div class="token-line"><span class="token plain">                    fmt.Println(x)</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            case x, ok := &lt;-ch2:</span></div><div class="token-line"><span class="token plain">                if !ok {</span></div><div class="token-line"><span class="token plain">                    ch2 = nil</span></div><div class="token-line"><span class="token plain">                } else {</span></div><div class="token-line"><span class="token plain">                    fmt.Println(x)</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            if ch1 == nil &amp;&amp; ch2 == nil {</span></div><div class="token-line"><span class="token plain">                break</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        fmt.Println(&quot;program end&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里，改进后的示例程序的最关键的一个变化，就是在判断ch1或ch2被关闭后，显式地将ch1或ch2置为nil。</p><p>而我们前面已经知道了，<strong>对一个nil channel执行获取操作，这个操作将阻塞</strong>。于是，这里已经被置为nil的c1或c2的分支，将再也不会被select选中执行。</p><p>改进后的示例的运行结果如下，与我们预期相符：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">5</span></div><div class="token-line"><span class="token plain">    7</span></div><div class="token-line"><span class="token plain">    program end</span></div></pre></div><h2 id="与select结合使用的一些惯用法"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#与select结合使用的一些惯用法"><span class="icon icon-link"></span></a>与select结合使用的一些惯用法</h2><p>channel和select的结合使用能形成强大的表达能力，我们在前面的例子中已经或多或少见识过了。这里我再强调几种channel与select结合的惯用法。</p><h3 id="第一种用法利用default分支避免阻塞"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#第一种用法利用default分支避免阻塞"><span class="icon icon-link"></span></a>第一种用法：利用default分支避免阻塞</h3><p>select语句的default分支的语义，就是在其他非default分支因通信未就绪，而无法被选择的时候执行的，这就给default分支赋予了一种“避免阻塞”的特性。</p><p>其实在前面的**“len(channel)的应用”**小节的例子中，我们就已经用到了“利用default分支”实现的<code>trySend</code>和<code>tryRecv</code>两个函数：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func tryRecv(c &lt;-chan int) (int, bool) {</span></div><div class="token-line"><span class="token plain">    	select {</span></div><div class="token-line"><span class="token plain">    	case i := &lt;-c:</span></div><div class="token-line"><span class="token plain">    		return i, true</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	default: // channel为空</span></div><div class="token-line"><span class="token plain">    		return 0, false</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func trySend(c chan&lt;- int, i int) bool {</span></div><div class="token-line"><span class="token plain">    	select {</span></div><div class="token-line"><span class="token plain">    	case c &lt;- i:</span></div><div class="token-line"><span class="token plain">    		return true</span></div><div class="token-line"><span class="token plain">    	default: // channel满了</span></div><div class="token-line"><span class="token plain">    		return false</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>而且，无论是无缓冲channel还是带缓冲channel，这两个函数都能适用，并且不会阻塞在空channel或元素个数已经达到容量的channel上。</p><p>在Go标准库中，这个惯用法也有应用，比如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// $GOROOT/src/time/sleep.go</span></div><div class="token-line"><span class="token plain">    func sendTime(c interface{}, seq uintptr) {</span></div><div class="token-line"><span class="token plain">        // 无阻塞的向c发送当前时间</span></div><div class="token-line"><span class="token plain">        select {</span></div><div class="token-line"><span class="token plain">        case c.(chan Time) &lt;- Now():</span></div><div class="token-line"><span class="token plain">        default:</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="第二种用法实现超时机制"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#第二种用法实现超时机制"><span class="icon icon-link"></span></a>第二种用法：实现超时机制</h3><p>带超时机制的select，是Go中常见的一种select和channel的组合用法。通过超时事件，我们既可以避免长期陷入某种操作的等待中，也可以做一些异常处理工作。</p><p>比如，下面示例代码实现了一次具有30s超时的select：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func worker() {</span></div><div class="token-line"><span class="token plain">    	select {</span></div><div class="token-line"><span class="token plain">    	case &lt;-c:</span></div><div class="token-line"><span class="token plain">    	     // ... do some stuff</span></div><div class="token-line"><span class="token plain">    	case &lt;-time.After(30 *time.Second):</span></div><div class="token-line"><span class="token plain">    	    return</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>不过，在应用带有超时机制的select时，我们要特别注意<strong>timer使用后的释放</strong>，尤其在大量创建timer的时候。</p><p>Go语言标准库提供的timer实际上是由Go运行时自行维护的，而不是操作系统级的定时器资源，它的使用代价要比操作系统级的低许多。但即便如此，作为time.Timer的使用者，我们也要尽量减少在使用Timer时给Go运行时和Go垃圾回收带来的压力，要及时调用timer的Stop方法回收Timer资源。</p><h3 id="第三种用法实现心跳机制"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#第三种用法实现心跳机制"><span class="icon icon-link"></span></a>第三种用法：实现心跳机制</h3><p>结合time包的Ticker，我们可以实现带有心跳机制的select。这种机制让我们可以在监听channel的同时，执行一些<strong>周期性的任务</strong>，比如下面这段代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">func worker() {</span></div><div class="token-line"><span class="token plain">    	heartbeat := time.NewTicker(30 * time.Second)</span></div><div class="token-line"><span class="token plain">    	defer heartbeat.Stop()</span></div><div class="token-line"><span class="token plain">    	for {</span></div><div class="token-line"><span class="token plain">    		select {</span></div><div class="token-line"><span class="token plain">    		case &lt;-c:</span></div><div class="token-line"><span class="token plain">    			// ... do some stuff</span></div><div class="token-line"><span class="token plain">    		case &lt;- heartbeat.C:</span></div><div class="token-line"><span class="token plain">    			//... do heartbeat stuff</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里我们使用time.NewTicker，创建了一个Ticker类型实例heartbeat。这个实例包含一个channel类型的字段C，这个字段会按一定时间间隔持续产生事件，就像“心跳”一样。这样for循环在channel c无数据接收时，会每隔特定时间完成一次迭代，然后回到for循环进行下一次迭代。</p><p>和timer一样，我们在使用完ticker之后，也不要忘记调用它的Stop方法，避免心跳事件在ticker的channel（上面示例中的heartbeat.C）中持续产生。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#小结"><span class="icon icon-link"></span></a>小结</h2><p>好了，今天的课讲到这里就结束了，现在我们一起来回顾一下吧。</p><p>在这一讲中，我们系统学习了Go CSP并发方案中除Goroutine之外的另一个重要组成部分：channel。Go为了原生支持并发，把channel视作一等公民身份，这就大幅提升了开发人员使用channel进行并发设计和实现的体验。</p><p>通过预定义函数make，我们可以创建两类channel：无缓冲channel与带缓冲的channel。这两类channel具有不同的收发特性，可以适用于不同的应用场合：无缓冲channel兼具通信与同步特性，常用于作为信号通知或替代同步锁；而带缓冲channel的异步性，让它更适合用来实现基于内存的消息队列、计数信号量等。</p><p>此外，你也要牢记值为nil的channel的阻塞特性，有些时候它也能帮上大忙。而面对已关闭的channel你也一定要小心，尤其要避免向已关闭的channel发送数据，那会导致panic。</p><p>最后，select是Go为了支持同时操作多个channel，而引入的另外一个并发原语，select与channel有几种常用的固定搭配，你也要好好掌握和理解。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-two/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>channel作为Go并发设计的重要组成部分，需要你掌握的细节非常多。而且，channel的应用模式也非常多，我们这一讲仅挑了几个常见的模式做了讲解。在日常开发中你还见过哪些实用的channel使用模式呢？欢迎在留言区分享。</p><p>如果你觉得有收获，也欢迎你把这节课分享给更多对Go并发感兴趣的朋友。我是Tony Bai，我们下节课见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/tonybaigo语言第一课/05.核心篇“脑勤+”洞彻核心/07.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">5/2/2022 02:41:33</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-two/umi.js"></script>
  </body>
</html>
